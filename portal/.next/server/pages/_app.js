/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/_app";
exports.ids = ["pages/_app"];
exports.modules = {

/***/ "./components/Calendar/index.tsx":
/*!***************************************!*\
  !*** ./components/Calendar/index.tsx ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Calendar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/react */ \"./node_modules/@fullcalendar/react/dist/main.cjs.js\");\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.cjs.js\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/interaction */ \"./node_modules/@fullcalendar/interaction/main.cjs.js\");\n/* harmony import */ var _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fullcalendar/timegrid */ \"./node_modules/@fullcalendar/timegrid/main.cjs.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"next/router\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nfunction Calendar() {\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const start = new Date();\n    const end = new Date(new Date().setMinutes(start.getMinutes() + 30));\n    const data = [\n        {\n            title: \"sala 1\",\n            start,\n            end,\n            backgroundColor: \"green\",\n            extendedProps: {\n                id: 1\n            }\n        },\n        {\n            title: \"sala 2\",\n            start: new Date(new Date().setHours(start.getHours() + 1)),\n            end: new Date(new Date().setHours(start.getHours() + 2)),\n            backgroundColor: \"purple\",\n            extendedProps: {\n                id: 2\n            }\n        },\n        {\n            title: \"sala 3\",\n            start: new Date(new Date().setHours(start.getHours() + 2)),\n            end: new Date(new Date().setHours(start.getHours() + 3)),\n            backgroundColor: \"#000\",\n            extendedProps: {\n                id: 3\n            }\n        }\n    ];\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(data);\n    const calendarRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            padding: 20\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_fullcalendar_react__WEBPACK_IMPORTED_MODULE_1___default()), {\n            nowIndicator: true,\n            eventClick: (info)=>console.log(info.event.extendedProps, info.event.title),\n            editable: true,\n            views: {\n                dayGrid: {\n                    selectable: true\n                },\n                timeGrid: {\n                    selectable: true\n                },\n                dayGridMonth: {\n                    selectable: false\n                }\n            },\n            ref: calendarRef,\n            plugins: [\n                _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n            ],\n            initialView: \"timeGridWeek\",\n            eventDrop: (info)=>{\n                const eventFiltered = events.filter((event)=>event.extendedProps.id !== info.event.extendedProps.id);\n                setEvents([\n                    ...eventFiltered,\n                    {\n                        title: info.event.title,\n                        start: info.event.startStr,\n                        end: info.event.endStr,\n                        backgroundColor: info.event.backgroundColor,\n                        extendedProps: {\n                            id: info.event.extendedProps.id\n                        }\n                    }\n                ]);\n                alert(\"Dropped \" + info.event.title);\n            },\n            eventResize: (info)=>{\n                const eventFiltered = events.filter((event)=>event.extendedProps.id !== info.event.extendedProps.id);\n                setEvents([\n                    ...eventFiltered,\n                    {\n                        title: info.event.title,\n                        start: info.event.startStr,\n                        end: info.event.endStr,\n                        backgroundColor: info.event.backgroundColor,\n                        extendedProps: {\n                            id: info.event.extendedProps.id\n                        }\n                    }\n                ]);\n                alert(\"Resized \" + info.event.title);\n            },\n            select: (info)=>{\n                // @ts-ignore\n                setEvents((event)=>{\n                    const newId = events[events.length - 1].extendedProps.id + 1;\n                    return [\n                        ...event,\n                        {\n                            title: `sala ${newId}`,\n                            start: info.startStr,\n                            end: info.endStr,\n                            backgroundColor: \"gray\",\n                            extendedProps: {\n                                id: newId\n                            }\n                        }\n                    ];\n                });\n                alert(\"selected \" + info.startStr + \" to \" + info.endStr);\n            },\n            events: events,\n            locale: \"pt-br\",\n            timeZone: \"UTF\",\n            titleFormat: {\n                year: \"numeric\",\n                month: \"long\"\n            },\n            // allDayText={\"24h\"}\n            allDaySlot: false,\n            buttonText: {\n                today: \"Hoje\",\n                month: \"M\\xeas\",\n                week: \"Semana\",\n                day: \"Dia\",\n                list: \"Lista\"\n            },\n            customButtons: {\n                custom1: {\n                    text: \"custom 1\",\n                    click: function() {\n                        alert(\"clicked custom button 1!\");\n                    }\n                },\n                custom2: {\n                    text: \"About page\",\n                    click: function() {\n                        router.push(\"/about\");\n                    }\n                }\n            },\n            headerToolbar: {\n                left: \"dayGridMonth,timeGridWeek,timeGridDay custom1\",\n                center: \"title\",\n                right: \"custom2 today prevYear,prev,next,nextYear\"\n            }\n        }, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Calendar/index.tsx\",\n            lineNumber: 33,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Calendar/index.tsx\",\n        lineNumber: 32,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NhbGVuZGFyL2luZGV4LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUE4QztBQUNHO0FBQ1M7QUFDTjtBQUNYO0FBQ0Y7QUFFeEIsU0FBU08sV0FBVztJQUNqQyxNQUFNQyxTQUFTRixzREFBU0E7SUFFeEIsTUFBTUcsUUFBUSxJQUFJQztJQUNsQixNQUFNQyxNQUFNLElBQUlELEtBQUssSUFBSUEsT0FBT0UsVUFBVSxDQUFDSCxNQUFNSSxVQUFVLEtBQUs7SUFFaEUsTUFBTUMsT0FBTztRQUNYO1lBQ0VDLE9BQU87WUFBVU47WUFBT0U7WUFBS0ssaUJBQWlCO1lBQVNDLGVBQWU7Z0JBQUVDLElBQUk7WUFBRTtRQUNoRjtRQUNBO1lBQ0VILE9BQU87WUFBVU4sT0FBTyxJQUFJQyxLQUFLLElBQUlBLE9BQU9TLFFBQVEsQ0FBQ1YsTUFBTVcsUUFBUSxLQUFLO1lBQUtULEtBQUssSUFBSUQsS0FBSyxJQUFJQSxPQUFPUyxRQUFRLENBQUNWLE1BQU1XLFFBQVEsS0FBSztZQUFLSixpQkFBaUI7WUFBVUMsZUFBZTtnQkFBRUMsSUFBSTtZQUFFO1FBQzNMO1FBQ0E7WUFDRUgsT0FBTztZQUFVTixPQUFPLElBQUlDLEtBQUssSUFBSUEsT0FBT1MsUUFBUSxDQUFDVixNQUFNVyxRQUFRLEtBQUs7WUFBS1QsS0FBSyxJQUFJRCxLQUFLLElBQUlBLE9BQU9TLFFBQVEsQ0FBQ1YsTUFBTVcsUUFBUSxLQUFLO1lBQUtKLGlCQUFpQjtZQUFRQyxlQUFlO2dCQUFFQyxJQUFJO1lBQUU7UUFDekw7S0FDRDtJQUVELE1BQU0sQ0FBQ0csUUFBUUMsVUFBVSxHQUFHakIsK0NBQVFBLENBQUNTO0lBR3JDLE1BQU1TLGNBQWNuQiw2Q0FBTUEsQ0FBQyxJQUFJO0lBRS9CLHFCQUNFLDhEQUFDb0I7UUFBSUMsT0FBTztZQUFFQyxTQUFTO1FBQUc7a0JBQ3hCLDRFQUFDMUIsNERBQVlBO1lBQ1gyQixjQUFjLElBQUk7WUFDbEJDLFlBQVksQ0FBQ0MsT0FBU0MsUUFBUUMsR0FBRyxDQUFDRixLQUFLRyxLQUFLLENBQUNmLGFBQWEsRUFBRVksS0FBS0csS0FBSyxDQUFDakIsS0FBSztZQUM1RWtCLFVBQVUsSUFBSTtZQUNkQyxPQUFPO2dCQUNMQyxTQUFTO29CQUNQQyxZQUFZLElBQUk7Z0JBQ2xCO2dCQUNBQyxVQUFVO29CQUNSRCxZQUFZLElBQUk7Z0JBQ2xCO2dCQUNBRSxjQUFjO29CQUNaRixZQUFZLEtBQUs7Z0JBQ25CO1lBRUY7WUFDQUcsS0FBS2hCO1lBQ0xpQixTQUFTO2dCQUFDdkMsNkRBQWFBO2dCQUFFQyxpRUFBaUJBO2dCQUFFQyw4REFBY0E7YUFBQztZQUMzRHNDLGFBQVk7WUFDWkMsV0FBVyxDQUFDYixPQUFTO2dCQUNuQixNQUFNYyxnQkFBZ0J0QixPQUFPdUIsTUFBTSxDQUFDWixDQUFBQSxRQUFTQSxNQUFNZixhQUFhLENBQUNDLEVBQUUsS0FBS1csS0FBS0csS0FBSyxDQUFDZixhQUFhLENBQUNDLEVBQUU7Z0JBQ25HSSxVQUFVO3VCQUNMcUI7b0JBQ0g7d0JBQUU1QixPQUFPYyxLQUFLRyxLQUFLLENBQUNqQixLQUFLO3dCQUFFTixPQUFPb0IsS0FBS0csS0FBSyxDQUFDYSxRQUFRO3dCQUFFbEMsS0FBS2tCLEtBQUtHLEtBQUssQ0FBQ2MsTUFBTTt3QkFBRTlCLGlCQUFpQmEsS0FBS0csS0FBSyxDQUFDaEIsZUFBZTt3QkFBRUMsZUFBZTs0QkFBRUMsSUFBSVcsS0FBS0csS0FBSyxDQUFDZixhQUFhLENBQUNDLEVBQUU7d0JBQUM7b0JBQUU7aUJBQ2hMO2dCQUVENkIsTUFBTSxhQUFhbEIsS0FBS0csS0FBSyxDQUFDakIsS0FBSztZQUNyQztZQUNBaUMsYUFBYSxDQUFDbkIsT0FBUztnQkFDckIsTUFBTWMsZ0JBQWdCdEIsT0FBT3VCLE1BQU0sQ0FBQ1osQ0FBQUEsUUFBU0EsTUFBTWYsYUFBYSxDQUFDQyxFQUFFLEtBQUtXLEtBQUtHLEtBQUssQ0FBQ2YsYUFBYSxDQUFDQyxFQUFFO2dCQUNuR0ksVUFBVTt1QkFDTHFCO29CQUNIO3dCQUFFNUIsT0FBT2MsS0FBS0csS0FBSyxDQUFDakIsS0FBSzt3QkFBRU4sT0FBT29CLEtBQUtHLEtBQUssQ0FBQ2EsUUFBUTt3QkFBRWxDLEtBQUtrQixLQUFLRyxLQUFLLENBQUNjLE1BQU07d0JBQUU5QixpQkFBaUJhLEtBQUtHLEtBQUssQ0FBQ2hCLGVBQWU7d0JBQUVDLGVBQWU7NEJBQUVDLElBQUlXLEtBQUtHLEtBQUssQ0FBQ2YsYUFBYSxDQUFDQyxFQUFFO3dCQUFDO29CQUFFO2lCQUNoTDtnQkFDRDZCLE1BQU0sYUFBYWxCLEtBQUtHLEtBQUssQ0FBQ2pCLEtBQUs7WUFDckM7WUFFQWtDLFFBQVEsQ0FBQ3BCLE9BQVM7Z0JBQ2hCLGFBQWE7Z0JBQ2JQLFVBQVVVLENBQUFBLFFBQVM7b0JBQ2pCLE1BQU1rQixRQUFRN0IsTUFBTSxDQUFDQSxPQUFPOEIsTUFBTSxHQUFHLEVBQUUsQ0FBQ2xDLGFBQWEsQ0FBQ0MsRUFBRSxHQUFHO29CQUMzRCxPQUFPOzJCQUNGYzt3QkFDSDs0QkFBRWpCLE9BQU8sQ0FBQyxLQUFLLEVBQUVtQyxNQUFNLENBQUM7NEJBQUV6QyxPQUFPb0IsS0FBS2dCLFFBQVE7NEJBQUVsQyxLQUFLa0IsS0FBS2lCLE1BQU07NEJBQUU5QixpQkFBaUI7NEJBQVFDLGVBQWU7Z0NBQUVDLElBQUlnQzs0QkFBTTt3QkFBRTtxQkFBRTtnQkFDOUg7Z0JBQ0FILE1BQU0sY0FBY2xCLEtBQUtnQixRQUFRLEdBQUcsU0FBU2hCLEtBQUtpQixNQUFNO1lBQzFEO1lBQ0F6QixRQUFRQTtZQUNSK0IsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLGFBQWE7Z0JBQUVDLE1BQU07Z0JBQVdDLE9BQU87WUFBTztZQUM5QyxxQkFBcUI7WUFDckJDLFlBQVksS0FBSztZQUNqQkMsWUFBWTtnQkFDVkMsT0FBTztnQkFDUEgsT0FBTztnQkFDUEksTUFBTTtnQkFDTkMsS0FBSztnQkFDTEMsTUFBTTtZQUNSO1lBQ0FDLGVBQWU7Z0JBQ2JDLFNBQVM7b0JBQ1BDLE1BQU07b0JBQ05DLE9BQU8sV0FBWTt3QkFDakJuQixNQUFNO29CQUNSO2dCQUNGO2dCQUNBb0IsU0FBUztvQkFDUEYsTUFBTTtvQkFDTkMsT0FBTyxXQUFZO3dCQUNqQjFELE9BQU80RCxJQUFJLENBQUM7b0JBQ2Q7Z0JBQ0Y7WUFDRjtZQUNBQyxlQUFlO2dCQUNiQyxNQUFNO2dCQUNOQyxRQUFRO2dCQUNSQyxPQUFPO1lBQ1Q7Ozs7Ozs7Ozs7O0FBSVIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC1mdWxsY2FsZW5kYXIvLi9jb21wb25lbnRzL0NhbGVuZGFyL2luZGV4LnRzeD85NjY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBGdWxsQ2FsZW5kYXIgZnJvbSAnQGZ1bGxjYWxlbmRhci9yZWFjdCdcbmltcG9ydCBkYXlHcmlkUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCdcbmltcG9ydCBpbnRlcmFjdGlvblBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvblwiO1xuaW1wb3J0IHRpbWVHcmlkUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL3RpbWVncmlkXCI7XG5pbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhbGVuZGFyKCkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKVxuXG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZW5kID0gbmV3IERhdGUobmV3IERhdGUoKS5zZXRNaW51dGVzKHN0YXJ0LmdldE1pbnV0ZXMoKSArIDMwKSk7XG5cbiAgY29uc3QgZGF0YSA9IFtcbiAgICB7XG4gICAgICB0aXRsZTogJ3NhbGEgMScsIHN0YXJ0LCBlbmQsIGJhY2tncm91bmRDb2xvcjogXCJncmVlblwiLCBleHRlbmRlZFByb3BzOiB7IGlkOiAxIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnc2FsYSAyJywgc3RhcnQ6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoc3RhcnQuZ2V0SG91cnMoKSArIDEpKSwgZW5kOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKHN0YXJ0LmdldEhvdXJzKCkgKyAyKSksIGJhY2tncm91bmRDb2xvcjogXCJwdXJwbGVcIiwgZXh0ZW5kZWRQcm9wczogeyBpZDogMiB9XG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ3NhbGEgMycsIHN0YXJ0OiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKHN0YXJ0LmdldEhvdXJzKCkgKyAyKSksIGVuZDogbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycyhzdGFydC5nZXRIb3VycygpICsgMykpLCBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMFwiLCBleHRlbmRlZFByb3BzOiB7IGlkOiAzIH1cbiAgICB9XG4gIF1cblxuICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGUoZGF0YSlcblxuXG4gIGNvbnN0IGNhbGVuZGFyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAyMCB9fT5cbiAgICAgIDxGdWxsQ2FsZW5kYXJcbiAgICAgICAgbm93SW5kaWNhdG9yPXt0cnVlfVxuICAgICAgICBldmVudENsaWNrPXsoaW5mbykgPT4gY29uc29sZS5sb2coaW5mby5ldmVudC5leHRlbmRlZFByb3BzLCBpbmZvLmV2ZW50LnRpdGxlKX1cbiAgICAgICAgZWRpdGFibGU9e3RydWV9XG4gICAgICAgIHZpZXdzPXt7XG4gICAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltZUdyaWQ6IHtcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgc2VsZWN0YWJsZTogZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgfX1cbiAgICAgICAgcmVmPXtjYWxlbmRhclJlZn1cbiAgICAgICAgcGx1Z2lucz17W2RheUdyaWRQbHVnaW4sIGludGVyYWN0aW9uUGx1Z2luLCB0aW1lR3JpZFBsdWdpbl19XG4gICAgICAgIGluaXRpYWxWaWV3PVwidGltZUdyaWRXZWVrXCJcbiAgICAgICAgZXZlbnREcm9wPXsoaW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50RmlsdGVyZWQgPSBldmVudHMuZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmV4dGVuZGVkUHJvcHMuaWQgIT09IGluZm8uZXZlbnQuZXh0ZW5kZWRQcm9wcy5pZCkgYXMgYW55XG4gICAgICAgICAgc2V0RXZlbnRzKFtcbiAgICAgICAgICAgIC4uLmV2ZW50RmlsdGVyZWQsXG4gICAgICAgICAgICB7IHRpdGxlOiBpbmZvLmV2ZW50LnRpdGxlLCBzdGFydDogaW5mby5ldmVudC5zdGFydFN0ciwgZW5kOiBpbmZvLmV2ZW50LmVuZFN0ciwgYmFja2dyb3VuZENvbG9yOiBpbmZvLmV2ZW50LmJhY2tncm91bmRDb2xvciwgZXh0ZW5kZWRQcm9wczogeyBpZDogaW5mby5ldmVudC5leHRlbmRlZFByb3BzLmlkIH0gfVxuICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgICAgYWxlcnQoJ0Ryb3BwZWQgJyArIGluZm8uZXZlbnQudGl0bGUpXG4gICAgICAgIH19XG4gICAgICAgIGV2ZW50UmVzaXplPXsoaW5mbykgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50RmlsdGVyZWQgPSBldmVudHMuZmlsdGVyKGV2ZW50ID0+IGV2ZW50LmV4dGVuZGVkUHJvcHMuaWQgIT09IGluZm8uZXZlbnQuZXh0ZW5kZWRQcm9wcy5pZCkgYXMgYW55XG4gICAgICAgICAgc2V0RXZlbnRzKFtcbiAgICAgICAgICAgIC4uLmV2ZW50RmlsdGVyZWQsXG4gICAgICAgICAgICB7IHRpdGxlOiBpbmZvLmV2ZW50LnRpdGxlLCBzdGFydDogaW5mby5ldmVudC5zdGFydFN0ciwgZW5kOiBpbmZvLmV2ZW50LmVuZFN0ciwgYmFja2dyb3VuZENvbG9yOiBpbmZvLmV2ZW50LmJhY2tncm91bmRDb2xvciwgZXh0ZW5kZWRQcm9wczogeyBpZDogaW5mby5ldmVudC5leHRlbmRlZFByb3BzLmlkIH0gfVxuICAgICAgICAgIF0pXG4gICAgICAgICAgYWxlcnQoJ1Jlc2l6ZWQgJyArIGluZm8uZXZlbnQudGl0bGUpXG4gICAgICAgIH19XG5cbiAgICAgICAgc2VsZWN0PXsoaW5mbykgPT4ge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzZXRFdmVudHMoZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLmV4dGVuZGVkUHJvcHMuaWQgKyAxXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgeyB0aXRsZTogYHNhbGEgJHtuZXdJZH1gLCBzdGFydDogaW5mby5zdGFydFN0ciwgZW5kOiBpbmZvLmVuZFN0ciwgYmFja2dyb3VuZENvbG9yOiBcImdyYXlcIiwgZXh0ZW5kZWRQcm9wczogeyBpZDogbmV3SWQgfSB9XVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYWxlcnQoJ3NlbGVjdGVkICcgKyBpbmZvLnN0YXJ0U3RyICsgJyB0byAnICsgaW5mby5lbmRTdHIpO1xuICAgICAgICB9fVxuICAgICAgICBldmVudHM9e2V2ZW50c31cbiAgICAgICAgbG9jYWxlPXtcInB0LWJyXCJ9XG4gICAgICAgIHRpbWVab25lPXtcIlVURlwifVxuICAgICAgICB0aXRsZUZvcm1hdD17eyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfX1cbiAgICAgICAgLy8gYWxsRGF5VGV4dD17XCIyNGhcIn1cbiAgICAgICAgYWxsRGF5U2xvdD17ZmFsc2V9XG4gICAgICAgIGJ1dHRvblRleHQ9e3tcbiAgICAgICAgICB0b2RheTogJ0hvamUnLFxuICAgICAgICAgIG1vbnRoOiAnTcOqcycsXG4gICAgICAgICAgd2VlazogJ1NlbWFuYScsXG4gICAgICAgICAgZGF5OiAnRGlhJyxcbiAgICAgICAgICBsaXN0OiAnTGlzdGEnXG4gICAgICAgIH19XG4gICAgICAgIGN1c3RvbUJ1dHRvbnM9e3tcbiAgICAgICAgICBjdXN0b20xOiB7XG4gICAgICAgICAgICB0ZXh0OiAnY3VzdG9tIDEnLFxuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWxlcnQoJ2NsaWNrZWQgY3VzdG9tIGJ1dHRvbiAxIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VzdG9tMjoge1xuICAgICAgICAgICAgdGV4dDogJ0Fib3V0IHBhZ2UnLFxuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcm91dGVyLnB1c2goJy9hYm91dCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgICBoZWFkZXJUb29sYmFyPXt7XG4gICAgICAgICAgbGVmdDogJ2RheUdyaWRNb250aCx0aW1lR3JpZFdlZWssdGltZUdyaWREYXkgY3VzdG9tMScsXG4gICAgICAgICAgY2VudGVyOiAndGl0bGUnLFxuICAgICAgICAgIHJpZ2h0OiAnY3VzdG9tMiB0b2RheSBwcmV2WWVhcixwcmV2LG5leHQsbmV4dFllYXInXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsiRnVsbENhbGVuZGFyIiwiZGF5R3JpZFBsdWdpbiIsImludGVyYWN0aW9uUGx1Z2luIiwidGltZUdyaWRQbHVnaW4iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVJvdXRlciIsIkNhbGVuZGFyIiwicm91dGVyIiwic3RhcnQiLCJEYXRlIiwiZW5kIiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJkYXRhIiwidGl0bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJleHRlbmRlZFByb3BzIiwiaWQiLCJzZXRIb3VycyIsImdldEhvdXJzIiwiZXZlbnRzIiwic2V0RXZlbnRzIiwiY2FsZW5kYXJSZWYiLCJkaXYiLCJzdHlsZSIsInBhZGRpbmciLCJub3dJbmRpY2F0b3IiLCJldmVudENsaWNrIiwiaW5mbyIsImNvbnNvbGUiLCJsb2ciLCJldmVudCIsImVkaXRhYmxlIiwidmlld3MiLCJkYXlHcmlkIiwic2VsZWN0YWJsZSIsInRpbWVHcmlkIiwiZGF5R3JpZE1vbnRoIiwicmVmIiwicGx1Z2lucyIsImluaXRpYWxWaWV3IiwiZXZlbnREcm9wIiwiZXZlbnRGaWx0ZXJlZCIsImZpbHRlciIsInN0YXJ0U3RyIiwiZW5kU3RyIiwiYWxlcnQiLCJldmVudFJlc2l6ZSIsInNlbGVjdCIsIm5ld0lkIiwibGVuZ3RoIiwibG9jYWxlIiwidGltZVpvbmUiLCJ0aXRsZUZvcm1hdCIsInllYXIiLCJtb250aCIsImFsbERheVNsb3QiLCJidXR0b25UZXh0IiwidG9kYXkiLCJ3ZWVrIiwiZGF5IiwibGlzdCIsImN1c3RvbUJ1dHRvbnMiLCJjdXN0b20xIiwidGV4dCIsImNsaWNrIiwiY3VzdG9tMiIsInB1c2giLCJoZWFkZXJUb29sYmFyIiwibGVmdCIsImNlbnRlciIsInJpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Calendar/index.tsx\n");

/***/ }),

/***/ "./components/Layout/index.tsx":
/*!*************************************!*\
  !*** ./components/Layout/index.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons */ \"@ant-design/icons\");\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd */ \"antd\");\n/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(antd__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Calendar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Calendar */ \"./components/Calendar/index.tsx\");\n/* harmony import */ var _Users__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Users */ \"./components/Users/index.tsx\");\n\n\n\n\n\n\nconst { Header , Content  } = antd__WEBPACK_IMPORTED_MODULE_3__.Layout;\nconst items = [\n    {\n        label: \"Calendar\",\n        key: \"1\",\n        icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__.AppstoreOutlined, {}, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n            lineNumber: 14,\n            columnNumber: 11\n        }, undefined)\n    },\n    {\n        label: \"Users\",\n        key: \"2\",\n        icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__.MailOutlined, {}, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n            lineNumber: 19,\n            columnNumber: 11\n        }, undefined)\n    }\n];\nconst AppLayout = ()=>{\n    const { token: { colorBgContainer  }  } = antd__WEBPACK_IMPORTED_MODULE_3__.theme.useToken();\n    const [current, setCurrent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"1\");\n    const onClick = (e)=>{\n        setCurrent(e.key);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Layout, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Header, {\n                className: \"header\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Menu, {\n                    theme: \"dark\",\n                    onClick: onClick,\n                    selectedKeys: [\n                        current\n                    ],\n                    mode: \"horizontal\",\n                    items: items\n                }, void 0, false, {\n                    fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                    lineNumber: 37,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Content, {\n                style: {\n                    padding: \"0 50px\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Layout, {\n                    style: {\n                        padding: \"24px 0\",\n                        background: colorBgContainer\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Content, {\n                        style: {\n                            padding: \"0 24px\",\n                            minHeight: 280\n                        },\n                        children: [\n                            current === \"1\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Calendar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                                lineNumber: 48,\n                                columnNumber: 33\n                            }, undefined),\n                            current === \"2\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Users__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {}, void 0, false, {\n                                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                                lineNumber: 49,\n                                columnNumber: 33\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                        lineNumber: 47,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                    lineNumber: 46,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n        lineNumber: 35,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AppLayout);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0xheW91dC9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFpQztBQUNrQztBQUV4QjtBQUNSO0FBQ047QUFFN0IsTUFBTSxFQUFFUSxPQUFNLEVBQUVDLFFBQU8sRUFBRSxHQUFHTix3Q0FBTUE7QUFFbEMsTUFBTU8sUUFBNEI7SUFDaEM7UUFDRUMsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLG9CQUFNLDhEQUFDWiwrREFBZ0JBOzs7OztJQUN6QjtJQUNBO1FBQ0VVLE9BQU87UUFDUEMsS0FBSztRQUNMQyxvQkFBTSw4REFBQ1gsMkRBQVlBOzs7OztJQUNyQjtDQUNEO0FBRUQsTUFBTVksWUFBc0IsSUFBTTtJQUNoQyxNQUFNLEVBQ0pDLE9BQU8sRUFBRUMsaUJBQWdCLEVBQUUsR0FDNUIsR0FBR1gsZ0RBQWM7SUFFbEIsTUFBTSxDQUFDYSxTQUFTQyxXQUFXLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNb0IsVUFBZ0MsQ0FBQ0MsSUFBTTtRQUMzQ0YsV0FBV0UsRUFBRVQsR0FBRztJQUNsQjtJQUVBLHFCQUNFLDhEQUFDVCx3Q0FBTUE7OzBCQUNMLDhEQUFDSztnQkFBT2MsV0FBVTswQkFDaEIsNEVBQUNsQixzQ0FBSUE7b0JBQ0hDLE9BQU07b0JBQ05lLFNBQVNBO29CQUNURyxjQUFjO3dCQUFDTDtxQkFBUTtvQkFDdkJNLE1BQUs7b0JBQ0xkLE9BQU9BOzs7Ozs7Ozs7OzswQkFHWCw4REFBQ0Q7Z0JBQVFnQixPQUFPO29CQUFFQyxTQUFTO2dCQUFTOzBCQUNsQyw0RUFBQ3ZCLHdDQUFNQTtvQkFBQ3NCLE9BQU87d0JBQUVDLFNBQVM7d0JBQVVDLFlBQVlYO29CQUFpQjs4QkFDL0QsNEVBQUNQO3dCQUFRZ0IsT0FBTzs0QkFBRUMsU0FBUzs0QkFBVUUsV0FBVzt3QkFBSTs7NEJBQ2pEVixZQUFZLHFCQUFPLDhEQUFDWixpREFBUUE7Ozs7OzRCQUM1QlksWUFBWSxxQkFBTyw4REFBQ1gsOENBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNdEM7QUFFQSxpRUFBZU8sU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC1mdWxsY2FsZW5kYXIvLi9jb21wb25lbnRzL0xheW91dC9pbmRleC50c3g/NjQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQXBwc3RvcmVPdXRsaW5lZCwgTWFpbE91dGxpbmVkIH0gZnJvbSBcIkBhbnQtZGVzaWduL2ljb25zXCI7XG5pbXBvcnQgdHlwZSB7IE1lbnVQcm9wcyB9IGZyb20gXCJhbnRkXCI7XG5pbXBvcnQgeyBMYXlvdXQsIE1lbnUsIHRoZW1lIH0gZnJvbSBcImFudGRcIjtcbmltcG9ydCBDYWxlbmRhciBmcm9tIFwiLi4vQ2FsZW5kYXJcIjtcbmltcG9ydCBVc2VycyBmcm9tIFwiLi4vVXNlcnNcIjtcblxuY29uc3QgeyBIZWFkZXIsIENvbnRlbnQgfSA9IExheW91dDtcblxuY29uc3QgaXRlbXM6IE1lbnVQcm9wc1tcIml0ZW1zXCJdID0gW1xuICB7XG4gICAgbGFiZWw6IFwiQ2FsZW5kYXJcIixcbiAgICBrZXk6IFwiMVwiLFxuICAgIGljb246IDxBcHBzdG9yZU91dGxpbmVkIC8+LFxuICB9LFxuICB7XG4gICAgbGFiZWw6IFwiVXNlcnNcIixcbiAgICBrZXk6IFwiMlwiLFxuICAgIGljb246IDxNYWlsT3V0bGluZWQgLz4sXG4gIH0sXG5dO1xuXG5jb25zdCBBcHBMYXlvdXQ6IFJlYWN0LkZDID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgdG9rZW46IHsgY29sb3JCZ0NvbnRhaW5lciB9LFxuICB9ID0gdGhlbWUudXNlVG9rZW4oKTtcblxuICBjb25zdCBbY3VycmVudCwgc2V0Q3VycmVudF0gPSB1c2VTdGF0ZShcIjFcIik7XG5cbiAgY29uc3Qgb25DbGljazogTWVudVByb3BzW1wib25DbGlja1wiXSA9IChlKSA9PiB7XG4gICAgc2V0Q3VycmVudChlLmtleSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8TGF5b3V0PlxuICAgICAgPEhlYWRlciBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICAgICAgPE1lbnVcbiAgICAgICAgICB0aGVtZT1cImRhcmtcIlxuICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgc2VsZWN0ZWRLZXlzPXtbY3VycmVudF19XG4gICAgICAgICAgbW9kZT1cImhvcml6b250YWxcIlxuICAgICAgICAgIGl0ZW1zPXtpdGVtc31cbiAgICAgICAgLz5cbiAgICAgIDwvSGVhZGVyPlxuICAgICAgPENvbnRlbnQgc3R5bGU9e3sgcGFkZGluZzogXCIwIDUwcHhcIiB9fT5cbiAgICAgICAgPExheW91dCBzdHlsZT17eyBwYWRkaW5nOiBcIjI0cHggMFwiLCBiYWNrZ3JvdW5kOiBjb2xvckJnQ29udGFpbmVyIH19PlxuICAgICAgICAgIDxDb250ZW50IHN0eWxlPXt7IHBhZGRpbmc6IFwiMCAyNHB4XCIsIG1pbkhlaWdodDogMjgwIH19PlxuICAgICAgICAgICAge2N1cnJlbnQgPT09IFwiMVwiICYmIDxDYWxlbmRhciAvPn1cbiAgICAgICAgICAgIHtjdXJyZW50ID09PSBcIjJcIiAmJiA8VXNlcnMgLz59XG4gICAgICAgICAgPC9Db250ZW50PlxuICAgICAgICA8L0xheW91dD5cbiAgICAgIDwvQ29udGVudD5cbiAgICA8L0xheW91dD5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFwcExheW91dDtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIkFwcHN0b3JlT3V0bGluZWQiLCJNYWlsT3V0bGluZWQiLCJMYXlvdXQiLCJNZW51IiwidGhlbWUiLCJDYWxlbmRhciIsIlVzZXJzIiwiSGVhZGVyIiwiQ29udGVudCIsIml0ZW1zIiwibGFiZWwiLCJrZXkiLCJpY29uIiwiQXBwTGF5b3V0IiwidG9rZW4iLCJjb2xvckJnQ29udGFpbmVyIiwidXNlVG9rZW4iLCJjdXJyZW50Iiwic2V0Q3VycmVudCIsIm9uQ2xpY2siLCJlIiwiY2xhc3NOYW1lIiwic2VsZWN0ZWRLZXlzIiwibW9kZSIsInN0eWxlIiwicGFkZGluZyIsImJhY2tncm91bmQiLCJtaW5IZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Layout/index.tsx\n");

/***/ }),

/***/ "./components/Users/index.tsx":
/*!************************************!*\
  !*** ./components/Users/index.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! antd */ \"antd\");\n/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(antd__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_infinite_scroll_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-infinite-scroll-component */ \"react-infinite-scroll-component\");\n/* harmony import */ var react_infinite_scroll_component__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_infinite_scroll_component__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst App = ()=>{\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const loadMoreData = ()=>{\n        if (loading) {\n            return;\n        }\n        setLoading(true);\n        fetch(\"https://randomuser.me/api/?results=10&inc=name,gender,email,nat,picture&noinfo\").then((res)=>res.json()).then((body)=>{\n            setData([\n                ...data,\n                ...body.results\n            ]);\n            setLoading(false);\n        }).catch(()=>{\n            setLoading(false);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        loadMoreData();\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        id: \"scrollableDiv\",\n        style: {\n            height: 400,\n            overflow: \"auto\",\n            padding: \"0 16px\",\n            border: \"1px solid rgba(140, 140, 140, 0.35)\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_infinite_scroll_component__WEBPACK_IMPORTED_MODULE_3___default()), {\n            dataLength: data.length,\n            next: loadMoreData,\n            hasMore: data.length < 50,\n            loader: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.Skeleton, {\n                avatar: true,\n                paragraph: {\n                    rows: 1\n                },\n                active: true\n            }, void 0, false, void 0, void 0),\n            endMessage: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.Divider, {\n                plain: true,\n                children: \"It is all, nothing more \\uD83E\\uDD10\"\n            }, void 0, false, void 0, void 0),\n            scrollableTarget: \"scrollableDiv\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.List, {\n                dataSource: data,\n                renderItem: (item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.List.Item, {\n                        actions: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                children: \"edit\"\n                            }, \"list-loadmore-edit\", false, void 0, void 0)\n                        ],\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.List.Item.Meta, {\n                            avatar: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_2__.Avatar, {\n                                src: item.picture.large\n                            }, void 0, false, void 0, void 0),\n                            title: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://ant.design\",\n                                children: item.name.last\n                            }, void 0, false, void 0, void 0),\n                            description: item.email\n                        }, void 0, false, void 0, void 0)\n                    }, item.email, false, void 0, void 0)\n            }, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Users/index.tsx\",\n                lineNumber: 63,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Users/index.tsx\",\n            lineNumber: 55,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Users/index.tsx\",\n        lineNumber: 46,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1VzZXJzL2luZGV4LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUFtRDtBQUNJO0FBQ007QUFrQjdELE1BQU1RLE1BQWdCLElBQU07SUFDMUIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdSLCtDQUFRQSxDQUFDLEtBQUs7SUFDNUMsTUFBTSxDQUFDUyxNQUFNQyxRQUFRLEdBQUdWLCtDQUFRQSxDQUFhLEVBQUU7SUFFL0MsTUFBTVcsZUFBZSxJQUFNO1FBQ3pCLElBQUlKLFNBQVM7WUFDWDtRQUNGLENBQUM7UUFDREMsV0FBVyxJQUFJO1FBQ2ZJLE1BQU0sa0ZBQ0hDLElBQUksQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxJQUFJLElBQ3RCRixJQUFJLENBQUMsQ0FBQ0csT0FBUztZQUNkTixRQUFRO21CQUFJRDttQkFBU08sS0FBS0MsT0FBTzthQUFDO1lBQ2xDVCxXQUFXLEtBQUs7UUFDbEIsR0FDQ1UsS0FBSyxDQUFDLElBQU07WUFDWFYsV0FBVyxLQUFLO1FBQ2xCO0lBQ0o7SUFFQVQsZ0RBQVNBLENBQUMsSUFBTTtRQUNkWTtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDUTtRQUNDQyxJQUFHO1FBQ0hDLE9BQU87WUFDTEMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLFNBQVM7WUFDVEMsUUFBUTtRQUNWO2tCQUVBLDRFQUFDcEIsd0VBQWNBO1lBQ2JxQixZQUFZakIsS0FBS2tCLE1BQU07WUFDdkJDLE1BQU1qQjtZQUNOa0IsU0FBU3BCLEtBQUtrQixNQUFNLEdBQUc7WUFDdkJHLHNCQUFRLDhEQUFDMUIsMENBQVFBO2dCQUFDMkIsTUFBTTtnQkFBQ0MsV0FBVztvQkFBRUMsTUFBTTtnQkFBRTtnQkFBR0MsTUFBTTs7WUFDdkRDLDBCQUFZLDhEQUFDakMseUNBQU9BO2dCQUFDa0MsS0FBSzswQkFBQzs7WUFDM0JDLGtCQUFpQjtzQkFFakIsNEVBQUNsQyxzQ0FBSUE7Z0JBQ0htQyxZQUFZN0I7Z0JBQ1o4QixZQUFZLENBQUNDLHFCQUNYLDhEQUFDckMsMkNBQVM7d0JBQWtCdUMsU0FBUzswQ0FBQyw4REFBQ0M7MENBQTJCOytCQUFyQjt5QkFBOEI7a0NBQ3pFLDRFQUFDeEMsZ0RBQWM7NEJBQ2I0QixzQkFBUSw4REFBQzlCLHdDQUFNQTtnQ0FBQzRDLEtBQUtMLEtBQUtNLE9BQU8sQ0FBQ0MsS0FBSzs7NEJBQ3ZDQyxxQkFBTyw4REFBQ0w7Z0NBQUVNLE1BQUs7MENBQXNCVCxLQUFLVSxJQUFJLENBQUNDLElBQUk7OzRCQUNuREMsYUFBYVosS0FBS2EsS0FBSzs7dUJBSlhiLEtBQUthLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZdEM7QUFFQSxpRUFBZS9DLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAtZnVsbGNhbGVuZGFyLy4vY29tcG9uZW50cy9Vc2Vycy9pbmRleC50c3g/ZjQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEF2YXRhciwgRGl2aWRlciwgTGlzdCwgU2tlbGV0b24gfSBmcm9tICdhbnRkJztcbmltcG9ydCBJbmZpbml0ZVNjcm9sbCBmcm9tICdyZWFjdC1pbmZpbml0ZS1zY3JvbGwtY29tcG9uZW50JztcblxuaW50ZXJmYWNlIERhdGFUeXBlIHtcbiAgZ2VuZGVyOiBzdHJpbmc7XG4gIG5hbWU6IHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGZpcnN0OiBzdHJpbmc7XG4gICAgbGFzdDogc3RyaW5nO1xuICB9O1xuICBlbWFpbDogc3RyaW5nO1xuICBwaWN0dXJlOiB7XG4gICAgbGFyZ2U6IHN0cmluZztcbiAgICBtZWRpdW06IHN0cmluZztcbiAgICB0aHVtYm5haWw6IHN0cmluZztcbiAgfTtcbiAgbmF0OiBzdHJpbmc7XG59XG5cbmNvbnN0IEFwcDogUmVhY3QuRkMgPSAoKSA9PiB7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGU8RGF0YVR5cGVbXT4oW10pO1xuXG4gIGNvbnN0IGxvYWRNb3JlRGF0YSA9ICgpID0+IHtcbiAgICBpZiAobG9hZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIGZldGNoKCdodHRwczovL3JhbmRvbXVzZXIubWUvYXBpLz9yZXN1bHRzPTEwJmluYz1uYW1lLGdlbmRlcixlbWFpbCxuYXQscGljdHVyZSZub2luZm8nKVxuICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcbiAgICAgIC50aGVuKChib2R5KSA9PiB7XG4gICAgICAgIHNldERhdGEoWy4uLmRhdGEsIC4uLmJvZHkucmVzdWx0c10pO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9hZE1vcmVEYXRhKCk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGlkPVwic2Nyb2xsYWJsZURpdlwiXG4gICAgICBzdHlsZT17e1xuICAgICAgICBoZWlnaHQ6IDQwMCxcbiAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgcGFkZGluZzogJzAgMTZweCcsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCByZ2JhKDE0MCwgMTQwLCAxNDAsIDAuMzUpJyxcbiAgICAgIH19XG4gICAgPlxuICAgICAgPEluZmluaXRlU2Nyb2xsXG4gICAgICAgIGRhdGFMZW5ndGg9e2RhdGEubGVuZ3RofVxuICAgICAgICBuZXh0PXtsb2FkTW9yZURhdGF9XG4gICAgICAgIGhhc01vcmU9e2RhdGEubGVuZ3RoIDwgNTB9XG4gICAgICAgIGxvYWRlcj17PFNrZWxldG9uIGF2YXRhciBwYXJhZ3JhcGg9e3sgcm93czogMSB9fSBhY3RpdmUgLz59XG4gICAgICAgIGVuZE1lc3NhZ2U9ezxEaXZpZGVyIHBsYWluPkl0IGlzIGFsbCwgbm90aGluZyBtb3JlIPCfpJA8L0RpdmlkZXI+fVxuICAgICAgICBzY3JvbGxhYmxlVGFyZ2V0PVwic2Nyb2xsYWJsZURpdlwiXG4gICAgICA+XG4gICAgICAgIDxMaXN0XG4gICAgICAgICAgZGF0YVNvdXJjZT17ZGF0YX1cbiAgICAgICAgICByZW5kZXJJdGVtPXsoaXRlbSkgPT4gKFxuICAgICAgICAgICAgPExpc3QuSXRlbSBrZXk9e2l0ZW0uZW1haWx9IGFjdGlvbnM9e1s8YSBrZXk9XCJsaXN0LWxvYWRtb3JlLWVkaXRcIj5lZGl0PC9hPl19PlxuICAgICAgICAgICAgICA8TGlzdC5JdGVtLk1ldGFcbiAgICAgICAgICAgICAgICBhdmF0YXI9ezxBdmF0YXIgc3JjPXtpdGVtLnBpY3R1cmUubGFyZ2V9IC8+fVxuICAgICAgICAgICAgICAgIHRpdGxlPXs8YSBocmVmPVwiaHR0cHM6Ly9hbnQuZGVzaWduXCI+e2l0ZW0ubmFtZS5sYXN0fTwvYT59XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb249e2l0ZW0uZW1haWx9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L0xpc3QuSXRlbT5cbiAgICAgICAgICApfVxuICAgICAgICAvPlxuICAgICAgPC9JbmZpbml0ZVNjcm9sbD5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkF2YXRhciIsIkRpdmlkZXIiLCJMaXN0IiwiU2tlbGV0b24iLCJJbmZpbml0ZVNjcm9sbCIsIkFwcCIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZGF0YSIsInNldERhdGEiLCJsb2FkTW9yZURhdGEiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJqc29uIiwiYm9keSIsInJlc3VsdHMiLCJjYXRjaCIsImRpdiIsImlkIiwic3R5bGUiLCJoZWlnaHQiLCJvdmVyZmxvdyIsInBhZGRpbmciLCJib3JkZXIiLCJkYXRhTGVuZ3RoIiwibGVuZ3RoIiwibmV4dCIsImhhc01vcmUiLCJsb2FkZXIiLCJhdmF0YXIiLCJwYXJhZ3JhcGgiLCJyb3dzIiwiYWN0aXZlIiwiZW5kTWVzc2FnZSIsInBsYWluIiwic2Nyb2xsYWJsZVRhcmdldCIsImRhdGFTb3VyY2UiLCJyZW5kZXJJdGVtIiwiaXRlbSIsIkl0ZW0iLCJhY3Rpb25zIiwiYSIsIk1ldGEiLCJzcmMiLCJwaWN0dXJlIiwibGFyZ2UiLCJ0aXRsZSIsImhyZWYiLCJuYW1lIiwibGFzdCIsImRlc2NyaXB0aW9uIiwiZW1haWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Users/index.tsx\n");

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_common_main_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common/main.css */ \"./node_modules/@fullcalendar/common/main.css\");\n/* harmony import */ var _fullcalendar_common_main_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_common_main_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fullcalendar_daygrid_main_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid/main.css */ \"./node_modules/@fullcalendar/daygrid/main.css\");\n/* harmony import */ var _fullcalendar_daygrid_main_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_daygrid_main_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _fullcalendar_timegrid_main_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/timegrid/main.css */ \"./node_modules/@fullcalendar/timegrid/main.css\");\n/* harmony import */ var _fullcalendar_timegrid_main_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_timegrid_main_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Layout */ \"./components/Layout/index.tsx\");\n// import '../styles/globals.css'\n\n\n\n\n\nfunction App({ Component , pageProps  }) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Layout__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        ...pageProps\n    }, void 0, false, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/pages/_app.tsx\",\n        lineNumber: 9,\n        columnNumber: 10\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQWlDO0FBQ2pDO0FBQXVDO0FBQ0M7QUFDQztBQUVDO0FBRTNCLFNBQVNDLElBQUksRUFBRUMsVUFBUyxFQUFFQyxVQUFTLEVBQVksRUFBRTtJQUM5RCxxQkFBTyw4REFBQ0gsMERBQU1BO1FBQUUsR0FBR0csU0FBUzs7Ozs7O0FBQzlCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAtZnVsbGNhbGVuZGFyLy4vcGFnZXMvX2FwcC50c3g/MmZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgJy4uL3N0eWxlcy9nbG9iYWxzLmNzcydcbmltcG9ydCBcIkBmdWxsY2FsZW5kYXIvY29tbW9uL21haW4uY3NzXCI7XG5pbXBvcnQgXCJAZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5jc3NcIjtcbmltcG9ydCBcIkBmdWxsY2FsZW5kYXIvdGltZWdyaWQvbWFpbi5jc3NcIjtcbmltcG9ydCB0eXBlIHsgQXBwUHJvcHMgfSBmcm9tICduZXh0L2FwcCdcbmltcG9ydCBMYXlvdXQgZnJvbSBcIi4uL2NvbXBvbmVudHMvTGF5b3V0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCh7IENvbXBvbmVudCwgcGFnZVByb3BzIH06IEFwcFByb3BzKSB7XG4gIHJldHVybiA8TGF5b3V0IHsuLi5wYWdlUHJvcHN9IC8+XG59XG4iXSwibmFtZXMiOlsiTGF5b3V0IiwiQXBwIiwiQ29tcG9uZW50IiwicGFnZVByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n;\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar vdom_cjs = __webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/common/vdom.cjs.js\");\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar EventSourceApi = /** @class */ function() {\n    function EventSourceApi(context, internalEventSource) {\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    EventSourceApi.prototype.remove = function() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    };\n    EventSourceApi.prototype.refetch = function() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    };\n    Object.defineProperty(EventSourceApi.prototype, \"id\", {\n        get: function() {\n            return this.internalEventSource.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"url\", {\n        get: function() {\n            return this.internalEventSource.meta.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"format\", {\n        get: function() {\n            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return EventSourceApi;\n}();\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    var containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    var allMatches = [];\n    for(var i = 0; i < containers.length; i += 1){\n        var matches = containers[i].querySelectorAll(selector);\n        for(var j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    var parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    var allMatches = [];\n    for(var i = 0; i < parents.length; i += 1){\n        var childNodes = parents[i].children; // only ever elements\n        for(var j = 0; j < childNodes.length; j += 1){\n            var childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(var propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = val + \"px\";\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\nfunction getElRoot(el) {\n    return el.getRootNode ? el.getRootNode() : document;\n}\n// Unique ID for DOM attribute\nvar guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return function(ev) {\n        var matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    var attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return function() {\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    var currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, function(mouseOverEv, matchedChild) {\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            var realOnMouseLeave_1 = function(mouseLeaveEv) {\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave_1);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave_1);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nvar transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    var realCallback = function(ev) {\n        callback(ev);\n        transitionEventNames.forEach(function(eventName) {\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach(function(eventName) {\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return tslib.__assign({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown: function(ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nvar guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.classList.add(\"fc-unselectable\");\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.classList.remove(\"fc-unselectable\");\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    var specs = [];\n    var tokens = [];\n    var i;\n    var token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    var i;\n    var cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    var s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter.apply(void 0, args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce(function(str, arg, index) {\n            return str.replace(\"$\" + index, arg || \"\");\n        }, formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    var allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    var contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nvar DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    var a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    var m0day = startOfDay(m0);\n    var m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    var d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    var y = marker.getUTCFullYear();\n    var w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    var firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    var dayStart = startOfDay(marker);\n    var days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    var fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    var fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC.apply(Date, a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId: defId,\n        range: range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    var dest = {};\n    if (complexPropsMap) {\n        for(var name_1 in complexPropsMap){\n            var complexObjs = [];\n            // collect the trailing object values, stopping when a non-object is discovered\n            for(var i = propObjs.length - 1; i >= 0; i -= 1){\n                var val = propObjs[i][name_1];\n                if (typeof val === \"object\" && val) {\n                    complexObjs.unshift(val);\n                } else if (val !== undefined) {\n                    dest[name_1] = val; // if there were no objects, this value will be used\n                    break;\n                }\n            }\n            // if the trailing values were objects, use the merged value\n            if (complexObjs.length) {\n                dest[name_1] = mergeProps(complexObjs);\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(var i = propObjs.length - 1; i >= 0; i -= 1){\n        var props = propObjs[i];\n        for(var name_2 in props){\n            if (!(name_2 in dest)) {\n                dest[name_2] = props[name_2];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    var filtered = {};\n    for(var key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    var newHash = {};\n    for(var key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    var hash = {};\n    for(var _i = 0, a_1 = a; _i < a_1.length; _i++){\n        var item = a_1[_i];\n        hash[item] = true;\n    }\n    return hash;\n}\nfunction buildHashFromArray(a, func) {\n    var hash = {};\n    for(var i = 0; i < a.length; i += 1){\n        var tuple = func(a[i], i);\n        hash[tuple[0]] = tuple[1];\n    }\n    return hash;\n}\nfunction hashValuesToArray(obj) {\n    var a = [];\n    for(var key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    var keys = [];\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n    if (equalityFuncs === void 0) {\n        equalityFuncs = {};\n    }\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(var key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(var key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n    if (startIndex === void 0) {\n        startIndex = 0;\n    }\n    if (step === void 0) {\n        step = 1;\n    }\n    var res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(var i = startIndex; i < endIndex; i += step){\n        var val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(var i = 0; i < recurringTypes.length; i += 1){\n        var parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            var allDay = refined.allDay;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay: allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;\n    var defs = eventStore.defs, instances = eventStore.instances;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, function(instance) {\n        return !defs[instance.defId].recurringDef;\n    });\n    for(var defId in defs){\n        var def = defs[defId];\n        if (def.recurringDef) {\n            var duration = def.recurringDef.duration;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for(var _i = 0, starts_1 = starts; _i < starts_1.length; _i++){\n                var start = starts_1[_i];\n                var instance = createEventInstance(defId, {\n                    start: start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nvar INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    var _a;\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject((_a = {}, _a[unit || \"milliseconds\"] = input, _a));\n    }\n    return null;\n}\nfunction parseString(s) {\n    var m = PARSE_RE.exec(s);\n    if (m) {\n        var sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    var duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    var weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    var res = null;\n    for(var i = 0; i < INTERNAL_UNITS.length; i += 1){\n        var unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            var localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    var ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n    if (stripZeroTime === void 0) {\n        stripZeroTime = false;\n    }\n    var s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso) {\n    if (doIso === void 0) {\n        doIso = false;\n    }\n    var sign = minutes < 0 ? \"-\" : \"+\";\n    var abs = Math.abs(minutes);\n    var hours = Math.floor(abs / 60);\n    var mins = Math.round(abs % 60);\n    if (doIso) {\n        return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n    }\n    return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : \"\");\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    var removeCnt = 0;\n    var i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    var len = a0.length;\n    var i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    var currentArgs;\n    var currentRes;\n    return function() {\n        var newArgs = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            newArgs[_i] = arguments[_i];\n        }\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArg;\n    var currentRes;\n    return function(newArg) {\n        if (!currentArg) {\n            currentRes = workerFunc.call(_this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.call(_this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgSets = [];\n    var currentResults = [];\n    return function(newArgSets) {\n        var currentLen = currentArgSets.length;\n        var newLen = newArgSets.length;\n        var i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                var res = workerFunc.apply(_this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgHash = {};\n    var currentResHash = {};\n    return function(newArgHash) {\n        var newResHash = {};\n        for(var key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                var res = workerFunc.apply(_this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nvar COMMA_RE = /,/g; // we need re for globalness\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\nvar UTC_RE = /UTC|GMT/;\nvar NativeFormatter = /** @class */ function() {\n    function NativeFormatter(formatSettings) {\n        var standardDateProps = {};\n        var extendedSettings = {};\n        var severity = 0;\n        for(var name_1 in formatSettings){\n            if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name_1] = formatSettings[name_1];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n            } else {\n                standardDateProps[name_1] = formatSettings[name_1];\n                if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    NativeFormatter.prototype.format = function(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    };\n    NativeFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;\n        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        var biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        var full0 = this.format(start, context);\n        var full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        var partial0 = partialFormattingFunc(start);\n        var partial1 = partialFormattingFunc(end);\n        var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    };\n    NativeFormatter.prototype.getLargestUnit = function() {\n        switch(this.severity){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    };\n    return NativeFormatter;\n}();\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    var standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return function(date) {\n            return formatTimeZoneOffset(date.timeZoneOffset);\n        };\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return function(date) {\n            return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n        };\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = tslib.__assign({}, standardDateProps); // copy\n    extendedSettings = tslib.__assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    var zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        var zeroProps = tslib.__assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return function(date) {\n        var marker = date.marker;\n        var format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        var s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase();\n        });\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase() + \"m\";\n        });\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, function(m0) {\n            return m0.toLocaleLowerCase();\n        });\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    var replaced = false;\n    s = s.replace(UTC_RE, function() {\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += \" \" + tzoStr;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    var parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    var partialOptions = {};\n    for(var name_2 in options){\n        if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n            partialOptions[name_2] = options[name_2];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    var i0 = 0;\n    while(i0 < full0.length){\n        var found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        var before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        var after0 = full0.substr(i0);\n        var i1 = 0;\n        while(i1 < full1.length){\n            var found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            var before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            var after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    var a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    var startInfo = expandZonedMarker(start, context.calendarSystem);\n    var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ var CmdFormatter = /** @class */ function() {\n    function CmdFormatter(cmdStr) {\n        this.cmdStr = cmdStr;\n    }\n    CmdFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    CmdFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return CmdFormatter;\n}();\nvar FuncFormatter = /** @class */ function() {\n    function FuncFormatter(func) {\n        this.func = func;\n    }\n    FuncFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    FuncFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return FuncFormatter;\n}();\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nvar BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    monthMode: Boolean,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nvar BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \"  \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30\n};\n// calendar listeners\n// ------------------\nvar CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nvar CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nvar VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    var refined = {};\n    var extra = {};\n    for(var propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(var propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined: refined,\n        extra: extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n    var eventStore = createEmptyEventStore();\n    var eventRefiners = buildEventRefiners(context);\n    for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n        var rawEvent = rawEvents_1[_i];\n        var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore) {\n    if (eventStore === void 0) {\n        eventStore = createEmptyEventStore();\n    }\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    var instance = eventStore.instances[instanceId];\n    if (instance) {\n        var def_1 = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        var newStore = filterEventStoreDefs(eventStore, function(lookDef) {\n            return isEventDefsGrouped(def_1, lookDef);\n        });\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def_1.defId] = def_1;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: tslib.__assign(tslib.__assign({}, store0.defs), store1.defs),\n        instances: tslib.__assign(tslib.__assign({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    var defs = filterHash(eventStore.defs, filterFunc);\n    var instances = filterHash(eventStore.instances, function(instance) {\n        return defs[instance.defId] // still exists?\n        ;\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    var defs = master.defs, instances = master.instances;\n    var filteredDefs = {};\n    var filteredInstances = {};\n    for(var defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(var instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nvar EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nvar EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    var constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nvar EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nvar EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nvar EVENT_REFINERS = tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;\n    var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def: def,\n            instance: null\n        };\n    }\n    var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context);\n        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        return {\n            def: def,\n            instance: instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n    var def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: guid(),\n        sourceId: sourceId,\n        allDay: allDay,\n        hasEnd: hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: tslib.__assign(tslib.__assign({}, refined.extendedProps || {}), extra)\n    };\n    for(var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++){\n        var memberAdder = _a[_i];\n        tslib.__assign(def, memberAdder(refined));\n    }\n    // help out EventApi from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    var allDay = refined.allDay;\n    var startMeta;\n    var startMarker = null;\n    var hasEnd = false;\n    var endMeta;\n    var endMarker = null;\n    var startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay: allDay,\n        hasEnd: hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    var res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    var start = startOfDay(timedRange.start);\n    var end = addDays(start, dayCnt);\n    return {\n        start: start,\n        end: end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n    if (nextDayThreshold === void 0) {\n        nextDayThreshold = createDuration(0);\n    }\n    var startDay = null;\n    var endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    var visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nfunction parseRange(input, dateEnv) {\n    var start = null;\n    var end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start: start,\n        end: end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    var invertedRanges = [];\n    var start = constraintRange.start; // the end of the previous range. the start of the new range\n    var i;\n    var dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start: start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start: start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    var start = range0.start, end = range0.end;\n    var newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start: start,\n            end: end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    var inverseBgByGroupId = {};\n    var inverseBgByDefId = {};\n    var defByGroupId = {};\n    var bgRanges = [];\n    var fgRanges = [];\n    var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        var ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = eventStore.defs[instance.defId];\n        var ui = eventUis[def.defId];\n        var origRange = instance.range;\n        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        var slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def: def,\n                    ui: ui,\n                    instance: instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(var groupId in inverseBgByGroupId){\n        var ranges = inverseBgByGroupId[groupId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++){\n            var invertedRange = invertedRanges_1[_i];\n            var def = defByGroupId[groupId];\n            var ui = eventUis[def.defId];\n            bgRanges.push({\n                def: def,\n                ui: ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(var defId in inverseBgByDefId){\n        var ranges = inverseBgByDefId[defId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++){\n            var invertedRange = invertedRanges_2[_a];\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, function(eventDef) {\n        return compileEventUi(eventDef, eventUiBases);\n    });\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    var uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    var objs = segs.map(buildSegCompareObj);\n    objs.sort(function(obj0, obj1) {\n        return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n    });\n    return objs.map(function(c) {\n        return c._seg;\n    });\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    var end = range.end ? range.end.valueOf() : 0; // \"\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start: start,\n        end: end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    var pluginHooks = context.pluginHooks;\n    var transformers = pluginHooks.isDraggableTransformers;\n    var _a = seg.eventRange, def = _a.def, ui = _a.ui;\n    var val = ui.startEditable;\n    for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n        var transformer = transformers_1[_i];\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;\n    var eventDef = seg.eventRange.def;\n    var eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    var wholeEventStart = eventInstance.range.start;\n    var wholeEventEnd = eventInstance.range.end;\n    var segStart = startOverride || seg.start || seg.eventRange.range.start;\n    var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    var segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end < (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    var classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString();\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    var _a = seg.eventRange, def = _a.def, instance = _a.instance;\n    var url = def.url;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    var emitter = context.emitter, options = context.options;\n    var eventInteractive = options.eventInteractive;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs(function(ev) {\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventApi(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nvar STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    var span = parseOpenDateSpan(raw, dateEnv);\n    var range = span.range;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;\n    var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    var allDay = standardProps.allDay;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return tslib.__assign({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay: allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(var propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(var propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return tslib.__assign(tslib.__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return tslib.__assign(tslib.__assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime: omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime: omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    var res = refineEventDef({\n        editable: false\n    }, context);\n    var def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def: def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", tslib.__assign(tslib.__assign({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    var props = {};\n    for(var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        tslib.__assign(props, transform(dateSpan, context));\n    }\n    tslib.__assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    var dest = createEmptyEventStore();\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    var standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    var copy = tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef), standardProps), {\n        ui: tslib.__assign(tslib.__assign({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = tslib.__assign(tslib.__assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for(var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++){\n        var applier = _a[_i];\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    var dateEnv = context.dateEnv;\n    var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    var copy = tslib.__assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar ViewApi = /** @class */ function() {\n    function ViewApi(type, getCurrentData, dateEnv) {\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    Object.defineProperty(ViewApi.prototype, \"calendar\", {\n        get: function() {\n            return this.getCurrentData().calendarApi;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"title\", {\n        get: function() {\n            return this.getCurrentData().viewTitle;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewApi.prototype.getOption = function(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    };\n    return ViewApi;\n}();\nvar EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventSourceRefiners(context);\n    }\n    var rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;\n        var metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    for(var i = defs.length - 1; i >= 0; i -= 1){\n        var def = defs[i];\n        var meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta: meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    var initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === \"function\") {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\nvar CalendarApi = /** @class */ function() {\n    function CalendarApi() {}\n    CalendarApi.prototype.getCurrentData = function() {\n        return this.currentDataManager.getCurrentData();\n    };\n    CalendarApi.prototype.dispatch = function(action) {\n        return this.currentDataManager.dispatch(action);\n    };\n    Object.defineProperty(CalendarApi.prototype, \"view\", {\n        get: function() {\n            return this.getCurrentData().viewApi;\n        } // for public API\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    CalendarApi.prototype.batchRendering = function(callback) {\n        callback();\n    };\n    CalendarApi.prototype.updateSize = function() {\n        this.trigger(\"_resize\", true);\n    };\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.setOption = function(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    };\n    CalendarApi.prototype.getOption = function(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    };\n    CalendarApi.prototype.getAvailableLocaleCodes = function() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    };\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.on = function(handlerName, handler) {\n        var currentDataManager = this.currentDataManager;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n        }\n    };\n    CalendarApi.prototype.off = function(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    };\n    // not meant for public use\n    CalendarApi.prototype.trigger = function(handlerName) {\n        var _a;\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this.currentDataManager.emitter).trigger.apply(_a, tslib.__spreadArray([\n            handlerName\n        ], args));\n    };\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.changeView = function(viewType, dateOrRange) {\n        var _this = this;\n        this.batchRendering(function() {\n            _this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType\n                    });\n                    _this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    var dateEnv = _this.getCurrentData().dateEnv;\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                _this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType: viewType\n                });\n            }\n        });\n    };\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    CalendarApi.prototype.zoomTo = function(dateMarker, viewType) {\n        var state = this.getCurrentData();\n        var spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker: dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: dateMarker\n            });\n        }\n    };\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    CalendarApi.prototype.getUnitViewSpec = function(unit) {\n        var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;\n        var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        var i;\n        var spec;\n        for(var viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    };\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.prev = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    };\n    CalendarApi.prototype.next = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    };\n    CalendarApi.prototype.prevYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    };\n    CalendarApi.prototype.nextYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    };\n    CalendarApi.prototype.today = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n        });\n    };\n    CalendarApi.prototype.gotoDate = function(zonedDateInput) {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    };\n    CalendarApi.prototype.incrementDate = function(deltaInput) {\n        var state = this.getCurrentData();\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    };\n    // for external API\n    CalendarApi.prototype.getDate = function() {\n        var state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    };\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.formatDate = function(d, formatter) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    };\n    // `settings` is for formatter AND isEndExclusive\n    CalendarApi.prototype.formatRange = function(d0, d1, settings) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    };\n    CalendarApi.prototype.formatIso = function(d, omitTime) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime: omitTime\n        });\n    };\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    // this public method receives start/end dates in any format, with any timezone\n    // NOTE: args were changed from v3\n    CalendarApi.prototype.select = function(dateOrObj, endDate) {\n        var selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        var state = this.getCurrentData();\n        var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection: selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    };\n    // public method\n    CalendarApi.prototype.unselect = function(pev) {\n        var state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    };\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.addEvent = function(eventInput, sourceInput) {\n        if (eventInput instanceof EventApi) {\n            var def = eventInput._def;\n            var instance = eventInput._instance;\n            var currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def: def,\n                        instance: instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        var state = this.getCurrentData();\n        var eventSource;\n        if (sourceInput instanceof EventSourceApi) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                eventSource = hashValuesToArray(state.eventSources)[0];\n            }\n        } else if (sourceInput != null) {\n            var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn('Could not find an event source with ID \"' + sourceInput + '\"'); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        var tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    };\n    CalendarApi.prototype.triggerEventAdd = function(eventApi) {\n        var _this = this;\n        var emitter = this.getCurrentData().emitter;\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: function() {\n                _this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    };\n    // TODO: optimize\n    CalendarApi.prototype.getEventById = function(id) {\n        var state = this.getCurrentData();\n        var _a = state.eventStore, defs = _a.defs, instances = _a.instances;\n        id = String(id);\n        for(var defId in defs){\n            var def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventApi(state, def, null);\n                }\n                for(var instanceId in instances){\n                    var instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventApi(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.getEvents = function() {\n        var currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    };\n    CalendarApi.prototype.removeAllEvents = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    };\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.getEventSources = function() {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        var sourceApis = [];\n        for(var internalId in sourceHash){\n            sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    };\n    CalendarApi.prototype.getEventSourceById = function(id) {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        id = String(id);\n        for(var sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceApi(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.addEventSource = function(sourceInput) {\n        var state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceApi) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        var eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceApi(state, eventSource);\n        }\n        return null;\n    };\n    CalendarApi.prototype.removeAllEventSources = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    };\n    CalendarApi.prototype.refetchEvents = function() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    };\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.scrollToTime = function(timeInput) {\n        var time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time: time\n            });\n        }\n    };\n    return CalendarApi;\n}();\nvar EventApi = /** @class */ function() {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    function EventApi(context, def, instance) {\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ EventApi.prototype.setProp = function(name, val) {\n        var _a, _b;\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: (_a = {}, _a[name] = val, _a)\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            var ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = (_b = {}, _b[name] = val, _b);\n            }\n            this.mutate({\n                standardProps: {\n                    ui: ui\n                }\n            });\n        } else {\n            console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n        }\n    };\n    EventApi.prototype.setExtendedProp = function(name, val) {\n        var _a;\n        this.mutate({\n            extendedProps: (_a = {}, _a[name] = val, _a)\n        });\n    };\n    EventApi.prototype.setStart = function(startInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            var instanceRange = this._instance.range;\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta: startDelta\n                });\n            }\n        }\n    };\n    EventApi.prototype.setEnd = function(endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta: endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    };\n    EventApi.prototype.setDates = function(startInput, endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var standardProps = {\n            allDay: options.allDay\n        };\n        var start = dateEnv.createMarker(startInput);\n        var end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            var instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps: standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta: startDelta,\n                        endDelta: endDelta,\n                        standardProps: standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps: standardProps\n                });\n            }\n        }\n    };\n    EventApi.prototype.moveStart = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveEnd = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveDates = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.setAllDay = function(allDay, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var standardProps = {\n            allDay: allDay\n        };\n        var maintainDuration = options.maintainDuration;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps: standardProps\n        });\n    };\n    EventApi.prototype.formatRange = function(formatInput) {\n        var dateEnv = this._context.dateEnv;\n        var instance = this._instance;\n        var formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    };\n    EventApi.prototype.mutate = function(mutation) {\n        var instance = this._instance;\n        if (instance) {\n            var def = this._def;\n            var context_1 = this._context;\n            var eventStore_1 = context_1.getCurrentData().eventStore;\n            var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n            var eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n            var oldEvent = new EventApi(context_1, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context_1.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context_1.emitter.trigger(\"eventChange\", {\n                oldEvent: oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n                revert: function() {\n                    context_1.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore: eventStore_1\n                    });\n                }\n            });\n        }\n    };\n    EventApi.prototype.remove = function() {\n        var context = this._context;\n        var asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert: function() {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    };\n    Object.defineProperty(EventApi.prototype, \"source\", {\n        get: function() {\n            var sourceId = this._def.sourceId;\n            if (sourceId) {\n                return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n            }\n            return null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"start\", {\n        get: function() {\n            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"end\", {\n        get: function() {\n            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance) {\n                return this._context.dateEnv.formatIso(instance.range.start, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"endStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance && this._def.hasEnd) {\n                return this._context.dateEnv.formatIso(instance.range.end, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedEndTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"id\", {\n        // computable props that all access the def\n        // TODO: find a TypeScript-compatible way to do this at scale\n        get: function() {\n            return this._def.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"groupId\", {\n        get: function() {\n            return this._def.groupId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allDay\", {\n        get: function() {\n            return this._def.allDay;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"title\", {\n        get: function() {\n            return this._def.title;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"url\", {\n        get: function() {\n            return this._def.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"display\", {\n        get: function() {\n            return this._def.ui.display || \"auto\";\n        } // bad. just normalize the type earlier\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startEditable\", {\n        get: function() {\n            return this._def.ui.startEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n        get: function() {\n            return this._def.ui.durationEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"constraint\", {\n        get: function() {\n            return this._def.ui.constraints[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"overlap\", {\n        get: function() {\n            return this._def.ui.overlap;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allow\", {\n        get: function() {\n            return this._def.ui.allows[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n        get: function() {\n            return this._def.ui.backgroundColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"borderColor\", {\n        get: function() {\n            return this._def.ui.borderColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"textColor\", {\n        get: function() {\n            return this._def.ui.textColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"classNames\", {\n        // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n        get: function() {\n            return this._def.ui.classNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n        get: function() {\n            return this._def.extendedProps;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EventApi.prototype.toPlainObject = function(settings) {\n        if (settings === void 0) {\n            settings = {};\n        }\n        var def = this._def;\n        var ui = def.ui;\n        var _a = this, startStr = _a.startStr, endStr = _a.endStr;\n        var res = {};\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                tslib.__assign(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    };\n    EventApi.prototype.toJSON = function() {\n        return this.toPlainObject();\n    };\n    return EventApi;\n}();\nfunction eventApiToStore(eventApi) {\n    var _a, _b;\n    var def = eventApi._def;\n    var instance = eventApi._instance;\n    return {\n        defs: (_a = {}, _a[def.defId] = def, _a),\n        instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    var defs = eventStore.defs, instances = eventStore.instances;\n    var eventApis = [];\n    var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(var id in instances){\n        var instance = instances[id];\n        var def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventApi(context, def, instance));\n        }\n    }\n    return eventApis;\n}\nvar calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nvar GregorianCalendarSystem = /** @class */ function() {\n    function GregorianCalendarSystem() {}\n    GregorianCalendarSystem.prototype.getMarkerYear = function(d) {\n        return d.getUTCFullYear();\n    };\n    GregorianCalendarSystem.prototype.getMarkerMonth = function(d) {\n        return d.getUTCMonth();\n    };\n    GregorianCalendarSystem.prototype.getMarkerDay = function(d) {\n        return d.getUTCDate();\n    };\n    GregorianCalendarSystem.prototype.arrayToMarker = function(arr) {\n        return arrayToUtcDate(arr);\n    };\n    GregorianCalendarSystem.prototype.markerToArray = function(marker) {\n        return dateToUtcArray(marker);\n    };\n    return GregorianCalendarSystem;\n}();\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    var m = ISO_RE.exec(str);\n    if (m) {\n        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n        if (isValidDate(marker)) {\n            var timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker: marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset: timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nvar DateEnv = /** @class */ function() {\n    function DateEnv(settings) {\n        var timeZone = this.timeZone = settings.timeZone;\n        var isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    DateEnv.prototype.createMarker = function(input) {\n        var meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    };\n    DateEnv.prototype.createNowMarker = function() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    };\n    DateEnv.prototype.createMarkerMeta = function(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        var marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    };\n    DateEnv.prototype.parse = function(s) {\n        var parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        var marker = parts.marker;\n        var forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo: forcedTzo\n        };\n    };\n    // Accessors\n    DateEnv.prototype.getYear = function(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    };\n    DateEnv.prototype.getMonth = function(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    };\n    // Adding / Subtracting\n    DateEnv.prototype.add = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.subtract = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addYears = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addMonths = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    // Diffing Whole Units\n    DateEnv.prototype.diffWholeYears = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    };\n    DateEnv.prototype.diffWholeMonths = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    };\n    // Range / Duration\n    DateEnv.prototype.greatestWholeUnit = function(m0, m1) {\n        var n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    };\n    DateEnv.prototype.countDurationsBetween = function(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        var diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    };\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    DateEnv.prototype.startOf = function(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    };\n    DateEnv.prototype.startOfYear = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    };\n    DateEnv.prototype.startOfMonth = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    };\n    DateEnv.prototype.startOfWeek = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    };\n    // Week Number\n    DateEnv.prototype.computeWeekNumber = function(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    };\n    // TODO: choke on timeZoneName: long\n    DateEnv.prototype.format = function(marker, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        return formatter.format({\n            marker: marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    };\n    DateEnv.prototype.formatRange = function(start, end, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    };\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ DateEnv.prototype.formatIso = function(marker, extraOptions) {\n        if (extraOptions === void 0) {\n            extraOptions = {};\n        }\n        var timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    };\n    // TimeZone\n    DateEnv.prototype.timestampToMarker = function(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    };\n    DateEnv.prototype.offsetForMarker = function(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    };\n    // Conversion\n    DateEnv.prototype.toDate = function(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    };\n    return DateEnv;\n}();\nvar globalLocales = [];\nvar MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nvar RAW_EN_LOCALE = tslib.__assign(tslib.__assign({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today: function(buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : \"This \" + buttonText;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint: function(eventCnt) {\n        return \"Show \" + eventCnt + \" more event\" + (eventCnt === 1 ? \"\" : \"s\");\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    var allRawLocales = globalLocales.concat(explicitRawLocales);\n    var rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for(var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++){\n        var rawLocale = allRawLocales_1[_i];\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode: defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    var codes = [].concat(codeArg || []); // will convert to array\n    var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(var i = 0; i < codes.length; i += 1){\n        var parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(var j = parts.length; j > 0; j -= 1){\n            var simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    var merged = mergeProps([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    var week = merged.week;\n    delete merged.week;\n    return {\n        codeArg: codeArg,\n        codes: codes,\n        week: week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\nfunction formatDate(dateInput, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var dateEnv = buildDateEnv$1(options);\n    var formatter = createFormatter(options);\n    var dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    var dateEnv = buildDateEnv$1(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    var formatter = createFormatter(options);\n    var startMeta = dateEnv.createMarkerMeta(startInput);\n    var endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv$1(settings) {\n    var locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new DateEnv(tslib.__assign(tslib.__assign({\n        timeZone: BASE_OPTION_DEFAULTS.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale: locale\n    }));\n}\nvar DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    var rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter(function(rawDef) {\n            return rawDef.daysOfWeek;\n        });\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map(function(rawDef) {\n        return tslib.__assign(tslib.__assign({}, DEF_DEFAULTS), rawDef);\n    });\n    return rawDefs;\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    var res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nvar canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    var el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    var div = el.querySelector(\"div\");\n    var possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nvar Splitter = /** @class */ function() {\n    function Splitter() {\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    Splitter.prototype.splitProps = function(props) {\n        var _this = this;\n        var keyInfos = this.getKeyInfo(props);\n        var defKeys = this.getKeysForEventDefs(props.eventStore);\n        var dateSelections = this.splitDateSelection(props.dateSelection);\n        var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        var eventStores = this.splitEventStore(props.eventStore, defKeys);\n        var eventDrags = this.splitEventDrag(props.eventDrag);\n        var eventResizes = this.splitEventResize(props.eventResize);\n        var splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, function(info, key) {\n            return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n        });\n        for(var key in keyInfos){\n            var keyInfo = keyInfos[key];\n            var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            var buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore: eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    };\n    Splitter.prototype._splitDateSpan = function(dateSpan) {\n        var dateSpans = {};\n        if (dateSpan) {\n            var keys = this.getKeysForDateSpan(dateSpan);\n            for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){\n                var key = keys_1[_i];\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    };\n    Splitter.prototype._getKeysForEventDefs = function(eventStore) {\n        var _this = this;\n        return mapHash(eventStore.defs, function(eventDef) {\n            return _this.getKeysForEventDef(eventDef);\n        });\n    };\n    Splitter.prototype._splitEventStore = function(eventStore, defKeys) {\n        var defs = eventStore.defs, instances = eventStore.instances;\n        var splitStores = {};\n        for(var defId in defs){\n            for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                var key = _a[_i];\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(var instanceId in instances){\n            var instance = instances[instanceId];\n            for(var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++){\n                var key = _c[_b];\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    };\n    Splitter.prototype._splitIndividualUi = function(eventUiBases, defKeys) {\n        var splitHashes = {};\n        for(var defId in eventUiBases){\n            if (defId) {\n                for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                    var key = _a[_i];\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    };\n    Splitter.prototype._splitInteraction = function(interaction) {\n        var splitStates = {};\n        if (interaction) {\n            var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            var populate = function(key) {\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(var key in affectedStores_1){\n                populate(key);\n            }\n            for(var key in mutatedStores_1){\n                populate(key);\n            }\n        }\n        return splitStates;\n    };\n    return Splitter;\n}();\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    var baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    var stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        tslib.__assign(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    var classNames = [\n        \"fc-day\",\n        \"fc-day-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    var classNames = [\n        \"fc-slot\",\n        \"fc-slot-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nvar DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nvar WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {\n    if (viewType === void 0) {\n        viewType = \"day\";\n    }\n    if (isTabbable === void 0) {\n        isTabbable = true;\n    }\n    var dateEnv = context.dateEnv, options = context.options, calendarApi = context.calendarApi;\n    var dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        var zonedDate = dateEnv.toDate(dateMarker);\n        var handleInteraction = function(ev) {\n            var customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return tslib.__assign({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nvar _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    var outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    var innerEl = outerEl.firstChild;\n    var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nvar _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    var el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    var res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding) {\n    if (getPadding === void 0) {\n        getPadding = false;\n    }\n    var computedStyle = window.getComputedStyle(el);\n    var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    var res = {\n        borderLeft: borderLeft,\n        borderRight: borderRight,\n        borderTop: borderTop,\n        borderBottom: borderBottom,\n        scrollbarBottom: scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n    if (goWithinPadding === void 0) {\n        goWithinPadding = false;\n    }\n    var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    var edges = computeEdges(el, goWithinPadding);\n    var res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    var rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.pageXOffset,\n        top: rect.top + window.pageYOffset,\n        right: rect.right + window.pageXOffset,\n        bottom: rect.bottom + window.pageYOffset\n    };\n}\nfunction computeClippedClientRect(el) {\n    var clippingParents = getClippingParents(el);\n    var rect = el.getBoundingClientRect();\n    for(var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++){\n        var clippingParent = clippingParents_1[_i];\n        var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\nfunction computeHeightAndMargins(el) {\n    return el.getBoundingClientRect().height + computeVMargins(el);\n}\nfunction computeVMargins(el) {\n    var computed = window.getComputedStyle(el);\n    return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n}\n// does not return window\nfunction getClippingParents(el) {\n    var parents = [];\n    while(el instanceof HTMLElement){\n        var computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n// given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\nfunction unpromisify(func, success, failure) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    var isResolved = false;\n    var wrappedSuccess = function() {\n        if (!isResolved) {\n            isResolved = true;\n            success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n    };\n    var wrappedFailure = function() {\n        if (!isResolved) {\n            isResolved = true;\n            if (failure) {\n                failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            }\n        }\n    };\n    var res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nvar Emitter = /** @class */ function() {\n    function Emitter() {\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    Emitter.prototype.setThisContext = function(thisContext) {\n        this.thisContext = thisContext;\n    };\n    Emitter.prototype.setOptions = function(options) {\n        this.options = options;\n    };\n    Emitter.prototype.on = function(type, handler) {\n        addToHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.off = function(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.trigger = function(type) {\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        var attachedHandlers = this.handlers[type] || [];\n        var optionHandler = this.options && this.options[type];\n        var handlers = [].concat(optionHandler || [], attachedHandlers);\n        for(var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++){\n            var handler = handlers_1[_a];\n            handler.apply(this.thisContext, args);\n        }\n    };\n    Emitter.prototype.hasHandlers = function(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    };\n    return Emitter;\n}();\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter(function(func) {\n                return func !== handler;\n            });\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ var PositionCache = /** @class */ function() {\n    function PositionCache(originEl, els, isHorizontal, isVertical) {\n        this.els = els;\n        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    PositionCache.prototype.buildElHorizontals = function(originClientLeft) {\n        var lefts = [];\n        var rights = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    };\n    // Populates the top/bottom internal coordinate arrays\n    PositionCache.prototype.buildElVerticals = function(originClientTop) {\n        var tops = [];\n        var bottoms = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    };\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.leftToIndex = function(leftPosition) {\n        var _a = this, lefts = _a.lefts, rights = _a.rights;\n        var len = lefts.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.topToIndex = function(topPosition) {\n        var _a = this, tops = _a.tops, bottoms = _a.bottoms;\n        var len = tops.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Gets the width of the element at the given index\n    PositionCache.prototype.getWidth = function(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    };\n    // Gets the height of the element at the given index\n    PositionCache.prototype.getHeight = function(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    };\n    return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ var ScrollController = /** @class */ function() {\n    function ScrollController() {}\n    ScrollController.prototype.getMaxScrollTop = function() {\n        return this.getScrollHeight() - this.getClientHeight();\n    };\n    ScrollController.prototype.getMaxScrollLeft = function() {\n        return this.getScrollWidth() - this.getClientWidth();\n    };\n    ScrollController.prototype.canScrollVertically = function() {\n        return this.getMaxScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollHorizontally = function() {\n        return this.getMaxScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollUp = function() {\n        return this.getScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollDown = function() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    };\n    ScrollController.prototype.canScrollLeft = function() {\n        return this.getScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollRight = function() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    };\n    return ScrollController;\n}();\nvar ElementScrollController = /** @class */ function(_super) {\n    tslib.__extends(ElementScrollController, _super);\n    function ElementScrollController(el) {\n        var _this = _super.call(this) || this;\n        _this.el = el;\n        return _this;\n    }\n    ElementScrollController.prototype.getScrollTop = function() {\n        return this.el.scrollTop;\n    };\n    ElementScrollController.prototype.getScrollLeft = function() {\n        return this.el.scrollLeft;\n    };\n    ElementScrollController.prototype.setScrollTop = function(top) {\n        this.el.scrollTop = top;\n    };\n    ElementScrollController.prototype.setScrollLeft = function(left) {\n        this.el.scrollLeft = left;\n    };\n    ElementScrollController.prototype.getScrollWidth = function() {\n        return this.el.scrollWidth;\n    };\n    ElementScrollController.prototype.getScrollHeight = function() {\n        return this.el.scrollHeight;\n    };\n    ElementScrollController.prototype.getClientHeight = function() {\n        return this.el.clientHeight;\n    };\n    ElementScrollController.prototype.getClientWidth = function() {\n        return this.el.clientWidth;\n    };\n    return ElementScrollController;\n}(ScrollController);\nvar WindowScrollController = /** @class */ function(_super) {\n    tslib.__extends(WindowScrollController, _super);\n    function WindowScrollController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WindowScrollController.prototype.getScrollTop = function() {\n        return window.pageYOffset;\n    };\n    WindowScrollController.prototype.getScrollLeft = function() {\n        return window.pageXOffset;\n    };\n    WindowScrollController.prototype.setScrollTop = function(n) {\n        window.scroll(window.pageXOffset, n);\n    };\n    WindowScrollController.prototype.setScrollLeft = function(n) {\n        window.scroll(n, window.pageYOffset);\n    };\n    WindowScrollController.prototype.getScrollWidth = function() {\n        return document.documentElement.scrollWidth;\n    };\n    WindowScrollController.prototype.getScrollHeight = function() {\n        return document.documentElement.scrollHeight;\n    };\n    WindowScrollController.prototype.getClientHeight = function() {\n        return document.documentElement.clientHeight;\n    };\n    WindowScrollController.prototype.getClientWidth = function() {\n        return document.documentElement.clientWidth;\n    };\n    return WindowScrollController;\n}(ScrollController);\nvar Theme = /** @class */ function() {\n    function Theme(calendarOptions) {\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    Theme.prototype.setIconOverride = function(iconOverrideHash) {\n        var iconClassesCopy;\n        var buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = tslib.__assign({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    };\n    Theme.prototype.applyIconOverridePrefix = function(className) {\n        var prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    };\n    Theme.prototype.getClass = function(key) {\n        return this.classes[key] || \"\";\n    };\n    Theme.prototype.getIconClass = function(buttonName, isRtl) {\n        var className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return this.baseIconClass + \" \" + className;\n        }\n        return \"\";\n    };\n    Theme.prototype.getCustomButtonIconClass = function(customButtonProps) {\n        var className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n            }\n        }\n        return \"\";\n    };\n    return Theme;\n}();\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\nvar ScrollResponder = /** @class */ function() {\n    function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n        var _this = this;\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = function(request) {\n            _this.queuedRequest = tslib.__assign({}, _this.queuedRequest || {}, request);\n            _this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    ScrollResponder.prototype.detach = function() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    };\n    ScrollResponder.prototype.update = function(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    };\n    ScrollResponder.prototype.fireInitialScroll = function() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    };\n    ScrollResponder.prototype.drain = function() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    };\n    return ScrollResponder;\n}();\nvar ViewContextType = vdom_cjs.createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv: dateEnv,\n        options: viewOptions,\n        pluginHooks: pluginHooks,\n        emitter: emitter,\n        dispatch: dispatch,\n        getCurrentData: getCurrentData,\n        calendarApi: calendarApi,\n        viewSpec: viewSpec,\n        viewApi: viewApi,\n        dateProfileGenerator: dateProfileGenerator,\n        theme: theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler: function(handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler: function(handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder: function(execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent: registerInteractiveComponent,\n        unregisterInteractiveComponent: unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ var PureComponent = /** @class */ function(_super) {\n    tslib.__extends(PureComponent, _super);\n    function PureComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PureComponent.prototype.shouldComponentUpdate = function(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    };\n    // HACK for freakin' React StrictMode\n    PureComponent.prototype.safeSetState = function(newState) {\n        if (!compareObjs(this.state, tslib.__assign(tslib.__assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    };\n    PureComponent.addPropsEquality = addPropsEquality;\n    PureComponent.addStateEquality = addStateEquality;\n    PureComponent.contextType = ViewContextType;\n    return PureComponent;\n}(vdom_cjs.Component);\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nvar BaseComponent = /** @class */ function(_super) {\n    tslib.__extends(BaseComponent, _super);\n    function BaseComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BaseComponent.contextType = ViewContextType;\n    return BaseComponent;\n}(PureComponent);\nfunction addPropsEquality(propEquality) {\n    var hash = Object.create(this.prototype.propEquality);\n    tslib.__assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    var hash = Object.create(this.prototype.stateEquality);\n    tslib.__assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ var DateComponent = /** @class */ function(_super) {\n    tslib.__extends(DateComponent, _super);\n    function DateComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.uid = guid();\n        return _this;\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.prepareHits = function() {};\n    DateComponent.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    };\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.isValidSegDownEl = function(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    };\n    DateComponent.prototype.isValidDateDownEl = function(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    };\n    return DateComponent;\n}(BaseComponent);\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: guid(),\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        contentTypeHandlers: input.contentTypeHandlers || {},\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    var isAdded = {};\n    var hooks = {\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        contentTypeHandlers: {},\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for(var _i = 0, defs_1 = defs; _i < defs_1.length; _i++){\n            var def = defs_1[_i];\n            if (!isAdded[def.id]) {\n                isAdded[def.id] = true;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    var currentOverrideDefs = [];\n    var currentGlobalDefs = [];\n    var currentHooks;\n    return function(overrideDefs, globalDefs) {\n        if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: tslib.__assign(tslib.__assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: tslib.__assign(tslib.__assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: tslib.__assign(tslib.__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        contentTypeHandlers: tslib.__assign(tslib.__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n        listenerRefiners: tslib.__assign(tslib.__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: tslib.__assign(tslib.__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: tslib.__assign(tslib.__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nvar StandardTheme = /** @class */ function(_super) {\n    tslib.__extends(StandardTheme, _super);\n    function StandardTheme() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StandardTheme;\n}(Theme);\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    var hash = {};\n    var viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    var defaultConfig = defaultConfigs[viewType];\n    var overrideConfig = overrideConfigs[viewType];\n    var queryProp = function(name) {\n        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    };\n    var theComponent = queryProp(\"component\");\n    var superType = queryProp(\"superType\");\n    var superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: tslib.__assign(tslib.__assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: tslib.__assign(tslib.__assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\n/* eslint max-classes-per-file: off */ // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\nvar RenderHook = /** @class */ function(_super) {\n    tslib.__extends(RenderHook, _super);\n    function RenderHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = vdom_cjs.createRef();\n        _this.handleRootEl = function(el) {\n            setRef(_this.rootElRef, el);\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        return _this;\n    }\n    RenderHook.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var hookProps = props.hookProps;\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: props.didMount,\n            willUnmount: props.willUnmount,\n            elRef: this.handleRootEl\n        }, function(rootElRef) {\n            return vdom_cjs.createElement(ContentHook, {\n                hookProps: hookProps,\n                content: props.content,\n                defaultContent: props.defaultContent,\n                backupElRef: _this.rootElRef\n            }, function(innerElRef, innerContent) {\n                return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n            });\n        });\n    };\n    return RenderHook;\n}(BaseComponent);\n// TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\nvar CustomContentRenderContext = vdom_cjs.createContext(0);\nfunction ContentHook(props) {\n    return vdom_cjs.createElement(CustomContentRenderContext.Consumer, null, function(renderId) {\n        return vdom_cjs.createElement(ContentHookInner, tslib.__assign({\n            renderId: renderId\n        }, props));\n    });\n}\nvar ContentHookInner = /** @class */ function(_super) {\n    tslib.__extends(ContentHookInner, _super);\n    function ContentHookInner() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.innerElRef = vdom_cjs.createRef();\n        return _this;\n    }\n    ContentHookInner.prototype.render = function() {\n        return this.props.children(this.innerElRef, this.renderInnerContent());\n    };\n    ContentHookInner.prototype.componentDidMount = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentDidUpdate = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentWillUnmount = function() {\n        if (this.customContentInfo && this.customContentInfo.destroy) {\n            this.customContentInfo.destroy();\n        }\n    };\n    ContentHookInner.prototype.renderInnerContent = function() {\n        var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n        var innerContent = this.getInnerContent();\n        var meta = this.getContentMeta(innerContent);\n        // initial run, or content-type changing? (from vue -> react for example)\n        if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n            // clearing old value\n            if (customContentInfo) {\n                if (customContentInfo.destroy) {\n                    customContentInfo.destroy();\n                }\n                customContentInfo = this.customContentInfo = null;\n            }\n            // assigning new value\n            if (meta.contentKey) {\n                customContentInfo = this.customContentInfo = tslib.__assign({\n                    contentKey: meta.contentKey,\n                    contentVal: innerContent[meta.contentKey]\n                }, meta.buildLifecycleFuncs());\n            }\n        // updating\n        } else if (customContentInfo) {\n            customContentInfo.contentVal = innerContent[meta.contentKey];\n        }\n        return customContentInfo ? [] // signal that something was specified\n         : innerContent; // assume a [p]react vdom node. use it\n    };\n    ContentHookInner.prototype.getInnerContent = function() {\n        var props = this.props;\n        var innerContent = normalizeContent(props.content, props.hookProps);\n        if (innerContent === undefined) {\n            innerContent = normalizeContent(props.defaultContent, props.hookProps);\n        }\n        return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n    };\n    ContentHookInner.prototype.getContentMeta = function(innerContent) {\n        var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n        var contentKey = \"\";\n        var buildLifecycleFuncs = null;\n        if (innerContent) {\n            for(var searchKey in contentTypeHandlers){\n                if (innerContent[searchKey] !== undefined) {\n                    contentKey = searchKey;\n                    buildLifecycleFuncs = contentTypeHandlers[searchKey];\n                    break;\n                }\n            }\n        }\n        return {\n            contentKey: contentKey,\n            buildLifecycleFuncs: buildLifecycleFuncs\n        };\n    };\n    ContentHookInner.prototype.updateCustomContent = function() {\n        if (this.customContentInfo) {\n            this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal);\n        }\n    };\n    return ContentHookInner;\n}(BaseComponent);\nvar MountHook = /** @class */ function(_super) {\n    tslib.__extends(MountHook, _super);\n    function MountHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, rootEl);\n            }\n        };\n        return _this;\n    }\n    MountHook.prototype.render = function() {\n        return this.props.children(this.handleRootEl);\n    };\n    MountHook.prototype.componentDidMount = function() {\n        var callback = this.props.didMount;\n        if (callback) {\n            callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    MountHook.prototype.componentWillUnmount = function() {\n        var callback = this.props.willUnmount;\n        if (callback) {\n            callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    return MountHook;\n}(BaseComponent);\nfunction buildClassNameNormalizer() {\n    var currentGenerator;\n    var currentHookProps;\n    var currentClassNames = [];\n    return function(generator, hookProps) {\n        if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n            currentGenerator = generator;\n            currentHookProps = hookProps;\n            currentClassNames = normalizeClassNames(generator, hookProps);\n        }\n        return currentClassNames;\n    };\n}\nfunction normalizeClassNames(classNames, hookProps) {\n    if (typeof classNames === \"function\") {\n        classNames = classNames(hookProps);\n    }\n    return parseClassNames(classNames);\n}\nfunction normalizeContent(input, hookProps) {\n    if (typeof input === \"function\") {\n        return input(hookProps, vdom_cjs.createElement); // give the function the vdom-creation func\n    }\n    return input;\n}\nvar ViewRoot = /** @class */ function(_super) {\n    tslib.__extends(ViewRoot, _super);\n    function ViewRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    ViewRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = {\n            view: context.viewApi\n        };\n        var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, [\n                \"fc-\" + props.viewSpec.type + \"-view\",\n                \"fc-view\"\n            ].concat(customClassNames));\n        });\n    };\n    return ViewRoot;\n}(BaseComponent);\nfunction parseViewConfigs(inputs) {\n    return mapHash(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    var rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    var component = rawOptions.component;\n    if (rawOptions.content) {\n        component = createViewHookComponent(rawOptions);\n    // TODO: remove content/classNames/didMount/etc from options?\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions: rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return function(viewProps) {\n        return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n            return vdom_cjs.createElement(ViewRoot, {\n                viewSpec: context.viewSpec\n            }, function(viewElRef, viewClassNames) {\n                var hookProps = tslib.__assign(tslib.__assign({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                });\n                return vdom_cjs.createElement(RenderHook, {\n                    hookProps: hookProps,\n                    classNames: options.classNames,\n                    content: options.content,\n                    didMount: options.didMount,\n                    willUnmount: options.willUnmount,\n                    elRef: viewElRef\n                }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                    return vdom_cjs.createElement(\"div\", {\n                        className: viewClassNames.concat(customClassNames).join(\" \"),\n                        ref: rootElRef\n                    }, innerContent);\n                });\n            });\n        });\n    };\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var defaultConfigs = parseViewConfigs(defaultInputs);\n    var overrideConfigs = parseViewConfigs(optionOverrides.views);\n    var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return mapHash(viewDefs, function(viewDef) {\n        return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    });\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    var duration = null;\n    var durationUnit = \"\";\n    var singleUnit = \"\";\n    var singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            var denom = greatestDurationDenominator(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    var queryButtonText = function(optionsSubset) {\n        var buttonTextMap = optionsSubset.buttonText || {};\n        var buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    var queryButtonTitle = function(optionsSubset) {\n        var buttonHints = optionsSubset.buttonHints || {};\n        var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration: duration,\n        durationUnit: durationUnit,\n        singleUnit: singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: tslib.__assign(tslib.__assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)\n    };\n}\n// hack to get memoization working\nvar durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    var json = JSON.stringify(durationInput);\n    var res = durationInputMap[json];\n    if (res === undefined) {\n        res = createDuration(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nvar DateProfileGenerator = /** @class */ function() {\n    function DateProfileGenerator(props) {\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    DateProfileGenerator.prototype.buildPrev = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    };\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    DateProfileGenerator.prototype.buildNext = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    };\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    DateProfileGenerator.prototype.build = function(currentDate, direction, forceToValid) {\n        if (forceToValid === void 0) {\n            forceToValid = true;\n        }\n        var props = this.props;\n        var validRange;\n        var currentInfo;\n        var isRangeAllDay;\n        var renderRange;\n        var activeRange;\n        var isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        return {\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange: validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay: isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange: activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange: renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid: isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    };\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildValidRange = function() {\n        var input = this.props.validRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.nowDate) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    };\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    DateProfileGenerator.prototype.buildCurrentRangeInfo = function(date, direction) {\n        var props = this.props;\n        var duration = null;\n        var unit = null;\n        var range = null;\n        var dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration: duration,\n            unit: unit,\n            range: range\n        };\n    };\n    DateProfileGenerator.prototype.getFallbackDuration = function() {\n        return createDuration({\n            day: 1\n        });\n    };\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    DateProfileGenerator.prototype.adjustActiveRange = function(range) {\n        var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;\n        var start = range.start, end = range.end;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    DateProfileGenerator.prototype.buildRangeFromDuration = function(date, direction, duration, unit) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var start;\n        var end;\n        var res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            var dateIncrement = this.props.dateIncrement;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start: start,\n                end: end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    };\n    // Builds the \"current\" range when a dayCount is specified.\n    DateProfileGenerator.prototype.buildRangeFromDayCount = function(date, direction, dayCount) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var runningCount = 0;\n        var start = date;\n        var end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    DateProfileGenerator.prototype.buildCustomVisibleRange = function(date) {\n        var props = this.props;\n        var input = props.visibleRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        var range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    };\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    };\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    DateProfileGenerator.prototype.buildDateIncrement = function(fallback) {\n        var dateIncrement = this.props.dateIncrement;\n        var customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    };\n    DateProfileGenerator.prototype.refineRange = function(rangeInput) {\n        if (rangeInput) {\n            var range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    };\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    DateProfileGenerator.prototype.initHiddenDays = function() {\n        var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        var dayCnt = 0;\n        var i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    };\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    DateProfileGenerator.prototype.trimHiddenDays = function(range) {\n        var start = range.start, end = range.end;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        return null;\n    };\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    DateProfileGenerator.prototype.isHiddenDay = function(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    };\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    DateProfileGenerator.prototype.skipHiddenDays = function(date, inc, isExclusive) {\n        if (inc === void 0) {\n            inc = 1;\n        }\n        if (isExclusive === void 0) {\n            isExclusive = false;\n        }\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    };\n    return DateProfileGenerator;\n}();\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    var _a;\n    switch(action.type){\n        case \"SET_OPTION\":\n            return tslib.__assign(tslib.__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    var dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(var sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    var hash = {};\n    for(var _i = 0, sources_1 = sources; _i < sources_1.length; _i++){\n        var source = sources_1[_i];\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return tslib.__assign(tslib.__assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return filterHash(eventSourceHash, function(eventSource) {\n        return eventSource.sourceId !== sourceId;\n    });\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function(eventSource) {\n        return isSourceDirty(eventSource, fetchRange, context);\n    }), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    var nextSources = {};\n    for(var sourceId in prevSources){\n        var source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    var options = context.options, calendarApi = context.calendarApi;\n    var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    var fetchId = guid();\n    sourceDef.fetch({\n        eventSource: eventSource,\n        range: fetchRange,\n        isRefetch: isRefetch,\n        context: context\n    }, function(res) {\n        var rawEvents = res.rawEvents;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            rawEvents: rawEvents\n        });\n    }, function(error) {\n        console.warn(error.message, error);\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            error: error\n        });\n    });\n    return tslib.__assign(tslib.__assign({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    var _a;\n    var eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return tslib.__assign(tslib.__assign({}, sourceHash), (_a = {}, _a[sourceId] = tslib.__assign(tslib.__assign({}, eventSource), {\n            isFetching: false,\n            fetchRange: fetchRange\n        }), _a));\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return filterHash(eventSources, function(eventSource) {\n        return doesSourceNeedRange(eventSource, context);\n    });\n}\nfunction parseInitialSources(rawOptions, context) {\n    var refiners = buildEventSourceRefiners(context);\n    var rawSources = [].concat(rawOptions.eventSources || []);\n    var sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for(var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++){\n        var rawSource = rawSources_1[_i];\n        var source = parseEventSource(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, function(eventDef) {\n                return !eventDef.sourceId // only keep events with no source id\n                ;\n            });\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    var calEachTransform = context.options.eventDataTransform;\n    var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    var refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n            var rawEvent = rawEvents_1[_i];\n            var refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    var defs = eventStore.defs;\n    var instances = mapHash(eventStore.instances, function(instance) {\n        var def = defs[instance.defId];\n        if (def.allDay || def.recurringDef) {\n            return instance; // isn't dependent on timezone\n        }\n        return tslib.__assign(tslib.__assign({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, function(eventDef) {\n        return eventDef.sourceId !== sourceId;\n    });\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, function(instance) {\n            return !removals[instance.instanceId];\n        })\n    };\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    var newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    var newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header: header,\n        footer: footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var sectionWidgets = {};\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    for(var sectionName in sectionStrHash){\n        var sectionStr = sectionStrHash[sectionName];\n        var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets: sectionWidgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var isRtl = calendarOptions.direction === \"rtl\";\n    var calendarCustomButtons = calendarOptions.customButtons || {};\n    var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    var calendarButtonText = calendarOptions.buttonText || {};\n    var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    var calendarButtonHints = calendarOptions.buttonHints || {};\n    var sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    var widgets = sectionSubstrs.map(function(buttonGroupStr) {\n        return buttonGroupStr.split(\",\").map(function(buttonName) {\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName: buttonName\n                };\n            }\n            var customButtonProps;\n            var viewSpec;\n            var buttonClick;\n            var buttonIcon; // only one of these will be set\n            var buttonText; // \"\n            var buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = function(ev) {\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = function() {\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = function() {\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    var prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = function(navUnit) {\n                        return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                    };\n                }\n            }\n            return {\n                buttonName: buttonName,\n                buttonClick: buttonClick,\n                buttonIcon: buttonIcon,\n                buttonText: buttonText,\n                buttonHint: buttonHint\n            };\n        });\n    });\n    return {\n        widgets: widgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\nvar eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta: function(refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success) {\n        success({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nvar arrayEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nvar eventSourceDef$1 = {\n    parseMeta: function(refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var dateEnv = arg.context.dateEnv;\n        var func = arg.eventSource.meta;\n        unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function(rawEvents) {\n            success({\n                rawEvents: rawEvents\n            }); // needs an object response\n        }, failure);\n    }\n};\nvar funcEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n    method = method.toUpperCase();\n    var body = null;\n    if (method === \"GET\") {\n        url = injectQueryStringParams(url, params);\n    } else {\n        body = encodeParams(params);\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    if (method !== \"GET\") {\n        xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    }\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 400) {\n            var parsed = false;\n            var res = void 0;\n            try {\n                res = JSON.parse(xhr.responseText);\n                parsed = true;\n            } catch (err) {\n            // will handle parsed=false\n            }\n            if (parsed) {\n                successCallback(res, xhr);\n            } else {\n                failureCallback(\"Failure parsing JSON\", xhr);\n            }\n        } else {\n            failureCallback(\"Request failed\", xhr);\n        }\n    };\n    xhr.onerror = function() {\n        failureCallback(\"Request failed\", xhr);\n    };\n    xhr.send(body);\n}\nfunction injectQueryStringParams(url, params) {\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + encodeParams(params);\n}\nfunction encodeParams(params) {\n    var parts = [];\n    for(var key in params){\n        parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return parts.join(\"&\");\n}\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: identity,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nvar eventSourceDef = {\n    parseMeta: function(refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var meta = arg.eventSource.meta;\n        var requestParams = buildRequestParams(meta, arg.range, arg.context);\n        requestJson(meta.method, meta.url, requestParams, function(rawEvents, xhr) {\n            success({\n                rawEvents: rawEvents,\n                xhr: xhr\n            });\n        }, function(errorMessage, xhr) {\n            failure({\n                message: errorMessage,\n                xhr: xhr\n            });\n        });\n    }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var startParam;\n    var endParam;\n    var timeZoneParam;\n    var customRequestParams;\n    var params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    tslib.__assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nvar SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: identity,\n    startTime: createDuration,\n    endTime: createDuration,\n    duration: createDuration,\n    startRecur: identity,\n    endRecur: identity\n};\nvar recurring = {\n    parse: function(refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            var recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n            };\n            var duration = void 0;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = subtractDurations(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration: duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand: function(typeData, framingRange, dateEnv) {\n        var clippedFramingRange = intersectRanges(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n    var dayMarker = startOfDay(framingRange.start);\n    var endMarker = framingRange.end;\n    var instanceStarts = [];\n    while(dayMarker < endMarker){\n        var instanceStart = void 0;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = addDays(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nvar changeHandlerPlugin = createPlugin({\n    optionChangeHandlers: {\n        events: function(events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n    var newInputs = [];\n    for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n        var input = inputs_1[_i];\n        var inputFound = false;\n        for(var i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for(var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++){\n        var unfoundSource = unfoundSources_1[_a];\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for(var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++){\n        var newInput = newInputs_1[_b];\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", tslib.__assign(tslib.__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    var emitter = context.emitter;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", buildEventApis(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ var globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        isLoadingFuncs: [\n            function(state) {\n                return computeEventSourcesLoading(state.eventSources);\n            }\n        ],\n        contentTypeHandlers: {\n            html: buildHtmlRenderer,\n            domNodes: buildDomNodeRenderer\n        },\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nfunction buildHtmlRenderer() {\n    var currentEl = null;\n    var currentHtml = \"\";\n    function render(el, html) {\n        if (el !== currentEl || html !== currentHtml) {\n            el.innerHTML = html;\n        }\n        currentEl = el;\n        currentHtml = html;\n    }\n    function destroy() {\n        currentEl.innerHTML = \"\";\n        currentEl = null;\n        currentHtml = \"\";\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nfunction buildDomNodeRenderer() {\n    var currentEl = null;\n    var currentDomNodes = [];\n    function render(el, domNodes) {\n        var newDomNodes = Array.prototype.slice.call(domNodes);\n        if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {\n            // append first, remove second (for scroll resetting)\n            for(var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++){\n                var newNode = newDomNodes_1[_i];\n                el.appendChild(newNode);\n            }\n            destroy();\n        }\n        currentEl = el;\n        currentDomNodes = newDomNodes;\n    }\n    function destroy() {\n        currentDomNodes.forEach(removeElement);\n        currentDomNodes = [];\n        currentEl = null;\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nvar DelayedRunner = /** @class */ function() {\n    function DelayedRunner(drainedOption) {\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    DelayedRunner.prototype.request = function(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    };\n    DelayedRunner.prototype.pause = function(scope) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    };\n    DelayedRunner.prototype.resume = function(scope, force) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                var depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    };\n    DelayedRunner.prototype.isPaused = function() {\n        return Object.keys(this.pauseDepths).length;\n    };\n    DelayedRunner.prototype.tryDrain = function() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    };\n    DelayedRunner.prototype.clear = function() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    };\n    DelayedRunner.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    };\n    DelayedRunner.prototype.drained = function() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    };\n    return DelayedRunner;\n}();\nvar TaskRunner = /** @class */ function() {\n    function TaskRunner(runTaskOption, drainedOption) {\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n    }\n    TaskRunner.prototype.request = function(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    };\n    TaskRunner.prototype.pause = function(scope) {\n        this.delayedRunner.pause(scope);\n    };\n    TaskRunner.prototype.resume = function(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    };\n    TaskRunner.prototype.drain = function() {\n        var queue = this.queue;\n        while(queue.length){\n            var completedTasks = [];\n            var task = void 0;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    };\n    TaskRunner.prototype.runTask = function(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    };\n    TaskRunner.prototype.drained = function(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    };\n    return TaskRunner;\n}();\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    var range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    var currentRangeUnit = dateProfile.currentRangeUnit;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nvar CalendarDataManager = /** @class */ function() {\n    function CalendarDataManager(props) {\n        var _this = this;\n        this.computeOptionsData = memoize(this._computeOptionsData);\n        this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n        this.organizeRawLocales = memoize(organizeRawLocales);\n        this.buildLocale = memoize(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = memoize(buildDateEnv);\n        this.buildTheme = memoize(buildTheme);\n        this.parseToolbars = memoize(parseToolbars);\n        this.buildViewSpecs = memoize(buildViewSpecs);\n        this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n        this.buildViewApi = memoize(buildViewApi);\n        this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n        this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n        this.buildEventUiBases = memoize(buildEventUiBases);\n        this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n        this.buildTitle = memoize(buildTitle);\n        this.emitter = new Emitter();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.getCurrentData = function() {\n            return _this.data;\n        };\n        this.dispatch = function(action) {\n            _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        var dynamicOptionOverrides = {};\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n        var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        // needs to be after setThisContext\n        for(var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++){\n            var callback = _a[_i];\n            callback(calendarContext);\n        }\n        // NOT DRY\n        var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        var initialState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources: eventSources,\n            eventUiBases: {},\n            eventStore: createEmptyEventStore(),\n            renderableEventStore: createEmptyEventStore(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), initialState);\n        for(var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++){\n            var reducer = _c[_b];\n            tslib.__assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    CalendarDataManager.prototype.resetOptions = function(optionOverrides, append) {\n        var props = this.props;\n        props.optionOverrides = append ? tslib.__assign(tslib.__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;\n        this.actionRunner.request({\n            type: \"NOTHING\"\n        });\n    };\n    CalendarDataManager.prototype._handleAction = function(action) {\n        var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;\n        var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = reduceViewType(state.currentViewType, action);\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: emitter,\n            getCurrentData: this.getCurrentData\n        };\n        var currentDate = state.currentDate, dateProfile = state.dateProfile;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = reduceCurrentDate(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj\n        var eventUiBySource = this.buildEventUiBySource(eventSources);\n        var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        var newState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            eventSources: eventSources,\n            eventStore: eventStore,\n            renderableEventStore: renderableEventStore,\n            selectionConfig: selectionConfig,\n            eventUiBases: eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), newState);\n        for(var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++){\n            var reducer = _c[_i];\n            tslib.__assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        var wasLoading = computeIsLoading(state, calendarContext);\n        var isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    };\n    CalendarDataManager.prototype.updateData = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var oldData = this.data;\n        var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        var data = this.data = tslib.__assign(tslib.__assign(tslib.__assign({\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        var oldCalendarOptions = oldData && oldData.calendarOptions;\n        var newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(var optionName in changeHandlers){\n                if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        if (props.onData) {\n            props.onData(data);\n        }\n    };\n    CalendarDataManager.prototype._computeOptionsData = function(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n        var theme = this.buildTheme(refinedOptions, pluginHooks);\n        var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n        return {\n            calendarOptions: refinedOptions,\n            pluginHooks: pluginHooks,\n            dateEnv: dateEnv,\n            viewSpecs: viewSpecs,\n            theme: theme,\n            toolbarConfig: toolbarConfig,\n            localeDefaults: localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    };\n    // always called from behind a memoizer\n    CalendarDataManager.prototype.processRawCalendarOptions = function(optionOverrides, dynamicOptionOverrides) {\n        var _a = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]), locales = _a.locales, locale = _a.locale;\n        var availableLocaleData = this.organizeRawLocales(locales);\n        var availableRawLocales = availableLocaleData.map;\n        var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        var refiners = this.currentCalendarOptionsRefiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var extra = {};\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refined = {};\n        var currentRaw = this.currentCalendarOptionsInput;\n        var currentRefined = this.currentCalendarOptionsRefined;\n        var anyChanges = false;\n        for(var optionName in raw){\n            if (optionName !== \"plugins\") {\n                if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n                    refined[optionName] = currentRefined[optionName];\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                    anyChanges = true;\n                } else {\n                    extra[optionName] = currentRaw[optionName];\n                }\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks: pluginHooks,\n            availableLocaleData: availableLocaleData,\n            localeDefaults: localeDefaults,\n            extra: extra\n        };\n    };\n    CalendarDataManager.prototype._computeCurrentViewData = function(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        var viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error('viewType \"' + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n        }\n        var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            monthMode: refinedOptions.monthMode,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec: viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator: dateProfileGenerator,\n            viewApi: viewApi\n        };\n    };\n    CalendarDataManager.prototype.processRawViewOptions = function(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var refined = {};\n        var currentRaw = this.currentViewOptionsInput;\n        var currentRefined = this.currentViewOptionsRefined;\n        var anyChanges = false;\n        var extra = {};\n        for(var optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra: extra\n        };\n    };\n    return CalendarDataManager;\n}();\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new DateEnv({\n        calendarSystem: \"gregory\",\n        timeZone: timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale: locale,\n        weekNumberCalculation: weekNumberCalculation,\n        firstDay: firstDay,\n        weekText: weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator: defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewApi(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return mapHash(eventSources, function(eventSource) {\n        return eventSource.ui;\n    });\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    var eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(var defId in eventDefs){\n        var def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    var options = calendarContext.options;\n    return {\n        eventUiSingleBase: createEventUi({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: createEventUi({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for(var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++){\n        var isLoadingFunc = _a[_i];\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(var optionName in options){\n        console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : \"\"));\n    }\n}\n// TODO: move this to react plugin?\nvar CalendarDataProvider = /** @class */ function(_super) {\n    tslib.__extends(CalendarDataProvider, _super);\n    function CalendarDataProvider(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleData = function(data) {\n            if (!_this.dataManager) {\n                // eslint-disable-next-line react/no-direct-mutation-state\n                _this.state = data; // can't use setState yet\n            } else {\n                _this.setState(data);\n            }\n        };\n        _this.dataManager = new CalendarDataManager({\n            optionOverrides: props.optionOverrides,\n            calendarApi: props.calendarApi,\n            onData: _this.handleData\n        });\n        return _this;\n    }\n    CalendarDataProvider.prototype.render = function() {\n        return this.props.children(this.state);\n    };\n    CalendarDataProvider.prototype.componentDidUpdate = function(prevProps) {\n        var newOptionOverrides = this.props.optionOverrides;\n        if (newOptionOverrides !== prevProps.optionOverrides) {\n            this.dataManager.resetOptions(newOptionOverrides);\n        }\n    };\n    return CalendarDataProvider;\n}(vdom_cjs.Component);\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nvar NamedTimeZoneImpl = /** @class */ function() {\n    function NamedTimeZoneImpl(timeZoneName) {\n        this.timeZoneName = timeZoneName;\n    }\n    return NamedTimeZoneImpl;\n}();\nvar SegHierarchy = /** @class */ function() {\n    function SegHierarchy() {\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    SegHierarchy.prototype.addSegs = function(inputs) {\n        var hiddenEntries = [];\n        for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n            var input = inputs_1[_i];\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    };\n    SegHierarchy.prototype.insertEntry = function(entry, hiddenEntries) {\n        var insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n            return 1;\n        }\n        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    };\n    SegHierarchy.prototype.isInsertionValid = function(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    };\n    // returns number of new entries inserted\n    SegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.splitEntry = function(entry, barrier, hiddenEntries) {\n        var partCnt = 0;\n        var splitHiddenEntries = [];\n        var entrySpan = entry.span;\n        var barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, splitHiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, splitHiddenEntries);\n        }\n        if (partCnt) {\n            hiddenEntries.push.apply(hiddenEntries, tslib.__spreadArray([\n                {\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: intersectSpans(barrierSpan, entrySpan)\n                }\n            ], splitHiddenEntries));\n            return partCnt;\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.insertEntryAt = function(entry, insertion) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    };\n    SegHierarchy.prototype.findInsertion = function(newEntry) {\n        var _a = this, levelCoords = _a.levelCoords, entriesByLevel = _a.entriesByLevel, strictOrder = _a.strictOrder, stackCnts = _a.stackCnts;\n        var levelCnt = levelCoords.length;\n        var candidateCoord = 0;\n        var touchingLevel = -1;\n        var touchingLateral = -1;\n        var touchingEntry = null;\n        var stackCnt = 0;\n        for(var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            var trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n                break;\n            }\n            var trackingEntries = entriesByLevel[trackingLevel];\n            var trackingEntry = void 0;\n            var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                var trackingEntryBottom = trackingCoord + trackingEntry.thickness;\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        var destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        var destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel: touchingLevel,\n            touchingLateral: touchingLateral,\n            touchingEntry: touchingEntry,\n            stackCnt: stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    };\n    // sorted by levelCoord (lowest to highest)\n    SegHierarchy.prototype.toRects = function() {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        var levelCnt = entriesByLevel.length;\n        var rects = [];\n        for(var level = 0; level < levelCnt; level += 1){\n            var entries = entriesByLevel[level];\n            var levelCoord = levelCoords[level];\n            for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n                var entry = entries_1[_i];\n                rects.push(tslib.__assign(tslib.__assign({}, entry), {\n                    levelCoord: levelCoord\n                }));\n            }\n        }\n        return rects;\n    };\n    return SegHierarchy;\n}();\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    var merges = [];\n    for(var _i = 0, entries_2 = entries; _i < entries_2.length; _i++){\n        var entry = entries_2[_i];\n        var filteredMerges = [];\n        var hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for(var _a = 0, merges_1 = merges; _a < merges_1.length; _a++){\n            var merge = merges_1[_a];\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    var start = Math.max(span0.start, span1.start);\n    var end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start: start,\n            end: end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    var startIndex = 0;\n    var endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        var middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\nvar Interaction = /** @class */ function() {\n    function Interaction(settings) {\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    Interaction.prototype.destroy = function() {};\n    return Interaction;\n}();\nfunction parseInteractionSettings(component, input) {\n    return {\n        component: component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    var _a;\n    return _a = {}, _a[settings.component.uid] = settings, _a;\n}\n// global state\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ var ElementDragging = /** @class */ function() {\n    function ElementDragging(el, selector) {\n        this.emitter = new Emitter();\n    }\n    ElementDragging.prototype.destroy = function() {};\n    ElementDragging.prototype.setMirrorIsVisible = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setMirrorNeedsRevert = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setAutoScrollEnabled = function(bool) {\n    // optional\n    };\n    return ElementDragging;\n}();\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ var DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    var _a = refineProps(raw, DRAG_META_REFINERS), refined = _a.refined, extra = _a.extra;\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\nvar ToolbarSection = /** @class */ function(_super) {\n    tslib.__extends(ToolbarSection, _super);\n    function ToolbarSection() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarSection.prototype.render = function() {\n        var _this = this;\n        var children = this.props.widgetGroups.map(function(widgetGroup) {\n            return _this.renderWidgetGroup(widgetGroup);\n        });\n        return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"div\",\n            {\n                className: \"fc-toolbar-chunk\"\n            }\n        ], children));\n    };\n    ToolbarSection.prototype.renderWidgetGroup = function(widgetGroup) {\n        var props = this.props;\n        var theme = this.context.theme;\n        var children = [];\n        var isOnlyButtons = true;\n        for(var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++){\n            var widget = widgetGroup_1[_i];\n            var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon, buttonHint = widget.buttonHint;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push(vdom_cjs.createElement(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                var isPressed = buttonName === props.activeButton;\n                var isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                var buttonClasses = [\n                    \"fc-\" + buttonName + \"-button\",\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push(vdom_cjs.createElement(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? vdom_cjs.createElement(\"span\", {\n                    className: buttonIcon\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            var groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n                \"div\",\n                {\n                    className: groupClassName\n                }\n            ], children));\n        }\n        return children[0];\n    };\n    return ToolbarSection;\n}(BaseComponent);\nvar Toolbar = /** @class */ function(_super) {\n    tslib.__extends(Toolbar, _super);\n    function Toolbar() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Toolbar.prototype.render = function() {\n        var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;\n        var forceLtr = false;\n        var startContent;\n        var endContent;\n        var sectionWidgets = model.sectionWidgets;\n        var centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        var classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return vdom_cjs.createElement(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    };\n    Toolbar.prototype.renderSection = function(key, widgetGroups) {\n        var props = this.props;\n        return vdom_cjs.createElement(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    };\n    return Toolbar;\n}(BaseComponent);\n// TODO: do function component?\nvar ViewContainer = /** @class */ function(_super) {\n    tslib.__extends(ViewContainer, _super);\n    function ViewContainer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            availableWidth: null\n        };\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n            _this.updateAvailableWidth();\n        };\n        _this.handleResize = function() {\n            _this.updateAvailableWidth();\n        };\n        return _this;\n    }\n    ViewContainer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var aspectRatio = props.aspectRatio;\n        var classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        var height = \"\";\n        var paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = 1 / aspectRatio * 100 + \"%\";\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return vdom_cjs.createElement(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height: height,\n                paddingBottom: paddingBottom\n            }\n        }, props.children);\n    };\n    ViewContainer.prototype.componentDidMount = function() {\n        this.context.addResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.updateAvailableWidth = function() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    };\n    return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ var EventClicking = /** @class */ function(_super) {\n    tslib.__extends(EventClicking, _super);\n    function EventClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handleSegClick = function(ev, segEl) {\n            var component = _this.component;\n            var context = component.context;\n            var seg = getElSeg(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                var hasUrlContainer = elementClosest(ev.target, \".fc-event-forced-url\");\n                var url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        _this.destroy = listenBySelector(settings.el, \"click\", \".fc-event\", _this.handleSegClick);\n        return _this;\n    }\n    return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ var EventHovering = /** @class */ function(_super) {\n    tslib.__extends(EventHovering, _super);\n    function EventHovering(settings) {\n        var _this = _super.call(this, settings) || this;\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        _this.handleEventElRemove = function(el) {\n            if (el === _this.currentSegEl) {\n                _this.handleSegLeave(null, _this.currentSegEl);\n            }\n        };\n        _this.handleSegEnter = function(ev, segEl) {\n            if (getElSeg(segEl)) {\n                _this.currentSegEl = segEl;\n                _this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        _this.handleSegLeave = function(ev, segEl) {\n            if (_this.currentSegEl) {\n                _this.currentSegEl = null;\n                _this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        _this.removeHoverListeners = listenToHoverBySelector(settings.el, \".fc-event\", _this.handleSegEnter, _this.handleSegLeave);\n        return _this;\n    }\n    EventHovering.prototype.destroy = function() {\n        this.removeHoverListeners();\n    };\n    EventHovering.prototype.triggerEvent = function(publicEvName, ev, segEl) {\n        var component = this.component;\n        var context = component.context;\n        var seg = getElSeg(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    };\n    return EventHovering;\n}(Interaction);\nvar CalendarContent = /** @class */ function(_super) {\n    tslib.__extends(CalendarContent, _super);\n    function CalendarContent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildViewContext = memoize(buildViewContext);\n        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n        _this.buildToolbarProps = memoize(buildToolbarProps);\n        _this.headerRef = vdom_cjs.createRef();\n        _this.footerRef = vdom_cjs.createRef();\n        _this.interactionsStore = {};\n        // eslint-disable-next-line\n        _this.state = {\n            viewLabelId: getUniqueDomId()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.registerInteractiveComponent = function(component, settingsInput) {\n            var settings = parseInteractionSettings(component, settingsInput);\n            var DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n            var interactions = interactionClasses.map(function(TheInteractionClass) {\n                return new TheInteractionClass(settings);\n            });\n            _this.interactionsStore[component.uid] = interactions;\n            interactionSettingsStore[component.uid] = settings;\n        };\n        _this.unregisterInteractiveComponent = function(component) {\n            var listeners = _this.interactionsStore[component.uid];\n            if (listeners) {\n                for(var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++){\n                    var listener = listeners_1[_i];\n                    listener.destroy();\n                }\n                delete _this.interactionsStore[component.uid];\n            }\n            delete interactionSettingsStore[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.resizeRunner = new DelayedRunner(function() {\n            _this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            _this.props.emitter.trigger(\"windowResize\", {\n                view: _this.props.viewApi\n            });\n        });\n        _this.handleWindowResize = function(ev) {\n            var options = _this.props.options;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                _this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n        return _this;\n    }\n    /*\n    renders INSIDE of an outer div\n    */ CalendarContent.prototype.render = function() {\n        var props = this.props;\n        var toolbarConfig = props.toolbarConfig, options = props.options;\n        var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);\n        var viewVGrow = false;\n        var viewHeight = \"\";\n        var viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : \"\";\n        return vdom_cjs.createElement(ViewContextType.Provider, {\n            value: viewContext\n        }, toolbarConfig.header && vdom_cjs.createElement(Toolbar, tslib.__assign({\n            ref: this.headerRef,\n            extraClassName: \"fc-header-toolbar\",\n            model: toolbarConfig.header,\n            titleId: viewLabelId\n        }, toolbarProps)), vdom_cjs.createElement(ViewContainer, {\n            liquid: viewVGrow,\n            height: viewHeight,\n            aspectRatio: viewAspectRatio,\n            labeledById: viewLabelId\n        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && vdom_cjs.createElement(Toolbar, tslib.__assign({\n            ref: this.footerRef,\n            extraClassName: \"fc-footer-toolbar\",\n            model: toolbarConfig.footer,\n            titleId: \"\"\n        }, toolbarProps)));\n    };\n    CalendarContent.prototype.componentDidMount = function() {\n        var props = this.props;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function(CalendarInteractionClass) {\n            return new CalendarInteractionClass(props);\n        });\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    };\n    CalendarContent.prototype.componentDidUpdate = function(prevProps) {\n        var props = this.props;\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    };\n    CalendarContent.prototype.componentWillUnmount = function() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for(var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++){\n            var interaction = _a[_i];\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    };\n    CalendarContent.prototype.buildAppendContent = function() {\n        var props = this.props;\n        var children = props.pluginHooks.viewContainerAppends.map(function(buildAppendContent) {\n            return buildAppendContent(props);\n        });\n        return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            vdom_cjs.Fragment,\n            {}\n        ], children));\n    };\n    CalendarContent.prototype.renderView = function(props) {\n        var pluginHooks = props.pluginHooks;\n        var viewSpec = props.viewSpec;\n        var viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n            var transformer = transformers_1[_i];\n            tslib.__assign(viewProps, transformer.transform(viewProps, props));\n        }\n        var ViewComponent = viewSpec.component;\n        return vdom_cjs.createElement(ViewComponent, tslib.__assign({}, viewProps));\n    };\n    return CalendarContent;\n}(PureComponent);\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title: title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map(function(TheClass) {\n        return new TheClass();\n    });\n}\nvar CalendarRoot = /** @class */ function(_super) {\n    tslib.__extends(CalendarRoot, _super);\n    function CalendarRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            forPrint: false\n        };\n        _this.handleBeforePrint = function() {\n            _this.setState({\n                forPrint: true\n            });\n        };\n        _this.handleAfterPrint = function() {\n            _this.setState({\n                forPrint: false\n            });\n        };\n        return _this;\n    }\n    CalendarRoot.prototype.render = function() {\n        var props = this.props;\n        var options = props.options;\n        var forPrint = this.state.forPrint;\n        var isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        var height = !isHeightAuto && options.height != null ? options.height : \"\";\n        var classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            \"fc-direction-\" + options.direction,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    };\n    CalendarRoot.prototype.componentDidMount = function() {\n        var emitter = this.props.emitter;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    };\n    CalendarRoot.prototype.componentWillUnmount = function() {\n        var emitter = this.props.emitter;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    };\n    return CalendarRoot;\n}(BaseComponent);\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nvar CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(hookProps) {\n    return hookProps.text;\n}\nvar TableDateCell = /** @class */ function(_super) {\n    tslib.__extends(TableDateCell, _super);\n    function TableDateCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDateCell.prototype.render = function() {\n        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;\n        var props = this.props;\n        var date = props.date, dateProfile = props.dateProfile;\n        var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        var hookProps = tslib.__assign(tslib.__assign(tslib.__assign({\n            date: dateEnv.toDate(date),\n            view: viewApi\n        }, props.extraHookProps), {\n            text: text\n        }), dayMeta);\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return vdom_cjs.createElement(\"th\", tslib.__assign({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && vdom_cjs.createElement(\"a\", tslib.__assign({\n                ref: innerElRef,\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \")\n            }, navLinkAttrs), innerContent)));\n        });\n    };\n    return TableDateCell;\n}(BaseComponent);\nvar WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nvar TableDowCell = /** @class */ function(_super) {\n    tslib.__extends(TableDowCell, _super);\n    function TableDowCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDowCell.prototype.render = function() {\n        var props = this.props;\n        var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;\n        var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        var dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        var hookProps = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({\n            date: date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraHookProps), {\n            text: text\n        });\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return vdom_cjs.createElement(\"th\", tslib.__assign({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, vdom_cjs.createElement(\"a\", {\n                \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT),\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \"),\n                ref: innerElRef\n            }, innerContent)));\n        });\n    };\n    return TableDowCell;\n}(BaseComponent);\nvar NowTimer = /** @class */ function(_super) {\n    tslib.__extends(NowTimer, _super);\n    function NowTimer(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        _this.initialNowQueriedMs = new Date().valueOf();\n        _this.state = _this.computeTiming().currentState;\n        return _this;\n    }\n    NowTimer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        return props.children(state.nowDate, state.todayRange);\n    };\n    NowTimer.prototype.componentDidMount = function() {\n        this.setTimeout();\n    };\n    NowTimer.prototype.componentDidUpdate = function(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    };\n    NowTimer.prototype.componentWillUnmount = function() {\n        this.clearTimeout();\n    };\n    NowTimer.prototype.computeTiming = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            nextState: {\n                nowDate: nextUnitStart,\n                todayRange: buildDayRange(nextUnitStart)\n            },\n            waitMs: waitMs\n        };\n    };\n    NowTimer.prototype.setTimeout = function() {\n        var _this = this;\n        var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;\n        this.timeoutId = setTimeout(function() {\n            _this.setState(nextState, function() {\n                _this.setTimeout();\n            });\n        }, waitMs);\n    };\n    NowTimer.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    };\n    NowTimer.contextType = ViewContextType;\n    return NowTimer;\n}(vdom_cjs.Component);\nfunction buildDayRange(date) {\n    var start = startOfDay(date);\n    var end = addDays(start, 1);\n    return {\n        start: start,\n        end: end\n    };\n}\nvar DayHeader = /** @class */ function(_super) {\n    tslib.__extends(DayHeader, _super);\n    function DayHeader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n        return _this;\n    }\n    DayHeader.prototype.render = function() {\n        var context = this.context;\n        var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;\n        var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return vdom_cjs.createElement(NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return vdom_cjs.createElement(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map(function(date) {\n                return datesRepDistinctDays ? vdom_cjs.createElement(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : vdom_cjs.createElement(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                });\n            }));\n        });\n    };\n    return DayHeader;\n}(BaseComponent);\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nvar DaySeriesModel = /** @class */ function() {\n    function DaySeriesModel(range, dateProfileGenerator) {\n        var date = range.start;\n        var end = range.end;\n        var indices = [];\n        var dates = [];\n        var dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    DaySeriesModel.prototype.sliceRange = function(range) {\n        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        var clippedFirstIndex = Math.max(0, firstIndex);\n        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    };\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    DaySeriesModel.prototype.getDateDayIndex = function(date) {\n        var indices = this.indices;\n        var dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    };\n    return DaySeriesModel;\n}();\nvar DayTableModel = /** @class */ function() {\n    function DayTableModel(daySeries, breakOnWeeks) {\n        var dates = daySeries.dates;\n        var daysPerRow;\n        var firstDay;\n        var rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    DayTableModel.prototype.buildCells = function() {\n        var rows = [];\n        for(var row = 0; row < this.rowCnt; row += 1){\n            var cells = [];\n            for(var col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    };\n    DayTableModel.prototype.buildCell = function(row, col) {\n        var date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date: date\n        };\n    };\n    DayTableModel.prototype.buildHeaderDates = function() {\n        var dates = [];\n        for(var col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    };\n    DayTableModel.prototype.sliceRange = function(range) {\n        var colCnt = this.colCnt;\n        var seriesSeg = this.daySeries.sliceRange(range);\n        var segs = [];\n        if (seriesSeg) {\n            var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;\n            var index = firstIndex;\n            while(index <= lastIndex){\n                var row = Math.floor(index / colCnt);\n                var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row: row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    };\n    return DayTableModel;\n}();\nvar Slicer = /** @class */ function() {\n    function Slicer() {\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    Slicer.prototype.sliceProps = function(props, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        var eventUiBases = props.eventUiBases;\n        var eventSegs = this.sliceEventStore.apply(this, tslib.__spreadArray([\n            props.eventStore,\n            eventUiBases,\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs));\n        return {\n            dateSelectionSegs: this.sliceDateSelection.apply(this, tslib.__spreadArray([\n                props.dateSelection,\n                eventUiBases,\n                context\n            ], extraArgs)),\n            businessHourSegs: this.sliceBusinessHours.apply(this, tslib.__spreadArray([\n                props.businessHours,\n                dateProfile,\n                nextDayThreshold,\n                context\n            ], extraArgs)),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag.apply(this, tslib.__spreadArray([\n                props.eventDrag,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventResize: this.sliceEventResize.apply(this, tslib.__spreadArray([\n                props.eventResize,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    };\n    Slicer.prototype.sliceNowDate = function(date, context) {\n        var extraArgs = [];\n        for(var _i = 2; _i < arguments.length; _i++){\n            extraArgs[_i - 2] = arguments[_i];\n        }\n        return this._sliceDateSpan.apply(this, tslib.__spreadArray([\n            {\n                range: {\n                    start: date,\n                    end: addMs(date, 1)\n                },\n                allDay: false\n            },\n            {},\n            context\n        ], extraArgs));\n    };\n    Slicer.prototype._sliceBusinessHours = function(businessHours, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore.apply(this, tslib.__spreadArray([\n            expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),\n            {},\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs)).bg;\n    };\n    Slicer.prototype._sliceEventStore = function(eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (eventStore) {\n            var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    };\n    Slicer.prototype._sliceInteraction = function(interaction, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!interaction) {\n            return null;\n        }\n        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    };\n    Slicer.prototype._sliceDateSpan = function(dateSpan, eventUiBases, context) {\n        var extraArgs = [];\n        for(var _i = 3; _i < arguments.length; _i++){\n            extraArgs[_i - 3] = arguments[_i];\n        }\n        if (!dateSpan) {\n            return [];\n        }\n        var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n        var segs = this.sliceRange.apply(this, tslib.__spreadArray([\n            dateSpan.range\n        ], extraArgs));\n        for(var _a = 0, segs_1 = segs; _a < segs_1.length; _a++){\n            var seg = segs_1[_a];\n            seg.eventRange = eventRange;\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRanges = function(eventRanges, extraArgs) {\n        var segs = [];\n        for(var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++){\n            var eventRange = eventRanges_1[_i];\n            segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRange = function(eventRange, extraArgs) {\n        var dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        var segs = this.sliceRange.apply(this, tslib.__spreadArray([\n            dateRange\n        ], extraArgs));\n        for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n            var seg = segs_2[_i];\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    };\n    return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    var range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    var instances = interaction.mutatedEvents.instances;\n    for(var instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection: dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    var calendarState = context.getCurrentData();\n    var props = tslib.__assign({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n    if (dateSpanMeta === void 0) {\n        dateSpanMeta = {};\n    }\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var currentState = context.getCurrentData();\n    var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    var subjectEventStore = interaction.mutatedEvents;\n    var subjectDefs = subjectEventStore.defs;\n    var subjectInstances = subjectEventStore.instances;\n    var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    var otherDefs = otherEventStore.defs;\n    var otherInstances = otherEventStore.instances;\n    var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(var subjectInstanceId in subjectInstances){\n        var subjectInstance = subjectInstances[subjectInstanceId];\n        var subjectRange = subjectInstance.range;\n        var subjectConfig = subjectConfigs[subjectInstance.defId];\n        var subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        var eventOverlap = context.options.eventOverlap;\n        var eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(var otherInstanceId in otherInstances){\n            var otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                var otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), new EventApi(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for(var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++){\n            var subjectAllow = _a[_i];\n            var subjectDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            var origDef = calendarEventStore.defs[subjectDef.defId];\n            var origInstance = calendarEventStore.instances[subjectInstanceId];\n            var eventApi = void 0;\n            if (origDef) {\n                eventApi = new EventApi(context, origDef, origInstance);\n            } else {\n                eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var relevantEventStore = state.eventStore;\n    var relevantDefs = relevantEventStore.defs;\n    var relevantInstances = relevantEventStore.instances;\n    var selection = state.dateSelection;\n    var selectionRange = selection.range;\n    var selectionConfig = context.getCurrentData().selectionConfig;\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    var selectOverlap = context.options.selectOverlap;\n    var selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(var relevantInstanceId in relevantInstances){\n        var relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for(var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++){\n        var selectionAllow = _a[_i];\n        var fullDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for(var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++){\n        var constraint = constraints_1[_i];\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function(eventDef) {\n            return eventDef.groupId === constraint;\n        }));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    var instances = eventStore.instances;\n    var ranges = [];\n    for(var instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for(var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++){\n        var outerRange = outerRanges_1[_i];\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nvar Scroller = /** @class */ function(_super) {\n    tslib.__extends(Scroller, _super);\n    function Scroller() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    Scroller.prototype.render = function() {\n        var props = this.props;\n        var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;\n        var isAbsolute = liquid && liquidIsAbsolute;\n        var className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return vdom_cjs.createElement(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    };\n    Scroller.prototype.needsXScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.needsYScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.getXScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    Scroller.prototype.getYScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ var RefMap = /** @class */ function() {\n    function RefMap(masterCallback) {\n        var _this = this;\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = function(val, key) {\n            var _a = _this, depths = _a.depths, currentMap = _a.currentMap;\n            var removed = false;\n            var added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete _this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (_this.masterCallback) {\n                if (removed) {\n                    _this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    _this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    RefMap.prototype.createRef = function(key) {\n        var _this = this;\n        var refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = function(val) {\n                _this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    };\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    RefMap.prototype.collect = function(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    };\n    RefMap.prototype.getAll = function() {\n        return hashValuesToArray(this.currentMap);\n    };\n    return RefMap;\n}();\nfunction computeShrinkWidth(chunkEls) {\n    var shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    var largestWidth = 0;\n    for(var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++){\n        var shrinkCell = shrinkCells_1[_i];\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    var expandRows = arg.expandRows;\n    var content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : vdom_cjs.createElement(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, vdom_cjs.createElement(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    var colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for(var _i = 0, cols_1 = cols; _i < cols_1.length; _i++){\n        var colProps = cols_1[_i];\n        var span = colProps.span || 1;\n        for(var i = 0; i < span; i += 1){\n            colNodes.push(vdom_cjs.createElement(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n        \"colgroup\",\n        {}\n    ], colNodes));\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for(var _i = 0, cols_2 = cols; _i < cols_2.length; _i++){\n        var col = cols_2[_i];\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    var classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    var classNames = [\n        \"fc-scrollgrid-section\",\n        \"fc-scrollgrid-section-\" + sectionConfig.type,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    var stickyHeaderDates = options.stickyHeaderDates;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    var stickyFooterScrollbar = options.stickyFooterScrollbar;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nvar SimpleScrollGrid = /** @class */ function(_super) {\n    tslib.__extends(SimpleScrollGrid, _super);\n    function SimpleScrollGrid() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.processCols = memoize(function(a) {\n            return a;\n        }, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        _this.renderMicroColGroup = memoize(renderMicroColGroup);\n        _this.scrollerRefs = new RefMap();\n        _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n        _this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        _this.handleSizing = function() {\n            _this.safeSetState(tslib.__assign({\n                shrinkWidth: _this.computeShrinkWidth()\n            }, _this.computeScrollerDims()));\n        };\n        return _this;\n    }\n    SimpleScrollGrid.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var sectionConfigs = props.sections || [];\n        var cols = this.processCols(props.cols);\n        var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        var classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        var configCnt = sectionConfigs.length;\n        var configI = 0;\n        var currentConfig;\n        var headSectionNodes = [];\n        var bodySectionNodes = [];\n        var footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        var isBuggy = !getCanVGrowWithinCell();\n        var roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return vdom_cjs.createElement(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"thead\",\n            roleAttrs\n        ], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"tbody\",\n            roleAttrs\n        ], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"tfoot\",\n            roleAttrs\n        ], footSectionNodes)), isBuggy && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([\n            \"tbody\",\n            roleAttrs\n        ], headSectionNodes), bodySectionNodes), footSectionNodes)));\n    };\n    SimpleScrollGrid.prototype.renderSection = function(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return vdom_cjs.createElement(vdom_cjs.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return vdom_cjs.createElement(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    };\n    SimpleScrollGrid.prototype.renderChunkTd = function(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        var props = this.props;\n        var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;\n        var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        var overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        var sectionKey = sectionConfig.key;\n        var content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: function() {}\n        }, isHeader);\n        return vdom_cjs.createElement(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, vdom_cjs.createElement(\"div\", {\n            className: \"fc-scroller-harness\" + (isLiquid ? \" fc-scroller-harness-liquid\" : \"\")\n        }, vdom_cjs.createElement(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    };\n    SimpleScrollGrid.prototype._handleScrollerEl = function(scrollerEl, key) {\n        var section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    };\n    SimpleScrollGrid.prototype.componentDidMount = function() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.componentDidUpdate = function() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    };\n    SimpleScrollGrid.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.computeShrinkWidth = function() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    };\n    SimpleScrollGrid.prototype.computeScrollerDims = function() {\n        var scrollbarWidth = getScrollbarWidths();\n        var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;\n        var forceYScrollbars = false;\n        var scrollerClientWidths = {};\n        var scrollerClientHeights = {};\n        for(var sectionKey in scrollerRefs.currentMap){\n            var scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for(var _i = 0, _b = this.props.sections; _i < _b.length; _i++){\n            var section = _b[_i];\n            var sectionKey = section.key;\n            var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars: forceYScrollbars,\n            scrollerClientWidths: scrollerClientWidths,\n            scrollerClientHeights: scrollerClientHeights\n        };\n    };\n    return SimpleScrollGrid;\n}(BaseComponent);\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for(var _i = 0, sections_1 = sections; _i < sections_1.length; _i++){\n        var section = sections_1[_i];\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nvar EventRoot = /** @class */ function(_super) {\n    tslib.__extends(EventRoot, _super);\n    function EventRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.elRef = vdom_cjs.createRef();\n        return _this;\n    }\n    EventRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var seg = props.seg;\n        var eventRange = seg.eventRange;\n        var ui = eventRange.ui;\n        var hookProps = {\n            event: new EventApi(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.eventClassNames,\n            content: options.eventContent,\n            defaultContent: props.defaultContent,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount,\n            elRef: this.elRef\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n        });\n    };\n    EventRoot.prototype.componentDidMount = function() {\n        setElSeg(this.elRef.current, this.props.seg);\n    };\n    /*\n    need to re-assign seg to the element if seg changes, even if the element is the same\n    */ EventRoot.prototype.componentDidUpdate = function(prevProps) {\n        var seg = this.props.seg;\n        if (seg !== prevProps.seg) {\n            setElSeg(this.elRef.current, seg);\n        }\n    };\n    return EventRoot;\n}(BaseComponent);\n// should not be a purecomponent\nvar StandardEvent = /** @class */ function(_super) {\n    tslib.__extends(StandardEvent, _super);\n    function StandardEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StandardEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var seg = props.seg;\n        var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n        var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return vdom_cjs.createElement(EventRoot, {\n            seg: seg,\n            timeText: timeText,\n            disableDragging: props.disableDragging,\n            disableResizing: props.disableResizing,\n            defaultContent: props.defaultContent || renderInnerContent$1,\n            isDragging: props.isDragging,\n            isResizing: props.isResizing,\n            isDateSelecting: props.isDateSelecting,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n            return vdom_cjs.createElement(\"a\", tslib.__assign({\n                className: props.extraClassNames.concat(classNames).join(\" \"),\n                style: {\n                    borderColor: hookProps.borderColor,\n                    backgroundColor: hookProps.backgroundColor\n                },\n                ref: rootElRef\n            }, getSegAnchorAttrs(seg, context)), vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-main\",\n                ref: innerElRef,\n                style: {\n                    color: hookProps.textColor\n                }\n            }, innerContent), hookProps.isStartResizable && vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), hookProps.isEndResizable && vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            }));\n        });\n    };\n    return StandardEvent;\n}(BaseComponent);\nfunction renderInnerContent$1(innerProps) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title-container\"\n    }, vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || vdom_cjs.createElement(vdom_cjs.Fragment, null, \"\\xa0\"))));\n}\nvar NowIndicatorRoot = function(props) {\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n        var options = context.options;\n        var hookProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.nowIndicatorClassNames,\n            content: options.nowIndicatorContent,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }, props.children);\n    });\n};\nvar DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nvar DayCellContent = /** @class */ function(_super) {\n    tslib.__extends(DayCellContent, _super);\n    function DayCellContent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DayCellContent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = refineDayCellHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        return vdom_cjs.createElement(ContentHook, {\n            hookProps: hookProps,\n            content: options.dayCellContent,\n            defaultContent: props.defaultContent\n        }, props.children);\n    };\n    return DayCellContent;\n}(BaseComponent);\nfunction refineDayCellHookProps(raw) {\n    var date = raw.date, dateEnv = raw.dateEnv;\n    var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n    return tslib.__assign(tslib.__assign(tslib.__assign({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : \"\"\n    }), raw.extraProps);\n}\nvar DayCellRoot = /** @class */ function(_super) {\n    tslib.__extends(DayCellRoot, _super);\n    function DayCellRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    DayCellRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = this.refineHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n         : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n        var dataAttrs = hookProps.isDisabled ? {} : {\n            \"data-date\": formatDayString(props.date)\n        };\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n        });\n    };\n    return DayCellRoot;\n}(BaseComponent);\nfunction renderFill(fillType) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-\" + fillType\n    });\n}\nvar BgEvent = function(props) {\n    return vdom_cjs.createElement(EventRoot, {\n        defaultContent: renderInnerContent,\n        seg: props.seg /* uselesss i think */ ,\n        timeText: \"\",\n        disableDragging: true,\n        disableResizing: true,\n        isDragging: false,\n        isResizing: false,\n        isDateSelecting: false,\n        isSelected: false,\n        isPast: props.isPast,\n        isFuture: props.isFuture,\n        isToday: props.isToday\n    }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n        return vdom_cjs.createElement(\"div\", {\n            ref: rootElRef,\n            className: [\n                \"fc-bg-event\"\n            ].concat(classNames).join(\" \"),\n            style: {\n                backgroundColor: hookProps.backgroundColor\n            }\n        }, innerContent);\n    });\n};\nfunction renderInnerContent(props) {\n    var title = props.event.title;\n    return title && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nvar WeekNumberRoot = function(props) {\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var date = props.date;\n        var format = options.weekNumberFormat || props.defaultFormat;\n        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        var text = dateEnv.format(date, format);\n        var hookProps = {\n            num: num,\n            text: text,\n            date: date\n        };\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.weekNumberClassNames,\n            content: options.weekNumberContent,\n            defaultContent: renderInner,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }, props.children);\n    });\n};\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nvar PADDING_FROM_VIEWPORT = 10;\nvar Popover = /** @class */ function(_super) {\n    tslib.__extends(Popover, _super);\n    function Popover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            titleId: getUniqueDomId()\n        };\n        _this.handleRootEl = function(el) {\n            _this.rootEl = el;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        _this.handleDocumentMouseDown = function(ev) {\n            // only hide the popover if the click happened outside the popover\n            var target = getEventTargetViaRoot(ev);\n            if (!_this.rootEl.contains(target)) {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleDocumentKeyDown = function(ev) {\n            if (ev.key === \"Escape\") {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleCloseClick = function() {\n            var onClose = _this.props.onClose;\n            if (onClose) {\n                onClose();\n            }\n        };\n        return _this;\n    }\n    Popover.prototype.render = function() {\n        var _a = this.context, theme = _a.theme, options = _a.options;\n        var _b = this, props = _b.props, state = _b.state;\n        var classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return vdom_cjs.createPortal(vdom_cjs.createElement(\"div\", tslib.__assign({\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId\n        }, props.extraAttrs, {\n            ref: this.handleRootEl\n        }), vdom_cjs.createElement(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, vdom_cjs.createElement(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), vdom_cjs.createElement(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), vdom_cjs.createElement(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    };\n    Popover.prototype.componentDidMount = function() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    };\n    Popover.prototype.componentWillUnmount = function() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    };\n    Popover.prototype.updateSize = function() {\n        var isRtl = this.context.isRtl;\n        var _a = this.props, alignmentEl = _a.alignmentEl, alignGridTop = _a.alignGridTop;\n        var rootEl = this.rootEl;\n        var alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            var popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            var popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin_1.top,\n                left: popoverLeft - origin_1.left\n            });\n        }\n    };\n    return Popover;\n}(BaseComponent);\nvar MorePopover = /** @class */ function(_super) {\n    tslib.__extends(MorePopover, _super);\n    function MorePopover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    MorePopover.prototype.render = function() {\n        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;\n        var props = this.props;\n        var startDate = props.startDate, todayRange = props.todayRange, dateProfile = props.dateProfile;\n        var title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return vdom_cjs.createElement(DayCellRoot, {\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange,\n            elRef: this.handleRootEl\n        }, function(rootElRef, dayClassNames, dataAttrs) {\n            return vdom_cjs.createElement(Popover, {\n                elRef: rootElRef,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(dayClassNames),\n                extraAttrs: dataAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, vdom_cjs.createElement(DayCellContent, {\n                date: startDate,\n                dateProfile: dateProfile,\n                todayRange: todayRange\n            }, function(innerElRef, innerContent) {\n                return innerContent && vdom_cjs.createElement(\"div\", {\n                    className: \"fc-more-popover-misc\",\n                    ref: innerElRef\n                }, innerContent);\n            }), props.children);\n        });\n    };\n    MorePopover.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        var _a = this, rootEl = _a.rootEl, props = _a.props;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: tslib.__assign({\n                    allDay: true,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    };\n    return MorePopover;\n}(DateComponent);\nvar MoreLinkRoot = /** @class */ function(_super) {\n    tslib.__extends(MoreLinkRoot, _super);\n    function MoreLinkRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.linkElRef = vdom_cjs.createRef();\n        _this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        _this.handleClick = function(ev) {\n            var _a = _this, props = _a.props, context = _a.context;\n            var moreLinkClick = context.options.moreLinkClick;\n            var date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;\n                return {\n                    event: new EventApi(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date: date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                _this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        _this.handlePopoverClose = function() {\n            _this.setState({\n                isPopoverOpen: false\n            });\n        };\n        return _this;\n    }\n    MoreLinkRoot.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state;\n        return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n            var viewApi = context.viewApi, options = context.options, calendarApi = context.calendarApi;\n            var moreLinkText = options.moreLinkText;\n            var moreCnt = props.moreCnt;\n            var range = computeRange(props);\n            var text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText;\n            var title = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            var hookProps = {\n                num: moreCnt,\n                shortText: \"+\" + moreCnt,\n                text: text,\n                view: viewApi\n            };\n            return vdom_cjs.createElement(vdom_cjs.Fragment, null, Boolean(props.moreCnt) && vdom_cjs.createElement(RenderHook, {\n                elRef: _this.linkElRef,\n                hookProps: hookProps,\n                classNames: options.moreLinkClassNames,\n                content: options.moreLinkContent,\n                defaultContent: props.defaultContent || renderMoreLinkInner,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                return props.children(rootElRef, [\n                    \"fc-more-link\"\n                ].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : \"\");\n            }), state.isPopoverOpen && vdom_cjs.createElement(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: _this.parentEl,\n                alignmentEl: props.alignmentElRef.current,\n                alignGridTop: props.alignGridTop,\n                onClose: _this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    };\n    MoreLinkRoot.prototype.componentDidMount = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.componentDidUpdate = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.updateParentEl = function() {\n        if (this.linkElRef.current) {\n            this.parentEl = elementClosest(this.linkElRef.current, \".fc-view-harness\");\n        }\n    };\n    return MoreLinkRoot;\n}(BaseComponent);\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    var hiddenSegs = props.hiddenSegs;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\n// exports\n// --------------------------------------------------------------------------------------------------\nvar version = \"5.11.3\"; // important to type it, so .d.ts has generic string\nexports.BASE_OPTION_DEFAULTS = BASE_OPTION_DEFAULTS;\nexports.BASE_OPTION_REFINERS = BASE_OPTION_REFINERS;\nexports.BaseComponent = BaseComponent;\nexports.BgEvent = BgEvent;\nexports.CalendarApi = CalendarApi;\nexports.CalendarContent = CalendarContent;\nexports.CalendarDataManager = CalendarDataManager;\nexports.CalendarDataProvider = CalendarDataProvider;\nexports.CalendarRoot = CalendarRoot;\nexports.ContentHook = ContentHook;\nexports.CustomContentRenderContext = CustomContentRenderContext;\nexports.DateComponent = DateComponent;\nexports.DateEnv = DateEnv;\nexports.DateProfileGenerator = DateProfileGenerator;\nexports.DayCellContent = DayCellContent;\nexports.DayCellRoot = DayCellRoot;\nexports.DayHeader = DayHeader;\nexports.DaySeriesModel = DaySeriesModel;\nexports.DayTableModel = DayTableModel;\nexports.DelayedRunner = DelayedRunner;\nexports.ElementDragging = ElementDragging;\nexports.ElementScrollController = ElementScrollController;\nexports.Emitter = Emitter;\nexports.EventApi = EventApi;\nexports.EventRoot = EventRoot;\nexports.EventSourceApi = EventSourceApi;\nexports.Interaction = Interaction;\nexports.MoreLinkRoot = MoreLinkRoot;\nexports.MountHook = MountHook;\nexports.NamedTimeZoneImpl = NamedTimeZoneImpl;\nexports.NowIndicatorRoot = NowIndicatorRoot;\nexports.NowTimer = NowTimer;\nexports.PositionCache = PositionCache;\nexports.RefMap = RefMap;\nexports.RenderHook = RenderHook;\nexports.ScrollController = ScrollController;\nexports.ScrollResponder = ScrollResponder;\nexports.Scroller = Scroller;\nexports.SegHierarchy = SegHierarchy;\nexports.SimpleScrollGrid = SimpleScrollGrid;\nexports.Slicer = Slicer;\nexports.Splitter = Splitter;\nexports.StandardEvent = StandardEvent;\nexports.TableDateCell = TableDateCell;\nexports.TableDowCell = TableDowCell;\nexports.Theme = Theme;\nexports.ViewApi = ViewApi;\nexports.ViewContextType = ViewContextType;\nexports.ViewRoot = ViewRoot;\nexports.WeekNumberRoot = WeekNumberRoot;\nexports.WindowScrollController = WindowScrollController;\nexports.addDays = addDays;\nexports.addDurations = addDurations;\nexports.addMs = addMs;\nexports.addWeeks = addWeeks;\nexports.allowContextMenu = allowContextMenu;\nexports.allowSelection = allowSelection;\nexports.applyMutationToEventStore = applyMutationToEventStore;\nexports.applyStyle = applyStyle;\nexports.applyStyleProp = applyStyleProp;\nexports.asCleanDays = asCleanDays;\nexports.asRoughMinutes = asRoughMinutes;\nexports.asRoughMs = asRoughMs;\nexports.asRoughSeconds = asRoughSeconds;\nexports.binarySearch = binarySearch;\nexports.buildClassNameNormalizer = buildClassNameNormalizer;\nexports.buildEntryKey = buildEntryKey;\nexports.buildEventApis = buildEventApis;\nexports.buildEventRangeKey = buildEventRangeKey;\nexports.buildHashFromArray = buildHashFromArray;\nexports.buildIsoString = buildIsoString;\nexports.buildNavLinkAttrs = buildNavLinkAttrs;\nexports.buildSegCompareObj = buildSegCompareObj;\nexports.buildSegTimeText = buildSegTimeText;\nexports.collectFromHash = collectFromHash;\nexports.combineEventUis = combineEventUis;\nexports.compareByFieldSpec = compareByFieldSpec;\nexports.compareByFieldSpecs = compareByFieldSpecs;\nexports.compareNumbers = compareNumbers;\nexports.compareObjs = compareObjs;\nexports.computeEarliestSegStart = computeEarliestSegStart;\nexports.computeEdges = computeEdges;\nexports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;\nexports.computeHeightAndMargins = computeHeightAndMargins;\nexports.computeInnerRect = computeInnerRect;\nexports.computeRect = computeRect;\nexports.computeSegDraggable = computeSegDraggable;\nexports.computeSegEndResizable = computeSegEndResizable;\nexports.computeSegStartResizable = computeSegStartResizable;\nexports.computeShrinkWidth = computeShrinkWidth;\nexports.computeSmallestCellWidth = computeSmallestCellWidth;\nexports.computeVisibleDayRange = computeVisibleDayRange;\nexports.config = config;\nexports.constrainPoint = constrainPoint;\nexports.createAriaClickAttrs = createAriaClickAttrs;\nexports.createDuration = createDuration;\nexports.createEmptyEventStore = createEmptyEventStore;\nexports.createEventInstance = createEventInstance;\nexports.createEventUi = createEventUi;\nexports.createFormatter = createFormatter;\nexports.createPlugin = createPlugin;\nexports.diffDates = diffDates;\nexports.diffDayAndTime = diffDayAndTime;\nexports.diffDays = diffDays;\nexports.diffPoints = diffPoints;\nexports.diffWeeks = diffWeeks;\nexports.diffWholeDays = diffWholeDays;\nexports.diffWholeWeeks = diffWholeWeeks;\nexports.disableCursor = disableCursor;\nexports.elementClosest = elementClosest;\nexports.elementMatches = elementMatches;\nexports.enableCursor = enableCursor;\nexports.eventTupleToStore = eventTupleToStore;\nexports.filterEventStoreDefs = filterEventStoreDefs;\nexports.filterHash = filterHash;\nexports.findDirectChildren = findDirectChildren;\nexports.findElements = findElements;\nexports.flexibleCompare = flexibleCompare;\nexports.formatDate = formatDate;\nexports.formatDayString = formatDayString;\nexports.formatIsoTimeString = formatIsoTimeString;\nexports.formatRange = formatRange;\nexports.getAllowYScrolling = getAllowYScrolling;\nexports.getCanVGrowWithinCell = getCanVGrowWithinCell;\nexports.getClippingParents = getClippingParents;\nexports.getDateMeta = getDateMeta;\nexports.getDayClassNames = getDayClassNames;\nexports.getDefaultEventEnd = getDefaultEventEnd;\nexports.getElRoot = getElRoot;\nexports.getElSeg = getElSeg;\nexports.getEntrySpanEnd = getEntrySpanEnd;\nexports.getEventClassNames = getEventClassNames;\nexports.getEventTargetViaRoot = getEventTargetViaRoot;\nexports.getIsRtlScrollbarOnLeft = getIsRtlScrollbarOnLeft;\nexports.getRectCenter = getRectCenter;\nexports.getRelevantEvents = getRelevantEvents;\nexports.getScrollGridClassNames = getScrollGridClassNames;\nexports.getScrollbarWidths = getScrollbarWidths;\nexports.getSectionClassNames = getSectionClassNames;\nexports.getSectionHasLiquidHeight = getSectionHasLiquidHeight;\nexports.getSegAnchorAttrs = getSegAnchorAttrs;\nexports.getSegMeta = getSegMeta;\nexports.getSlotClassNames = getSlotClassNames;\nexports.getStickyFooterScrollbar = getStickyFooterScrollbar;\nexports.getStickyHeaderDates = getStickyHeaderDates;\nexports.getUnequalProps = getUnequalProps;\nexports.getUniqueDomId = getUniqueDomId;\nexports.globalLocales = globalLocales;\nexports.globalPlugins = globalPlugins;\nexports.greatestDurationDenominator = greatestDurationDenominator;\nexports.groupIntersectingEntries = groupIntersectingEntries;\nexports.guid = guid;\nexports.hasBgRendering = hasBgRendering;\nexports.hasShrinkWidth = hasShrinkWidth;\nexports.identity = identity;\nexports.interactionSettingsStore = interactionSettingsStore;\nexports.interactionSettingsToStore = interactionSettingsToStore;\nexports.intersectRanges = intersectRanges;\nexports.intersectRects = intersectRects;\nexports.intersectSpans = intersectSpans;\nexports.isArraysEqual = isArraysEqual;\nexports.isColPropsEqual = isColPropsEqual;\nexports.isDateSelectionValid = isDateSelectionValid;\nexports.isDateSpansEqual = isDateSpansEqual;\nexports.isInt = isInt;\nexports.isInteractionValid = isInteractionValid;\nexports.isMultiDayRange = isMultiDayRange;\nexports.isPropsEqual = isPropsEqual;\nexports.isPropsValid = isPropsValid;\nexports.isValidDate = isValidDate;\nexports.joinSpans = joinSpans;\nexports.listenBySelector = listenBySelector;\nexports.mapHash = mapHash;\nexports.memoize = memoize;\nexports.memoizeArraylike = memoizeArraylike;\nexports.memoizeHashlike = memoizeHashlike;\nexports.memoizeObjArg = memoizeObjArg;\nexports.mergeEventStores = mergeEventStores;\nexports.multiplyDuration = multiplyDuration;\nexports.padStart = padStart;\nexports.parseBusinessHours = parseBusinessHours;\nexports.parseClassNames = parseClassNames;\nexports.parseDragMeta = parseDragMeta;\nexports.parseEventDef = parseEventDef;\nexports.parseFieldSpecs = parseFieldSpecs;\nexports.parseMarker = parse;\nexports.pointInsideRect = pointInsideRect;\nexports.preventContextMenu = preventContextMenu;\nexports.preventDefault = preventDefault;\nexports.preventSelection = preventSelection;\nexports.rangeContainsMarker = rangeContainsMarker;\nexports.rangeContainsRange = rangeContainsRange;\nexports.rangesEqual = rangesEqual;\nexports.rangesIntersect = rangesIntersect;\nexports.refineEventDef = refineEventDef;\nexports.refineProps = refineProps;\nexports.removeElement = removeElement;\nexports.removeExact = removeExact;\nexports.renderChunkContent = renderChunkContent;\nexports.renderFill = renderFill;\nexports.renderMicroColGroup = renderMicroColGroup;\nexports.renderScrollShim = renderScrollShim;\nexports.requestJson = requestJson;\nexports.sanitizeShrinkWidth = sanitizeShrinkWidth;\nexports.setElSeg = setElSeg;\nexports.setRef = setRef;\nexports.sliceEventStore = sliceEventStore;\nexports.sliceEvents = sliceEvents;\nexports.sortEventSegs = sortEventSegs;\nexports.startOfDay = startOfDay;\nexports.translateRect = translateRect;\nexports.triggerDateSelect = triggerDateSelect;\nexports.unpromisify = unpromisify;\nexports.version = version;\nexports.whenTransitionDone = whenTransitionDone;\nexports.wholeDivideDurations = wholeDivideDurations;\nObject.keys(vdom_cjs).forEach(function(k) {\n    if (k !== \"default\" && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return vdom_cjs[k];\n        }\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQSxHQUNBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7O0FBRzdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLG9EQUFvRDtBQUNwRCxtQ0FBbUM7QUFDbkMsSUFBSUUsaUJBQWlCLFdBQVcsR0FBSSxXQUFZO0lBQzVDLFNBQVNBLGVBQWVDLE9BQU8sRUFBRUMsbUJBQW1CLEVBQUU7UUFDbEQsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR0E7SUFDL0I7SUFDQUYsZUFBZUcsU0FBUyxDQUFDQyxNQUFNLEdBQUcsV0FBWTtRQUMxQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksUUFBUSxDQUFDO1lBQ2xCQyxNQUFNO1lBQ05DLFVBQVUsSUFBSSxDQUFDTCxtQkFBbUIsQ0FBQ0ssUUFBUTtRQUMvQztJQUNKO0lBQ0FQLGVBQWVHLFNBQVMsQ0FBQ0ssT0FBTyxHQUFHLFdBQVk7UUFDM0MsSUFBSSxDQUFDUCxPQUFPLENBQUNJLFFBQVEsQ0FBQztZQUNsQkMsTUFBTTtZQUNORyxXQUFXO2dCQUFDLElBQUksQ0FBQ1AsbUJBQW1CLENBQUNLLFFBQVE7YUFBQztZQUM5Q0csV0FBVyxJQUFJO1FBQ25CO0lBQ0o7SUFDQWpCLE9BQU9DLGNBQWMsQ0FBQ00sZUFBZUcsU0FBUyxFQUFFLE1BQU07UUFDbERRLEtBQUssV0FBWTtZQUNiLE9BQU8sSUFBSSxDQUFDVCxtQkFBbUIsQ0FBQ1UsUUFBUTtRQUM1QztRQUNBQyxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBckIsT0FBT0MsY0FBYyxDQUFDTSxlQUFlRyxTQUFTLEVBQUUsT0FBTztRQUNuRFEsS0FBSyxXQUFZO1lBQ2IsT0FBTyxJQUFJ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MEIsR0FBRzZGO0FBQzdCN0YsNEJBQTRCLEdBQUdpVztBQUMvQm5XLE9BQU84USxJQUFJLENBQUN4USxVQUFVNEYsT0FBTyxDQUFDLFNBQVU2cUUsQ0FBQyxFQUFFO0lBQ3ZDLElBQUlBLE1BQU0sYUFBYSxDQUFDN3dFLFFBQVFtUCxjQUFjLENBQUMwaEUsSUFBSS93RSxPQUFPQyxjQUFjLENBQUNDLFNBQVM2d0UsR0FBRztRQUNqRjN2RSxZQUFZLElBQUk7UUFDaEJGLEtBQUssV0FBWTtZQUNiLE9BQU9aLFFBQVEsQ0FBQ3l3RSxFQUFFO1FBQ3RCO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC1mdWxsY2FsZW5kYXIvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5janMuanM/ZDA3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMS4zXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMiBBZGFtIFNoYXdcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbjtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgdmRvbV9janMgPSByZXF1aXJlKCcuL3Zkb20uY2pzJyk7XG5cbi8vIG5vIHB1YmxpYyB0eXBlcyB5ZXQuIHdoZW4gdGhlcmUgYXJlLCBleHBvcnQgZnJvbTpcbi8vIGltcG9ydCB7fSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG52YXIgRXZlbnRTb3VyY2VBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRTb3VyY2VBcGkoY29udGV4dCwgaW50ZXJuYWxFdmVudFNvdXJjZSkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UgPSBpbnRlcm5hbEV2ZW50U291cmNlO1xuICAgIH1cbiAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUucmVmZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkczogW3RoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZF0sXG4gICAgICAgICAgICBpc1JlZmV0Y2g6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlQXBpLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEudXJsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlQXBpLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS5mb3JtYXQ7IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBFdmVudFNvdXJjZUFwaTtcbn0oKSk7XG5cbmZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG59XG4vLyBRdWVyeWluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcbi8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XG4gICAgdmFyIGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xuICAgIHZhciBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXG4vLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXG5mdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcbiAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBQSVhFTF9QUk9QX1JFID0gLyh0b3B8bGVmdHxyaWdodHxib3R0b218d2lkdGh8aGVpZ2h0KSQvaTtcbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZWwsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgICAgYXBwbHlTdHlsZVByb3AoZWwsIHByb3BOYW1lLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5U3R5bGVQcm9wKGVsLCBuYW1lLCB2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgUElYRUxfUFJPUF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsICsgXCJweFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XG4gICAgfVxufVxuLy8gRXZlbnQgSGFuZGxpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XG59XG4vLyBTaGFkb3cgRE9NIGNvbnN1ZGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRFbFJvb3QoZWwpIHtcbiAgICByZXR1cm4gZWwuZ2V0Um9vdE5vZGUgPyBlbC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQ7XG59XG4vLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcbnZhciBndWlkJDEgPSAwO1xuZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XG4gICAgZ3VpZCQxICs9IDE7XG4gICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcbn1cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG59XG4vLyBFdmVudCBEZWxlZ2F0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgbWF0Y2hlZENoaWxkID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCBzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChtYXRjaGVkQ2hpbGQsIGV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCBldmVudFR5cGUsIHNlbGVjdG9yLCBoYW5kbGVyKSB7XG4gICAgdmFyIGF0dGFjaGVkSGFuZGxlciA9IGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKGNvbnRhaW5lciwgc2VsZWN0b3IsIG9uTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlKSB7XG4gICAgdmFyIGN1cnJlbnRNYXRjaGVkQ2hpbGQ7XG4gICAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSB7XG4gICAgICAgIGlmIChtYXRjaGVkQ2hpbGQgIT09IGN1cnJlbnRNYXRjaGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBtYXRjaGVkQ2hpbGQ7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICB2YXIgcmVhbE9uTW91c2VMZWF2ZV8xID0gZnVuY3Rpb24gKG1vdXNlTGVhdmVFdikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGxpc3RlbiB0byB0aGUgbmV4dCBtb3VzZWxlYXZlLCBhbmQgdGhlbiB1bmF0dGFjaFxuICAgICAgICAgICAgbWF0Y2hlZENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlXzEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB0cmFuc2l0aW9uRXZlbnROYW1lcyA9IFtcbiAgICAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ290cmFuc2l0aW9uZW5kJyxcbiAgICAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb25FbmQnLFxuICAgICd0cmFuc2l0aW9uZW5kJyxcbl07XG4vLyB0cmlnZ2VyZWQgb25seSB3aGVuIHRoZSBuZXh0IHNpbmdsZSBzdWJzZXF1ZW50IHRyYW5zaXRpb24gZmluaXNoZXNcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRG9uZShlbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVhbENhbGxiYWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGNhbGxiYWNrKGV2KTtcbiAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcmVhbENhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB0cmFuc2l0aW9uRXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7IC8vIGNyb3NzLWJyb3dzZXIgd2F5IHRvIGRldGVybWluZSB3aGVuIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzXG4gICAgfSk7XG59XG4vLyBBUklBIHdvcmthcm91bmRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjcmVhdGVBcmlhQ2xpY2tBdHRycyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5ID09PSAnRW50ZXInIHx8IGV2LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcihldik7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgLy8gaWYgc3BhY2UsIGRvbid0IHNjcm9sbCBkb3duIHBhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG52YXIgZ3VpZE51bWJlciA9IDA7XG5mdW5jdGlvbiBndWlkKCkge1xuICAgIGd1aWROdW1iZXIgKz0gMTtcbiAgICByZXR1cm4gU3RyaW5nKGd1aWROdW1iZXIpO1xufVxuLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXG5mdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZmMtbm90LWFsbG93ZWQnKTtcbn1cbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZmMtbm90LWFsbG93ZWQnKTtcbn1cbi8qIFNlbGVjdGlvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5mdW5jdGlvbiBhbGxvd1NlbGVjdGlvbihlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuLyogQ29udGV4dCBNZW51XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHByZXZlbnRDb250ZXh0TWVudShlbCkge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gYWxsb3dDb250ZXh0TWVudShlbCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XG4gICAgdmFyIHNwZWNzID0gW107XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciB0b2tlbjtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICB0b2tlbnMgPSBpbnB1dDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3BlY3M7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGZpZWxkU3BlY3MpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgY21wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzW2ldKTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWMpIHtcbiAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajAsIG9iajEpO1xuICAgIH1cbiAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajBbZmllbGRTcGVjLmZpZWxkXSwgb2JqMVtmaWVsZFNwZWMuZmllbGRdKVxuICAgICAgICAqIChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XG59XG5mdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xuICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xuICAgIH1cbiAgICByZXR1cm4gYSAtIGI7XG59XG4vKiBTdHJpbmcgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHBhZFN0YXJ0KHZhbCwgbGVuKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcodmFsKTtcbiAgICByZXR1cm4gJzAwMCcuc3Vic3RyKDAsIGxlbiAtIHMubGVuZ3RoKSArIHM7XG59XG5mdW5jdGlvbiBmb3JtYXRXaXRoT3JkaW5hbHMoZm9ybWF0dGVyLCBhcmdzLCBmYWxsYmFja1RleHQpIHtcbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnc3RyaW5nJykgeyAvLyBub24tYmxhbmsgc3RyaW5nXG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBhcmcsIGluZGV4KSB7IHJldHVybiAoc3RyLnJlcGxhY2UoJyQnICsgaW5kZXgsIGFyZyB8fCAnJykpOyB9LCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xufVxuLyogTnVtYmVyIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gaXNJbnQobikge1xuICAgIHJldHVybiBuICUgMSA9PT0gMDtcbn1cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbCkge1xuICAgIHZhciBhbGxXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScpO1xuICAgIHZhciBjb250ZW50V2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicpO1xuICAgIGlmICghYWxsV2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpOyAvLyBUT0RPOiB1c2UgY29uc3RcbiAgICB9XG4gICAgaWYgKCFjb250ZW50V2lkdGhFbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICAgICAgY29udGVudFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG59XG5cbnZhciBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcbi8vIEFkZGluZ1xuZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xuICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVsyXSArPSBuICogNztcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcbiAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbjtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGRNcyhtLCBuKSB7XG4gICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzZdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXG4vLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XG5mdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XG4gICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xufVxuZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xufVxuZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcbn1cbmZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XG59XG5mdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcbiAgICB2YXIgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcbiAgICB2YXIgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXG4gICAgfTtcbn1cbi8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbmZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xuICAgIHZhciBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkIC8gNztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xuICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBTdGFydC1PZlxuZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcbiAgICBdKTtcbn1cbi8vIFdlZWsgQ29tcHV0YXRpb25cbmZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xuICAgIHZhciB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgdmFyIHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XG4gICAgaWYgKHcgPCAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xuICAgIH1cbiAgICB2YXIgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xuICAgIGlmIChuZXh0VyA+PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufVxuZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcbiAgICB2YXIgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XG4gICAgdmFyIGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxufVxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgIHZhciBmd2QgPSA3ICsgZG93IC0gZG95O1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICB2YXIgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuLy8gQXJyYXkgQ29udmVyc2lvblxuZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxuICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xufVxuZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxuICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcbiAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXG4gICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cbiAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShEYXRlLCBhKSk7XG59XG4vLyBPdGhlciBVdGlsc1xuZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xuICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gdGltZUFzTXMobSkge1xuICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwgcmFuZ2UsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZUlkOiBndWlkKCksXG4gICAgICAgIGRlZklkOiBkZWZJZCxcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogZm9yY2VkU3RhcnRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRTdGFydFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gICAgfTtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXApIHtcbiAgICB2YXIgZGVzdCA9IHt9O1xuICAgIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXhPYmpzID0gW107XG4gICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gcHJvcE9ianNbaV1bbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV8xXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcbiAgICAgICAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVfMV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG4gICAgZm9yICh2YXIgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHByb3BPYmpzW2ldO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzIgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKG5hbWVfMiBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXzJdID0gcHJvcHNbbmFtZV8yXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cbmZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xuICAgIHZhciBmaWx0ZXJlZCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XG4gICAgICAgIGlmIChmdW5jKGhhc2hba2V5XSwga2V5KSkge1xuICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG59XG5mdW5jdGlvbiBtYXBIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICB2YXIgbmV3SGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBoYXNoKSB7XG4gICAgICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3SGFzaDtcbn1cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGEpIHtcbiAgICB2YXIgaGFzaCA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgYV8xID0gYTsgX2kgPCBhXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYV8xW19pXTtcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuZnVuY3Rpb24gYnVpbGRIYXNoRnJvbUFycmF5KGEsIGZ1bmMpIHtcbiAgICB2YXIgaGFzaCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdHVwbGUgPSBmdW5jKGFbaV0sIGkpO1xuICAgICAgICBoYXNoW3R1cGxlWzBdXSA9IHR1cGxlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGhhc2hWYWx1ZXNUb0FycmF5KG9iaikge1xuICAgIHZhciBhID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBhLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgaWYgKG9iajAgPT09IG9iajEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iajApIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBjb21wYXJlT2JqcyhvbGRQcm9wcywgbmV3UHJvcHMsIGVxdWFsaXR5RnVuY3MpIHtcbiAgICBpZiAoZXF1YWxpdHlGdW5jcyA9PT0gdm9pZCAwKSB7IGVxdWFsaXR5RnVuY3MgPSB7fTsgfVxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoa2V5IGluIG9sZFByb3BzICYmIGlzT2JqVmFsc0VxdWFsKG9sZFByb3BzW2tleV0sIG5ld1Byb3BzW2tleV0sIGVxdWFsaXR5RnVuY3Nba2V5XSkpIDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHByb3BzIHRoYXQgd2VyZSBvbWl0dGVkIGluIHRoZSBuZXdcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLypcbmFzc3VtZWQgXCJ0cnVlXCIgZXF1YWxpdHkgZm9yIGhhbmRsZXIgbmFtZXMgbGlrZSBcIm9uUmVjZWl2ZVNvbWV0aGluZ1wiXG4qL1xuZnVuY3Rpb24gaXNPYmpWYWxzRXF1YWwodmFsMCwgdmFsMSwgY29tcGFyYXRvcikge1xuICAgIGlmICh2YWwwID09PSB2YWwxIHx8IGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKHZhbDAsIHZhbDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0RnJvbUhhc2goaGFzaCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApIHtcbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMTsgfVxuICAgIHZhciByZXMgPSBbXTtcbiAgICBpZiAoZW5kSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBlbmRJbmRleCA9IE9iamVjdC5rZXlzKGhhc2gpLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSBzdGVwKSB7XG4gICAgICAgIHZhciB2YWwgPSBoYXNoW2ldO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHsgLy8gd2lsbCBkaXNyZWdhcmQgdW5kZWZpbmVkIGZvciBzcGFyc2UgYXJyYXlzXG4gICAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN1cnJpbmdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcmVjdXJyaW5nVHlwZXNbaV0ucGFyc2UocmVmaW5lZCwgZGF0ZUVudik7XG4gICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgIHZhciBhbGxEYXkgPSByZWZpbmVkLmFsbERheTtcbiAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERheSA9IHBhcnNlZC5hbGxEYXlHdWVzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIHBsdWdpbkhvb2tzID0gY29udGV4dC5wbHVnaW5Ib29rcywgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcywgaW5zdGFuY2VzID0gZXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIHJlY3VycmluZyBpbnN0YW5jZXNcbiAgICAvLyBUT0RPOiBiYWQuIGFsd2F5cyBleHBhbmQgZXZlbnRzIGFzIGEgc2Vjb25kIHN0ZXBcbiAgICBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAhZGVmc1tpbnN0YW5jZS5kZWZJZF0ucmVjdXJyaW5nRGVmOyB9KTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IGRlZi5yZWN1cnJpbmdEZWYuZHVyYXRpb247XG4gICAgICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkZWYuYWxsRGF5ID9cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydHMgPSBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCBwbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0YXJ0c18xID0gc3RhcnRzOyBfaSA8IHN0YXJ0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHN0YXJ0c18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZklkLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG4vKlxuRXZlbnQgTVVTVCBoYXZlIGEgcmVjdXJyaW5nRGVmXG4qL1xuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGV2ZW50RGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIHZhciB0eXBlRGVmID0gcmVjdXJyaW5nVHlwZXNbZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVJZF07XG4gICAgdmFyIG1hcmtlcnMgPSB0eXBlRGVmLmV4cGFuZChldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZURhdGEsIHtcbiAgICAgICAgc3RhcnQ6IGRhdGVFbnYuc3VidHJhY3QoZnJhbWluZ1JhbmdlLnN0YXJ0LCBkdXJhdGlvbiksXG4gICAgICAgIGVuZDogZnJhbWluZ1JhbmdlLmVuZCxcbiAgICB9LCBkYXRlRW52KTtcbiAgICAvLyB0aGUgcmVjdXJyZW5jZSBwbHVnaW5zIGRvbid0IGd1YXJhbnRlZSB0aGF0IGFsbC1kYXkgZXZlbnRzIGFyZSBzdGFydC1vZi1kYXksIHNvIHdlIGhhdmUgdG9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcChzdGFydE9mRGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcnM7XG59XG5cbnZhciBJTlRFUk5BTF9VTklUUyA9IFsneWVhcnMnLCAnbW9udGhzJywgJ2RheXMnLCAnbWlsbGlzZWNvbmRzJ107XG52YXIgUEFSU0VfUkUgPSAvXigtPykoPzooXFxkKylcXC4pPyhcXGQrKTooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlxcLihcXGRcXGRcXGQpKT8pPy87XG4vLyBQYXJzaW5nIGFuZCBDcmVhdGlvblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHVuaXQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU9iamVjdCgoX2EgPSB7fSwgX2FbdW5pdCB8fCAnbWlsbGlzZWNvbmRzJ10gPSBpbnB1dCwgX2EpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzKSB7XG4gICAgdmFyIG0gPSBQQVJTRV9SRS5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIHZhciBzaWduID0gbVsxXSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgICAgICAgICAobVs0XSA/IHBhcnNlSW50KG1bNF0sIDEwKSA6IDApICogNjAgKiAxMDAwICsgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgdmFyIGR1cmF0aW9uID0ge1xuICAgICAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgICAgIG1vbnRoczogb2JqLm1vbnRocyB8fCBvYmoubW9udGggfHwgMCxcbiAgICAgICAgZGF5czogb2JqLmRheXMgfHwgb2JqLmRheSB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChvYmouaG91cnMgfHwgb2JqLmhvdXIgfHwgMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAob2JqLm1pbnV0ZXMgfHwgb2JqLm1pbnV0ZSB8fCAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIChvYmouc2Vjb25kcyB8fCBvYmouc2Vjb25kIHx8IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgIChvYmoubWlsbGlzZWNvbmRzIHx8IG9iai5taWxsaXNlY29uZCB8fCBvYmoubXMgfHwgMCksIC8vIG1zXG4gICAgfTtcbiAgICB2YXIgd2Vla3MgPSBvYmoud2Vla3MgfHwgb2JqLndlZWs7XG4gICAgaWYgKHdlZWtzKSB7XG4gICAgICAgIGR1cmF0aW9uLmRheXMgKz0gd2Vla3MgKiA3O1xuICAgICAgICBkdXJhdGlvbi5zcGVjaWZpZWRXZWVrcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cbi8vIEVxdWFsaXR5XG5mdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcbiAgICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgICAgIGQwLm1vbnRocyA9PT0gZDEubW9udGhzICYmXG4gICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICAgICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHM7XG59XG5mdW5jdGlvbiBhc0NsZWFuRGF5cyhkdXIpIHtcbiAgICBpZiAoIWR1ci55ZWFycyAmJiAhZHVyLm1vbnRocyAmJiAhZHVyLm1pbGxpc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gZHVyLmRheXM7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8gU2ltcGxlIE1hdGhcbmZ1bmN0aW9uIGFkZER1cmF0aW9ucyhkMCwgZDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZDAueWVhcnMgKyBkMS55ZWFycyxcbiAgICAgICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgICAgIGRheXM6IGQwLmRheXMgKyBkMS5kYXlzLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQwLm1pbGxpc2Vjb25kcyArIGQxLm1pbGxpc2Vjb25kcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgICAgICBkYXlzOiBkMS5kYXlzIC0gZDAuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZCwgbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICAgICAgbW9udGhzOiBkLm1vbnRocyAqIG4sXG4gICAgICAgIGRheXM6IGQuZGF5cyAqIG4sXG4gICAgICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuLFxuICAgIH07XG59XG4vLyBDb252ZXJzaW9uc1xuLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcbmZ1bmN0aW9uIGFzUm91Z2hZZWFycyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDM2NTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hEYXlzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1O1xufVxuZnVuY3Rpb24gYXNSb3VnaE1pbnV0ZXMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAxMDAwO1xufVxuZnVuY3Rpb24gYXNSb3VnaE1zKGR1cikge1xuICAgIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICAgICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5kYXlzICogODY0ZTUgK1xuICAgICAgICBkdXIubWlsbGlzZWNvbmRzO1xufVxuLy8gQWR2YW5jZWQgTWF0aFxuZnVuY3Rpb24gd2hvbGVEaXZpZGVEdXJhdGlvbnMobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIHZhciByZXMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSU5URVJOQUxfVU5JVFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHVuaXQgPSBJTlRFUk5BTF9VTklUU1tpXTtcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxSZXMgPSBudW1lcmF0b3JbdW5pdF0gLyBkZW5vbWluYXRvclt1bml0XTtcbiAgICAgICAgICAgIGlmICghaXNJbnQobG9jYWxSZXMpIHx8IChyZXMgIT09IG51bGwgJiYgcmVzICE9PSBsb2NhbFJlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IGxvY2FsUmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cikge1xuICAgIHZhciBtcyA9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgaWYgKG1zKSB7XG4gICAgICAgIGlmIChtcyAlIDEwMDAgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG1zIC8gMTAwMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjAgKiA2MCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwICogNjApIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR1ci5kYXlzKSB7XG4gICAgICAgIGlmIChkdXIuc3BlY2lmaWVkV2Vla3MgJiYgZHVyLmRheXMgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBkdXIuZGF5cyAvIDcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IGR1ci5kYXlzIH07XG4gICAgfVxuICAgIGlmIChkdXIubW9udGhzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBkdXIubW9udGhzIH07XG4gICAgfVxuICAgIGlmIChkdXIueWVhcnMpIHtcbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogZHVyLnllYXJzIH07XG4gICAgfVxuICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiAwIH07XG59XG5cbi8vIHRpbWVab25lT2Zmc2V0IGlzIGluIG1pbnV0ZXNcbmZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIHN0cmlwWmVyb1RpbWUpIHtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSA9PT0gdm9pZCAwKSB7IHN0cmlwWmVyb1RpbWUgPSBmYWxzZTsgfVxuICAgIHZhciBzID0gbWFya2VyLnRvSVNPU3RyaW5nKCk7XG4gICAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKTtcbiAgICBpZiAoc3RyaXBaZXJvVGltZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCdUMDA6MDA6MDBaJywgJycpO1xuICAgIH1cbiAgICBpZiAocy5sZW5ndGggPiAxMCkgeyAvLyB0aW1lIHBhcnQgd2Fzbid0IHN0cmlwcGVkLCBjYW4gYWRkIHRpbWV6b25lIGluZm9cbiAgICAgICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZVpvbmVPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCBmb3JtYXRUaW1lWm9uZU9mZnNldCh0aW1lWm9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaXRzIFVUQy0wIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIFpcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmZ1bmN0aW9uIGZvcm1hdERheVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC4qJC8sICcnKTtcbn1cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5mdW5jdGlvbiBmb3JtYXRJc29UaW1lU3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBwYWRTdGFydChtYXJrZXIuZ2V0VVRDSG91cnMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDTWludXRlcygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpO1xufVxuZnVuY3Rpb24gZm9ybWF0VGltZVpvbmVPZmZzZXQobWludXRlcywgZG9Jc28pIHtcbiAgICBpZiAoZG9Jc28gPT09IHZvaWQgMCkgeyBkb0lzbyA9IGZhbHNlOyB9XG4gICAgdmFyIHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJztcbiAgICB2YXIgYWJzID0gTWF0aC5hYnMobWludXRlcyk7XG4gICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MCk7XG4gICAgdmFyIG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKTtcbiAgICBpZiAoZG9Jc28pIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBwYWRTdGFydChob3VycywgMikgKyBcIjpcIiArIHBhZFN0YXJ0KG1pbnMsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJHTVRcIiArIHNpZ24gKyBob3VycyArIChtaW5zID8gXCI6XCIgKyBwYWRTdGFydChtaW5zLCAyKSA6ICcnKTtcbn1cblxuLy8gVE9ETzogbmV3IHV0aWwgYXJyYXlpZnk/XG5mdW5jdGlvbiByZW1vdmVFeGFjdChhcnJheSwgZXhhY3RWYWwpIHtcbiAgICB2YXIgcmVtb3ZlQ250ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBleGFjdFZhbCkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmVtb3ZlQ250ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZUNudDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlzRXF1YWwoYTAsIGExLCBlcXVhbGl0eUZ1bmMpIHtcbiAgICBpZiAoYTAgPT09IGExKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbGVuID0gYTAubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIGlmIChsZW4gIT09IGExLmxlbmd0aCkgeyAvLyBub3QgYXJyYXk/IG9yIG5vdCBzYW1lIGxlbmd0aD9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCEoZXF1YWxpdHlGdW5jID8gZXF1YWxpdHlGdW5jKGEwW2ldLCBhMVtpXSkgOiBhMFtpXSA9PT0gYTFbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBjdXJyZW50QXJncztcbiAgICB2YXIgY3VycmVudFJlcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY3VycmVudEFyZztcbiAgICB2YXIgY3VycmVudFJlcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5ld0FyZykge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmNhbGwoX3RoaXMsIG5ld0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuY2FsbChfdGhpcywgbmV3QXJnKTtcbiAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmcgPSBuZXdBcmc7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplQXJyYXlsaWtlKC8vIHVzZWQgYXQgYWxsP1xud29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmdTZXRzID0gW107XG4gICAgdmFyIGN1cnJlbnRSZXN1bHRzID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmdTZXRzKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xuICAgICAgICB2YXIgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnU2V0c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzdWx0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgbmV3TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnU2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ1NldHMgPSBuZXdBcmdTZXRzO1xuICAgICAgICBjdXJyZW50UmVzdWx0cy5zcGxpY2UobmV3TGVuKTsgLy8gcmVtb3ZlIGV4Y2Vzc1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdHM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVIYXNobGlrZSh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY3VycmVudEFyZ0hhc2ggPSB7fTtcbiAgICB2YXIgY3VycmVudFJlc0hhc2ggPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5ld0FyZ0hhc2gpIHtcbiAgICAgICAgdmFyIG5ld1Jlc0hhc2ggPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld0FyZ0hhc2gpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFJlc0hhc2hba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnSGFzaFtrZXldLCBuZXdBcmdIYXNoW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KF90aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcbiAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xuICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcbiAgICB9O1xufVxuXG52YXIgRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMgPSB7XG4gICAgd2VlazogMyxcbiAgICBzZXBhcmF0b3I6IDAsXG4gICAgb21pdFplcm9NaW51dGU6IDAsXG4gICAgbWVyaWRpZW06IDAsXG4gICAgb21pdENvbW1hczogMCxcbn07XG52YXIgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XG4gICAgdGltZVpvbmVOYW1lOiA3LFxuICAgIGVyYTogNixcbiAgICB5ZWFyOiA1LFxuICAgIG1vbnRoOiA0LFxuICAgIGRheTogMixcbiAgICB3ZWVrZGF5OiAyLFxuICAgIGhvdXI6IDEsXG4gICAgbWludXRlOiAxLFxuICAgIHNlY29uZDogMSxcbn07XG52YXIgTUVSSURJRU1fUkUgPSAvXFxzKihbYXBdKVxcLj9tXFwuPy9pOyAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xudmFyIENPTU1BX1JFID0gLywvZzsgLy8gd2UgbmVlZCByZSBmb3IgZ2xvYmFsbmVzc1xudmFyIE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcbnZhciBMVFJfUkUgPSAvXFx1MjAwZS9nOyAvLyBjb250cm9sIGNoYXJhY3RlclxudmFyIFVUQ19SRSA9IC9VVEN8R01ULztcbnZhciBOYXRpdmVGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF0aXZlRm9ybWF0dGVyKGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgIHZhciBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xuICAgICAgICB2YXIgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgc2V2ZXJpdHkgPSAwO1xuICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gZm9ybWF0U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChuYW1lXzEgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFNldHRpbmdzW25hbWVfMV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV8xXSA9IGZvcm1hdFNldHRpbmdzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVfMSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgeyAvLyBUT0RPOiB3aGF0IGFib3V0IGhvdXIxMj8gbm8gc2V2ZXJpdHlcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgPSBNYXRoLm1heChTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXzFdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcbiAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpO1xuICAgIH1cbiAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmModGhpcy5zdGFuZGFyZERhdGVQcm9wcywgdGhpcy5leHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KShkYXRlKTtcbiAgICB9O1xuICAgIE5hdGl2ZUZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGFuZGFyZERhdGVQcm9wcyA9IF9hLnN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzID0gX2EuZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgdmFyIGRpZmZTZXZlcml0eSA9IGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoc3RhcnQubWFya2VyLCBlbmQubWFya2VyLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKTtcbiAgICAgICAgaWYgKCFkaWZmU2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA9IGRpZmZTZXZlcml0eTtcbiAgICAgICAgaWYgKGJpZ2dlc3RVbml0Rm9yUGFydGlhbCA+IDEgJiYgLy8gdGhlIHR3byBkYXRlcyBhcmUgZGlmZmVyZW50IGluIGEgd2F5IHRoYXQncyBsYXJnZXIgc2NhbGUgdGhhbiB0aW1lXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMueWVhciA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICcyLWRpZ2l0JykgJiZcbiAgICAgICAgICAgIChzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1vbnRoID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnbnVtZXJpYycgfHwgc3RhbmRhcmREYXRlUHJvcHMuZGF5ID09PSAnMi1kaWdpdCcpKSB7XG4gICAgICAgICAgICBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSAxOyAvLyBtYWtlIGl0IGxvb2sgbGlrZSB0aGUgZGF0ZXMgYXJlIG9ubHkgZGlmZmVyZW50IGluIHRlcm1zIG9mIHRpbWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVsbDAgPSB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dCk7XG4gICAgICAgIHZhciBmdWxsMSA9IHRoaXMuZm9ybWF0KGVuZCwgY29udGV4dCk7XG4gICAgICAgIGlmIChmdWxsMCA9PT0gZnVsbDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdWxsMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydGlhbERhdGVQcm9wcyA9IGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMoc3RhbmRhcmREYXRlUHJvcHMsIGJpZ2dlc3RVbml0Rm9yUGFydGlhbCk7XG4gICAgICAgIHZhciBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMgPSBidWlsZEZvcm1hdHRpbmdGdW5jKHBhcnRpYWxEYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgICAgICB2YXIgcGFydGlhbDAgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoc3RhcnQpO1xuICAgICAgICB2YXIgcGFydGlhbDEgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoZW5kKTtcbiAgICAgICAgdmFyIGluc2VydGlvbiA9IGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gZXh0ZW5kZWRTZXR0aW5ncy5zZXBhcmF0b3IgfHwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IgfHwgJyc7XG4gICAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRpb24uYmVmb3JlICsgcGFydGlhbDAgKyBzZXBhcmF0b3IgKyBwYXJ0aWFsMSArIGluc2VydGlvbi5hZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVsbDAgKyBzZXBhcmF0b3IgKyBmdWxsMTtcbiAgICB9O1xuICAgIE5hdGl2ZUZvcm1hdHRlci5wcm90b3R5cGUuZ2V0TGFyZ2VzdFVuaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXZlcml0eSkge1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiAneWVhcic7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtb250aCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd3ZWVrJztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RheSc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAndGltZSc7IC8vIHJlYWxseT9cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5hdGl2ZUZvcm1hdHRlcjtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7IH07XG4gICAgfVxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChmb3JtYXRXZWVrTnVtYmVyKGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLCBjb250ZXh0LndlZWtUZXh0LCBjb250ZXh0LndlZWtUZXh0TG9uZywgY29udGV4dC5sb2NhbGUsIGV4dGVuZGVkU2V0dGluZ3Mud2VlaykpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpOyAvLyBjb3B5XG4gICAgZXh0ZW5kZWRTZXR0aW5ncyA9IHRzbGliLl9fYXNzaWduKHt9LCBleHRlbmRlZFNldHRpbmdzKTsgLy8gY29weVxuICAgIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpO1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lID0gJ1VUQyc7IC8vIHdlIGxldmVyYWdlIHRoZSBvbmx5IGd1YXJhbnRlZWQgdGltZVpvbmUgZm9yIG91ciBVVEMgbWFya2Vyc1xuICAgIHZhciBub3JtYWxGb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2Rlcywgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgIHZhciB6ZXJvRm9ybWF0OyAvLyBuZWVkZWQ/XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICAgICAgdmFyIHplcm9Qcm9wcyA9IHRzbGliLl9fYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXG4gICAgICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBkYXRlLm1hcmtlcjtcbiAgICAgICAgdmFyIGZvcm1hdDtcbiAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBub3JtYWxGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpIHtcbiAgICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcbiAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUpIHtcbiAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgfVxuICAgIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XG4gICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKTsgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xuICAgICAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXG4gICAgICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnOjAwJywgJycpOyAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xuICAgIH1cbiAgICAvLyBeIGRvIGFueXRoaW5nIHRoYXQgbWlnaHQgY3JlYXRlIGFkamFjZW50IHNwYWNlcyBiZWZvcmUgdGhpcyBwb2ludCxcbiAgICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAnJykudHJpbSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24gKG0wLCBtMSkgeyByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKTsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24gKG0wLCBtMSkgeyByZXR1cm4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSArIFwibVwiOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ2xvd2VyY2FzZScpIHsgLy8gb3RoZXIgbWVyaWRpZW0gdHJhbnNmb3JtZXJzIGFscmVhZHkgY29udmVydGVkIHRvIGxvd2VyY2FzZVxuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCBmdW5jdGlvbiAobTApIHsgcmV0dXJuIG0wLnRvTG9jYWxlTG93ZXJDYXNlKCk7IH0pO1xuICAgIH1cbiAgICBzID0gcy5yZXBsYWNlKE1VTFRJX1NQQUNFX1JFLCAnICcpO1xuICAgIHMgPSBzLnRyaW0oKTtcbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGluamVjdFR6b1N0cihzLCB0em9TdHIpIHtcbiAgICB2YXIgcmVwbGFjZWQgPSBmYWxzZTtcbiAgICBzID0gcy5yZXBsYWNlKFVUQ19SRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXBsYWNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0em9TdHI7XG4gICAgfSk7XG4gICAgLy8gSUUxMSBkb2Vzbid0IGluY2x1ZGUgVVRDL0dNVCBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nLCBzbyBhcHBlbmQgdG8gZW5kXG4gICAgaWYgKCFyZXBsYWNlZCkge1xuICAgICAgICBzICs9IFwiIFwiICsgdHpvU3RyO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtLCB3ZWVrVGV4dCwgd2Vla1RleHRMb25nLCBsb2NhbGUsIGRpc3BsYXkpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHRMb25nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzcGxheSA9PT0gJ3Nob3J0JyB8fCBkaXNwbGF5ID09PSAnbmFycm93Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJyB8fCBkaXNwbGF5ID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHBhcnRzLnB1c2goJyAnKTtcbiAgICB9XG4gICAgcGFydHMucHVzaChsb2NhbGUuc2ltcGxlTnVtYmVyRm9ybWF0LmZvcm1hdChudW0pKTtcbiAgICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuLy8gMCA9IGV4YWN0bHkgdGhlIHNhbWVcbi8vIDEgPSBkaWZmZXJlbnQgYnkgdGltZVxuLy8gYW5kIGJpZ2dlclxuZnVuY3Rpb24gY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eShkMCwgZDEsIGNhKSB7XG4gICAgaWYgKGNhLmdldE1hcmtlclllYXIoZDApICE9PSBjYS5nZXRNYXJrZXJZZWFyKGQxKSkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlck1vbnRoKGQwKSAhPT0gY2EuZ2V0TWFya2VyTW9udGgoZDEpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyRGF5KGQwKSAhPT0gY2EuZ2V0TWFya2VyRGF5KGQxKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKHRpbWVBc01zKGQwKSAhPT0gdGltZUFzTXMoZDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMob3B0aW9ucywgYmlnZ2VzdFVuaXQpIHtcbiAgICB2YXIgcGFydGlhbE9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lXzIgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIShuYW1lXzIgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHx8IC8vIG5vdCBhIGRhdGUgcGFydCBwcm9wIChsaWtlIHRpbWVab25lKVxuICAgICAgICAgICAgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8yXSA8PSBiaWdnZXN0VW5pdCkge1xuICAgICAgICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV8yXSA9IG9wdGlvbnNbbmFtZV8yXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydGlhbE9wdGlvbnM7XG59XG5mdW5jdGlvbiBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKSB7XG4gICAgdmFyIGkwID0gMDtcbiAgICB3aGlsZSAoaTAgPCBmdWxsMC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGZvdW5kMCA9IGZ1bGwwLmluZGV4T2YocGFydGlhbDAsIGkwKTtcbiAgICAgICAgaWYgKGZvdW5kMCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWZvcmUwID0gZnVsbDAuc3Vic3RyKDAsIGZvdW5kMCk7XG4gICAgICAgIGkwID0gZm91bmQwICsgcGFydGlhbDAubGVuZ3RoO1xuICAgICAgICB2YXIgYWZ0ZXIwID0gZnVsbDAuc3Vic3RyKGkwKTtcbiAgICAgICAgdmFyIGkxID0gMDtcbiAgICAgICAgd2hpbGUgKGkxIDwgZnVsbDEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQxID0gZnVsbDEuaW5kZXhPZihwYXJ0aWFsMSwgaTEpO1xuICAgICAgICAgICAgaWYgKGZvdW5kMSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiZWZvcmUxID0gZnVsbDEuc3Vic3RyKDAsIGZvdW5kMSk7XG4gICAgICAgICAgICBpMSA9IGZvdW5kMSArIHBhcnRpYWwxLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhZnRlcjEgPSBmdWxsMS5zdWJzdHIoaTEpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZTAgPT09IGJlZm9yZTEgJiYgYWZ0ZXIwID09PSBhZnRlcjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZTAsXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyOiBhZnRlcjAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXhwYW5kWm9uZWRNYXJrZXIoZGF0ZUluZm8sIGNhbGVuZGFyU3lzdGVtKSB7XG4gICAgdmFyIGEgPSBjYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KGRhdGVJbmZvLm1hcmtlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFya2VyOiBkYXRlSW5mby5tYXJrZXIsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlSW5mby50aW1lWm9uZU9mZnNldCxcbiAgICAgICAgYXJyYXk6IGEsXG4gICAgICAgIHllYXI6IGFbMF0sXG4gICAgICAgIG1vbnRoOiBhWzFdLFxuICAgICAgICBkYXk6IGFbMl0sXG4gICAgICAgIGhvdXI6IGFbM10sXG4gICAgICAgIG1pbnV0ZTogYVs0XSxcbiAgICAgICAgc2Vjb25kOiBhWzVdLFxuICAgICAgICBtaWxsaXNlY29uZDogYVs2XSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyA9IGV4cGFuZFpvbmVkTWFya2VyKHN0YXJ0LCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKTtcbiAgICB2YXIgZW5kSW5mbyA9IGVuZCA/IGV4cGFuZFpvbmVkTWFya2VyKGVuZCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGU6IHN0YXJ0SW5mbyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mbyxcbiAgICAgICAgZW5kOiBlbmRJbmZvLFxuICAgICAgICB0aW1lWm9uZTogY29udGV4dC50aW1lWm9uZSxcbiAgICAgICAgbG9jYWxlQ29kZXM6IGNvbnRleHQubG9jYWxlLmNvZGVzLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIHx8IGNvbnRleHQuZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9O1xufVxuXG4vKlxuVE9ETzogZml4IHRoZSB0ZXJtaW5vbG9neSBvZiBcImZvcm1hdHRlclwiIHZzIFwiZm9ybWF0dGluZyBmdW5jXCJcbiovXG4vKlxuQXQgdGhlIHRpbWUgb2YgaW5zdGFudGlhdGlvbiwgdGhpcyBvYmplY3QgZG9lcyBub3Qga25vdyB3aGljaCBjbWQtZm9ybWF0dGluZyBzeXN0ZW0gaXQgd2lsbCB1c2UuXG5JdCByZWNlaXZlcyB0aGlzIGF0IHRoZSB0aW1lIG9mIGZvcm1hdHRpbmcsIGFzIGEgc2V0dGluZy5cbiovXG52YXIgQ21kRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENtZEZvcm1hdHRlcihjbWRTdHIpIHtcbiAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XG4gICAgfVxuICAgIENtZEZvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICBDbWRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ21kRm9ybWF0dGVyO1xufSgpKTtcblxudmFyIEZ1bmNGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVuY0Zvcm1hdHRlcihmdW5jKSB7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgfVxuICAgIEZ1bmNGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgRnVuY0Zvcm1hdHRlci5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jRm9ybWF0dGVyO1xufSgpKTtcblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbWRGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY0Zvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyBiYXNlIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLVxudmFyIEJBU0VfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHksXG4gICAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHksXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSxcbiAgICBidXR0b25JY29uczogaWRlbnRpdHksXG4gICAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcbiAgICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgc2xvdE1heFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNuYXBEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZm9vdGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJzOiBCb29sZWFuLFxuICAgIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIGRheUhlYWRlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgaW5pdGlhbFZpZXc6IFN0cmluZyxcbiAgICBhc3BlY3RSYXRpbzogTnVtYmVyLFxuICAgIHdlZWtlbmRzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogaWRlbnRpdHksXG4gICAgd2Vla051bWJlcnM6IEJvb2xlYW4sXG4gICAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZWRpdGFibGU6IEJvb2xlYW4sXG4gICAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHZpZXdEaWRNb3VudDogaWRlbnRpdHksXG4gICAgdmlld1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXG4gICAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yQ29udGVudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxuICAgIGxhenlGZXRjaGluZzogQm9vbGVhbixcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmU6IFN0cmluZyxcbiAgICBsb2NhbGVzOiBpZGVudGl0eSxcbiAgICBsb2NhbGU6IGlkZW50aXR5LFxuICAgIHRoZW1lU3lzdGVtOiBTdHJpbmcsXG4gICAgZHJhZ1JldmVydER1cmF0aW9uOiBOdW1iZXIsXG4gICAgZHJhZ1Njcm9sbDogQm9vbGVhbixcbiAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxuICAgIHVuc2VsZWN0QXV0bzogQm9vbGVhbixcbiAgICBkcm9wQWNjZXB0OiBpZGVudGl0eSxcbiAgICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXG4gICAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcbiAgICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXG4gICAgd2luZG93UmVzaXplRGVsYXk6IE51bWJlcixcbiAgICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgZXhwYW5kUm93czogQm9vbGVhbixcbiAgICBoZWlnaHQ6IGlkZW50aXR5LFxuICAgIGNvbnRlbnRIZWlnaHQ6IGlkZW50aXR5LFxuICAgIGRpcmVjdGlvbjogU3RyaW5nLFxuICAgIHdlZWtOdW1iZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxuICAgIGRpc3BsYXlFdmVudEVuZDogQm9vbGVhbixcbiAgICB3ZWVrVGV4dDogU3RyaW5nLFxuICAgIHdlZWtUZXh0TG9uZzogU3RyaW5nLFxuICAgIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXG4gICAgYnVzaW5lc3NIb3VyczogaWRlbnRpdHksXG4gICAgaW5pdGlhbERhdGU6IGlkZW50aXR5LFxuICAgIG5vdzogaWRlbnRpdHksXG4gICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHksXG4gICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSxcbiAgICB2aWV3SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICAgIGV2ZW50U291cmNlRmFpbHVyZTogaWRlbnRpdHksXG4gICAgZXZlbnRTb3VyY2VTdWNjZXNzOiBpZGVudGl0eSxcbiAgICBldmVudERpc3BsYXk6IFN0cmluZyxcbiAgICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZXZlbnREdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBldmVudEFsbG93OiBpZGVudGl0eSxcbiAgICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICBldmVudFRleHRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29udGVudDogaWRlbnRpdHksXG4gICAgZXZlbnREaWRNb3VudDogaWRlbnRpdHksXG4gICAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgc2VsZWN0QWxsb3c6IGlkZW50aXR5LFxuICAgIGRyb3BwYWJsZTogQm9vbGVhbixcbiAgICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxuICAgIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFuZUNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSxcbiAgICBkYXlNYXhFdmVudFJvd3M6IGlkZW50aXR5LFxuICAgIGRheU1pbldpZHRoOiBOdW1iZXIsXG4gICAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGFsbERheVRleHQ6IFN0cmluZyxcbiAgICBhbGxEYXlDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSxcbiAgICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHksXG4gICAgYWxsRGF5V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RNaW5XaWR0aDogTnVtYmVyLFxuICAgIG5hdkxpbmtzOiBCb29sZWFuLFxuICAgIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIHJlcmVuZGVyRGVsYXk6IE51bWJlcixcbiAgICBtb3JlTGlua1RleHQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rSGludDogaWRlbnRpdHksXG4gICAgc2VsZWN0TWluRGlzdGFuY2U6IE51bWJlcixcbiAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICAgIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgZXZlbnRMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIHNlbGVjdE1pcnJvcjogQm9vbGVhbixcbiAgICBldmVudE1heFN0YWNrOiBOdW1iZXIsXG4gICAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcbiAgICBldmVudE1pbldpZHRoOiBOdW1iZXIsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxuICAgIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgZmlyc3REYXk6IE51bWJlcixcbiAgICBkYXlDb3VudDogTnVtYmVyLFxuICAgIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcbiAgICBoaWRkZW5EYXlzOiBpZGVudGl0eSxcbiAgICBtb250aE1vZGU6IEJvb2xlYW4sXG4gICAgZml4ZWRXZWVrQ291bnQ6IEJvb2xlYW4sXG4gICAgdmFsaWRSYW5nZTogaWRlbnRpdHksXG4gICAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSxcbiAgICB0aXRsZUZvcm1hdDogaWRlbnRpdHksXG4gICAgZXZlbnRJbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICAvLyBvbmx5IHVzZWQgYnkgbGlzdC12aWV3LCBidXQgbGFuZ3VhZ2VzIGRlZmluZSB0aGUgdmFsdWUsIHNvIHdlIG5lZWQgaXQgaW4gYmFzZSBvcHRpb25zXG4gICAgbm9FdmVudHNUZXh0OiBTdHJpbmcsXG4gICAgdmlld0hpbnQ6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtIaW50OiBpZGVudGl0eSxcbiAgICBjbG9zZUhpbnQ6IFN0cmluZyxcbiAgICB0aW1lSGludDogU3RyaW5nLFxuICAgIGV2ZW50SGludDogU3RyaW5nLFxuICAgIG1vcmVMaW5rQ2xpY2s6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbn07XG4vLyBkbyBOT1QgZ2l2ZSBhIHR5cGUgaGVyZS4gbmVlZCBgdHlwZW9mIEJBU0VfT1BUSU9OX0RFRkFVTFRTYCB0byBnaXZlIHJlYWwgcmVzdWx0cy5cbi8vIHJhdyB2YWx1ZXMuXG52YXIgQkFTRV9PUFRJT05fREVGQVVMVFMgPSB7XG4gICAgZXZlbnREaXNwbGF5OiAnYXV0bycsXG4gICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiAnIC0gJyxcbiAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJyxcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDE6MDA6MDAnLFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheTogMSB9LFxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXG4gICAgbmV4dERheVRocmVzaG9sZDogJzAwOjAwOjAwJyxcbiAgICBkYXlIZWFkZXJzOiB0cnVlLFxuICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICBhc3BlY3RSYXRpbzogMS4zNSxcbiAgICBoZWFkZXJUb29sYmFyOiB7XG4gICAgICAgIHN0YXJ0OiAndGl0bGUnLFxuICAgICAgICBjZW50ZXI6ICcnLFxuICAgICAgICBlbmQ6ICd0b2RheSBwcmV2LG5leHQnLFxuICAgIH0sXG4gICAgd2Vla2VuZHM6IHRydWUsXG4gICAgd2Vla051bWJlcnM6IGZhbHNlLFxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcbiAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgbm93SW5kaWNhdG9yOiBmYWxzZSxcbiAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxuICAgIHNjcm9sbFRpbWVSZXNldDogdHJ1ZSxcbiAgICBzbG90TWluVGltZTogJzAwOjAwOjAwJyxcbiAgICBzbG90TWF4VGltZTogJzI0OjAwOjAwJyxcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxuICAgIGxhenlGZXRjaGluZzogdHJ1ZSxcbiAgICBzdGFydFBhcmFtOiAnc3RhcnQnLFxuICAgIGVuZFBhcmFtOiAnZW5kJyxcbiAgICB0aW1lWm9uZVBhcmFtOiAndGltZVpvbmUnLFxuICAgIHRpbWVab25lOiAnbG9jYWwnLFxuICAgIGxvY2FsZXM6IFtdLFxuICAgIGxvY2FsZTogJycsXG4gICAgdGhlbWVTeXN0ZW06ICdzdGFuZGFyZCcsXG4gICAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXG4gICAgZHJhZ1Njcm9sbDogdHJ1ZSxcbiAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBmYWxzZSxcbiAgICB1bnNlbGVjdEF1dG86IHRydWUsXG4gICAgZHJvcEFjY2VwdDogJyonLFxuICAgIGV2ZW50T3JkZXI6ICdzdGFydCwtZHVyYXRpb24sYWxsRGF5LHRpdGxlJyxcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcbiAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXG4gICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcbiAgICBsb25nUHJlc3NEZWxheTogMTAwMCxcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogNSxcbiAgICBleHBhbmRSb3dzOiBmYWxzZSxcbiAgICBuYXZMaW5rczogZmFsc2UsXG4gICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgZXZlbnRNaW5IZWlnaHQ6IDE1LFxuICAgIGV2ZW50TWluV2lkdGg6IDMwLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IDMwLFxufTtcbi8vIGNhbGVuZGFyIGxpc3RlbmVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gICAgZGF0ZXNTZXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50c1NldDogaWRlbnRpdHksXG4gICAgZXZlbnRBZGQ6IGlkZW50aXR5LFxuICAgIGV2ZW50Q2hhbmdlOiBpZGVudGl0eSxcbiAgICBldmVudFJlbW92ZTogaWRlbnRpdHksXG4gICAgd2luZG93UmVzaXplOiBpZGVudGl0eSxcbiAgICBldmVudENsaWNrOiBpZGVudGl0eSxcbiAgICBldmVudE1vdXNlRW50ZXI6IGlkZW50aXR5LFxuICAgIGV2ZW50TW91c2VMZWF2ZTogaWRlbnRpdHksXG4gICAgc2VsZWN0OiBpZGVudGl0eSxcbiAgICB1bnNlbGVjdDogaWRlbnRpdHksXG4gICAgbG9hZGluZzogaWRlbnRpdHksXG4gICAgLy8gaW50ZXJuYWxcbiAgICBfdW5tb3VudDogaWRlbnRpdHksXG4gICAgX2JlZm9yZXByaW50OiBpZGVudGl0eSxcbiAgICBfYWZ0ZXJwcmludDogaWRlbnRpdHksXG4gICAgX25vRXZlbnREcm9wOiBpZGVudGl0eSxcbiAgICBfbm9FdmVudFJlc2l6ZTogaWRlbnRpdHksXG4gICAgX3Jlc2l6ZTogaWRlbnRpdHksXG4gICAgX3Njcm9sbFJlcXVlc3Q6IGlkZW50aXR5LFxufTtcbi8vIGNhbGVuZGFyLXNwZWNpZmljIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYnV0dG9uVGV4dDogaWRlbnRpdHksXG4gICAgYnV0dG9uSGludHM6IGlkZW50aXR5LFxuICAgIHZpZXdzOiBpZGVudGl0eSxcbiAgICBwbHVnaW5zOiBpZGVudGl0eSxcbiAgICBpbml0aWFsRXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlczogaWRlbnRpdHksXG59O1xudmFyIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTID0ge1xuICAgIGhlYWRlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZm9vdGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25UZXh0OiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkhpbnRzOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvbkljb25zOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGRhdGVJbmNyZW1lbnQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG59O1xuZnVuY3Rpb24gaXNNYXliZU9iamVjdHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiKSB7IC8vIGJvdGggbm9uLW51bGwgb2JqZWN0c1xuICAgICAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYSA9PT0gYjtcbn1cbi8vIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVklFV19PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNvbXBvbmVudDogaWRlbnRpdHksXG4gICAgYnV0dG9uVGV4dDogU3RyaW5nLFxuICAgIGJ1dHRvblRleHRLZXk6IFN0cmluZyxcbiAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSxcbiAgICB1c2VzTWluTWF4VGltZTogQm9vbGVhbixcbiAgICBjbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBjb250ZW50OiBpZGVudGl0eSxcbiAgICBkaWRNb3VudDogaWRlbnRpdHksXG4gICAgd2lsbFVubW91bnQ6IGlkZW50aXR5LFxufTtcbi8vIHV0aWwgZnVuY3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpO1xufVxuZnVuY3Rpb24gcmVmaW5lUHJvcHMoaW5wdXQsIHJlZmluZXJzKSB7XG4gICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiByZWZpbmVycykge1xuICAgICAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XG4gICAgICAgICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmaW5lZDogcmVmaW5lZCwgZXh0cmE6IGV4dHJhIH07XG59XG5mdW5jdGlvbiBpZGVudGl0eShyYXcpIHtcbiAgICByZXR1cm4gcmF3O1xufVxuXG5mdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIHZhciBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgdmFyIGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50ID0gcmF3RXZlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMpO1xuICAgICAgICBpZiAodHVwbGUpIHtcbiAgICAgICAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKSB7XG4gICAgaWYgKGV2ZW50U3RvcmUgPT09IHZvaWQgMCkgeyBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IH1cbiAgICBldmVudFN0b3JlLmRlZnNbdHVwbGUuZGVmLmRlZklkXSA9IHR1cGxlLmRlZjtcbiAgICBpZiAodHVwbGUuaW5zdGFuY2UpIHtcbiAgICAgICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG4vLyByZXRyaWV2ZXMgZXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBncm91cElkIGFzIHRoZSBpbnN0YW5jZSBzcGVjaWZpZWQgYnkgYGluc3RhbmNlSWRgXG4vLyBvciB0aGV5IGFyZSB0aGUgc2FtZSBhcyB0aGUgaW5zdGFuY2UuXG4vLyB3aHkgbWlnaHQgaW5zdGFuY2VJZCBub3QgYmUgaW4gdGhlIHN0b3JlPyBhbiBldmVudCBmcm9tIGFub3RoZXIgY2FsZW5kYXI/XG5mdW5jdGlvbiBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlLCBpbnN0YW5jZUlkKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWZfMSA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICB2YXIgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAobG9va0RlZikgeyByZXR1cm4gaXNFdmVudERlZnNHcm91cGVkKGRlZl8xLCBsb29rRGVmKTsgfSk7XG4gICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWZfMS5kZWZJZF0gPSBkZWZfMTtcbiAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xufVxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH07XG59XG5mdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxuICAgICAgICBpbnN0YW5jZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzdG9yZTAuaW5zdGFuY2VzKSwgc3RvcmUxLmluc3RhbmNlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZpbHRlckZ1bmMpIHtcbiAgICB2YXIgZGVmcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5kZWZzLCBmaWx0ZXJGdW5jKTtcbiAgICB2YXIgaW5zdGFuY2VzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAoZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gc3RpbGwgZXhpc3RzP1xuICAgICk7IH0pO1xuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXIsIHN1Yikge1xuICAgIHZhciBkZWZzID0gbWFzdGVyLmRlZnMsIGluc3RhbmNlcyA9IG1hc3Rlci5pbnN0YW5jZXM7XG4gICAgdmFyIGZpbHRlcmVkRGVmcyA9IHt9O1xuICAgIHZhciBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xuICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcbiAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb25zdHJhaW50KGlucHV0LCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhpbnB1dCwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBwYXJzZUV2ZW50cyhbaW5wdXRdLCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lcyhyYXcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmF3LnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cblxuLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcbi8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xuLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXG52YXIgRVZFTlRfVUlfUkVGSU5FUlMgPSB7XG4gICAgZGlzcGxheTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBjb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBvdmVybGFwOiBpZGVudGl0eSxcbiAgICBhbGxvdzogaWRlbnRpdHksXG4gICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICB0ZXh0Q29sb3I6IFN0cmluZyxcbn07XG52YXIgRU1QVFlfRVZFTlRfVUkgPSB7XG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IG51bGwsXG4gICAgY29uc3RyYWludHM6IFtdLFxuICAgIG92ZXJsYXA6IG51bGwsXG4gICAgYWxsb3dzOiBbXSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICB0ZXh0Q29sb3I6ICcnLFxuICAgIGNsYXNzTmFtZXM6IFtdLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCkge1xuICAgIHZhciBjb25zdHJhaW50ID0gbm9ybWFsaXplQ29uc3RyYWludChyZWZpbmVkLmNvbnN0cmFpbnQsIGNvbnRleHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IHJlZmluZWQuZGlzcGxheSB8fCBudWxsLFxuICAgICAgICBzdGFydEVkaXRhYmxlOiByZWZpbmVkLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnRFZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGNvbnN0cmFpbnQgIT0gbnVsbCA/IFtjb25zdHJhaW50XSA6IFtdLFxuICAgICAgICBvdmVybGFwOiByZWZpbmVkLm92ZXJsYXAgIT0gbnVsbCA/IHJlZmluZWQub3ZlcmxhcCA6IG51bGwsXG4gICAgICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmaW5lZC5iYWNrZ3JvdW5kQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHJlZmluZWQuYm9yZGVyQ29sb3IgfHwgcmVmaW5lZC5jb2xvciB8fCAnJyxcbiAgICAgICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICAgICAgY2xhc3NOYW1lczogKHJlZmluZWQuY2xhc3NOYW1lIHx8IFtdKS5jb25jYXQocmVmaW5lZC5jbGFzc05hbWVzIHx8IFtdKSwgLy8gam9pbiBzaW5ndWxhciBhbmQgcGx1cmFsXG4gICAgfTtcbn1cbi8vIFRPRE86IHByZXZlbnQgYWdhaW5zdCBwcm9ibGVtcyB3aXRoIDwyIGFyZ3MhXG5mdW5jdGlvbiBjb21iaW5lRXZlbnRVaXModWlzKSB7XG4gICAgcmV0dXJuIHVpcy5yZWR1Y2UoY29tYmluZVR3b0V2ZW50VWlzLCBFTVBUWV9FVkVOVF9VSSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTAsIGl0ZW0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogaXRlbTEuZGlzcGxheSAhPSBudWxsID8gaXRlbTEuZGlzcGxheSA6IGl0ZW0wLmRpc3BsYXksXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5kdXJhdGlvbkVkaXRhYmxlIDogaXRlbTAuZHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludHM6IGl0ZW0wLmNvbnN0cmFpbnRzLmNvbmNhdChpdGVtMS5jb25zdHJhaW50cyksXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICAgICAgYWxsb3dzOiBpdGVtMC5hbGxvd3MuY29uY2F0KGl0ZW0xLmFsbG93cyksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXRlbTEuYmFja2dyb3VuZENvbG9yIHx8IGl0ZW0wLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgICAgICB0ZXh0Q29sb3I6IGl0ZW0xLnRleHRDb2xvciB8fCBpdGVtMC50ZXh0Q29sb3IsXG4gICAgICAgIGNsYXNzTmFtZXM6IGl0ZW0wLmNsYXNzTmFtZXMuY29uY2F0KGl0ZW0xLmNsYXNzTmFtZXMpLFxuICAgIH07XG59XG5cbnZhciBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuLFxufTtcbnZhciBFVkVOVF9EQVRFX1JFRklORVJTID0ge1xuICAgIHN0YXJ0OiBpZGVudGl0eSxcbiAgICBlbmQ6IGlkZW50aXR5LFxuICAgIGRhdGU6IGlkZW50aXR5LFxuICAgIGFsbERheTogQm9vbGVhbixcbn07XG52YXIgRVZFTlRfUkVGSU5FUlMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzKSB7XG4gICAgaWYgKHJlZmluZXJzID09PSB2b2lkIDApIHsgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7IH1cbiAgICB2YXIgX2EgPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgdmFyIGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dC5kYXRlRW52LCBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XG4gICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXG4gICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxuICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBudWxsIH07XG4gICAgfVxuICAgIHZhciBzaW5nbGVSZXMgPSBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSk7XG4gICAgaWYgKHNpbmdsZVJlcykge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpIHtcbiAgICBpZiAocmVmaW5lcnMgPT09IHZvaWQgMCkgeyByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KTsgfVxuICAgIHJldHVybiByZWZpbmVQcm9wcyhyYXcsIHJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzKTtcbn1cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZnVuY3Rpb24gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXG4gICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXG4gICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcbiAgICAgICAgZGVmSWQ6IGd1aWQoKSxcbiAgICAgICAgc291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgaGFzRW5kOiBoYXNFbmQsXG4gICAgICAgIGludGVyYWN0aXZlOiByZWZpbmVkLmludGVyYWN0aXZlLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZW1iZXJBZGRlciA9IF9hW19pXTtcbiAgICAgICAgdHNsaWIuX19hc3NpZ24oZGVmLCBtZW1iZXJBZGRlcihyZWZpbmVkKSk7XG4gICAgfVxuICAgIC8vIGhlbHAgb3V0IEV2ZW50QXBpIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gICAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgdmFyIGFsbERheSA9IHJlZmluZWQuYWxsRGF5O1xuICAgIHZhciBzdGFydE1ldGE7XG4gICAgdmFyIHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICB2YXIgaGFzRW5kID0gZmFsc2U7XG4gICAgdmFyIGVuZE1ldGE7XG4gICAgdmFyIGVuZE1hcmtlciA9IG51bGw7XG4gICAgdmFyIHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlO1xuICAgIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE1ldGEubWFya2VyO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZWZpbmVkLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZCk7XG4gICAgfVxuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoZW5kTWV0YSkge1xuICAgICAgICBlbmRNYXJrZXIgPSBlbmRNZXRhLm1hcmtlcjtcbiAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gc3RhcnRPZkRheShlbmRNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE1hcmtlcikge1xuICAgICAgICBoYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgaGFzRW5kID0gY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgZW5kTWFya2VyID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICBoYXNFbmQ6IGhhc0VuZCxcbiAgICAgICAgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0TWFya2VyLCBlbmQ6IGVuZE1hcmtlciB9LFxuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhID8gc3RhcnRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciByZXMgPSBudWxsO1xuICAgIGlmIChldmVudFNvdXJjZSkge1xuICAgICAgICByZXMgPSBldmVudFNvdXJjZS5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZSkge1xuICAgIHZhciBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMTtcbiAgICB2YXIgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgaWYgKG5leHREYXlUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBuZXh0RGF5VGhyZXNob2xkID0gY3JlYXRlRHVyYXRpb24oMCk7IH1cbiAgICB2YXIgc3RhcnREYXkgPSBudWxsO1xuICAgIHZhciBlbmREYXkgPSBudWxsO1xuICAgIGlmICh0aW1lZFJhbmdlLmVuZCkge1xuICAgICAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKTtcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZWRSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG59XG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMTtcbn1cbmZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGxhcmdlVW5pdCkge1xuICAgIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0LCBkYXRlRW52KSB7XG4gICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgZW5kID0gbnVsbDtcbiAgICBpZiAoaW5wdXQuc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5lbmQpIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuZW5kKTtcbiAgICB9XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyBTSURFLUVGRkVDVDogd2lsbCBtdXRhdGUgcmFuZ2VzLlxuLy8gV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgY29uc3RyYWludFJhbmdlKSB7XG4gICAgdmFyIGludmVydGVkUmFuZ2VzID0gW107XG4gICAgdmFyIHN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0ZVJhbmdlO1xuICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogZGF0ZVJhbmdlLnN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlUmFuZ2UuZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZVJhbmdlLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgIGlmIChzdGFydCA8IGNvbnN0cmFpbnRSYW5nZS5lbmQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0OiBzdGFydCwgZW5kOiBjb25zdHJhaW50UmFuZ2UuZW5kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW52ZXJ0ZWRSYW5nZXM7XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIHJhbmdlMC5zdGFydC52YWx1ZU9mKCkgLSByYW5nZTEuc3RhcnQudmFsdWVPZigpOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuZnVuY3Rpb24gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2UwLnN0YXJ0LCBlbmQgPSByYW5nZTAuZW5kO1xuICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XG4gICAgaWYgKHJhbmdlMS5zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2UxLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXcgRGF0ZShNYXRoLm1heChzdGFydC52YWx1ZU9mKCksIHJhbmdlMS5zdGFydC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmFuZ2UxLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlMS5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShNYXRoLm1pbihlbmQudmFsdWVPZigpLCByYW5nZTEuZW5kLnZhbHVlT2YoKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JhbmdlO1xufVxuZnVuY3Rpb24gcmFuZ2VzRXF1YWwocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuc3RhcnQudmFsdWVPZigpKSA9PT0gKHJhbmdlMS5zdGFydCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuc3RhcnQudmFsdWVPZigpKSAmJlxuICAgICAgICAocmFuZ2UwLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuZW5kLnZhbHVlT2YoKSkgPT09IChyYW5nZTEuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5lbmQudmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0ludGVyc2VjdChyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiAocmFuZ2UwLmVuZCA9PT0gbnVsbCB8fCByYW5nZTEuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UwLmVuZCA+IHJhbmdlMS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlMC5zdGFydCA9PT0gbnVsbCB8fCByYW5nZTEuZW5kID09PSBudWxsIHx8IHJhbmdlMC5zdGFydCA8IHJhbmdlMS5lbmQpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpIHtcbiAgICByZXR1cm4gKG91dGVyUmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydCA+PSBvdXRlclJhbmdlLnN0YXJ0KSkgJiZcbiAgICAgICAgKG91dGVyUmFuZ2UuZW5kID09PSBudWxsIHx8IChpbm5lclJhbmdlLmVuZCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZCA8PSBvdXRlclJhbmdlLmVuZCkpO1xufVxuZnVuY3Rpb24gcmFuZ2VDb250YWluc01hcmtlcihyYW5nZSwgZGF0ZSkge1xuICAgIHJldHVybiAocmFuZ2Uuc3RhcnQgPT09IG51bGwgfHwgZGF0ZSA+PSByYW5nZS5zdGFydCkgJiZcbiAgICAgICAgKHJhbmdlLmVuZCA9PT0gbnVsbCB8fCBkYXRlIDwgcmFuZ2UuZW5kKTtcbn1cbi8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cbi8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxuZnVuY3Rpb24gY29uc3RyYWluTWFya2VyVG9SYW5nZShkYXRlLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsICYmIGRhdGUgPCByYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCAmJiBkYXRlID49IHJhbmdlLmVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocmFuZ2UuZW5kLnZhbHVlT2YoKSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLypcblNwZWNpZnlpbmcgbmV4dERheVRocmVzaG9sZCBzaWduYWxzIHRoYXQgYWxsLWRheSByYW5nZXMgc2hvdWxkIGJlIHNsaWNlZC5cbiovXG5mdW5jdGlvbiBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBmcmFtaW5nUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICB2YXIgaW52ZXJzZUJnQnlHcm91cElkID0ge307XG4gICAgdmFyIGludmVyc2VCZ0J5RGVmSWQgPSB7fTtcbiAgICB2YXIgZGVmQnlHcm91cElkID0ge307XG4gICAgdmFyIGJnUmFuZ2VzID0gW107XG4gICAgdmFyIGZnUmFuZ2VzID0gW107XG4gICAgdmFyIGV2ZW50VWlzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gZGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgIHZhciBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgICAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICAgICAgICBvcmlnUmFuZ2U7XG4gICAgICAgIHZhciBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVpLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbm9ybWFsUmFuZ2UuZW5kICYmIG5vcm1hbFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZ3JvdXBJZCBpbiBpbnZlcnNlQmdCeUdyb3VwSWQpIHsgLy8gQlkgR1JPVVBcbiAgICAgICAgdmFyIHJhbmdlcyA9IGludmVyc2VCZ0J5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbnZlcnRlZFJhbmdlc18xID0gaW52ZXJ0ZWRSYW5nZXM7IF9pIDwgaW52ZXJ0ZWRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdO1xuICAgICAgICAgICAgdmFyIHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgIHVpOiB1aSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBkZWZJZCBpbiBpbnZlcnNlQmdCeURlZklkKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeURlZklkW2RlZklkXTtcbiAgICAgICAgdmFyIGludmVydGVkUmFuZ2VzID0gaW52ZXJ0UmFuZ2VzKHJhbmdlcywgZnJhbWluZ1JhbmdlKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBpbnZlcnRlZFJhbmdlc18yID0gaW52ZXJ0ZWRSYW5nZXM7IF9hIDwgaW52ZXJ0ZWRSYW5nZXNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlZFJhbmdlID0gaW52ZXJ0ZWRSYW5nZXNfMltfYV07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xufVxuZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xufVxuZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgIGVsLmZjU2VnID0gc2VnO1xufVxuZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICByZXR1cm4gZWwuZmNTZWcgfHxcbiAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICAgICAgbnVsbDtcbn1cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcyk7IH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xuICAgIHZhciB1aXMgPSBbXTtcbiAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XG4gICAgfVxuICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcbiAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xuICAgIHZhciBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcbiAgICBvYmpzLnNvcnQoZnVuY3Rpb24gKG9iajAsIG9iajEpIHsgcmV0dXJuIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKTsgfSk7XG4gICAgcmV0dXJuIG9ianMubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLl9zZWc7IH0pO1xufVxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIHZhciBldmVudERlZiA9IGV2ZW50UmFuZ2UuZGVmO1xuICAgIHZhciByYW5nZSA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UgPyBldmVudFJhbmdlLmluc3RhbmNlLnJhbmdlIDogZXZlbnRSYW5nZS5yYW5nZTtcbiAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCA/IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA6IDA7IC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBvcGVuLXJhbmdlIGV2ZW50c1xuICAgIHZhciBlbmQgPSByYW5nZS5lbmQgPyByYW5nZS5lbmQudmFsdWVPZigpIDogMDsgLy8gXCJcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50RGVmLmV4dGVuZGVkUHJvcHMpLCBldmVudERlZiksIHsgaWQ6IGV2ZW50RGVmLnB1YmxpY0lkLCBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLCBkdXJhdGlvbjogZW5kIC0gc3RhcnQsIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksIF9zZWc6IHNlZyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIHBsdWdpbkhvb2tzID0gY29udGV4dC5wbHVnaW5Ib29rcztcbiAgICB2YXIgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgdWkgPSBfYS51aTtcbiAgICB2YXIgdmFsID0gdWkuc3RhcnRFZGl0YWJsZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHRyYW5zZm9ybWVyc18xID0gdHJhbnNmb3JtZXJzOyBfaSA8IHRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcnNfMVtfaV07XG4gICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XG59XG5mdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcbnN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRpc3BsYXlFdmVudFRpbWUgPSBvcHRpb25zLmRpc3BsYXlFdmVudFRpbWUsIGRpc3BsYXlFdmVudEVuZCA9IG9wdGlvbnMuZGlzcGxheUV2ZW50RW5kO1xuICAgIHZhciBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcbiAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydDtcbiAgICB2YXIgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kO1xuICAgIHZhciBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xuICAgIHZhciBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbiAgICB2YXIgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKTtcbiAgICB2YXIgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKCk7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgJiYgIWV2ZW50RGVmLmFsbERheSAmJiAoaXNTdGFydERheSB8fCBpc0VuZERheSkpIHtcbiAgICAgICAgc2VnU3RhcnQgPSBpc1N0YXJ0RGF5ID8gd2hvbGVFdmVudFN0YXJ0IDogc2VnU3RhcnQ7XG4gICAgICAgIHNlZ0VuZCA9IGlzRW5kRGF5ID8gd2hvbGVFdmVudEVuZCA6IHNlZ0VuZDtcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCAmJiBldmVudERlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHNlZ1N0YXJ0LCBzZWdFbmQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgICAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSB7XG4gICAgdmFyIHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNQYXN0OiBzZWdSYW5nZS5lbmQgPCAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBldmVudFJhbmdlLmRlZi5kZWZJZCArIFwiOlwiICsgZXZlbnRSYW5nZS5yYW5nZS5zdGFydC50b0lTT1N0cmluZygpO1xuICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZTtcbiAgICB2YXIgdXJsID0gZGVmLnVybDtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJldHVybiB7IGhyZWY6IHVybCB9O1xuICAgIH1cbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlciwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZXZlbnRJbnRlcmFjdGl2ZSA9IG9wdGlvbnMuZXZlbnRJbnRlcmFjdGl2ZTtcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbnZhciBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIHZhciBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICB2YXIgcmFuZ2UgPSBzcGFuLnJhbmdlO1xuICAgIGlmICghcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmFuZ2UuZW5kKSB7XG4gICAgICAgIGlmIChkZWZhdWx0RHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UuZW5kID0gZGF0ZUVudi5hZGQocmFuZ2Uuc3RhcnQsIGRlZmF1bHREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xufVxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmZ1bmN0aW9uIHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudikge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpLCBzdGFuZGFyZFByb3BzID0gX2EucmVmaW5lZCwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICB2YXIgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGw7XG4gICAgdmFyIGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsO1xuICAgIHZhciBhbGxEYXkgPSBzdGFuZGFyZFByb3BzLmFsbERheTtcbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgYWxsRGF5ID0gKHN0YXJ0TWV0YSAmJiBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheTogYWxsRGF5IH0sIGV4dHJhKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNwYW5zRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHJhbmdlc0VxdWFsKHNwYW4wLnJhbmdlLCBzcGFuMS5yYW5nZSkgJiZcbiAgICAgICAgc3BhbjAuYWxsRGF5ID09PSBzcGFuMS5hbGxEYXkgJiZcbiAgICAgICAgaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpO1xufVxuLy8gdGhlIE5PTi1EQVRFLVJFTEFURUQgcHJvcHNcbmZ1bmN0aW9uIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjEpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmFuZ2UnICYmIHByb3BOYW1lICE9PSAnYWxsRGF5Jykge1xuICAgICAgICAgICAgaWYgKHNwYW4wW3Byb3BOYW1lXSAhPT0gc3BhbjFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFyZSB0aGVyZSBhbnkgcHJvcHMgdGhhdCBzcGFuMCBoYXMgdGhhdCBzcGFuMSBET0VTTidUIGhhdmU/XG4gICAgLy8gYm90aCBoYXZlIHJhbmdlL2FsbERheSwgc28gbm8gbmVlZCB0byBzcGVjaWFsLWNhc2UuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3BhbjApIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gc3BhbjEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KSxcbiAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWU6IG9taXRUaW1lIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0gcmVmaW5lRXZlbnREZWYoeyBlZGl0YWJsZTogZmFsc2UgfSwgY29udGV4dCk7XG4gICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYocmVzLnJlZmluZWQsIHJlcy5leHRyYSwgJycsIC8vIHNvdXJjZUlkXG4gICAgZGF0ZVNwYW4uYWxsRGF5LCB0cnVlLCAvLyBoYXNFbmRcbiAgICBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcbiAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXG4gICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNFbmQ6IHRydWUsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignc2VsZWN0JywgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzZWxlY3Rpb24sIGNvbnRleHQpKSwgeyBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KSk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCd1bnNlbGVjdCcsIHtcbiAgICAgICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZGF0ZVNwYW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU3BhblRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIHRzbGliLl9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgdHNsaWIuX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVNwYW5BcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbi8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cbi8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXG5mdW5jdGlvbiBnZXREZWZhdWx0RXZlbnRFbmQoYWxsRGF5LCBtYXJrZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZW5kID0gbWFya2VyO1xuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpO1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgdmFyIGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgdmFyIGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXG4gICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICB9XG4gICAgdmFyIGNvcHkgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50RGVmLnVpKSwgc3RhbmRhcmRQcm9wcy51aSkgfSk7XG4gICAgaWYgKG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgY29weS5leHRlbmRlZFByb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvcHkuZXh0ZW5kZWRQcm9wcyksIG11dGF0aW9uLmV4dGVuZGVkUHJvcHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBhcHBsaWVyID0gX2FbX2ldO1xuICAgICAgICBhcHBsaWVyKGNvcHksIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG4gICAgICAgIGNvcHkuaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UsIGV2ZW50RGVmLCAvLyBtdXN0IGZpcnN0IGJlIG1vZGlmaWVkIGJ5IGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmXG5ldmVudENvbmZpZywgbXV0YXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudjtcbiAgICB2YXIgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xuICAgIHZhciBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xuICAgIHZhciBjb3B5ID0gdHNsaWIuX19hc3NpZ24oe30sIGV2ZW50SW5zdGFuY2UpO1xuICAgIGlmIChmb3JjZUFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShjb3B5LnJhbmdlKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmRhdGVzRGVsdGEgJiYgZXZlbnRDb25maWcuc3RhcnRFZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5zdGFydERlbHRhKSxcbiAgICAgICAgICAgIGVuZDogY29weS5yYW5nZS5lbmQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5lbmREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNsZWFyRW5kKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgICAvLyBiZXR0ZXIgdXRpbCBmb3IgdGhpcz9cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRPZkRheShjb3B5LnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogc3RhcnRPZkRheShjb3B5LnJhbmdlLmVuZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICAgIGlmIChjb3B5LnJhbmdlLmVuZCA8IGNvcHkucmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIG5vIHB1YmxpYyB0eXBlcyB5ZXQuIHdoZW4gdGhlcmUgYXJlLCBleHBvcnQgZnJvbTpcbi8vIGltcG9ydCB7fSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG52YXIgVmlld0FwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBnZXRDdXJyZW50RGF0YTtcbiAgICAgICAgdGhpcy5kYXRlRW52ID0gZGF0ZUVudjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImNhbGVuZGFyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmNhbGVuZGFyQXBpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJhY3RpdmVFbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImN1cnJlbnRTdGFydFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiY3VycmVudEVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld0FwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5vcHRpb25zW25hbWVdOyAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdBcGk7XG59KCkpO1xuXG52YXIgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBmb3JtYXQ6IFN0cmluZyxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgLy8gZm9yIGFueSBuZXR3b3JrLXJlbGF0ZWQgc291cmNlc1xuICAgIHN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGZhaWx1cmU6IGlkZW50aXR5LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjb250ZXh0LCByZWZpbmVycykge1xuICAgIGlmIChyZWZpbmVycyA9PT0gdm9pZCAwKSB7IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpOyB9XG4gICAgdmFyIHJhd09iajtcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmF3T2JqID0geyB1cmw6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdvYmplY3QnICYmIHJhdykgeyAvLyBub3QgbnVsbFxuICAgICAgICByYXdPYmogPSByYXc7XG4gICAgfVxuICAgIGlmIChyYXdPYmopIHtcbiAgICAgICAgdmFyIF9hID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB2YXIgbWV0YVJlcyA9IGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWV0YVJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgaXNGZXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGF0ZXN0RmV0Y2hJZDogJycsXG4gICAgICAgICAgICAgICAgZmV0Y2hSYW5nZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWxsRGF5OiByZWZpbmVkLmRlZmF1bHRBbGxEYXksXG4gICAgICAgICAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiByZWZpbmVkLmV2ZW50RGF0YVRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZWZpbmVkLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVmaW5lZC5mYWlsdXJlLFxuICAgICAgICAgICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBndWlkKCksXG4gICAgICAgICAgICAgICAgc291cmNlRGVmSWQ6IG1ldGFSZXMuc291cmNlRGVmSWQsXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YVJlcy5tZXRhLFxuICAgICAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IGV4dHJhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VSZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlTWV0YShyYXcsIGNvbnRleHQpIHtcbiAgICB2YXIgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIGZvciAodmFyIGkgPSBkZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7IC8vIGxhdGVyLWFkZGVkIHBsdWdpbnMgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2ldO1xuICAgICAgICB2YXIgbWV0YSA9IGRlZi5wYXJzZU1ldGEocmF3KTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNvdXJjZURlZklkOiBpLCBtZXRhOiBtZXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zLCBkYXRlRW52KSB7XG4gICAgdmFyIGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlO1xuICAgIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxuICAgIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXG59XG5mdW5jdGlvbiBnZXROb3cobm93SW5wdXQsIGRhdGVFbnYpIHtcbiAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKTtcbiAgICB9XG4gICAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dCk7XG59XG5cbnZhciBDYWxlbmRhckFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYWxlbmRhckFwaSgpIHtcbiAgICB9XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FsZW5kYXJBcGkucHJvdG90eXBlLCBcInZpZXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3QXBpOyB9IC8vIGZvciBwdWJsaWMgQVBJXG4gICAgICAgICxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5iYXRjaFJlbmRlcmluZyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpO1xuICAgIH07XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRBdmFpbGFibGVMb2NhbGVDb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5hdmFpbGFibGVSYXdMb2NhbGVzKTtcbiAgICB9O1xuICAgIC8vIFRyaWdnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXI7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YU1hbmFnZXIuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub24oaGFuZGxlck5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsaXN0ZW5lciBuYW1lICdcIiArIGhhbmRsZXJOYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8vIG5vdCBtZWFudCBmb3IgcHVibGljIHVzZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGhhbmRsZXJOYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlcikudHJpZ2dlci5hcHBseShfYSwgdHNsaWIuX19zcHJlYWRBcnJheShbaGFuZGxlck5hbWVdLCBhcmdzKSk7XG4gICAgfTtcbiAgICAvLyBWaWV3XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZGF0ZU9yUmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5iYXRjaFJlbmRlcmluZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPclJhbmdlLnN0YXJ0ICYmIGRhdGVPclJhbmdlLmVuZCkgeyAvLyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlOiB2aWV3VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6ICd2aXNpYmxlUmFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IGRhdGVPclJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlRW52ID0gX3RoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24gKGRhdGVNYXJrZXIsIHZpZXdUeXBlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cbiAgICAgICAgc3BlYyA9IHN0YXRlLnZpZXdTcGVjc1t2aWV3VHlwZV0gfHwgdGhpcy5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLCB2aWV3U3BlY3MgPSBfYS52aWV3U3BlY3MsIHRvb2xiYXJDb25maWcgPSBfYS50b29sYmFyQ29uZmlnO1xuICAgICAgICB2YXIgdmlld1R5cGVzID0gW10uY29uY2F0KHRvb2xiYXJDb25maWcuaGVhZGVyID8gdG9vbGJhckNvbmZpZy5oZWFkZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdLCB0b29sYmFyQ29uZmlnLmZvb3RlciA/IHRvb2xiYXJDb25maWcuZm9vdGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgc3BlYztcbiAgICAgICAgZm9yICh2YXIgdmlld1R5cGUgaW4gdmlld1NwZWNzKSB7XG4gICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dO1xuICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIEN1cnJlbnQgRGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnTkVYVCcgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucHJldlllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmFkZFllYXJzKHN0YXRlLmN1cnJlbnREYXRlLCAtMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogZ2V0Tm93KHN0YXRlLmNhbGVuZGFyT3B0aW9ucy5ub3csIHN0YXRlLmRhdGVFbnYpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nb3RvRGF0ZSA9IGZ1bmN0aW9uICh6b25lZERhdGVJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5jcmVhdGVNYXJrZXIoem9uZWREYXRlSW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmb3IgZXh0ZXJuYWwgQVBJXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICB9O1xuICAgIC8vIERhdGUgRm9ybWF0dGluZyBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmZvcm1hdERhdGUgPSBmdW5jdGlvbiAoZCwgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xuICAgIH07XG4gICAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChkMCwgZDEsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKGQsIG9taXRUaW1lKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVFbnY7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZTogb21pdFRpbWUgfSk7XG4gICAgfTtcbiAgICAvLyBEYXRlIFNlbGVjdGlvbiAvIEV2ZW50IFNlbGVjdGlvbiAvIERheUNsaWNrXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gICAgLy8gTk9URTogYXJncyB3ZXJlIGNoYW5nZWQgZnJvbSB2M1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0ZU9yT2JqLCBlbmREYXRlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JbnB1dDtcbiAgICAgICAgaWYgKGVuZERhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGRhdGVPck9iai5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JbnB1dCA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZU9yT2JqLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gcGFyc2VEYXRlU3BhbihzZWxlY3Rpb25JbnB1dCwgc3RhdGUuZGF0ZUVudiwgY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikgeyAvLyB0aHJvdyBwYXJzZSBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogc2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBudWxsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHB1YmxpYyBtZXRob2RcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHVibGljIEV2ZW50cyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50QXBpKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZXZlbnRJbnB1dC5fZGVmO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRJbnB1dC5faW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghY3VycmVudERhdGEuZXZlbnRTdG9yZS5kZWZzW2RlZi5kZWZJZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFR1cGxlVG9TdG9yZSh7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfSksIC8vIFRPRE86IGJldHRlciB1dGlsIGZvciB0d28gYXJncz9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChldmVudElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudElucHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VJbnB1dCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlSW5wdXQpIHsgLy8gdHJ1ZS4gcGFydCBvZiB0aGUgZmlyc3QgZXZlbnQgc291cmNlXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBoYXNoVmFsdWVzVG9BcnJheShzdGF0ZS5ldmVudFNvdXJjZXMpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZUlucHV0ICE9IG51bGwpIHsgLy8gYW4gSUQuIGFjY2VwdHMgYSBudW1iZXIgdG9vXG4gICAgICAgICAgICB2YXIgc291cmNlQXBpID0gdGhpcy5nZXRFdmVudFNvdXJjZUJ5SWQoc291cmNlSW5wdXQpOyAvLyBUT0RPOiB1c2UgYW4gaW50ZXJuYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICghc291cmNlQXBpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXFxcIlwiICsgc291cmNlSW5wdXQgKyBcIlxcXCJcIik7IC8vIFRPRE86IHRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoc3RhdGUsIHR1cGxlLmRlZiwgdHVwbGUuZGVmLnJlY3VycmluZ0RlZiA/IG51bGwgOiB0dXBsZS5pbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudEFkZChuZXdFdmVudEFwaSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRBcGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudHJpZ2dlckV2ZW50QWRkID0gZnVuY3Rpb24gKGV2ZW50QXBpKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCB7XG4gICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBvcHRpbWl6ZVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRFdmVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgX2EgPSBzdGF0ZS5ldmVudFN0b3JlLCBkZWZzID0gX2EuZGVmcywgaW5zdGFuY2VzID0gX2EuaW5zdGFuY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGVmSWQgPT09IGRlZi5kZWZJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEFwaShzdGF0ZSwgZGVmLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRTJyB9KTtcbiAgICB9O1xuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB2YXIgc291cmNlSGFzaCA9IHN0YXRlLmV2ZW50U291cmNlcztcbiAgICAgICAgdmFyIHNvdXJjZUFwaXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICAgICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgIGlkID0gU3RyaW5nKGlkKTtcbiAgICAgICAgZm9yICh2YXIgc291cmNlSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUhhc2hbc291cmNlSWRdLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5hZGRFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbnB1dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlQXBpKSB7XG4gICAgICAgICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgICAgICAgIGlmICghc3RhdGUuZXZlbnRTb3VyY2VzW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHNvdXJjZUlucHV0LCBzdGF0ZSk7XG4gICAgICAgIGlmIChldmVudFNvdXJjZSkgeyAvLyBUT0RPOiBlcnJvciBvdGhlcndpc2U/XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogW2V2ZW50U291cmNlXSB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIGV2ZW50U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLCBpc1JlZmV0Y2g6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvLyBTY3JvbGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zY3JvbGxUb1RpbWUgPSBmdW5jdGlvbiAodGltZUlucHV0KSB7XG4gICAgICAgIHZhciB0aW1lID0gY3JlYXRlRHVyYXRpb24odGltZUlucHV0KTtcbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX3Njcm9sbFJlcXVlc3QnLCB7IHRpbWU6IHRpbWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckFwaTtcbn0oKSk7XG5cbnZhciBFdmVudEFwaSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcbiAgICBmdW5jdGlvbiBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgLypcbiAgICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICAgKi9cbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0UHJvcCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YXIgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpID0gKF9iID0ge30sIF9iW25hbWVdID0gdmFsLCBfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyB1aTogdWkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHNldCBwcm9wICdcIiArIG5hbWUgKyBcIicuIFVzZSBzZXRFeHRlbmRlZFByb3AgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFeHRlbmRlZFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogKF9hID0ge30sIF9hW25hbWVdID0gdmFsLCBfYSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldEVuZCA9IGZ1bmN0aW9uIChlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiB7IGhhc0VuZDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldERhdGVzID0gZnVuY3Rpb24gKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xuICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogc3RhcnREZWx0YSwgZW5kRGVsdGE6IGVuZERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBtZWFucyBcImNsZWFyIHRoZSBlbmRcIlxuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tb3ZlRW5kID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZURhdGVzID0gZnVuY3Rpb24gKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogZGVsdGEgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRBbGxEYXkgPSBmdW5jdGlvbiAoYWxsRGF5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IGFsbERheSB9O1xuICAgICAgICB2YXIgbWFpbnRhaW5EdXJhdGlvbiA9IG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgaWYgKG1haW50YWluRHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWFpbnRhaW5EdXJhdGlvbiA9IHRoaXMuX2NvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gbWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZm9ybWF0SW5wdXQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdElucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5oYXNFbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5yYW5nZS5lbmQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmVfMSA9IGNvbnRleHRfMS5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmU7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhldmVudFN0b3JlXzEsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50Q29uZmlnQmFzZSA9IHtcbiAgICAgICAgICAgICAgICAnJzoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0XzEpO1xuICAgICAgICAgICAgdmFyIG9sZEV2ZW50ID0gbmV3IEV2ZW50QXBpKGNvbnRleHRfMSwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XG4gICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywge1xuICAgICAgICAgICAgICAgIG9sZEV2ZW50OiBvbGRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgY29udGV4dF8xLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmVfMSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIHZhciBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpO1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gdGhpcy5fZGVmLnNvdXJjZUlkO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNvdXJjZUFwaSh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImVuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydFN0clwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZW5kU3RyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBUeXBlU2NyaXB0LWNvbXBhdGlibGUgd2F5IHRvIGRvIHRoaXMgYXQgc2NhbGVcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYucHVibGljSWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImdyb3VwSWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5ncm91cElkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxEYXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5hbGxEYXk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudGl0bGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVybDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZGlzcGxheVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmRpc3BsYXkgfHwgJ2F1dG8nOyB9IC8vIGJhZC4ganVzdCBub3JtYWxpemUgdGhlIHR5cGUgZWFybGllclxuICAgICAgICAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInN0YXJ0RWRpdGFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJkdXJhdGlvbkVkaXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY29uc3RyYWludFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcIm92ZXJsYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJhbGxvd1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImJvcmRlckNvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XG4gICAgICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImV4dGVuZGVkUHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnRvUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSB7fTsgfVxuICAgICAgICB2YXIgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICB2YXIgdWkgPSBkZWYudWk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXJ0U3RyID0gX2Euc3RhcnRTdHIsIGVuZFN0ciA9IF9hLmVuZFN0cjtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBpZiAoZGVmLnRpdGxlKSB7XG4gICAgICAgICAgICByZXMudGl0bGUgPSBkZWYudGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0U3RyKSB7XG4gICAgICAgICAgICByZXMuc3RhcnQgPSBzdGFydFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kU3RyKSB7XG4gICAgICAgICAgICByZXMuZW5kID0gZW5kU3RyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucHVibGljSWQpIHtcbiAgICAgICAgICAgIHJlcy5pZCA9IGRlZi5wdWJsaWNJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgIHJlcy5ncm91cElkID0gZGVmLmdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51cmwpIHtcbiAgICAgICAgICAgIHJlcy51cmwgPSBkZWYudXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5kaXNwbGF5ICYmIHVpLmRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmVzLmRpc3BsYXkgPSB1aS5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgcmVjdXJyaW5nLWV2ZW50IHByb3BlcnRpZXM/Pz9cbiAgICAgICAgLy8gVE9ETzogaW5jbHVkZSBzdGFydEVkaXRhYmxlL2R1cmF0aW9uRWRpdGFibGUvY29uc3RyYWludC9vdmVybGFwL2FsbG93XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUNvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgPT09IHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICByZXMuY29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodWkuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmVzLmJhY2tncm91bmRDb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5ib3JkZXJDb2xvciA9IHVpLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aS50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIHJlcy50ZXh0Q29sb3IgPSB1aS50ZXh0Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZi5leHRlbmRlZFByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUV4dGVuZGVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUGxhaW5PYmplY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEFwaTtcbn0oKSk7XG5mdW5jdGlvbiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBkZWYgPSBldmVudEFwaS5fZGVmO1xuICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiAoX2EgPSB7fSwgX2FbZGVmLmRlZklkXSA9IGRlZiwgX2EpLFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICAgICAgICA/IChfYiA9IHt9LCBfYltpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlLCBfYikgOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBldmVudEFwaXMgPSBbXTtcbiAgICB2YXIgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xuICAgIGZvciAodmFyIGlkIGluIGluc3RhbmNlcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRBcGlzO1xufVxuXG52YXIgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xuZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcbn1cbnZhciBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSgpIHtcbiAgICB9XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlclllYXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmdldE1hcmtlck1vbnRoID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9O1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJEYXkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuYXJyYXlUb01hcmtlciA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUubWFya2VyVG9BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVUb1V0Y0FycmF5KG1hcmtlcik7XG4gICAgfTtcbiAgICByZXR1cm4gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW07XG59KCkpO1xucmVnaXN0ZXJDYWxlbmRhclN5c3RlbSgnZ3JlZ29yeScsIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtKTtcblxudmFyIElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIHZhciBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoXCIwLlwiICsgbVsxMl0pICogMTAwMCA6IDApKTtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IChtWzE1XSA9PT0gJy0nID8gLTEgOiAxKSAqIChOdW1iZXIobVsxNl0gfHwgMCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAgICAgICAgICAgIGlzVGltZVVuc3BlY2lmaWVkOiAhbVs2XSxcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogdGltZVpvbmVPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgRGF0ZUVudiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXRlRW52KHNldHRpbmdzKSB7XG4gICAgICAgIHZhciB0aW1lWm9uZSA9IHRoaXMudGltZVpvbmUgPSBzZXR0aW5ncy50aW1lWm9uZTtcbiAgICAgICAgdmFyIGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJztcbiAgICAgICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5Db21wdXRlT2Zmc2V0ID0gQm9vbGVhbighaXNOYW1lZFRpbWVab25lIHx8IHRoaXMubmFtZWRUaW1lWm9uZUltcGwpO1xuICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtID0gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0oc2V0dGluZ3MuY2FsZW5kYXJTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZTtcbiAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG93O1xuICAgICAgICB0aGlzLndlZWtEb3kgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3k7XG4gICAgICAgIGlmIChzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSAxO1xuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla051bWJlckZ1bmMgPSBzZXR0aW5ncy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53ZWVrVGV4dCA9IHNldHRpbmdzLndlZWtUZXh0ICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dCA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0O1xuICAgICAgICB0aGlzLndlZWtUZXh0TG9uZyA9IChzZXR0aW5ncy53ZWVrVGV4dExvbmcgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0TG9uZyA6IHNldHRpbmdzLmxvY2FsZS5vcHRpb25zLndlZWtUZXh0TG9uZykgfHwgdGhpcy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdFNlcGFyYXRvciA9IHNldHRpbmdzLmRlZmF1bHRTZXBhcmF0b3I7XG4gICAgfVxuICAgIC8vIENyZWF0aW5nIC8gUGFyc2luZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuY3JlYXRlTWFya2VyTWV0YShpbnB1dCk7XG4gICAgICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0YS5tYXJrZXI7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVOb3dNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxuICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTWFya2VyTWV0YSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcGFyc2Uocyk7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtlciA9IHBhcnRzLm1hcmtlcjtcbiAgICAgICAgdmFyIGZvcmNlZFR6byA9IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIobWFya2VyLnZhbHVlT2YoKSAtIHBhcnRzLnRpbWVab25lT2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcmtlcjogbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6bzogZm9yY2VkVHpvIH07XG4gICAgfTtcbiAgICAvLyBBY2Nlc3NvcnNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRZZWFyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG1hcmtlcik7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5nZXRNb250aCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobWFya2VyKTtcbiAgICB9O1xuICAgIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gKz0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdICs9IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gKz0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gKz0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG1hcmtlciwgZHVyKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xuICAgICAgICBhWzFdIC09IGR1ci5tb250aHM7XG4gICAgICAgIGFbMl0gLT0gZHVyLmRheXM7XG4gICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmFkZFllYXJzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRNb250aHMgPSBmdW5jdGlvbiAobWFya2VyLCBuKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XG4gICAgICAgIGFbMV0gKz0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcbiAgICB9O1xuICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVZZWFycyA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIGNhbGVuZGFyU3lzdGVtID0gdGhpcy5jYWxlbmRhclN5c3RlbTtcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5kaWZmV2hvbGVNb250aHMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSkge1xuICAgICAgICAgICAgcmV0dXJuIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMCkpICtcbiAgICAgICAgICAgICAgICAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKSkgKiAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIFJhbmdlIC8gRHVyYXRpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS5ncmVhdGVzdFdob2xlVW5pdCA9IGZ1bmN0aW9uIChtMCwgbTEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XG4gICAgICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZkhvdXJzKG0wLCBtMSk7XG4gICAgICAgIGlmIChpc0ludChuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkgfTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNvdW50RHVyYXRpb25zQmV0d2VlbiA9IGZ1bmN0aW9uIChtMCwgbTEsIGQpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgICAgICB2YXIgZGlmZjtcbiAgICAgICAgaWYgKGQueWVhcnMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLm1vbnRocykge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaE1vbnRocyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5kYXlzKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKTtcbiAgICB9O1xuICAgIC8vIFN0YXJ0LU9mXG4gICAgLy8gdGhlc2UgRE9OJ1QgcmV0dXJuIHpvbmVkLWRhdGVzLiBvbmx5IFVUQyBzdGFydC1vZiBkYXRlc1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2YgPSBmdW5jdGlvbiAobSwgdW5pdCkge1xuICAgICAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZZZWFyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuc3RhcnRPZk1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZXZWVrID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICAgICAgbS5nZXRVVENEYXRlKCkgLSAoKG0uZ2V0VVRDRGF5KCkgLSB0aGlzLndlZWtEb3cgKyA3KSAlIDcpLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8vIFdlZWsgTnVtYmVyXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY29tcHV0ZVdlZWtOdW1iZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGRhdGVPcHRpb25zID09PSB2b2lkIDApIHsgZGF0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoe1xuICAgICAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgICB9LCB0aGlzLCBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIC8qXG4gICAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gICAgbWlnaHQgYXMgd2VsbCB1c2UgYnVpbGRJc29TdHJpbmcgb3Igc29tZSBvdGhlciB1dGlsIGRpcmVjdGx5XG4gICAgKi9cbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXRJc28gPSBmdW5jdGlvbiAobWFya2VyLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICB9O1xuICAgIC8vIFRpbWVab25lXG4gICAgRGF0ZUVudi5wcm90b3R5cGUudGltZXN0YW1wVG9NYXJrZXIgPSBmdW5jdGlvbiAobXMpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKG1zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJyB8fCAhdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUodGhpcy5uYW1lZFRpbWVab25lSW1wbC50aW1lc3RhbXBUb0FycmF5KG1zKSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5vZmZzZXRGb3JNYXJrZXIgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpOyAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIENvbnZlcnNpb25cbiAgICBEYXRlRW52LnByb3RvdHlwZS50b0RhdGUgPSBmdW5jdGlvbiAobSwgZm9yY2VkVHpvKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpOyAvLyBtYWtlIHN1cmUgaXQncyBhIGNvcHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUVudjtcbn0oKSk7XG5cbnZhciBnbG9iYWxMb2NhbGVzID0gW107XG5cbnZhciBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XG4gICAgY29kZTogJ2VuJyxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGRvdzogMCxcbiAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICAgIH0sXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBidXR0b25UZXh0OiB7XG4gICAgICAgIHByZXY6ICdwcmV2JyxcbiAgICAgICAgbmV4dDogJ25leHQnLFxuICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcbiAgICAgICAgeWVhcjogJ3llYXInLFxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcbiAgICAgICAgbW9udGg6ICdtb250aCcsXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcbiAgICAgICAgZGF5OiAnZGF5JyxcbiAgICAgICAgbGlzdDogJ2xpc3QnLFxuICAgIH0sXG4gICAgd2Vla1RleHQ6ICdXJyxcbiAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcbiAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXG4gICAgdGltZUhpbnQ6ICdUaW1lJyxcbiAgICBldmVudEhpbnQ6ICdFdmVudCcsXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxuICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxuICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn07XG52YXIgUkFXX0VOX0xPQ0FMRSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxuICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcbiAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cbiAgICBidXR0b25IaW50czoge1xuICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxuICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXG4gICAgICAgIHRvZGF5OiBmdW5jdGlvbiAoYnV0dG9uVGV4dCwgdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICA/ICdUb2RheSdcbiAgICAgICAgICAgICAgICA6IFwiVGhpcyBcIiArIGJ1dHRvblRleHQ7XG4gICAgICAgIH0sXG4gICAgfSwgdmlld0hpbnQ6ICckMCB2aWV3JywgbmF2TGlua0hpbnQ6ICdHbyB0byAkMCcsIG1vcmVMaW5rSGludDogZnVuY3Rpb24gKGV2ZW50Q250KSB7XG4gICAgICAgIHJldHVybiBcIlNob3cgXCIgKyBldmVudENudCArIFwiIG1vcmUgZXZlbnRcIiArIChldmVudENudCA9PT0gMSA/ICcnIDogJ3MnKTtcbiAgICB9IH0pO1xuZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlcykge1xuICAgIHZhciBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nO1xuICAgIHZhciBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKTtcbiAgICB2YXIgcmF3TG9jYWxlTWFwID0ge1xuICAgICAgICBlbjogUkFXX0VOX0xPQ0FMRSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgYWxsUmF3TG9jYWxlc18xID0gYWxsUmF3TG9jYWxlczsgX2kgPCBhbGxSYXdMb2NhbGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdMb2NhbGUgPSBhbGxSYXdMb2NhbGVzXzFbX2ldO1xuICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcbiAgICAgICAgZGVmYXVsdENvZGU6IGRlZmF1bHRDb2RlLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZExvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0U2luZ3VsYXIgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGlucHV0U2luZ3VsYXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxvY2FsZShpbnB1dFNpbmd1bGFyLmNvZGUsIFtpbnB1dFNpbmd1bGFyLmNvZGVdLCBpbnB1dFNpbmd1bGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5TG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSk7XG59XG5mdW5jdGlvbiBxdWVyeUxvY2FsZShjb2RlQXJnLCBhdmFpbGFibGUpIHtcbiAgICB2YXIgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSk7IC8vIHdpbGwgY29udmVydCB0byBhcnJheVxuICAgIHZhciByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFO1xuICAgIHJldHVybiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgICAgICAgdmFyIHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVtzaW1wbGVJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlW3NpbXBsZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpIHtcbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VQcm9wcyhbTUlOSU1BTF9SQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSk7XG4gICAgZGVsZXRlIG1lcmdlZC5jb2RlOyAvLyBkb24ndCB3YW50IHRoaXMgcGFydCBvZiB0aGUgb3B0aW9uc1xuICAgIHZhciB3ZWVrID0gbWVyZ2VkLndlZWs7XG4gICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVBcmc6IGNvZGVBcmcsXG4gICAgICAgIGNvZGVzOiBjb2RlcyxcbiAgICAgICAgd2Vlazogd2VlayxcbiAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXG4gICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGRhdGVFbnYgPSBidWlsZERhdGVFbnYkMShvcHRpb25zKTtcbiAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIHZhciBkYXRlTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShkYXRlSW5wdXQpO1xuICAgIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZU1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkVHpvOiBkYXRlTWV0YS5mb3JjZWRUem8sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxuICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgdmFyIHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICB2YXIgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XG4gICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxuZnVuY3Rpb24gYnVpbGREYXRlRW52JDEoc2V0dGluZ3MpIHtcbiAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgdGltZVpvbmU6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLnRpbWVab25lLCBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknIH0sIHNldHRpbmdzKSwgeyBsb2NhbGU6IGxvY2FsZSB9KSk7XG59XG5cbnZhciBERUZfREVGQVVMVFMgPSB7XG4gICAgc3RhcnRUaW1lOiAnMDk6MDAnLFxuICAgIGVuZFRpbWU6ICcxNzowMCcsXG4gICAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLFxuICAgIGRpc3BsYXk6ICdpbnZlcnNlLWJhY2tncm91bmQnLFxuICAgIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICAgIGdyb3VwSWQ6ICdfYnVzaW5lc3NIb3VycycsIC8vIHNvIG11bHRpcGxlIGRlZnMgZ2V0IGdyb3VwZWRcbn07XG4vKlxuVE9ETzogcGFzcyBhcm91bmQgYXMgRXZlbnREZWZIYXNoISEhXG4qL1xuZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKHJlZmluZUlucHV0cyhpbnB1dCksIG51bGwsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0KSB7XG4gICAgdmFyIHJhd0RlZnM7XG4gICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgIHJhd0RlZnMgPSBbe31dOyAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgLy8gaWYgc3BlY2lmeWluZyBhbiBhcnJheSwgZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xuICAgICAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChyYXdEZWYpIHsgcmV0dXJuIHJhd0RlZi5kYXlzT2ZXZWVrOyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmF3RGVmcyA9IFtpbnB1dF07XG4gICAgfVxuICAgIGVsc2UgeyAvLyBpcyBwcm9iYWJseSBmYWxzZVxuICAgICAgICByYXdEZWZzID0gW107XG4gICAgfVxuICAgIHJhd0RlZnMgPSByYXdEZWZzLm1hcChmdW5jdGlvbiAocmF3RGVmKSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpOyB9KTtcbiAgICByZXR1cm4gcmF3RGVmcztcbn1cblxuZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICB9O1xuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICAgIH07XG59XG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgICB9O1xufVxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgICB9O1xufVxuXG52YXIgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIHZhciBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxudmFyIEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7IC8vIGZvciBwdXJlY29tcG9uZW50cy4gVE9ETzoga2VlcCBlbHNld2hlcmVcbnZhciBTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGxpdHRlcigpIHtcbiAgICAgICAgdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzID0gbWVtb2l6ZSh0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc3BsaXRFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zcGxpdEluZGl2aWR1YWxVaSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbmRpdmlkdWFsVWkpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSB7fTsgLy8gVE9ETzogdHlwZXNjcmlwdCBwcm90ZWN0aW9uXG4gICAgfVxuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5zcGxpdFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgIHZhciBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xuICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcbiAgICAgICAgdmFyIGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICB2YXIgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcbiAgICAgICAgdmFyIGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XG4gICAgICAgIHZhciBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICB2YXIgc3BsaXRQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIGZ1bmN0aW9uIChpbmZvLCBrZXkpIHsgcmV0dXJuIF90aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KTsgfSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlJbmZvcykge1xuICAgICAgICAgICAgdmFyIGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xuICAgICAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xuICAgICAgICAgICAgdmFyIGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XG4gICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmUsXG4gICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdERhdGVTcGFuID0gZnVuY3Rpb24gKGRhdGVTcGFuKSB7XG4gICAgICAgIHZhciBkYXRlU3BhbnMgPSB7fTtcbiAgICAgICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwga2V5c18xID0ga2V5czsgX2kgPCBrZXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9nZXRLZXlzRm9yRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTdG9yZS5kZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIF90aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZik7IH0pO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZGVmS2V5cykge1xuICAgICAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcywgaW5zdGFuY2VzID0gZXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgICAgIHZhciBzcGxpdFN0b3JlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmRlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBkZWZLZXlzW2luc3RhbmNlLmRlZklkXTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdFN0b3Jlc1trZXldKSB7IC8vIG11c3QgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldLmluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRTdG9yZXM7XG4gICAgfTtcbiAgICBTcGxpdHRlci5wcm90b3R5cGUuX3NwbGl0SW5kaXZpZHVhbFVpID0gZnVuY3Rpb24gKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xuICAgICAgICB2YXIgc3BsaXRIYXNoZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZGVmS2V5c1tkZWZJZF07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRIYXNoZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV1bZGVmSWRdID0gZXZlbnRVaUJhc2VzW2RlZklkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0SGFzaGVzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIHZhciBzcGxpdFN0YXRlcyA9IHt9O1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFN0b3Jlc18xID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLCB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSk7XG4gICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgIHZhciBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xuICAgICAgICAgICAgdmFyIG11dGF0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpO1xuICAgICAgICAgICAgdmFyIHBvcHVsYXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdGF0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBzcGxpdFN0YXRlc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGFmZmVjdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNfMVtrZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFmZmVjdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG11dGF0ZWRTdG9yZXNfMSkge1xuICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFNwbGl0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XG4gICAgdmFyIGJhc2VQYXJ0cyA9IFtdO1xuICAgIGlmIChhbGxVaSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xuICAgIH1cbiAgICB2YXIgc3R1ZmYgPSB7XG4gICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcbiAgICB9O1xuICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcbiAgICAgICAgdHNsaWIuX19hc3NpZ24oc3R1ZmYsIGluZGl2aWR1YWxVaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHVmZjtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZGF0ZVByb2ZpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksXG4gICAgICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNUb2RheTogQm9vbGVhbih0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgZGF0ZSkpLFxuICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcbiAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1kYXknLFxuICAgICAgICBcImZjLWRheS1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWZ1dHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTbG90Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2xvdCcsXG4gICAgICAgIFwiZmMtc2xvdC1cIiArIERBWV9JRFNbbWV0YS5kb3ddLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxudmFyIERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xudmFyIFdFRUtfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ2xvbmcnIH0pO1xuZnVuY3Rpb24gYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZU1hcmtlciwgdmlld1R5cGUsIGlzVGFiYmFibGUpIHtcbiAgICBpZiAodmlld1R5cGUgPT09IHZvaWQgMCkgeyB2aWV3VHlwZSA9ICdkYXknOyB9XG4gICAgaWYgKGlzVGFiYmFibGUgPT09IHZvaWQgMCkgeyBpc1RhYmJhYmxlID0gdHJ1ZTsgfVxuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgdmFyIGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcbiAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xuICAgICAgICB2YXIgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XG4gICAgICAgIHZhciBoYW5kbGVJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IHZpZXdUeXBlID09PSAnZGF5JyA/IG9wdGlvbnMubmF2TGlua0RheUNsaWNrIDpcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gb3B0aW9ucy5uYXZMaW5rV2Vla0NsaWNrIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWN0aW9uLmNhbGwoY2FsZW5kYXJBcGksIGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLnpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IHRpdGxlOiBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5uYXZMaW5rSGludCwgW2RhdGVTdHIsIHpvbmVkRGF0ZV0sIGRhdGVTdHIpLCAnZGF0YS1uYXZsaW5rJzogJycgfSwgKGlzVGFiYmFibGVcbiAgICAgICAgICAgID8gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlSW50ZXJhY3Rpb24pXG4gICAgICAgICAgICA6IHsgb25DbGljazogaGFuZGxlSW50ZXJhY3Rpb24gfSkpO1xuICAgIH1cbiAgICByZXR1cm4geyAnYXJpYS1sYWJlbCc6IGRhdGVTdHIgfTtcbn1cblxudmFyIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgIHZhciBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IC0xMDAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgICB9KTtcbiAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcbiAgICB2YXIgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICB2YXIgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIF9zY3JvbGxiYXJXaWR0aHM7XG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB2YXIgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gV0FSTklORzogd2lsbCBpbmNsdWRlIGJvcmRlclxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICB5OiBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbCwgZ2V0UGFkZGluZykge1xuICAgIGlmIChnZXRQYWRkaW5nID09PSB2b2lkIDApIHsgZ2V0UGFkZGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgdmFyIGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICB2YXIgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpOyAvLyBpbmNsdWRlcyBib3JkZXIhXG4gICAgdmFyIHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0O1xuICAgIHZhciBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICBib3JkZXJMZWZ0OiBib3JkZXJMZWZ0LFxuICAgICAgICBib3JkZXJSaWdodDogYm9yZGVyUmlnaHQsXG4gICAgICAgIGJvcmRlclRvcDogYm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJCb3R0b206IGJvcmRlckJvdHRvbSxcbiAgICAgICAgc2Nyb2xsYmFyQm90dG9tOiBzY3JvbGxiYXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXG4gICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxuICAgIH07XG4gICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cbiAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XG4gICAgfVxuICAgIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZywgZG9Gcm9tV2luZG93Vmlld3BvcnQpIHtcbiAgICBpZiAoZ29XaXRoaW5QYWRkaW5nID09PSB2b2lkIDApIHsgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2U7IH1cbiAgICB2YXIgb3V0ZXJSZWN0ID0gZG9Gcm9tV2luZG93Vmlld3BvcnQgPyBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGNvbXB1dGVSZWN0KGVsKTtcbiAgICB2YXIgZWRnZXMgPSBjb21wdXRlRWRnZXMoZWwsIGdvV2l0aGluUGFkZGluZyk7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbGVmdDogb3V0ZXJSZWN0LmxlZnQgKyBlZGdlcy5ib3JkZXJMZWZ0ICsgZWRnZXMuc2Nyb2xsYmFyTGVmdCxcbiAgICAgICAgcmlnaHQ6IG91dGVyUmVjdC5yaWdodCAtIGVkZ2VzLmJvcmRlclJpZ2h0IC0gZWRnZXMuc2Nyb2xsYmFyUmlnaHQsXG4gICAgICAgIHRvcDogb3V0ZXJSZWN0LnRvcCArIGVkZ2VzLmJvcmRlclRvcCxcbiAgICAgICAgYm90dG9tOiBvdXRlclJlY3QuYm90dG9tIC0gZWRnZXMuYm9yZGVyQm90dG9tIC0gZWRnZXMuc2Nyb2xsYmFyQm90dG9tLFxuICAgIH07XG4gICAgaWYgKGdvV2l0aGluUGFkZGluZykge1xuICAgICAgICByZXMubGVmdCArPSBlZGdlcy5wYWRkaW5nTGVmdDtcbiAgICAgICAgcmVzLnJpZ2h0IC09IGVkZ2VzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVzLnRvcCArPSBlZGdlcy5wYWRkaW5nVG9wO1xuICAgICAgICByZXMuYm90dG9tIC09IGVkZ2VzLnBhZGRpbmdCb3R0b207XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21wdXRlUmVjdChlbCkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGVsKSB7XG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCk7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNsaXBwaW5nUGFyZW50c18xID0gY2xpcHBpbmdQYXJlbnRzOyBfaSA8IGNsaXBwaW5nUGFyZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNfMVtfaV07XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSZWN0cyhyZWN0LCBjbGlwcGluZ1BhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlY3QgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zKGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGNvbXB1dGVWTWFyZ2lucyhlbCk7XG59XG5mdW5jdGlvbiBjb21wdXRlVk1hcmdpbnMoZWwpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApICtcbiAgICAgICAgcGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luQm90dG9tLCAxMCk7XG59XG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xufVxuXG4vLyBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXG4vLyB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcbi8vIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxuLy8gaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXG5mdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tzIGJlaW5nIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciB3cmFwcGVkU3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRGYWlsdXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcbiAgICB9XG59XG5cbnZhciBFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldFRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKHRoaXNDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH07XG4gICAgRW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoZWRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV0gfHwgW107XG4gICAgICAgIHZhciBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2EgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19hXTtcbiAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMuaGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEVtaXR0ZXI7XG59KCkpO1xuZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcbiAgICAgICAgLnB1c2goaGFuZGxlcik7XG59XG5mdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcbiAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAoZnVuYykgeyByZXR1cm4gZnVuYyAhPT0gaGFuZGxlcjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxuICAgIH1cbn1cblxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xudmFyIFBvc2l0aW9uQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5lbHMgPSBlbHM7XG4gICAgICAgIHZhciBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuYnVpbGRFbEhvcml6b250YWxzID0gZnVuY3Rpb24gKG9yaWdpbkNsaWVudExlZnQpIHtcbiAgICAgICAgdmFyIGxlZnRzID0gW107XG4gICAgICAgIHZhciByaWdodHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZWxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVsID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxlZnRzLnB1c2gocmVjdC5sZWZ0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgICAgICByaWdodHMucHVzaChyZWN0LnJpZ2h0IC0gb3JpZ2luQ2xpZW50TGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcbiAgICB9O1xuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxWZXJ0aWNhbHMgPSBmdW5jdGlvbiAob3JpZ2luQ2xpZW50VG9wKSB7XG4gICAgICAgIHZhciB0b3BzID0gW107XG4gICAgICAgIHZhciBib3R0b21zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHJlY3QuYm90dG9tIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmxlZnRUb0luZGV4ID0gZnVuY3Rpb24gKGxlZnRQb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBsZWZ0cyA9IF9hLmxlZnRzLCByaWdodHMgPSBfYS5yaWdodHM7XG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0UG9zaXRpb24gPj0gbGVmdHNbaV0gJiYgbGVmdFBvc2l0aW9uIDwgcmlnaHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS50b3BUb0luZGV4ID0gZnVuY3Rpb24gKHRvcFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHRvcHMgPSBfYS50b3BzLCBib3R0b21zID0gX2EuYm90dG9tcztcbiAgICAgICAgdmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgIH07XG4gICAgcmV0dXJuIFBvc2l0aW9uQ2FjaGU7XG59KCkpO1xuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG52YXIgU2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxDb250cm9sbGVyKCkge1xuICAgIH1cbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldE1heFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKCk7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxIb3Jpem9udGFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxDb250cm9sbGVyO1xufSgpKTtcbnZhciBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFNjcm9sbENvbnRyb2xsZXI7XG59KFNjcm9sbENvbnRyb2xsZXIpKTtcbnZhciBXaW5kb3dTY3JvbGxDb250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBuKTtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U2Nyb2xsQ29udHJvbGxlcjtcbn0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhlbWUoY2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIHZhciBpY29uQ2xhc3Nlc0NvcHk7XG4gICAgICAgIHZhciBidXR0b25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb25PdmVycmlkZUhhc2ggPT09ICdvYmplY3QnICYmIGljb25PdmVycmlkZUhhc2gpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHkgPSB0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5pY29uQ2xhc3Nlcyk7XG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGljb25PdmVycmlkZUhhc2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRJY29uQ2xhc3MgPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSwgaXNSdGwpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArIFwiIFwiICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBUaGVtZTtcbn0oKSk7XG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xuXG52YXIgU2Nyb2xsUmVzcG9uZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgc2Nyb2xsVGltZSwgc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXhlY0Z1bmMgPSBleGVjRnVuYztcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lID0gc2Nyb2xsVGltZTtcbiAgICAgICAgdGhpcy5zY3JvbGxUaW1lUmVzZXQgPSBzY3JvbGxUaW1lUmVzZXQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gdHNsaWIuX19hc3NpZ24oe30sIF90aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpO1xuICAgICAgICAgICAgX3RoaXMuZHJhaW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgZW1pdHRlci5vbignX3Njcm9sbFJlcXVlc3QnLCB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7XG4gICAgfVxuICAgIFNjcm9sbFJlc3BvbmRlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIub2ZmKCdfc2Nyb2xsUmVxdWVzdCcsIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpc0RhdGVzTmV3KSB7XG4gICAgICAgIGlmIChpc0RhdGVzTmV3ICYmIHRoaXMuc2Nyb2xsVGltZVJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbml0aWFsU2Nyb2xsKCk7IC8vIHdpbGwgZHJhaW5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS5maXJlSW5pdGlhbFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KHtcbiAgICAgICAgICAgIHRpbWU6IHRoaXMuc2Nyb2xsVGltZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLmRyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWRSZXF1ZXN0ICYmIHRoaXMuZXhlY0Z1bmModGhpcy5xdWV1ZWRSZXF1ZXN0KSkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbFJlc3BvbmRlcjtcbn0oKSk7XG5cbnZhciBWaWV3Q29udGV4dFR5cGUgPSB2ZG9tX2Nqcy5jcmVhdGVDb250ZXh0KHt9KTsgLy8gZm9yIENvbXBvbmVudHNcbmZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQodmlld1NwZWMsIHZpZXdBcGksIHZpZXdPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgZGF0ZUVudiwgdGhlbWUsIHBsdWdpbkhvb2tzLCBkaXNwYXRjaCwgZ2V0Q3VycmVudERhdGEsIGVtaXR0ZXIsIGNhbGVuZGFyQXBpLCByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgcGx1Z2luSG9va3M6IHBsdWdpbkhvb2tzLFxuICAgICAgICBlbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgICAgIGdldEN1cnJlbnREYXRhOiBnZXRDdXJyZW50RGF0YSxcbiAgICAgICAgY2FsZW5kYXJBcGk6IGNhbGVuZGFyQXBpLFxuICAgICAgICB2aWV3U3BlYzogdmlld1NwZWMsXG4gICAgICAgIHZpZXdBcGk6IHZpZXdBcGksXG4gICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBkYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICBpc1J0bDogdmlld09wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJyxcbiAgICAgICAgYWRkUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcjogZnVuY3Rpb24gKGV4ZWNGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjcm9sbFJlc3BvbmRlcihleGVjRnVuYywgZW1pdHRlciwgY3JlYXRlRHVyYXRpb24odmlld09wdGlvbnMuc2Nyb2xsVGltZSksIHZpZXdPcHRpb25zLnNjcm9sbFRpbWVSZXNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgICAgIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudDogdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG52YXIgUHVyZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoUHVyZUNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdXJlQ29tcG9uZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGdldFVuZXF1YWxQcm9wcyhuZXh0UHJvcHMsIHRoaXMucHJvcHMpLCBnZXRVbmVxdWFsUHJvcHMobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb21wYXJlT2Jqcyh0aGlzLnByb3BzLCBuZXh0UHJvcHMsIHRoaXMucHJvcEVxdWFsaXR5KSB8fFxuICAgICAgICAgICAgIWNvbXBhcmVPYmpzKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSwgdGhpcy5zdGF0ZUVxdWFsaXR5KTtcbiAgICB9O1xuICAgIC8vIEhBQ0sgZm9yIGZyZWFraW4nIFJlYWN0IFN0cmljdE1vZGVcbiAgICBQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zYWZlU2V0U3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKCFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5zdGF0ZSksIG5ld1N0YXRlKSwgdGhpcy5zdGF0ZUVxdWFsaXR5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XG4gICAgUHVyZUNvbXBvbmVudC5hZGRTdGF0ZUVxdWFsaXR5ID0gYWRkU3RhdGVFcXVhbGl0eTtcbiAgICBQdXJlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBQdXJlQ29tcG9uZW50O1xufSh2ZG9tX2Nqcy5Db21wb25lbnQpKTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xudmFyIEJhc2VDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEJhc2VDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuICAgIHJldHVybiBCYXNlQ29tcG9uZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBhZGRQcm9wc0VxdWFsaXR5KHByb3BFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5wcm9wRXF1YWxpdHkpO1xuICAgIHRzbGliLl9fYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaDtcbn1cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkoc3RhdGVFcXVhbGl0eSkge1xuICAgIHZhciBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5KTtcbiAgICB0c2xpYi5fX2Fzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcbiAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcbn1cbi8vIHVzZSBvdGhlciBvbmVcbmZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYoY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgfVxufVxuXG4vKlxuYW4gSU5URVJBQ1RBQkxFIGRhdGUgY29tcG9uZW50XG5cblBVUlBPU0VTOlxuLSBob29rIHVwIHRvIGZnLCBmaWxsLCBhbmQgbWlycm9yIHJlbmRlcmVyc1xuLSBpbnRlcmZhY2UgZm9yIGRyYWdnaW5nIGFuZCBoaXRzXG4qL1xudmFyIERhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVpZCA9IGd1aWQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyB0aGlzIHNob3VsZCBiZSBhYnN0cmFjdFxuICAgIH07XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNWYWxpZFNlZ0Rvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9O1xuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWREYXRlRG93bkVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKTsgLy8gaGFja1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDb21wb25lbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZWFzaWVyIHdheSB0byBhZGQgbmV3IGhvb2tzPyBuZWVkIHRvIHVwZGF0ZSBhIG1pbGxpb24gdGhpbmdzXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW4oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczogaW5wdXQuY29udGVudFR5cGVIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XG4gICAgdmFyIGlzQWRkZWQgPSB7fTtcbiAgICB2YXIgaG9va3MgPSB7XG4gICAgICAgIHJlZHVjZXJzOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IFtdLFxuICAgICAgICBjb250ZXh0SW5pdDogW10sXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHt9LFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBbXSxcbiAgICAgICAgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOiBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IFtdLFxuICAgICAgICB2aWV3czoge30sXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IFtdLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogW10sXG4gICAgICAgIHRoZW1lQ2xhc3Nlczoge30sXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogbnVsbCxcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtdLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogbnVsbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogbnVsbCxcbiAgICAgICAgY29udGVudFR5cGVIYW5kbGVyczoge30sXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBkZWZzXzEgPSBkZWZzOyBfaSA8IGRlZnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBkZWZzXzFbX2ldO1xuICAgICAgICAgICAgaWYgKCFpc0FkZGVkW2RlZi5pZF0pIHtcbiAgICAgICAgICAgICAgICBpc0FkZGVkW2RlZi5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwbHVnaW5EZWZzKSB7XG4gICAgICAgIGFkZERlZnMocGx1Z2luRGVmcyk7XG4gICAgfVxuICAgIGFkZERlZnMoZ2xvYmFsRGVmcyk7XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCkge1xuICAgIHZhciBjdXJyZW50T3ZlcnJpZGVEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRHbG9iYWxEZWZzID0gW107XG4gICAgdmFyIGN1cnJlbnRIb29rcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcykge1xuICAgICAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnM7XG4gICAgICAgIGN1cnJlbnRHbG9iYWxEZWZzID0gZ2xvYmFsRGVmcztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRIb29rcztcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMCwgaG9va3MxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICAgICAgaXNMb2FkaW5nRnVuY3M6IGhvb2tzMC5pc0xvYWRpbmdGdW5jcy5jb25jYXQoaG9va3MxLmlzTG9hZGluZ0Z1bmNzKSxcbiAgICAgICAgY29udGV4dEluaXQ6IGhvb2tzMC5jb250ZXh0SW5pdC5jb25jYXQoaG9va3MxLmNvbnRleHRJbml0KSxcbiAgICAgICAgZXZlbnRSZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMpLCBob29rczEuZXZlbnRTb3VyY2VSZWZpbmVycyksXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBob29rczAuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyksXG4gICAgICAgIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzOiBob29rczAuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMuY29uY2F0KGhvb2tzMS5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyksXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGhvb2tzMC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyksXG4gICAgICAgIGRhdGVQb2ludFRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlUG9pbnRUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZGF0ZVBvaW50VHJhbnNmb3JtcyksXG4gICAgICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLnZpZXdzKSwgaG9va3MxLnZpZXdzKSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBob29rczAudmlld1Byb3BzVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEudmlld1Byb3BzVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBob29rczEuaXNQcm9wc1ZhbGlkIHx8IGhvb2tzMC5pc1Byb3BzVmFsaWQsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBob29rczAudmlld0NvbnRhaW5lckFwcGVuZHMuY29uY2F0KGhvb2tzMS52aWV3Q29udGFpbmVyQXBwZW5kcyksXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaG9va3MwLmV2ZW50RHJvcFRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmV2ZW50RHJvcFRyYW5zZm9ybWVycyksXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaG9va3MwLmNvbXBvbmVudEludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNvbXBvbmVudEludGVyYWN0aW9ucyksXG4gICAgICAgIHRoZW1lQ2xhc3NlczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSwgaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzKSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAuY29udGVudFR5cGVIYW5kbGVycyksIGhvb2tzMS5jb250ZW50VHlwZUhhbmRsZXJzKSxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxuICAgICAgICBvcHRpb25SZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25SZWZpbmVycyksIGhvb2tzMS5vcHRpb25SZWZpbmVycyksXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5wcm9wU2V0SGFuZGxlcnMpLCBob29rczEucHJvcFNldEhhbmRsZXJzKSxcbiAgICB9O1xufVxuXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xufShUaGVtZSkpO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgICByb290OiAnZmMtdGhlbWUtc3RhbmRhcmQnLFxuICAgIHRhYmxlQ2VsbFNoYWRlZDogJ2ZjLWNlbGwtc2hhZGVkJyxcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uIGZjLWJ1dHRvbi1wcmltYXJ5JyxcbiAgICBidXR0b25BY3RpdmU6ICdmYy1idXR0b24tYWN0aXZlJyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XG4gICAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1yaWdodCcsXG4gICAgbmV4dDogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYnV0dG9uSWNvbnMnOyAvLyBUT0RPOiBtYWtlIFRTLWZyaWVuZGx5XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xuXG5mdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgdmFyIHZpZXdUeXBlO1xuICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xuICAgIH1cbiAgICB2YXIgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgaWYgKHZpZXdEZWYpIHtcbiAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xuICAgIH1cbiAgICByZXR1cm4gdmlld0RlZjtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIHZhciBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XG4gICAgdmFyIHF1ZXJ5UHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTsgfTtcbiAgICB2YXIgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcbiAgICB2YXIgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcbiAgICB2YXIgc3VwZXJEZWYgPSBudWxsO1xuICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXG4gICAgICAgIGRlZmF1bHRzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSkpLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgICAgIG92ZXJyaWRlczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLm92ZXJyaWRlcyA6IHt9KSksIChvdmVycmlkZUNvbmZpZyA/IG92ZXJyaWRlQ29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG4vLyBOT1RFOiBpbiBKU1gsIHlvdSBzaG91bGQgYWx3YXlzIHVzZSB0aGlzIGNsYXNzIHdpdGggPEhvb2tQcm9wcz4gYXJnLiBvdGhlcndpc2UsIHdpbGwgZGVmYXVsdCB0byBhbnk/Pz9cbnZhciBSZW5kZXJIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhSZW5kZXJIb29rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlckhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSBwcm9wcy5ob29rUHJvcHM7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChNb3VudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGRpZE1vdW50OiBwcm9wcy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IHByb3BzLndpbGxVbm1vdW50LCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZikgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNvbnRlbnQ6IHByb3BzLmNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCwgYmFja3VwRWxSZWY6IF90aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lcywgaG9va1Byb3BzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KTsgfSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVySG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuLy8gVE9ETzogcmVuYW1lIHRvIGJlIGFib3V0IGZ1bmN0aW9uLCBub3QgZGVmYXVsdC4gdXNlIGluIGFib3ZlIHR5cGVcbi8vIGZvciBmb3JjaW5nIHJlcmVuZGVyIG9mIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlIENvbnRlbnRIb29rXG52YXIgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQgPSB2ZG9tX2Nqcy5jcmVhdGVDb250ZXh0KDApO1xuZnVuY3Rpb24gQ29udGVudEhvb2socHJvcHMpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChyZW5kZXJJZCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2tJbm5lciwgdHNsaWIuX19hc3NpZ24oeyByZW5kZXJJZDogcmVuZGVySWQgfSwgcHJvcHMpKSk7IH0pKTtcbn1cbnZhciBDb250ZW50SG9va0lubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDb250ZW50SG9va0lubmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRlbnRIb29rSW5uZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbm5lckVsUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmlubmVyRWxSZWYsIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCkpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ3VzdG9tQ29udGVudCgpO1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21Db250ZW50SW5mbyAmJiB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm87IC8vIG9ubHkgcG9wdWxhdGVkIGlmIHVzaW5nIG5vbi1bcF1yZWFjdCBub2RlKHMpXG4gICAgICAgIHZhciBpbm5lckNvbnRlbnQgPSB0aGlzLmdldElubmVyQ29udGVudCgpO1xuICAgICAgICB2YXIgbWV0YSA9IHRoaXMuZ2V0Q29udGVudE1ldGEoaW5uZXJDb250ZW50KTtcbiAgICAgICAgLy8gaW5pdGlhbCBydW4sIG9yIGNvbnRlbnQtdHlwZSBjaGFuZ2luZz8gKGZyb20gdnVlIC0+IHJlYWN0IGZvciBleGFtcGxlKVxuICAgICAgICBpZiAoIWN1c3RvbUNvbnRlbnRJbmZvIHx8IGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRLZXkgIT09IG1ldGEuY29udGVudEtleSkge1xuICAgICAgICAgICAgLy8gY2xlYXJpbmcgb2xkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3NpZ25pbmcgbmV3IHZhbHVlXG4gICAgICAgICAgICBpZiAobWV0YS5jb250ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvID0gdHNsaWIuX19hc3NpZ24oeyBjb250ZW50S2V5OiBtZXRhLmNvbnRlbnRLZXksIGNvbnRlbnRWYWw6IGlubmVyQ29udGVudFttZXRhLmNvbnRlbnRLZXldIH0sIG1ldGEuYnVpbGRMaWZlY3ljbGVGdW5jcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0aW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tQ29udGVudEluZm8pIHtcbiAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvLmNvbnRlbnRWYWwgPSBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VzdG9tQ29udGVudEluZm9cbiAgICAgICAgICAgID8gW10gLy8gc2lnbmFsIHRoYXQgc29tZXRoaW5nIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIDogaW5uZXJDb250ZW50OyAvLyBhc3N1bWUgYSBbcF1yZWFjdCB2ZG9tIG5vZGUuIHVzZSBpdFxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuZ2V0SW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5jb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50ID09PSB1bmRlZmluZWQpIHsgLy8gdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50KHByb3BzLmRlZmF1bHRDb250ZW50LCBwcm9wcy5ob29rUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbm5lckNvbnRlbnQgPT0gbnVsbCA/IG51bGwgOiBpbm5lckNvbnRlbnQ7IC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgKGJldHRlciBmb3IgUmVhY3QpXG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5nZXRDb250ZW50TWV0YSA9IGZ1bmN0aW9uIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGFuZGxlcnMgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3MuY29udGVudFR5cGVIYW5kbGVycztcbiAgICAgICAgdmFyIGNvbnRlbnRLZXkgPSAnJztcbiAgICAgICAgdmFyIGJ1aWxkTGlmZWN5Y2xlRnVuY3MgPSBudWxsO1xuICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7IC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgZm9yIGNvbnZlbmllbmNlIHRvIGNhbGxlclxuICAgICAgICAgICAgZm9yICh2YXIgc2VhcmNoS2V5IGluIGNvbnRlbnRUeXBlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50W3NlYXJjaEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50S2V5ID0gc2VhcmNoS2V5O1xuICAgICAgICAgICAgICAgICAgICBidWlsZExpZmVjeWNsZUZ1bmNzID0gY29udGVudFR5cGVIYW5kbGVyc1tzZWFyY2hLZXldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29udGVudEtleTogY29udGVudEtleSwgYnVpbGRMaWZlY3ljbGVGdW5jczogYnVpbGRMaWZlY3ljbGVGdW5jcyB9O1xuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUudXBkYXRlQ3VzdG9tQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8pIHsgLy8gZm9yIG5vbi1bcF1yZWFjdFxuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5yZW5kZXIodGhpcy5pbm5lckVsUmVmLmN1cnJlbnQgfHwgdGhpcy5wcm9wcy5iYWNrdXBFbFJlZi5jdXJyZW50LCAvLyB0aGUgZWxlbWVudCB0byByZW5kZXIgaW50b1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbnRlbnRIb29rSW5uZXI7XG59KEJhc2VDb21wb25lbnQpKTtcbnZhciBNb3VudEhvb2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1vdW50SG9vaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb3VudEhvb2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAocm9vdEVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIHJvb3RFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW91bnRIb29rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuaGFuZGxlUm9vdEVsKTtcbiAgICB9O1xuICAgIE1vdW50SG9vay5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMucHJvcHMuZGlkTW91bnQ7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMucHJvcHMuaG9va1Byb3BzKSwgeyBlbDogdGhpcy5yb290RWwgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb3VudEhvb2sucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzLndpbGxVbm1vdW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmhvb2tQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vdW50SG9vaztcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCkge1xuICAgIHZhciBjdXJyZW50R2VuZXJhdG9yO1xuICAgIHZhciBjdXJyZW50SG9va1Byb3BzO1xuICAgIHZhciBjdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZ2VuZXJhdG9yLCBob29rUHJvcHMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va1Byb3BzIHx8ICFpc1Byb3BzRXF1YWwoY3VycmVudEhvb2tQcm9wcywgaG9va1Byb3BzKSB8fCBnZW5lcmF0b3IgIT09IGN1cnJlbnRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgICAgICBjdXJyZW50SG9va1Byb3BzID0gaG9va1Byb3BzO1xuICAgICAgICAgICAgY3VycmVudENsYXNzTmFtZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKGdlbmVyYXRvciwgaG9va1Byb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENsYXNzTmFtZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoY2xhc3NOYW1lcywgaG9va1Byb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKGhvb2tQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUNsYXNzTmFtZXMoY2xhc3NOYW1lcyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGlucHV0LCBob29rUHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbnB1dChob29rUHJvcHMsIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQpOyAvLyBnaXZlIHRoZSBmdW5jdGlvbiB0aGUgdmRvbS1jcmVhdGlvbiBmdW5jXG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxudmFyIFZpZXdSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhWaWV3Um9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3Um9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMgPSBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9O1xuICAgICAgICB2YXIgY3VzdG9tQ2xhc3NOYW1lcyA9IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBob29rUHJvcHMpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCwgZWxSZWY6IHByb3BzLmVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgW1wiZmMtXCIgKyBwcm9wcy52aWV3U3BlYy50eXBlICsgXCItdmlld1wiLCAnZmMtdmlldyddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Um9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xuICAgIHZhciByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgICAgICBpbnB1dDtcbiAgICB2YXIgY29tcG9uZW50ID0gcmF3T3B0aW9ucy5jb21wb25lbnQ7XG4gICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xuICAgICAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKTtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGNvbnRlbnQvY2xhc3NOYW1lcy9kaWRNb3VudC9ldGMgZnJvbSBvcHRpb25zP1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdXBlclR5cGU6IHJhd09wdGlvbnMudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIHJhd09wdGlvbnM6IHJhd09wdGlvbnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXdQcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgZnVuY3Rpb24gKHZpZXdFbFJlZiwgdmlld0NsYXNzTmFtZXMpIHtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5jbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmNvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLmRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53aWxsVW5tb3VudCwgZWxSZWY6IHZpZXdFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH0pKTsgfSkpOyB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgdmFyIGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcbiAgICB2YXIgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpO1xuICAgIHZhciB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgZnVuY3Rpb24gKHZpZXdEZWYpIHsgcmV0dXJuIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTsgfSk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIHZhciBkdXJhdGlvbklucHV0ID0gdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbjtcbiAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xuICAgIHZhciBkdXJhdGlvblVuaXQgPSAnJztcbiAgICB2YXIgc2luZ2xlVW5pdCA9ICcnO1xuICAgIHZhciBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgdmFyIGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XG4gICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVlcnlCdXR0b25UZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnNTdWJzZXQpIHtcbiAgICAgICAgdmFyIGJ1dHRvblRleHRNYXAgPSBvcHRpb25zU3Vic2V0LmJ1dHRvblRleHQgfHwge307XG4gICAgICAgIHZhciBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xuICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgdmFyIHF1ZXJ5QnV0dG9uVGl0bGUgPSBmdW5jdGlvbiAob3B0aW9uc1N1YnNldCkge1xuICAgICAgICB2YXIgYnV0dG9uSGludHMgPSBvcHRpb25zU3Vic2V0LmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgICAgICB2YXIgYnV0dG9uS2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5OyAvLyB1c2Ugc2FtZSBrZXkgYXMgdGV4dFxuICAgICAgICBpZiAoYnV0dG9uS2V5ICE9IG51bGwgJiYgYnV0dG9uSGludHNbYnV0dG9uS2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbYnV0dG9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uVW5pdDogZHVyYXRpb25Vbml0LFxuICAgICAgICBzaW5nbGVVbml0OiBzaW5nbGVVbml0LFxuICAgICAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcbiAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXG4gICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcbiAgICAgICAgLy8gbm90IERSWVxuICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXG4gICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcbiAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXG4gICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxuICAgIH07XG59XG4vLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXG52YXIgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XG4gICAgdmFyIHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XG4gICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xuICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLm5vd0RhdGUgPSBnZXROb3cocHJvcHMubm93SW5wdXQsIHByb3BzLmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgfVxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgcHJldkRhdGUgPSBkYXRlRW52LnN1YnRyYWN0KGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQocHJldkRhdGUsIC0xLCBmb3JjZVRvVmFsaWQpO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLnByb3BzLmRhdGVFbnY7XG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGRhdGVFbnYuYWRkKGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICAgIGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGQobmV4dERhdGUsIDEsIGZvcmNlVG9WYWxpZCk7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkID09PSB2b2lkIDApIHsgZm9yY2VUb1ZhbGlkID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdmFsaWRSYW5nZTtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xuICAgICAgICB2YXIgaXNSYW5nZUFsbERheTtcbiAgICAgICAgdmFyIHJlbmRlclJhbmdlO1xuICAgICAgICB2YXIgYWN0aXZlUmFuZ2U7XG4gICAgICAgIHZhciBpc1ZhbGlkO1xuICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRSYW5nZSk7XG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gY29uc3RyYWluTWFya2VyVG9SYW5nZShjdXJyZW50RGF0ZSwgdmFsaWRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZm8gPSB0aGlzLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyhjdXJyZW50RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby5yYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpO1xuICAgICAgICBhY3RpdmVSYW5nZSA9IHJlbmRlclJhbmdlO1xuICAgICAgICBpZiAoIXByb3BzLnNob3dOb25DdXJyZW50RGF0ZXMpIHtcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCBjdXJyZW50SW5mby5yYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUmFuZ2UgPSB0aGlzLmFkanVzdEFjdGl2ZVJhbmdlKGFjdGl2ZVJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIHZhbGlkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgICAgIGlzVmFsaWQgPSByYW5nZXNJbnRlcnNlY3QoY3VycmVudEluZm8ucmFuZ2UsIHZhbGlkUmFuZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhbGlkUmFuZ2U6IHZhbGlkUmFuZ2UsXG4gICAgICAgICAgICAvLyByYW5nZSB0aGUgdmlldyBpcyBmb3JtYWxseSByZXNwb25zaWJsZSBmb3IuXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogY3VycmVudEluZm8ucmFuZ2UsXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuICAgICAgICAgICAgaXNSYW5nZUFsbERheTogaXNSYW5nZUFsbERheSxcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xuICAgICAgICAgICAgYWN0aXZlUmFuZ2U6IGFjdGl2ZVJhbmdlLFxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgcmVuZGVyUmFuZ2U6IHJlbmRlclJhbmdlLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRWYWxpZFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgfTtcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgcmFuZ2UgPSBudWxsO1xuICAgICAgICB2YXIgZGF5Q291bnQ7XG4gICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcbiAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xuICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgcmFuZ2U6IHJhbmdlIH07XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5OiAxIH0pO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG4gICAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB1c2VzTWluTWF4VGltZSA9IF9hLnVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSA9IF9hLnNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSA9IF9hLnNsb3RNYXhUaW1lO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbUR1cmF0aW9uID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgPSBfYS5kYXRlQWxpZ25tZW50O1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxuICAgICAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSW5jcmVtZW50ID0gdGhpcy5wcm9wcy5kYXRlSW5jcmVtZW50O1xuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZGF0ZUluY3JlbWVudCkudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZUFsaWdubWVudCA9IF9hLmRhdGVBbGlnbm1lbnQ7XG4gICAgICAgIHZhciBydW5uaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlO1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcbiAgICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaW5wdXQgPSBwcm9wcy52aXNpYmxlUmFuZ2VJbnB1dDtcbiAgICAgICAgdmFyIHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwocHJvcHMuY2FsZW5kYXJBcGksIHByb3BzLmRhdGVFbnYudG9EYXRlKGRhdGUpKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yZWZpbmVSYW5nZShzaW1wbGVJbnB1dCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiAocmFuZ2Uuc3RhcnQgPT0gbnVsbCB8fCByYW5nZS5lbmQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZERhdGVJbmNyZW1lbnQgPSBmdW5jdGlvbiAoZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnQgPSB0aGlzLnByb3BzLmRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XG4gICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XG4gICAgfTtcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUucmVmaW5lUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VJbnB1dCkge1xuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qIEhpZGRlbiBEYXlzXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmluaXRIaWRkZW5EYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGlkZGVuRGF5cyA9IHRoaXMucHJvcHMuaGlkZGVuRGF5cyB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cbiAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXG4gICAgICAgIHZhciBkYXlDbnQgPSAwO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMud2Vla2VuZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gaGlkZGVuRGF5cy5pbmRleE9mKGkpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICBkYXlDbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRheUNudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpZGRlbkRheXMnKTsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcbiAgICB9O1xuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICBpZiAoZGF5IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgZGF5ID0gZGF5LmdldFVUQ0RheSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xuICAgIH07XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxuICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHZvaWQgMCkgeyBpc0V4Y2x1c2l2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XG4gICAgfVxuICAgIHJldHVybiB2aWV3VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZHluYW1pY09wdGlvbk92ZXJyaWRlcyksIChfYSA9IHt9LCBfYVthY3Rpb24ub3B0aW9uTmFtZV0gPSBhY3Rpb24ucmF3T3B0aW9uVmFsdWUsIF9hKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9pIDwgc291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19pXTtcbiAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7IHJldHVybiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQ7IH0pO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCk7IH0pLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yICh2YXIgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIGNhbGVuZGFyQXBpID0gY29udGV4dC5jYWxlbmRhckFwaTtcbiAgICB2YXIgc291cmNlRGVmID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdO1xuICAgIHZhciBmZXRjaElkID0gZ3VpZCgpO1xuICAgIHNvdXJjZURlZi5mZXRjaCh7XG4gICAgICAgIGV2ZW50U291cmNlOiBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaDogaXNSZWZldGNoLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIH0sIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIHJhd0V2ZW50cyA9IHJlcy5yYXdFdmVudHM7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICAgICAgcmF3RXZlbnRzID0gb3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMueGhyKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxuICAgICAgICAgICAgZmV0Y2hJZDogZmV0Y2hJZCxcbiAgICAgICAgICAgIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgICAgICByYXdFdmVudHM6IHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UX0VSUk9SJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50U291cmNlKSwgeyBpc0ZldGNoaW5nOiB0cnVlLCBsYXRlc3RGZXRjaElkOiBmZXRjaElkIH0pO1xufVxuZnVuY3Rpb24gcmVjZWl2ZVJlc3BvbnNlKHNvdXJjZUhhc2gsIHNvdXJjZUlkLCBmZXRjaElkLCBmZXRjaFJhbmdlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzb3VyY2VIYXNoKSwgKF9hID0ge30sIF9hW3NvdXJjZUlkXSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2U6IGZldGNoUmFuZ2UgfSksIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpOyB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICB2YXIgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgcmF3U291cmNlc18xID0gcmF3U291cmNlczsgX2kgPCByYXdTb3VyY2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdTb3VyY2UgPSByYXdTb3VyY2VzXzFbX2ldO1xuICAgICAgICB2YXIgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGV2ZW50RGVmKSB7IHJldHVybiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcbiAgICAgICAgICAgICk7IH0pO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcbiAgICApIHtcbiAgICAgICAgdmFyIHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xuICAgIHZhciBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0V2ZW50cztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICB2YXIgcmVmaW5lZEV2ZW50cztcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByYXdFdmVudHNfMSA9IHJhd0V2ZW50czsgX2kgPCByYXdFdmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgICAgIHZhciByZWZpbmVkRXZlbnQgPSBmdW5jKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkRXZlbnRzLnB1c2gocmVmaW5lZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZWRFdmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KTtcbiAgICAgICAgICAgIH0gLy8gaWYgYSBkaWZmZXJlbnQgZmFsc3kgdmFsdWUsIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmaW5lZEV2ZW50cztcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmUsIHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoZXhwYW5kUmFuZ2UpIHtcbiAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZXhwYW5kUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBzdWJzZXQpO1xufVxuZnVuY3Rpb24gcmV6b25lRXZlbnRTdG9yZURhdGVzKGV2ZW50U3RvcmUsIG9sZERhdGVFbnYsIG5ld0RhdGVFbnYpIHtcbiAgICB2YXIgZGVmcyA9IGV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGRlZi5hbGxEYXkgfHwgZGVmLnJlY3VycmluZ0RlZikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlOyAvLyBpc24ndCBkZXBlbmRlbnQgb24gdGltZXpvbmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGluc3RhbmNlKSwgeyByYW5nZToge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLmVuZCwgaW5zdGFuY2UuZm9yY2VkRW5kVHpvKSksXG4gICAgICAgICAgICB9LCBmb3JjZWRTdGFydFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8gfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZGVmczogZGVmcywgaW5zdGFuY2VzOiBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkOyB9KTtcbn1cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTsgfSksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRGF0ZVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRUxFQ1RfREFURVMnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudERyYWcoY3VycmVudERyYWcsIGFjdGlvbikge1xuICAgIHZhciBuZXdEcmFnO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfRFJBRyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgbmV3RHJhZyA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld0RyYWcuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3RHJhZy5tdXRhdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERyYWc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplLCBhY3Rpb24pIHtcbiAgICB2YXIgbmV3UmVzaXplO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IG5ld1Jlc2l6ZS5hZmZlY3RlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdSZXNpemUuaXNFdmVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlc2l6ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XG4gICAgdmFyIGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHJldHVybiB7IGhlYWRlcjogaGVhZGVyLCBmb290ZXI6IGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIHZhciB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgdmFyIGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgdmFyIHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIHZhciBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2guYXBwbHkodmlld3NXaXRoQnV0dG9ucywgc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0czogc2VjdGlvbldpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnM6IHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlOiBoYXNUaXRsZSB9O1xufVxuLypcbkJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcbiovXG5mdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxuY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXG50aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIHZhciBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIHZhciBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgIHZhciBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcbiAgICB2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIHZhciBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIHZhciB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKGZ1bmN0aW9uIChidXR0b25Hcm91cFN0cikgeyByZXR1cm4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lOiBidXR0b25OYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xuICAgICAgICB2YXIgdmlld1NwZWM7XG4gICAgICAgIHZhciBidXR0b25DbGljaztcbiAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XG4gICAgICAgIHZhciBidXR0b25UZXh0OyAvLyBcIlxuICAgICAgICB2YXIgYnV0dG9uSGludDtcbiAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XG4gICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xuICAgICAgICAgICAgdmFyIHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XG4gICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxuICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxuICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxuICAgICAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmdW5jdGlvbiAobmF2VW5pdCkgeyByZXR1cm4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxuICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2s6IGJ1dHRvbkNsaWNrLCBidXR0b25JY29uOiBidXR0b25JY29uLCBidXR0b25UZXh0OiBidXR0b25UZXh0LCBidXR0b25IaW50OiBidXR0b25IaW50IH07XG4gICAgfSkpOyB9KTtcbiAgICByZXR1cm4geyB3aWRnZXRzOiB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zOiB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZTogaGFzVGl0bGUgfTtcbn1cblxudmFyIGV2ZW50U291cmNlRGVmJDIgPSB7XG4gICAgaWdub3JlUmFuZ2U6IHRydWUsXG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZpbmVkLmV2ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzKSB7XG4gICAgICAgIHN1Y2Nlc3Moe1xuICAgICAgICAgICAgcmF3RXZlbnRzOiBhcmcuZXZlbnRTb3VyY2UubWV0YSxcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxudmFyIGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhOiBmdW5jdGlvbiAocmVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IGFyZy5jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCBmdW5jdGlvbiAocmF3RXZlbnRzKSB7XG4gICAgICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzOiByYXdFdmVudHMgfSk7IC8vIG5lZWRzIGFuIG9iamVjdCByZXNwb25zZVxuICAgICAgICB9LCBmYWlsdXJlKTtcbiAgICB9LFxufTtcbnZhciBmdW5jRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxufSk7XG5cbmZ1bmN0aW9uIHJlcXVlc3RKc29uKG1ldGhvZCwgdXJsLCBwYXJhbXMsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgbWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHVybCA9IGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgaGFuZGxlIHBhcnNlZD1mYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjayhyZXMsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdSZXF1ZXN0IGZhaWxlZCcsIHhocik7XG4gICAgfTtcbiAgICB4aHIuc2VuZChib2R5KTtcbn1cbmZ1bmN0aW9uIGluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zKHVybCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybCArXG4gICAgICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICBlbmNvZGVQYXJhbXMocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJicpO1xufVxuXG52YXIgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBtZXRob2Q6IFN0cmluZyxcbiAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxufTtcblxudmFyIGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbiAoYXJnLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgIHZhciBtZXRhID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMsIGZ1bmN0aW9uIChyYXdFdmVudHMsIHhocikge1xuICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgeGhyKSB7XG4gICAgICAgICAgICBmYWlsdXJlKHsgbWVzc2FnZTogZXJyb3JNZXNzYWdlLCB4aHI6IHhociB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbn07XG52YXIganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KTtcbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCByYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBzdGFydFBhcmFtO1xuICAgIHZhciBlbmRQYXJhbTtcbiAgICB2YXIgdGltZVpvbmVQYXJhbTtcbiAgICB2YXIgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICB0c2xpYi5fX2Fzc2lnbihwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xuICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF0ZUVudi50aW1lWm9uZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICBwYXJhbXNbdGltZVpvbmVQYXJhbV0gPSBkYXRlRW52LnRpbWVab25lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuXG52YXIgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcbiAgICBlbmRSZWN1cjogaWRlbnRpdHksXG59O1xuXG52YXIgcmVjdXJyaW5nID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiAocmVmaW5lZCwgZGF0ZUVudikge1xuICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgICAgICAgdmFyIHJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbiAodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgICAgICB2YXIgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XG4gICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG59O1xudmFyIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXG59KTtcbmZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xuICAgIHZhciBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcbiAgICB2YXIgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xuICAgIHZhciBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xuICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQgXG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgPSB2b2lkIDA7XG4gICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcbiAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcbn1cblxudmFyIGNoYW5nZUhhbmRsZXJQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgICAgIGV2ZW50czogZnVuY3Rpb24gKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gICAgfSxcbn0pO1xuLypcbkJVRzogaWYgYGV2ZW50YCB3YXMgc3VwcGxpZWQsIGFsbCBwcmV2aW91c2x5LWdpdmVuIGBldmVudFNvdXJjZXNgIHdpbGwgYmUgd2lwZWQgb3V0XG4qL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRTb3VyY2VzKGlucHV0cywgY29udGV4dCkge1xuICAgIHZhciB1bmZvdW5kU291cmNlcyA9IGhhc2hWYWx1ZXNUb0FycmF5KGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXMpO1xuICAgIHZhciBuZXdJbnB1dHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgIHZhciBpbnB1dEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5mb3VuZFNvdXJjZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh1bmZvdW5kU291cmNlc1tpXS5fcmF3ID09PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIHVuZm91bmRTb3VyY2VzLnNwbGljZShpLCAxKTsgLy8gZGVsZXRlXG4gICAgICAgICAgICAgICAgaW5wdXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dEZvdW5kKSB7XG4gICAgICAgICAgICBuZXdJbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCB1bmZvdW5kU291cmNlc18xID0gdW5mb3VuZFNvdXJjZXM7IF9hIDwgdW5mb3VuZFNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHVuZm91bmRTb3VyY2UgPSB1bmZvdW5kU291cmNlc18xW19hXTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgbmV3SW5wdXRzXzEgPSBuZXdJbnB1dHM7IF9iIDwgbmV3SW5wdXRzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBuZXdJbnB1dCA9IG5ld0lucHV0c18xW19iXTtcbiAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS5hZGRFdmVudFNvdXJjZShuZXdJbnB1dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlc1NldCcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpKSwgeyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW1pdHRlciA9IGNvbnRleHQuZW1pdHRlcjtcbiAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcbiAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XG4gICAgfVxufVxuXG4vKlxudGhpcyBhcnJheSBpcyBleHBvc2VkIG9uIHRoZSByb290IG5hbWVzcGFjZSBzbyB0aGF0IFVNRCBwbHVnaW5zIGNhbiBhZGQgdG8gaXQuXG5zZWUgdGhlIHJvbGx1cC1idW5kbGVzIHNjcmlwdC5cbiovXG52YXIgZ2xvYmFsUGx1Z2lucyA9IFtcbiAgICBhcnJheUV2ZW50U291cmNlUGx1Z2luLFxuICAgIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAgICBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luLFxuICAgIHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbixcbiAgICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICAgIGNyZWF0ZVBsdWdpbih7XG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAgICAgICBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyk7IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGh0bWw6IGJ1aWxkSHRtbFJlbmRlcmVyLFxuICAgICAgICAgICAgZG9tTm9kZXM6IGJ1aWxkRG9tTm9kZVJlbmRlcmVyLFxuICAgICAgICB9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgICAgIH0sXG4gICAgfSksXG5dO1xuZnVuY3Rpb24gYnVpbGRIdG1sUmVuZGVyZXIoKSB7XG4gICAgdmFyIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRIdG1sID0gJyc7XG4gICAgZnVuY3Rpb24gcmVuZGVyKGVsLCBodG1sKSB7XG4gICAgICAgIGlmIChlbCAhPT0gY3VycmVudEVsIHx8IGh0bWwgIT09IGN1cnJlbnRIdG1sKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRFbCA9IGVsO1xuICAgICAgICBjdXJyZW50SHRtbCA9IGh0bWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGN1cnJlbnRFbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgY3VycmVudEh0bWwgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVuZGVyOiByZW5kZXIsIGRlc3Ryb3k6IGRlc3Ryb3kgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRG9tTm9kZVJlbmRlcmVyKCkge1xuICAgIHZhciBjdXJyZW50RWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RG9tTm9kZXMgPSBbXTtcbiAgICBmdW5jdGlvbiByZW5kZXIoZWwsIGRvbU5vZGVzKSB7XG4gICAgICAgIHZhciBuZXdEb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvbU5vZGVzKTtcbiAgICAgICAgaWYgKGVsICE9PSBjdXJyZW50RWwgfHwgIWlzQXJyYXlzRXF1YWwoY3VycmVudERvbU5vZGVzLCBuZXdEb21Ob2RlcykpIHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBmaXJzdCwgcmVtb3ZlIHNlY29uZCAoZm9yIHNjcm9sbCByZXNldHRpbmcpXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0RvbU5vZGVzXzEgPSBuZXdEb21Ob2RlczsgX2kgPCBuZXdEb21Ob2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gbmV3RG9tTm9kZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEVsID0gZWw7XG4gICAgICAgIGN1cnJlbnREb21Ob2RlcyA9IG5ld0RvbU5vZGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjdXJyZW50RG9tTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcbiAgICAgICAgY3VycmVudERvbU5vZGVzID0gW107XG4gICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlcjogcmVuZGVyLCBkZXN0cm95OiBkZXN0cm95IH07XG59XG5cbnZhciBEZWxheWVkUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5ZWRSdW5uZXIoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9ICcnOyB9XG4gICAgICAgIHZhciBwYXVzZURlcHRocyA9IHRoaXMucGF1c2VEZXB0aHM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS50cnlEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiAhdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkKCk7IC8vIG1pZ2h0IHNldCBpc0RpcnR5IHRvIHRydWUgYWdhaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmRyYWluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXllZFJ1bm5lcjtcbn0oKSk7XG5cbnZhciBUYXNrUnVubmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tSdW5uZXIocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAodGFzaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucGF1c2Uoc2NvcGUpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKHNjb3BlLCBmb3JjZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSk7XG4gICAgfTtcbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZFRhc2tzID0gW107XG4gICAgICAgICAgICB2YXIgdGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IHF1ZXVlLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UYXNrKHRhc2spO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzLnB1c2godGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9IC8vIGtlZXAgZ29pbmcsIGluIGNhc2UgbmV3IHRhc2tzIHdlcmUgYWRkZWQgaW4gdGhlIGRyYWluZWQgaGFuZGxlclxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUuZHJhaW5lZCA9IGZ1bmN0aW9uIChjb21wbGV0ZWRUYXNrcykge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFza1J1bm5lcjtcbn0oKSk7XG5cbi8vIENvbXB1dGVzIHdoYXQgdGhlIHRpdGxlIGF0IHRoZSB0b3Agb2YgdGhlIGNhbGVuZGFyQXBpIHNob3VsZCBiZSBmb3IgdGhpcyB2aWV3XG5mdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlLCB2aWV3T3B0aW9ucywgZGF0ZUVudikge1xuICAgIHZhciByYW5nZTtcbiAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2U7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBmb3IgZGF5IHVuaXRzIG9yIHNtYWxsZXIsIHVzZSB0aGUgYWN0dWFsIGRheSByYW5nZVxuICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBjcmVhdGVGb3JtYXR0ZXIodmlld09wdGlvbnMudGl0bGVGb3JtYXQgfHwgYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkpLCB7XG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0pO1xufVxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpIHtcbiAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH07IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG4gICAgfVxuICAgIHZhciBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbn1cblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xudmFyIENhbGVuZGFyRGF0YU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJEYXRhTWFuYWdlcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZU9wdGlvbnNEYXRhKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcbiAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcbiAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYpO1xuICAgICAgICB0aGlzLmJ1aWxkVGhlbWUgPSBtZW1vaXplKGJ1aWxkVGhlbWUpO1xuICAgICAgICB0aGlzLnBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNzID0gbWVtb2l6ZShidWlsZFZpZXdTcGVjcyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciA9IG1lbW9pemVPYmpBcmcoYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1VpUHJvcHMgPSBtZW1vaXplT2JqQXJnKGJ1aWxkVmlld1VpUHJvcHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCeVNvdXJjZSwgaXNQcm9wc0VxdWFsKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpO1xuICAgICAgICB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMgPSBtZW1vaXplT2JqQXJnKHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGl0bGUgPSBtZW1vaXplKGJ1aWxkVGl0bGUpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lciA9IG5ldyBUYXNrUnVubmVyKHRoaXMuX2hhbmRsZUFjdGlvbi5iaW5kKHRoaXMpLCB0aGlzLnVwZGF0ZURhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRhdGE7IH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcbiAgICAgICAgdmFyIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9hW19pXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9UIERSWVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZTogY3VycmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgY3VycmVudERhdGU6IGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICAgICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICAgICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICAgICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2VyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2NbX2JdO1xuICAgICAgICAgICAgdHNsaWIuX19hc3NpZ24oaW5pdGlhbFN0YXRlLCByZWR1Y2VyKG51bGwsIG51bGwsIGNvbnRleHRBbmRTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlSXNMb2FkaW5nKGluaXRpYWxTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTsgLy8gTk9UIERSWVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLmFjdGlvblJ1bm5lci5yZXN1bWUoKTtcbiAgICB9XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyA9IGFwcGVuZFxuICAgICAgICAgICAgPyB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzKSwgb3B0aW9uT3ZlcnJpZGVzKSA6IG9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAnTk9USElORycsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUuX2hhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgZW1pdHRlciA9IF9hLmVtaXR0ZXI7XG4gICAgICAgIHZhciBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0gcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyhzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBhY3Rpb24pO1xuICAgICAgICB2YXIgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3VHlwZSA9IHJlZHVjZVZpZXdUeXBlKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgYWN0aW9uKTtcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShjdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICAvLyB3aXJlIHRoaW5ncyB1cFxuICAgICAgICAvLyBUT0RPOiBub3QgRFJZXG4gICAgICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXM7XG4gICAgICAgIGVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBlbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICB2YXIgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBzdGF0ZS5jdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgPSBzdGF0ZS5kYXRlUHJvZmlsZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgIT09IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcikgeyAvLyBoYWNrXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGUgPSByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgZGF0ZVByb2ZpbGUgPSByZWR1Y2VEYXRlUHJvZmlsZShkYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnUFJFVicgfHwgLy8gVE9ETzogbW92ZSB0aGlzIGxvZ2ljIGludG8gRGF0ZVByb2ZpbGVHZW5lcmF0b3JcbiAgICAgICAgICAgIGFjdGlvbi50eXBlID09PSAnTkVYVCcgfHwgLy8gXCJcbiAgICAgICAgICAgICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGV2ZW50U3RvcmUgPSByZWR1Y2VFdmVudFN0b3JlKHN0YXRlLmV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGlzRXZlbnRzTG9hZGluZyA9IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcyk7IC8vIEJBRC4gYWxzbyBjYWxsZWQgaW4gdGhpcyBmdW5jIGluIGNvbXB1dGVJc0xvYWRpbmdcbiAgICAgICAgdmFyIHJlbmRlcmFibGVFdmVudFN0b3JlID0gKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAgICAgKHN0YXRlLnJlbmRlcmFibGVFdmVudFN0b3JlIHx8IGV2ZW50U3RvcmUpIDogLy8gdHJ5IGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgIGV2ZW50U3RvcmU7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLCBldmVudFVpU2luZ2xlQmFzZSA9IF9iLmV2ZW50VWlTaW5nbGVCYXNlLCBzZWxlY3Rpb25Db25maWcgPSBfYi5zZWxlY3Rpb25Db25maWc7IC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgICAgdmFyIGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHRoaXMuYnVpbGRFdmVudFVpQmFzZXMocmVuZGVyYWJsZUV2ZW50U3RvcmUuZGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGU6IGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogZXZlbnRTb3VyY2VzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiByZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZzogc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dEFuZFN0YXRlID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNhbGVuZGFyQ29udGV4dCksIG5ld1N0YXRlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlZHVjZXIgPSBfY1tfaV07XG4gICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbihuZXdTdGF0ZSwgcmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBjb250ZXh0QW5kU3RhdGUpKTsgLy8gZ2l2ZSB0aGUgT0xEIHN0YXRlLCBmb3Igb2xkIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB2YXIgaXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhuZXdTdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgLy8gVE9ETzogdXNlIHByb3BTZXRIYW5kbGVycyBpbiBwbHVnaW4gc3lzdGVtXG4gICAgICAgIGlmICghd2FzTG9hZGluZyAmJiBpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdhc0xvYWRpbmcgJiYgIWlzTG9hZGluZykge1xuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByb3BzLm9uQWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBzdGF0ZS5keW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSwgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsIGVtaXR0ZXI6IHRoaXMuZW1pdHRlciwgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEgfSwgb3B0aW9uc0RhdGEpLCBjdXJyZW50Vmlld0RhdGEpLCBzdGF0ZSk7XG4gICAgICAgIHZhciBjaGFuZ2VIYW5kbGVycyA9IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLm9wdGlvbkNoYW5nZUhhbmRsZXJzO1xuICAgICAgICB2YXIgb2xkQ2FsZW5kYXJPcHRpb25zID0gb2xkRGF0YSAmJiBvbGREYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgdmFyIG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucztcbiAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFja1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U291cmNlcyA9IGRhdGEuZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZGF0YS5ldmVudFNvdXJjZXMsIHN0YXRlLmRhdGVQcm9maWxlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFN0b3JlID0gZGF0YS5ldmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEuZXZlbnRTdG9yZSwgb2xkRGF0YS5kYXRlRW52LCBkYXRhLmRhdGVFbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IG5ld0NhbGVuZGFyT3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLl9jb21wdXRlT3B0aW9uc0RhdGEgPSBmdW5jdGlvbiAob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBjYWxlbmRhckFwaSkge1xuICAgICAgICAvLyBUT0RPOiBibGFja2xpc3Qgb3B0aW9ucyB0aGF0IGFyZSBoYW5kbGVkIGJ5IG9wdGlvbkNoYW5nZUhhbmRsZXJzXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyA9IF9hLnBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cyA9IF9hLmxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhID0gX2EuYXZhaWxhYmxlTG9jYWxlRGF0YSwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLmJ1aWxkRGF0ZUVudihyZWZpbmVkT3B0aW9ucy50aW1lWm9uZSwgcmVmaW5lZE9wdGlvbnMubG9jYWxlLCByZWZpbmVkT3B0aW9ucy53ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LCByZWZpbmVkT3B0aW9ucy53ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIHJlZmluZWRPcHRpb25zLmRlZmF1bHRSYW5nZVNlcGFyYXRvcik7XG4gICAgICAgIHZhciB2aWV3U3BlY3MgPSB0aGlzLmJ1aWxkVmlld1NwZWNzKHBsdWdpbkhvb2tzLnZpZXdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XG4gICAgICAgIHZhciB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCBvcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9uczogcmVmaW5lZE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBkYXRlRW52OiBkYXRlRW52LFxuICAgICAgICAgICAgdmlld1NwZWNzOiB2aWV3U3BlY3MsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnOiB0b29sYmFyQ29uZmlnLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHM6IGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgX2EgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKSwgbG9jYWxlcyA9IF9hLmxvY2FsZXMsIGxvY2FsZSA9IF9hLmxvY2FsZTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKTtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJhd0xvY2FsZXMgPSBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcDtcbiAgICAgICAgdmFyIGxvY2FsZURlZmF1bHRzID0gdGhpcy5idWlsZExvY2FsZShsb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlUmF3TG9jYWxlcykub3B0aW9ucztcbiAgICAgICAgdmFyIHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKTtcbiAgICAgICAgdmFyIHJlZmluZXJzID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIHBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMpLCBwbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyk7XG4gICAgICAgIHZhciBleHRyYSA9IHt9O1xuICAgICAgICB2YXIgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dDtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWZpbmVkID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25OYW1lICE9PSAncGx1Z2lucycpIHsgLy8gYmVjYXVzZSBwbHVnaW5zIGlzIHNwZWNpYWwtY2FzZWRcbiAgICAgICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0sIHJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBwbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGE6IGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0czogbG9jYWxlRGVmYXVsdHMsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgb3B0aW9uc0RhdGEsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBvcHRpb25zRGF0YS52aWV3U3BlY3Nbdmlld1R5cGVdO1xuICAgICAgICBpZiAoIXZpZXdTcGVjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aWV3VHlwZSBcXFwiXCIgKyB2aWV3VHlwZSArIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSd2ZSBsb2FkZWQgYWxsIG5lY2Nlc3NhcnkgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCByZWZpbmVkT3B0aW9ucyA9IF9hLnJlZmluZWRPcHRpb25zLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgbW9udGhNb2RlOiByZWZpbmVkT3B0aW9ucy5tb250aE1vZGUsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld0FwaSA9IHRoaXMuYnVpbGRWaWV3QXBpKHZpZXdUeXBlLCB0aGlzLmdldEN1cnJlbnREYXRhLCBvcHRpb25zRGF0YS5kYXRlRW52KTtcbiAgICAgICAgcmV0dXJuIHsgdmlld1NwZWM6IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpOiB2aWV3QXBpIH07XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUmF3Vmlld09wdGlvbnMgPSBmdW5jdGlvbiAodmlld1NwZWMsIHBsdWdpbkhvb2tzLCBsb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIHZhciByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByZWZpbmVycyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgVklFV19PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICB2YXIgcmVmaW5lZCA9IHt9O1xuICAgICAgICB2YXIgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQ7XG4gICAgICAgIHZhciBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZDtcbiAgICAgICAgdmFyIGFueUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dHJhID0ge307XG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSwgY3VycmVudFJhd1tvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbb3B0aW9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgaW4gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCkgeyAvLyBtaWdodCBiZSBhbiBcImV4dHJhXCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmaW5lcnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSByYXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhckRhdGFNYW5hZ2VyO1xufSgpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudih0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xuICAgIHZhciBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgICAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgICAgIGZpcnN0RGF5OiBmaXJzdERheSxcbiAgICAgICAgd2Vla1RleHQ6IHdlZWtUZXh0LFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IHBsdWdpbkhvb2tzLmNtZEZvcm1hdHRlcixcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogZGVmYXVsdFNlcGFyYXRvcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUob3B0aW9ucywgcGx1Z2luSG9va3MpIHtcbiAgICB2YXIgVGhlbWVDbGFzcyA9IHBsdWdpbkhvb2tzLnRoZW1lQ2xhc3Nlc1tvcHRpb25zLnRoZW1lU3lzdGVtXSB8fCBTdGFuZGFyZFRoZW1lO1xuICAgIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IocHJvcHMpIHtcbiAgICB2YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgcmV0dXJuIG5ldyBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgIHJldHVybiBuZXcgVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gZXZlbnRTb3VyY2UudWk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XG4gICAgdmFyIGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjYWxlbmRhckNvbnRleHQub3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFVpU2luZ2xlQmFzZTogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBvcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogb3B0aW9ucy5ldmVudFN0YXJ0RWRpdGFibGUsXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuZXZlbnRDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuZXZlbnRPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmV2ZW50T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuZXZlbnRCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ldmVudEJvcmRlckNvbG9yLFxuICAgICAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuZXZlbnRDb2xvcixcbiAgICAgICAgICAgIC8vIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzIC8vIHJlbmRlciBob29rIHdpbGwgaGFuZGxlIHRoaXNcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IG9wdGlvbnMuc2VsZWN0Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLnNlbGVjdEFsbG93LFxuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNMb2FkaW5nKHN0YXRlLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpc0xvYWRpbmdGdW5jID0gX2FbX2ldO1xuICAgICAgICBpZiAoaXNMb2FkaW5nRnVuYyhzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQub3B0aW9ucy5idXNpbmVzc0hvdXJzLCBjYWxlbmRhckNvbnRleHQpO1xufVxuZnVuY3Rpb24gd2FyblVua25vd25PcHRpb25zKG9wdGlvbnMsIHZpZXdOYW1lKSB7XG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gb3B0aW9uICdcIiArIG9wdGlvbk5hbWUgKyBcIidcIiArXG4gICAgICAgICAgICAodmlld05hbWUgPyBcIiBmb3IgdmlldyAnXCIgKyB2aWV3TmFtZSArIFwiJ1wiIDogJycpKTtcbiAgICB9XG59XG5cbi8vIFRPRE86IG1vdmUgdGhpcyB0byByZWFjdCBwbHVnaW4/XG52YXIgQ2FsZW5kYXJEYXRhUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKENhbGVuZGFyRGF0YVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyRGF0YVByb3ZpZGVyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGF0YU1hbmFnZXIpIHsgLy8gc3RpbGwgd2l0aGluIGluaXRpYWwgcnVuLCBiZWZvcmUgYXNzaWdubWVudCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kaXJlY3QtbXV0YXRpb24tc3RhdGVcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IGRhdGE7IC8vIGNhbid0IHVzZSBzZXRTdGF0ZSB5ZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kYXRhTWFuYWdlciA9IG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlczogcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgb25EYXRhOiBfdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYWxlbmRhckRhdGFQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YVByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25PdmVycmlkZXMgPSB0aGlzLnByb3BzLm9wdGlvbk92ZXJyaWRlcztcbiAgICAgICAgaWYgKG5ld09wdGlvbk92ZXJyaWRlcyAhPT0gcHJldlByb3BzLm9wdGlvbk92ZXJyaWRlcykgeyAvLyBwcmV2ZW50IHJlY3Vyc2l2ZSBoYW5kbGVEYXRhXG4gICAgICAgICAgICB0aGlzLmRhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhuZXdPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRhUHJvdmlkZXI7XG59KHZkb21fY2pzLkNvbXBvbmVudCkpO1xuXG4vLyBIRUxQRVJTXG4vKlxuaWYgbmV4dERheVRocmVzaG9sZCBpcyBzcGVjaWZpZWQsIHNsaWNpbmcgaXMgZG9uZSBpbiBhbiBhbGwtZGF5IGZhc2hpb24uXG55b3UgY2FuIGdldCBuZXh0RGF5VGhyZXNob2xkIGZyb20gY29udGV4dC5uZXh0RGF5VGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudHMocHJvcHMsIGFsbERheSkge1xuICAgIHJldHVybiBzbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBwcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgYWxsRGF5ID8gcHJvcHMubmV4dERheVRocmVzaG9sZCA6IG51bGwpLmZnO1xufVxuXG52YXIgTmFtZWRUaW1lWm9uZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZWRUaW1lWm9uZUltcGw7XG59KCkpO1xuXG52YXIgU2VnSGllcmFyY2h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgLy8gc2V0dGluZ3NcbiAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XG4gICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxuICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xuICAgIH1cbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoaW5wdXRzKSB7XG4gICAgICAgIHZhciBoaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW5wdXRzXzEgPSBpbnB1dHM7IF9pIDwgaW5wdXRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dHNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KGlucHV0LCBoaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuRW50cmllcztcbiAgICB9O1xuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaW5zZXJ0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIGluc2VydGlvbiA9IHRoaXMuZmluZEluc2VydGlvbihlbnRyeSk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uLCBlbnRyeSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmlzSW5zZXJ0aW9uVmFsaWQgPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4Q29vcmQgPT09IC0xIHx8IGluc2VydGlvbi5sZXZlbENvb3JkICsgZW50cnkudGhpY2tuZXNzIDw9IHRoaXMubWF4Q29vcmQpICYmXG4gICAgICAgICAgICAodGhpcy5tYXhTdGFja0NudCA9PT0gLTEgfHwgaW5zZXJ0aW9uLnN0YWNrQ250IDwgdGhpcy5tYXhTdGFja0NudCk7XG4gICAgfTtcbiAgICAvLyByZXR1cm5zIG51bWJlciBvZiBuZXcgZW50cmllcyBpbnNlcnRlZFxuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbiA9IGZ1bmN0aW9uIChpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nICYmIGluc2VydGlvbi50b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEVudHJ5KGVudHJ5LCBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnNwbGl0RW50cnkgPSBmdW5jdGlvbiAoZW50cnksIGJhcnJpZXIsIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIHBhcnRDbnQgPSAwO1xuICAgICAgICB2YXIgc3BsaXRIaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIHZhciBlbnRyeVNwYW4gPSBlbnRyeS5zcGFuO1xuICAgICAgICB2YXIgYmFycmllclNwYW4gPSBiYXJyaWVyLnNwYW47XG4gICAgICAgIGlmIChlbnRyeVNwYW4uc3RhcnQgPCBiYXJyaWVyU3Bhbi5zdGFydCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogZW50cnlTcGFuLnN0YXJ0LCBlbmQ6IGJhcnJpZXJTcGFuLnN0YXJ0IH0sXG4gICAgICAgICAgICB9LCBzcGxpdEhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICAgICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBiYXJyaWVyU3Bhbi5lbmQsIGVuZDogZW50cnlTcGFuLmVuZCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydENudCkge1xuICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoLmFwcGx5KGhpZGRlbkVudHJpZXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3tcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogaW50ZXJzZWN0U3BhbnMoYmFycmllclNwYW4sIGVudHJ5U3BhbiksIC8vIGd1YXJhbnRlZWQgdG8gaW50ZXJzZWN0XG4gICAgICAgICAgICAgICAgfV0sIHNwbGl0SGlkZGVuRW50cmllcykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRDbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmluc2VydEVudHJ5QXQgPSBmdW5jdGlvbiAoZW50cnksIGluc2VydGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uLmxhdGVyYWwgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGxldmVsQ29vcmRzLCBpbnNlcnRpb24ubGV2ZWwsIGluc2VydGlvbi5sZXZlbENvb3JkKTtcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsLCBpbnNlcnRpb24ubGV2ZWwsIFtlbnRyeV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGludG8gZXhpc3RpbmcgbGV2ZWxcbiAgICAgICAgICAgIGluc2VydEF0KGVudHJpZXNCeUxldmVsW2luc2VydGlvbi5sZXZlbF0sIGluc2VydGlvbi5sYXRlcmFsLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFja0NudHNbYnVpbGRFbnRyeUtleShlbnRyeSldID0gaW5zZXJ0aW9uLnN0YWNrQ250O1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5maW5kSW5zZXJ0aW9uID0gZnVuY3Rpb24gKG5ld0VudHJ5KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyID0gX2Euc3RyaWN0T3JkZXIsIHN0YWNrQ250cyA9IF9hLnN0YWNrQ250cztcbiAgICAgICAgdmFyIGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgICAgICB2YXIgY2FuZGlkYXRlQ29vcmQgPSAwO1xuICAgICAgICB2YXIgdG91Y2hpbmdMZXZlbCA9IC0xO1xuICAgICAgICB2YXIgdG91Y2hpbmdMYXRlcmFsID0gLTE7XG4gICAgICAgIHZhciB0b3VjaGluZ0VudHJ5ID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YWNrQ250ID0gMDtcbiAgICAgICAgZm9yICh2YXIgdHJhY2tpbmdMZXZlbCA9IDA7IHRyYWNraW5nTGV2ZWwgPCBsZXZlbENudDsgdHJhY2tpbmdMZXZlbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdDb29yZCA9IGxldmVsQ29vcmRzW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgcGFzdCB0aGUgcGxhY2VkIGVudHJ5LCB3ZSBoYXZlIGZvdW5kIGEgZ29vZCBlbXB0eSBzcGFjZSBhbmQgY2FuIHN0b3AuXG4gICAgICAgICAgICAvLyBpZiBzdHJpY3RPcmRlciwga2VlcCBmaW5kaW5nIG1vcmUgbGF0ZXJhbCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICAgICAgaWYgKCFzdHJpY3RPcmRlciAmJiB0cmFja2luZ0Nvb3JkID49IGNhbmRpZGF0ZUNvb3JkICsgbmV3RW50cnkudGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBzZWFyY2hSZXMgPSBiaW5hcnlTZWFyY2godHJhY2tpbmdFbnRyaWVzLCBuZXdFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpOyAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICAgICAgICB2YXIgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB0cmFja2luZ0VudHJ5LnNwYW4uc3RhcnQgPCBuZXdFbnRyeS5zcGFuLmVuZCAvLyBhbmQgbm90IGVudGlyZWx5IHBhc3QgbmV3RW50cnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRyYWNraW5nRW50cnkudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdHMgaW50byB0aGUgdG9wIG9mIHRoZSBjYW5kaWRhdGU/XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVDb29yZCA9IHRyYWNraW5nRW50cnlCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsID0gdHJhY2tpbmdMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsID0gbGF0ZXJhbEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tDbnQgPSBNYXRoLm1heChzdGFja0NudCwgc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkodHJhY2tpbmdFbnRyeSldICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhdGVyYWxJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkZXN0aW5hdGlvbiBsZXZlbCB3aWxsIGJlIGFmdGVyIHRvdWNoaW5nRW50cnkncyBsZXZlbC4gZmluZCBpdFxuICAgICAgICB2YXIgZGVzdExldmVsID0gMDtcbiAgICAgICAgaWYgKHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGRlc3RMZXZlbCA9IHRvdWNoaW5nTGV2ZWwgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPCBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgIGRlc3RMZXZlbCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFkZGluZyB0byBhbiBleGlzdGluZyBsZXZlbCwgZmluZCB3aGVyZSB0byBpbnNlcnRcbiAgICAgICAgdmFyIGRlc3RMYXRlcmFsID0gLTE7XG4gICAgICAgIGlmIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgZGVzdExhdGVyYWwgPSBiaW5hcnlTZWFyY2goZW50cmllc0J5TGV2ZWxbZGVzdExldmVsXSwgbmV3RW50cnkuc3Bhbi5lbmQsIGdldEVudHJ5U3BhbkVuZClbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWw6IHRvdWNoaW5nTGV2ZWwsXG4gICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWw6IHRvdWNoaW5nTGF0ZXJhbCxcbiAgICAgICAgICAgIHRvdWNoaW5nRW50cnk6IHRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzdGFja0NudDogc3RhY2tDbnQsXG4gICAgICAgICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgICAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICAgICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLnRvUmVjdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzID0gX2EubGV2ZWxDb29yZHM7XG4gICAgICAgIHZhciBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgICAgICB2YXIgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18xID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19pXTtcbiAgICAgICAgICAgICAgICByZWN0cy5wdXNoKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBlbnRyeSksIHsgbGV2ZWxDb29yZDogbGV2ZWxDb29yZCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH07XG4gICAgcmV0dXJuIFNlZ0hpZXJhcmNoeTtcbn0oKSk7XG5mdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XG59XG5mdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcbn1cbi8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcbmZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XG4gICAgdmFyIG1lcmdlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgZW50cmllc18yID0gZW50cmllczsgX2kgPCBlbnRyaWVzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMltfaV07XG4gICAgICAgIHZhciBmaWx0ZXJlZE1lcmdlcyA9IFtdO1xuICAgICAgICB2YXIgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICBzcGFuOiBlbnRyeS5zcGFuLFxuICAgICAgICAgICAgZW50cmllczogW2VudHJ5XSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBtZXJnZXNfMSA9IG1lcmdlczsgX2EgPCBtZXJnZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IG1lcmdlc18xW19hXTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xuICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcbiAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZXM7XG59XG5mdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XG4gICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBnZW5lcmFsIHV0aWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xuICAgIHZhciBzdGFydEluZGV4ID0gMDtcbiAgICB2YXIgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXG4gICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXG4gICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xuICAgIH1cbiAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgIHZhciBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XG4gICAgICAgIHZhciBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcbiAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xuICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxuICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcbn1cblxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVyYWN0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkID0gc2V0dGluZ3MuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbDtcbiAgICB9XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICByZXR1cm4gSW50ZXJhY3Rpb247XG59KCkpO1xuZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgZWw6IGlucHV0LmVsLFxuICAgICAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IGlucHV0LmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVtzZXR0aW5ncy5jb21wb25lbnQudWlkXSA9IHNldHRpbmdzLFxuICAgICAgICBfYTtcbn1cbi8vIGdsb2JhbCBzdGF0ZVxudmFyIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xuXG4vKlxuQW4gYWJzdHJhY3Rpb24gZm9yIGEgZHJhZ2dpbmcgaW50ZXJhY3Rpb24gb3JpZ2luYXRpbmcgb24gYW4gZXZlbnQuXG5Eb2VzIGhpZ2hlci1sZXZlbCB0aGluZ3MgdGhhbiBQb2ludGVyRHJhZ2dlciwgc3VjaCBhcyBwb3NzaWJseTpcbi0gYSBcIm1pcnJvclwiIHRoYXQgbW92ZXMgd2l0aCB0aGUgcG9pbnRlclxuLSBhIG1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyBvciBvdGhlciBjcml0ZXJpYSBmb3IgYSB0cnVlIGRyYWcgdG8gYmVnaW5cblxuc3ViY2xhc3NlcyBtdXN0IGVtaXQ6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBkcmFnbW92ZVxuLSBwb2ludGVydXBcbi0gZHJhZ2VuZFxuKi9cbnZhciBFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudERyYWdnaW5nKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvck5lZWRzUmV2ZXJ0ID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9O1xuICAgIEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnREcmFnZ2luZztcbn0oKSk7XG5cbi8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBpbiBmYXZvciBvZiBvcHRpb25zIHN5c3RlbSxcbi8vIHRobyBpdCdzIHJlYWxseSBlYXN5IHRvIGFjY2VzcyB0aGlzIGdsb2JhbGx5IHJhdGhlciB0aGFuIHBhc3MgdGhydSBvcHRpb25zLlxudmFyIGNvbmZpZyA9IHt9O1xuXG4vKlxuSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxub250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXG4qL1xudmFyIERSQUdfTUVUQV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBjcmVhdGU6IEJvb2xlYW4sXG4gICAgc291cmNlSWQ6IFN0cmluZyxcbn07XG5mdW5jdGlvbiBwYXJzZURyYWdNZXRhKHJhdykge1xuICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKSwgcmVmaW5lZCA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxuICAgICAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgICAgICBjcmVhdGU6IHJlZmluZWQuY3JlYXRlICE9IG51bGwgPyByZWZpbmVkLmNyZWF0ZSA6IHRydWUsXG4gICAgICAgIHNvdXJjZUlkOiByZWZpbmVkLnNvdXJjZUlkLFxuICAgICAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgICB9O1xufVxuXG52YXIgVG9vbGJhclNlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRvb2xiYXJTZWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJTZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXJTZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcChmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHsgcmV0dXJuIF90aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKTsgfSk7XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfV0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBUb29sYmFyU2VjdGlvbi5wcm90b3R5cGUucmVuZGVyV2lkZ2V0R3JvdXAgPSBmdW5jdGlvbiAod2lkZ2V0R3JvdXApIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jb250ZXh0LnRoZW1lO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHdpZGdldEdyb3VwXzEgPSB3aWRnZXRHcm91cDsgX2kgPCB3aWRnZXRHcm91cF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHdpZGdldCA9IHdpZGdldEdyb3VwXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbk5hbWUgPSB3aWRnZXQuYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2sgPSB3aWRnZXQuYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQgPSB3aWRnZXQuYnV0dG9uVGV4dCwgYnV0dG9uSWNvbiA9IHdpZGdldC5idXR0b25JY29uLCBidXR0b25IaW50ID0gd2lkZ2V0LmJ1dHRvbkhpbnQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJmYy10b29sYmFyLXRpdGxlXCIsIGlkOiBwcm9wcy50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQcmVzc2VkID0gYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uO1xuICAgICAgICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcyA9IFtcImZjLVwiICsgYnV0dG9uTmFtZSArIFwiLWJ1dHRvblwiLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godmRvbV9janMuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiB0eXBlb2YgYnV0dG9uSGludCA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkhpbnQocHJvcHMubmF2VW5pdCkgOiBidXR0b25IaW50LCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgXCJhcmlhLXByZXNzZWRcIjogaXNQcmVzc2VkLCBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiBidXR0b25DbGljayB9LCBidXR0b25UZXh0IHx8IChidXR0b25JY29uID8gdmRvbV9janMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkljb24gfSkgOiAnJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwQ2xhc3NOYW1lID0gKGlzT25seUJ1dHRvbnMgJiYgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFsnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH1dLCBjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblswXTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyU2VjdGlvbjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVG9vbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVG9vbGJhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbW9kZWwgPSBfYS5tb2RlbCwgZXh0cmFDbGFzc05hbWUgPSBfYS5leHRyYUNsYXNzTmFtZTtcbiAgICAgICAgdmFyIGZvcmNlTHRyID0gZmFsc2U7XG4gICAgICAgIHZhciBzdGFydENvbnRlbnQ7XG4gICAgICAgIHZhciBlbmRDb250ZW50O1xuICAgICAgICB2YXIgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcbiAgICAgICAgdmFyIGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XG4gICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAgICAgICAnZmMtdG9vbGJhcicsXG4gICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIChrZXksIHdpZGdldEdyb3Vwcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2xiYXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gVE9ETzogZG8gZnVuY3Rpb24gY29tcG9uZW50P1xudmFyIFZpZXdDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFZpZXdDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgdmFyIGFzcGVjdFJhdGlvID0gcHJvcHMuYXNwZWN0UmF0aW87XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXZpZXctaGFybmVzcycsXG4gICAgICAgICAgICAoYXNwZWN0UmF0aW8gfHwgcHJvcHMubGlxdWlkIHx8IHByb3BzLmhlaWdodClcbiAgICAgICAgICAgICAgICA/ICdmYy12aWV3LWhhcm5lc3MtYWN0aXZlJyAvLyBoYXJuZXNzIGNvbnRyb2xzIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZWlnaHQgPSAnJztcbiAgICAgICAgdmFyIHBhZGRpbmdCb3R0b20gPSAnJztcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzdGF0ZS5hdmFpbGFibGVXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2lsbCBjYXVzZSBsb3RzIG9mIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMgd2l0aGluIHNjcm9sbGdyaWQuXG4gICAgICAgICAgICAgICAgLy8gQkVUVEVSOiBkb24ndCBzdGFydCByZW5kZXJpbmcgQU5ZVEhJTkcgeWV0IHVudGlsIHdlIGtub3cgY29udGFpbmVyIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9ICgxIC8gYXNwZWN0UmF0aW8pICogMTAwICsgXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogcHJvcHMubGFiZWxlZEJ5SWQsIHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBoZWlnaHQsIHBhZGRpbmdCb3R0b206IHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS51cGRhdGVBdmFpbGFibGVXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbnRhaW5lcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xudmFyIEV2ZW50Q2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEV2ZW50Q2xpY2tpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRDbGlja2luZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2sgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXG4gICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xuICAgICAgICAgICAgICAgIHZhciBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbXBvbmVudC5jb250ZXh0LCBzZWcuZXZlbnRSYW5nZS5kZWYsIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXJsICYmICFldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnQ2xpY2spO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFdmVudENsaWNraW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbnZhciBFdmVudEhvdmVyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudEhvdmVyaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50SG92ZXJpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxuICAgICAgICBfdGhpcy5oYW5kbGVFdmVudEVsUmVtb3ZlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IF90aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIF90aGlzLmN1cnJlbnRTZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0VudGVyID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckV2ZW50KCdldmVudE1vdXNlRW50ZXInLCBldiwgc2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2VnRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdFbnRlciwgX3RoaXMuaGFuZGxlU2VnTGVhdmUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIEV2ZW50SG92ZXJpbmcucHJvdG90eXBlLnRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudEhvdmVyaW5nO1xufShJbnRlcmFjdGlvbikpO1xuXG52YXIgQ2FsZW5kYXJDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDYWxlbmRhckNvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dCk7XG4gICAgICAgIF90aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICBfdGhpcy5idWlsZFRvb2xiYXJQcm9wcyA9IG1lbW9pemUoYnVpbGRUb29sYmFyUHJvcHMpO1xuICAgICAgICBfdGhpcy5oZWFkZXJSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuZm9vdGVyUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmludGVyYWN0aW9uc1N0b3JlID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KTtcbiAgICAgICAgICAgIHZhciBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcbiAgICAgICAgICAgICAgICBFdmVudENsaWNraW5nLFxuICAgICAgICAgICAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uQ2xhc3NlcyA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdChfdGhpcy5wcm9wcy5wbHVnaW5Ib29rcy5jb21wb25lbnRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9ucyA9IGludGVyYWN0aW9uQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUludGVyYWN0aW9uQ2xhc3MpIHsgcmV0dXJuIG5ldyBUaGVJbnRlcmFjdGlvbkNsYXNzKHNldHRpbmdzKTsgfSk7XG4gICAgICAgICAgICBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaXN0ZW5lcnNfMSA9IGxpc3RlbmVyczsgX2kgPCBsaXN0ZW5lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIF90aGlzLnJlc2l6ZVJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cbiAgICAgICAgICAgIF90aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignd2luZG93UmVzaXplJywgeyB2aWV3OiBfdGhpcy5wcm9wcy52aWV3QXBpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaGFuZGxlV2luZG93UmVzaXplID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLnByb3BzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAvLyBhdm9pZCBqcXVpIGV2ZW50c1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLypcbiAgICByZW5kZXJzIElOU0lERSBvZiBhbiBvdXRlciBkaXZcbiAgICAqL1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHByb3BzLnRvb2xiYXJDb25maWcsIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zO1xuICAgICAgICB2YXIgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhwcm9wcy52aWV3U3BlYywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5jdXJyZW50RGF0ZSwgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgICBwcm9wcy52aWV3VGl0bGUpO1xuICAgICAgICB2YXIgdmlld1ZHcm93ID0gZmFsc2U7XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIHZhciB2aWV3QXNwZWN0UmF0aW87XG4gICAgICAgIGlmIChwcm9wcy5pc0hlaWdodEF1dG8gfHwgcHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3Vkdyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY29udGVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gb3B0aW9ucy5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlld0FzcGVjdFJhdGlvID0gTWF0aC5tYXgob3B0aW9ucy5hc3BlY3RSYXRpbywgMC41KTsgLy8gcHJldmVudCBmcm9tIGdldHRpbmcgdG9vIHRhbGxcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0NvbnRleHQgPSB0aGlzLmJ1aWxkVmlld0NvbnRleHQocHJvcHMudmlld1NwZWMsIHByb3BzLnZpZXdBcGksIHByb3BzLm9wdGlvbnMsIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLCBwcm9wcy5kYXRlRW52LCBwcm9wcy50aGVtZSwgcHJvcHMucGx1Z2luSG9va3MsIHByb3BzLmRpc3BhdGNoLCBwcm9wcy5nZXRDdXJyZW50RGF0YSwgcHJvcHMuZW1pdHRlciwgcHJvcHMuY2FsZW5kYXJBcGksIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpO1xuICAgICAgICB2YXIgdmlld0xhYmVsSWQgPSAodG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgdG9vbGJhckNvbmZpZy5oZWFkZXIuaGFzVGl0bGUpXG4gICAgICAgICAgICA/IHRoaXMuc3RhdGUudmlld0xhYmVsSWRcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIsIHsgdmFsdWU6IHZpZXdDb250ZXh0IH0sXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChUb29sYmFyLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGxpcXVpZDogdmlld1ZHcm93LCBoZWlnaHQ6IHZpZXdIZWlnaHQsIGFzcGVjdFJhdGlvOiB2aWV3QXNwZWN0UmF0aW8sIGxhYmVsZWRCeUlkOiB2aWV3TGFiZWxJZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmZvb3RlciAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChUb29sYmFyLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSB7IHJldHVybiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKTsgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBwcm9wU2V0SGFuZGxlcnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5wcm9wU2V0SGFuZGxlcnM7XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPT0gcHJldlByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyLmNsZWFyKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5idWlsZEFwcGVuZENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcChmdW5jdGlvbiAoYnVpbGRBcHBlbmRDb250ZW50KSB7IHJldHVybiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpOyB9KTtcbiAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt2ZG9tX2Nqcy5GcmFnbWVudCwge31dLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJDb250ZW50LnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICB2YXIgdmlld1NwZWMgPSBwcm9wcy52aWV3U3BlYztcbiAgICAgICAgdmFyIHZpZXdQcm9wcyA9IHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBwcm9wcy5yZW5kZXJhYmxlRXZlbnRTdG9yZSxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLFxuICAgICAgICAgICAgaXNIZWlnaHRBdXRvOiBwcm9wcy5pc0hlaWdodEF1dG8sXG4gICAgICAgICAgICBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lcnMgPSB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMocGx1Z2luSG9va3Mudmlld1Byb3BzVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgICAgIHRzbGliLl9fYXNzaWduKHZpZXdQcm9wcywgdHJhbnNmb3JtZXIudHJhbnNmb3JtKHZpZXdQcm9wcywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVmlld0NvbXBvbmVudCA9IHZpZXdTcGVjLmNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb21wb25lbnQsIHRzbGliLl9fYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJDb250ZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBidWlsZFRvb2xiYXJQcm9wcyh2aWV3U3BlYywgZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBjdXJyZW50RGF0ZSwgbm93LCB0aXRsZSkge1xuICAgIC8vIGRvbid0IGZvcmNlIGFueSBkYXRlLXByb2ZpbGVzIHRvIHZhbGlkIGRhdGUgcHJvZmlsZXMgKHRoZSBgZmFsc2VgKSBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIGl0J3MgaW52YWxpZFxuICAgIHZhciB0b2RheUluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3csIHVuZGVmaW5lZCwgZmFsc2UpOyAvLyBUT0RPOiBuZWVkIGB1bmRlZmluZWRgIG9yIGVsc2UgSU5GSU5JVEUgTE9PUCBmb3Igc29tZSByZWFzb25cbiAgICB2YXIgcHJldkluZm8gPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoZGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmYWxzZSk7XG4gICAgdmFyIG5leHRJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFRoZUNsYXNzKSB7IHJldHVybiBuZXcgVGhlQ2xhc3MoKTsgfSk7XG59XG5cbnZhciBDYWxlbmRhclJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKENhbGVuZGFyUm9vdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhclJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZvclByaW50OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVBZnRlclByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICAgICAgdmFyIGZvclByaW50ID0gdGhpcy5zdGF0ZS5mb3JQcmludDtcbiAgICAgICAgdmFyIGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgICAgIHZhciBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjJyxcbiAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgICAgICAgXCJmYy1kaXJlY3Rpb24tXCIgKyBvcHRpb25zLmRpcmVjdGlvbixcbiAgICAgICAgICAgIHByb3BzLnRoZW1lLmdldENsYXNzKCdyb290JyksXG4gICAgICAgIF07XG4gICAgICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KTtcbiAgICB9O1xuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5wcm9wcy5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJSb290LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVtaXR0ZXIgPSB0aGlzLnByb3BzLmVtaXR0ZXI7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcbiAgICAgICAgZW1pdHRlci5vZmYoJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxlbmRhclJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuZnVuY3Rpb24gY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXlDbnQpIHtcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxuICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICAgIGlmICghZGF0ZXNSZXBEaXN0aW5jdERheXMgfHwgZGF5Q250ID4gMTApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSk7IC8vIFwiU2F0XCJcbiAgICB9XG4gICAgaWYgKGRheUNudCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnLCBvbWl0Q29tbWFzOiB0cnVlIH0pOyAvLyBcIlNhdCAxMS8xMlwiXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7IC8vIFwiU2F0dXJkYXlcIlxufVxuXG52YXIgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5mdW5jdGlvbiByZW5kZXJJbm5lciQxKGhvb2tQcm9wcykge1xuICAgIHJldHVybiBob29rUHJvcHMudGV4dDtcbn1cblxudmFyIFRhYmxlRGF0ZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlRGF0ZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEYXRlQ2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZURhdGVDZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaTtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICAvLyBpZiBjb2xDbnQgaXMgMSwgd2UgYXJlIGFscmVhZHkgaW4gYSBkYXktdmlldyBhbmQgZG9uJ3QgbmVlZCBhIG5hdmxpbmtcbiAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9ICghZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF0ZSlcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiB2aWV3QXBpIH0sIHByb3BzLmV4dHJhSG9va1Byb3BzKSwgeyB0ZXh0OiB0ZXh0IH0pLCBkYXlNZXRhKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXIkMSwgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCByb2xlOiBcImNvbHVtbmhlYWRlclwiLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgXCJkYXRhLWRhdGVcIjogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCwgY29sU3BhbjogcHJvcHMuY29sU3BhbiB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiIH0sICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCkpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEYXRlQ2VsbDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgV0VFS0RBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnbG9uZycgfSk7XG52YXIgVGFibGVEb3dDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZURvd0NlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVEb3dDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlRG93Q2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCB0aGVtZSA9IF9hLnRoZW1lLCB2aWV3QXBpID0gX2Eudmlld0FwaSwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgICAgIHZhciBkYXRlTWV0YSA9IHtcbiAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF0ZU1ldGEsIHRoZW1lKSwgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFIb29rUHJvcHMpLCB7IHRleHQ6IHRleHQgfSk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyJDEsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwidGhcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgXCJhcmlhLWxhYmVsXCI6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgPyAnZmMtc3RpY2t5JyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZURvd0NlbGw7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIE5vd1RpbWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhOb3dUaW1lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3dUaW1lcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTm93VGltZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMudW5pdCAhPT0gdGhpcy5wcm9wcy51bml0KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wdXRlVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xuICAgICAgICB2YXIgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xuICAgICAgICB2YXIgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcbiAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIHdhaXRNczogd2FpdE1zLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcHV0ZVRpbWluZygpLCBuZXh0U3RhdGUgPSBfYS5uZXh0U3RhdGUsIHdhaXRNcyA9IF9hLndhaXRNcztcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKG5leHRTdGF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB3YWl0TXMpO1xuICAgIH07XG4gICAgTm93VGltZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3dUaW1lci5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gTm93VGltZXI7XG59KHZkb21fY2pzLkNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xufVxuXG52YXIgRGF5SGVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5SGVhZGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUhlYWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZXMgPSBfYS5kYXRlcywgZGF0ZVByb2ZpbGUgPSBfYS5kYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXMgPSBfYS5kYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gPSBfYS5yZW5kZXJJbnRybztcbiAgICAgICAgdmFyIGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCBmdW5jdGlvbiAobm93RGF0ZSwgdG9kYXlSYW5nZSkgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcbiAgICAgICAgICAgIGRhdGVzLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpOyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5SGVhZGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gICAgcmV0dXJuIGV4cGxpY2l0Rm9ybWF0IHx8IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCk7XG59XG5cbnZhciBEYXlTZXJpZXNNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEYXlTZXJpZXNNb2RlbChyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICAgICAgdmFyIGRhdGUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcbiAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgRGF5U2VyaWVzTW9kZWwucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgdmFyIGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgoYWRkRGF5cyhyYW5nZS5lbmQsIC0xKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG4gICAgICAgIHZhciBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGgubWF4KDAsIGZpcnN0SW5kZXgpO1xuICAgICAgICB2YXIgY2xpcHBlZExhc3RJbmRleCA9IE1hdGgubWluKHRoaXMuY250IC0gMSwgbGFzdEluZGV4KTtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xuICAgICAgICBjbGlwcGVkRmlyc3RJbmRleCA9IE1hdGguY2VpbChjbGlwcGVkRmlyc3RJbmRleCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgICAgICBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5mbG9vcihjbGlwcGVkTGFzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxuICAgICAgICBpZiAoY2xpcHBlZEZpcnN0SW5kZXggPD0gY2xpcHBlZExhc3RJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXg6IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmlyc3RJbmRleCA9PT0gY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgICBEYXlTZXJpZXNNb2RlbC5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGljZXM7XG4gICAgICAgIHZhciBkYXlPZmZzZXQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRoaXMuZGF0ZXNbMF0sIGRhdGUpKTtcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzWzBdIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlc1tkYXlPZmZzZXRdO1xuICAgIH07XG4gICAgcmV0dXJuIERheVNlcmllc01vZGVsO1xufSgpKTtcblxudmFyIERheVRhYmxlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGJyZWFrT25XZWVrcykge1xuICAgICAgICB2YXIgZGF0ZXMgPSBkYXlTZXJpZXMuZGF0ZXM7XG4gICAgICAgIHZhciBkYXlzUGVyUm93O1xuICAgICAgICB2YXIgZmlyc3REYXk7XG4gICAgICAgIHZhciByb3dDbnQ7XG4gICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XG4gICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcbiAgICB9XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRDZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZENlbGwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5idWlsZEhlYWRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZXM7XG4gICAgfTtcbiAgICBEYXlUYWJsZU1vZGVsLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcbiAgICAgICAgdmFyIHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICB2YXIgc2VncyA9IFtdO1xuICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RJbmRleCA9IHNlcmllc1NlZy5maXJzdEluZGV4LCBsYXN0SW5kZXggPSBzZXJpZXNTZWcubGFzdEluZGV4O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZmlyc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29sOiBpbmRleCAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZXJpZXNTZWcuaXNTdGFydCAmJiBpbmRleCA9PT0gZmlyc3RJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlcmllc1NlZy5pc0VuZCAmJiAobmV4dEluZGV4IC0gMSkgPT09IGxhc3RJbmRleCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZU1vZGVsO1xufSgpKTtcblxudmFyIFNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZXIoKSB7XG4gICAgICAgIHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZSh0aGlzLl9zbGljZUJ1c2luZXNzSG91cnMpO1xuICAgICAgICB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3Bhbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zbGljZUV2ZW50U3RvcmUpO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZTsgLy8gaGFja1xuICAgIH1cbiAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRVaUJhc2VzID0gcHJvcHMuZXZlbnRVaUJhc2VzO1xuICAgICAgICB2YXIgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZVNlbGVjdGlvblNlZ3M6IHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50VWlCYXNlcywgY29udGV4dF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICAgICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxuICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VOb3dEYXRlID0gZnVuY3Rpb24gKC8vIGRvZXMgbm90IG1lbW9pemVcbiAgICBkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbi5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgY29udGV4dF0sIGV4dHJhQXJncykpO1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VCdXNpbmVzc0hvdXJzID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2V4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBjb250ZXh0KSxcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkXSwgZXh0cmFBcmdzKSkuYmc7XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUV2ZW50U3RvcmUgPSBmdW5jdGlvbiAoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLl9zbGljZUludGVyYWN0aW9uID0gZnVuY3Rpb24gKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSA0OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ3M6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5mZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMsXG4gICAgICAgICAgICBpc0V2ZW50OiBpbnRlcmFjdGlvbi5pc0V2ZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGV4dHJhQXJnc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtkYXRlU3Bhbi5yYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9hIDwgc2Vnc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfYV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzLCBleHRyYUFyZ3MpIHtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudFJhbmdlc18xID0gZXZlbnRSYW5nZXM7IF9pIDwgZXZlbnRSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gZXZlbnRSYW5nZXNfMVtfaV07XG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICAvKlxuICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAgICovXG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZUV2ZW50UmFuZ2UgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSB7XG4gICAgICAgIHZhciBkYXRlUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAvLyBoYWNrIHRvIG1ha2UgbXVsdGktZGF5IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBmb3JjZS1kaXNwbGF5ZWQgYXMgbGlzdC1pdGVtcyB0byB0YWtlIHVwIG9ubHkgb25lIGRheVxuICAgICAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2RhdGVSYW5nZV0sIGV4dHJhQXJncykpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMltfaV07XG4gICAgICAgICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgICAgICBzZWcuaXNTdGFydCA9IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWcuaXNTdGFydDtcbiAgICAgICAgICAgIHNlZy5pc0VuZCA9IGV2ZW50UmFuZ2UuaXNFbmQgJiYgc2VnLmlzRW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlcjtcbn0oKSk7XG4vKlxuZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcblRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxuVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcbiovXG5mdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgdmFyIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XG4gICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxuICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XG4gICAgfTtcbn1cblxuLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZXMgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLmluc3RhbmNlcztcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgdmFyIHByb3BzID0gdHNsaWIuX19hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiAnJywgZXZlbnREcmFnOiBudWxsLCBldmVudFJlc2l6ZTogbnVsbCB9LCBuZXdQcm9wcyk7XG4gICAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBpZiAoZGF0ZVNwYW5NZXRhID09PSB2b2lkIDApIHsgZGF0ZVNwYW5NZXRhID0ge307IH1cbiAgICBpZiAoc3RhdGUuZXZlbnREcmFnICYmICFpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB2YXIgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWc7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xuICAgIHZhciBzdWJqZWN0RXZlbnRTdG9yZSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgdmFyIHN1YmplY3REZWZzID0gc3ViamVjdEV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgc3ViamVjdEluc3RhbmNlcyA9IHN1YmplY3RFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgc3ViamVjdENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoc3ViamVjdERlZnMsIGludGVyYWN0aW9uLmlzRXZlbnQgP1xuICAgICAgICBzdGF0ZS5ldmVudFVpQmFzZXMgOlxuICAgICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0pO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpO1xuICAgIH1cbiAgICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgICB2YXIgb3RoZXJFdmVudFN0b3JlID0gZXhjbHVkZUluc3RhbmNlcyhzdGF0ZS5ldmVudFN0b3JlLCBpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cy5pbnN0YW5jZXMpO1xuICAgIHZhciBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpO1xuICAgIGZvciAodmFyIHN1YmplY3RJbnN0YW5jZUlkIGluIHN1YmplY3RJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHN1YmplY3RJbnN0YW5jZSA9IHN1YmplY3RJbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICB2YXIgc3ViamVjdFJhbmdlID0gc3ViamVjdEluc3RhbmNlLnJhbmdlO1xuICAgICAgICB2YXIgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIHZhciBzdWJqZWN0RGVmID0gc3ViamVjdERlZnNbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgLy8gY29uc3RyYWludFxuICAgICAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVybGFwXG4gICAgICAgIHZhciBldmVudE92ZXJsYXAgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRPdmVybGFwO1xuICAgICAgICB2YXIgZXZlbnRPdmVybGFwRnVuYyA9IHR5cGVvZiBldmVudE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBldmVudE92ZXJsYXAgOiBudWxsO1xuICAgICAgICBmb3IgKHZhciBvdGhlckluc3RhbmNlSWQgaW4gb3RoZXJJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHZhciBvdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZXNbb3RoZXJJbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc3ViamVjdFJhbmdlLCBvdGhlckluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgb3RoZXIgZXZlbnQncyBvdmVybGFwLiBvbmx5IGRvIHRoaXMgaWYgdGhlIHN1YmplY3QgZXZlbnQgaXMgYSBcInJlYWxcIiBldmVudFxuICAgICAgICAgICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdENvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChldmVudE92ZXJsYXBGdW5jICYmICFldmVudE92ZXJsYXBGdW5jKG5ldyBFdmVudEFwaShjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgICAgICAgIG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgICAgICB2YXIgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdWJqZWN0Q29uZmlnLmFsbG93czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0QWxsb3cgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgc3ViamVjdERhdGVTcGFuID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHsgcmFuZ2U6IHN1YmplY3RJbnN0YW5jZS5yYW5nZSwgYWxsRGF5OiBzdWJqZWN0RGVmLmFsbERheSB9KTtcbiAgICAgICAgICAgIHZhciBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICB2YXIgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxuICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIHN1YmplY3REZWYpOyAvLyBubyBpbnN0YW5jZSwgYmVjYXVzZSBoYWQgbm8gZGF0ZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3ViamVjdEFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChzdWJqZWN0RGF0ZVNwYW4sIGNvbnRleHQpLCBldmVudEFwaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBEYXRlIFNlbGVjdGlvbiBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgdmFyIHJlbGV2YW50RXZlbnRTdG9yZSA9IHN0YXRlLmV2ZW50U3RvcmU7XG4gICAgdmFyIHJlbGV2YW50RGVmcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5kZWZzO1xuICAgIHZhciByZWxldmFudEluc3RhbmNlcyA9IHJlbGV2YW50RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLmRhdGVTZWxlY3Rpb247XG4gICAgdmFyIHNlbGVjdGlvblJhbmdlID0gc2VsZWN0aW9uLnJhbmdlO1xuICAgIHZhciBzZWxlY3Rpb25Db25maWcgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuc2VsZWN0aW9uQ29uZmlnO1xuICAgIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICAgICAgc2VsZWN0aW9uQ29uZmlnID0gZmlsdGVyQ29uZmlnKHNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gb3ZlcmxhcFxuICAgIHZhciBzZWxlY3RPdmVybGFwID0gY29udGV4dC5vcHRpb25zLnNlbGVjdE92ZXJsYXA7XG4gICAgdmFyIHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcbiAgICBmb3IgKHZhciByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xuICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY29udGV4dCwgcmVsZXZhbnREZWZzW3JlbGV2YW50SW5zdGFuY2UuZGVmSWRdLCByZWxldmFudEluc3RhbmNlKSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWxsb3cgKGEgZnVuY3Rpb24pXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNlbGVjdGlvbkNvbmZpZy5hbGxvd3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25BbGxvdyA9IF9hW19pXTtcbiAgICAgICAgdmFyIGZ1bGxEYXRlU3BhbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkFsbG93KGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gQ29uc3RyYWludCBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBhbGxDb25zdHJhaW50c1Bhc3MoY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgY29udGV4dCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgY29uc3RyYWludHNfMSA9IGNvbnN0cmFpbnRzOyBfaSA8IGNvbnN0cmFpbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNfMVtfaV07XG4gICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xub3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXG5idXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG5jb250ZXh0KSB7XG4gICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludDsgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2Vcbn1cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XG4gICAgdmFyIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XG5mdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIG91dGVyUmFuZ2VzXzEgPSBvdXRlclJhbmdlczsgX2kgPCBvdXRlclJhbmdlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb3V0ZXJSYW5nZSA9IG91dGVyUmFuZ2VzXzFbX2ldO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBWSVNJQkxFX0hJRERFTl9SRSA9IC9eKHZpc2libGV8aGlkZGVuKSQvO1xudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTY3JvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZUVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGxpcXVpZCA9IHByb3BzLmxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSA9IHByb3BzLmxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XG4gICAgICAgIGlmIChsaXF1aWQpIHtcbiAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLm5lZWRzWFNjcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxXaWR0aD5jbGllbnRXaWR0aCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5uZWVkc1lTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsSGVpZ2h0PmNsaWVudEhlaWdodCBpcyB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIgd2hlbiBwaXhlbCBoZWlnaHRzIGFyZW4ndCBpbnRlZ2Vycy5cbiAgICAgICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgICAgIC8vIGlubmVyLWNoaWxkIG1hcmdpbnMgYW5kIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgICAgIHZhciByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldEhlaWdodCAtIHRoaXMuZWwuY2xpZW50SGVpZ2h0OyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0WVNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbGVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8qXG5UT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xuVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXG4qL1xudmFyIFJlZk1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZNYXAobWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayA9IG1hc3RlckNhbGxiYWNrO1xuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWxsYmFja01hcCA9IHt9O1xuICAgICAgICB0aGlzLmhhbmRsZVZhbHVlID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgZGVwdGhzID0gX2EuZGVwdGhzLCBjdXJyZW50TWFwID0gX2EuY3VycmVudE1hcDtcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXN0ZXJDYWxsYmFjayh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFJlZk1hcC5wcm90b3R5cGUuY3JlYXRlUmVmID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XG4gICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVZhbHVlKHZhbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmQ2FsbGJhY2s7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAgIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAgIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICAgIFJlZk1hcC5wcm90b3R5cGUuY29sbGVjdCA9IGZ1bmN0aW9uIChzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdEZyb21IYXNoKHRoaXMuY3VycmVudE1hcCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApO1xuICAgIH07XG4gICAgUmVmTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWVzVG9BcnJheSh0aGlzLmN1cnJlbnRNYXApO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZk1hcDtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xuICAgIHZhciBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xuICAgIHZhciBsYXJnZXN0V2lkdGggPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgc2hyaW5rQ2VsbHNfMSA9IHNocmlua0NlbGxzOyBfaSA8IHNocmlua0NlbGxzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzaHJpbmtDZWxsID0gc2hyaW5rQ2VsbHNfMVtfaV07XG4gICAgICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KGxhcmdlc3RXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbChsYXJnZXN0V2lkdGgpOyAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBwcm9wcy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQ7IC8vIGRvZXMgdGhlIHNlY3Rpb24gZG8gbGlxdWlkLWhlaWdodD8gKG5lZWQgdG8gaGF2ZSB3aG9sZSBzY3JvbGxncmlkIGxpcXVpZC1oZWlnaHQgYXMgd2VsbClcbn1cbmZ1bmN0aW9uIGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykge1xuICAgIHJldHVybiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCAhPSBudWxsIHx8IC8vIGlmIGl0cyBwb3NzaWJsZSBmb3IgdGhlIGhlaWdodCB0byBtYXggb3V0LCB3ZSBtaWdodCBuZWVkIHNjcm9sbGJhcnNcbiAgICAgICAgZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7IC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cbi8vIFRPRE86IE9OTFkgdXNlIGBhcmdgLiBmb3JjZSBvdXQgaW50ZXJuYWwgZnVuY3Rpb24gdG8gdXNlIHNhbWUgQVBJXG5mdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWcsIGFyZywgaXNIZWFkZXIpIHtcbiAgICB2YXIgZXhwYW5kUm93cyA9IGFyZy5leHBhbmRSb3dzO1xuICAgIHZhciBjb250ZW50ID0gdHlwZW9mIGNodW5rQ29uZmlnLmNvbnRlbnQgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjaHVua0NvbmZpZy5jb250ZW50KGFyZykgOlxuICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgY2h1bmtDb25maWcudGFibGVDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgc2VjdGlvbkNvbmZpZy5zeW5jUm93SGVpZ2h0cyA/ICdmYy1zY3JvbGxncmlkLXN5bmMtdGFibGUnIDogJycsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdmRvbV9janMuY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aGVhZCcgOiAndGJvZHknLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdHlwZW9mIGNodW5rQ29uZmlnLnJvd0NvbnRlbnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2h1bmtDb25maWcucm93Q29udGVudChhcmcpXG4gICAgICAgICAgICA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIGlzQ29sUHJvcHNFcXVhbChjb2xzMCwgY29sczEpIHtcbiAgICByZXR1cm4gaXNBcnJheXNFcXVhbChjb2xzMCwgY29sczEsIGlzUHJvcHNFcXVhbCk7XG59XG5mdW5jdGlvbiByZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHNocmlua1dpZHRoKSB7XG4gICAgdmFyIGNvbE5vZGVzID0gW107XG4gICAgLypcbiAgICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gICAgSE9XRVZFUiwgQ2hyb21lIHdhcyBnZXR0aW5nIG1lc3NpbmcgdXAgZGlzdHJpYnV0aW5nIHRoZSB3aWR0aCB0byA8dGQ+Lzx0aD4gZWxlbWVudHMgd2l0aCBjb2xzcGFucy5cbiAgICBTT0xVVElPTjogbWFraW5nIGluZGl2aWR1YWwgPGNvbD4gZWxlbWVudHMgbWFrZXMgQ2hyb21lIGJlaGF2ZS5cbiAgICAqL1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sc18xID0gY29sczsgX2kgPCBjb2xzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb2xQcm9wcyA9IGNvbHNfMVtfaV07XG4gICAgICAgIHZhciBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sTm9kZXMucHVzaCh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiY29sXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ2NvbGdyb3VwJywge31dLCBjb2xOb2RlcykpO1xufVxuZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aCkge1xuICAgIC8qIHdoeSA0PyBpZiB3ZSBkbyAwLCBpdCB3aWxsIGtpbGwgYW55IGJvcmRlciwgd2hpY2ggYXJlIG5lZWRlZCBmb3IgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoXG4gICAgNCBhY2NvdW50cyBmb3IgMiAyLXBpeGVsIGJvcmRlcnMuIFRPRE86IGJldHRlciBzb2x1dGlvbj8gKi9cbiAgICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aDtcbn1cbmZ1bmN0aW9uIGhhc1Nocmlua1dpZHRoKGNvbHMpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHNfMiA9IGNvbHM7IF9pIDwgY29sc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sID0gY29sc18yW19pXTtcbiAgICAgICAgaWYgKGNvbC53aWR0aCA9PT0gJ3NocmluaycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKGxpcXVpZCwgY29udGV4dCkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgXTtcbiAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1saXF1aWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3cpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgICAgIFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLVwiICsgc2VjdGlvbkNvbmZpZy50eXBlLFxuICAgICAgICBzZWN0aW9uQ29uZmlnLmNsYXNzTmFtZSwgLy8gdXNlZD9cbiAgICBdO1xuICAgIGlmICh3aG9sZVRhYmxlVkdyb3cgJiYgc2VjdGlvbkNvbmZpZy5saXF1aWQgJiYgc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1saXF1aWQnKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25Db25maWcuaXNTdGlja3kpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Jyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gcmVuZGVyU2Nyb2xsU2hpbShhcmcpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IGFyZy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgfSB9KSk7XG59XG5mdW5jdGlvbiBnZXRTdGlja3lIZWFkZXJEYXRlcyhvcHRpb25zKSB7XG4gICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcztcbiAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gb3B0aW9ucy5zdGlja3lGb290ZXJTY3JvbGxiYXI7XG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XG59XG5cbnZhciBTaW1wbGVTY3JvbGxHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTaW1wbGVTY3JvbGxHcmlkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZVNjcm9sbEdyaWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcm9jZXNzQ29scyA9IG1lbW9pemUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGE7IH0sIGlzQ29sUHJvcHNFcXVhbCk7IC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG4gICAgICAgIC8vIHl1Y2t5IHRvIG1lbW9pemUgVk5vZGVzLCBidXQgbXVjaCBtb3JlIGVmZmljaWVudCBmb3IgY29uc3VtZXJzXG4gICAgICAgIF90aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAgPSBtZW1vaXplKHJlbmRlck1pY3JvQ29sR3JvdXApO1xuICAgICAgICBfdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcChfdGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKF90aGlzKSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGNhbiBkbyBhIHJlYWxseSBzaW1wbGUgcHJpbnQtdmlldy4gZG9udCBuZWVkIHRvIGpvaW4gcm93c1xuICAgICAgICBfdGhpcy5oYW5kbGVTaXppbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zYWZlU2V0U3RhdGUodHNsaWIuX19hc3NpZ24oeyBzaHJpbmtXaWR0aDogX3RoaXMuY29tcHV0ZVNocmlua1dpZHRoKCkgfSwgX3RoaXMuY29tcHV0ZVNjcm9sbGVyRGltcygpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlY3Rpb25Db25maWdzID0gcHJvcHMuc2VjdGlvbnMgfHwgW107XG4gICAgICAgIHZhciBjb2xzID0gdGhpcy5wcm9jZXNzQ29scyhwcm9wcy5jb2xzKTtcbiAgICAgICAgdmFyIG1pY3JvQ29sR3JvdXBOb2RlID0gdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHN0YXRlLnNocmlua1dpZHRoKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhwcm9wcy5saXF1aWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAocHJvcHMuY29sbGFwc2libGVXaWR0aCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWNvbGxhcHNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogbWFrZSBEUllcbiAgICAgICAgdmFyIGNvbmZpZ0NudCA9IHNlY3Rpb25Db25maWdzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbmZpZ0kgPSAwO1xuICAgICAgICB2YXIgY3VycmVudENvbmZpZztcbiAgICAgICAgdmFyIGhlYWRTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIGJvZHlTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIGZvb3RTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2hlYWRlcicpIHtcbiAgICAgICAgICAgIGhlYWRTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGJvZHlTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2Zvb3RlcicpIHtcbiAgICAgICAgICAgIGZvb3RTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJlZm94IGJ1Zzogd2hlbiBzZXR0aW5nIGhlaWdodCBvbiB0YWJsZSBhbmQgdGhlcmUgaXMgYSB0aGVhZCBvciB0Zm9vdCxcbiAgICAgICAgLy8gdGhlIG5lY2Vzc2FyeSBoZWlnaHQ6MTAwJSBvbiB0aGUgbGlxdWlkLWhlaWdodCBib2R5IHNlY3Rpb24gZm9yY2VzIHRoZSAqd2hvbGUqIHRhYmxlIHRvIGJlIHRhbGxlci4gKGJ1ZyAjNTUyNClcbiAgICAgICAgLy8gdXNlIGdldENhblZHcm93V2l0aGluQ2VsbCBhcyBhIHdheSB0byBkZXRlY3QgdGFibGUtc3R1cGlkIGZpcmVmb3guXG4gICAgICAgIC8vIGlmIHNvLCB1c2UgYSBzaW1wbGVyIGRvbSBzdHJ1Y3R1cmUsIGphbSBldmVyeXRoaW5nIGludG8gYSBsb25lIHRib2R5LlxuICAgICAgICB2YXIgaXNCdWdneSA9ICFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKTtcbiAgICAgICAgdmFyIHJvbGVBdHRycyA9IHsgcm9sZTogJ3Jvd2dyb3VwJyB9O1xuICAgICAgICByZXR1cm4gdmRvbV9janMuY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAnZ3JpZCcsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBwcm9wcy5oZWlnaHQgfSxcbiAgICAgICAgfSwgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoWyd0aGVhZCcsIHJvbGVBdHRyc10sIGhlYWRTZWN0aW9uTm9kZXMpKSwgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoWyd0Ym9keScsIHJvbGVBdHRyc10sIGJvZHlTZWN0aW9uTm9kZXMpKSwgQm9vbGVhbighaXNCdWdneSAmJiBmb290U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoWyd0Zm9vdCcsIHJvbGVBdHRyc10sIGZvb3RTZWN0aW9uTm9kZXMpKSwgaXNCdWdneSAmJiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoWyd0Ym9keScsIHJvbGVBdHRyc10sIGhlYWRTZWN0aW9uTm9kZXMpLCBib2R5U2VjdGlvbk5vZGVzKSwgZm9vdFNlY3Rpb25Ob2RlcykpKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBzZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQodmRvbV9janMuRnJhZ21lbnQsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSB9LCBzZWN0aW9uQ29uZmlnLm91dGVyQ29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB0aGlzLnByb3BzLmxpcXVpZCkuam9pbignICcpIH0sIHRoaXMucmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgc2VjdGlvbkNvbmZpZy5jaHVuaywgaXNIZWFkZXIpKSk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5yZW5kZXJDaHVua1RkID0gZnVuY3Rpb24gKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcbiAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIGZvcmNlWVNjcm9sbGJhcnMgPSBfYS5mb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocyA9IF9hLnNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgPSBfYS5zY3JvbGxlckNsaWVudEhlaWdodHM7XG4gICAgICAgIHZhciBuZWVkc1lTY3JvbGxpbmcgPSBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBUT0RPOiBkbyBsYXppbHkuIGRvIGluIHNlY3Rpb24gY29uZmlnP1xuICAgICAgICB2YXIgaXNMaXF1aWQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgLy8gZm9yIGAhcHJvcHMubGlxdWlkYCAtIGlzIFdIT0xFIHNjcm9sbGdyaWQgbmF0dXJhbCBoZWlnaHQ/XG4gICAgICAgIC8vIFRPRE86IGRvIHNhbWUgdGhpbmcgaW4gYWR2YW5jZWQgc2Nyb2xsZ3JpZD8gcHJvbGx5IG5vdCBiL2MgYWx3YXlzIGhhcyBob3Jpem9udGFsIHNjcm9sbGJhcnNcbiAgICAgICAgdmFyIG92ZXJmbG93WSA9ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOlxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA/ICdzY3JvbGwnIDpcbiAgICAgICAgICAgICAgICAhbmVlZHNZU2Nyb2xsaW5nID8gJ2hpZGRlbicgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0byc7XG4gICAgICAgIHZhciBzZWN0aW9uS2V5ID0gc2VjdGlvbkNvbmZpZy5rZXk7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCB7XG4gICAgICAgICAgICB0YWJsZUNvbEdyb3VwTm9kZTogbWljcm9Db2xHcm91cE5vZGUsXG4gICAgICAgICAgICB0YWJsZU1pbldpZHRoOiAnJyxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoOiAoIXByb3BzLmNvbGxhcHNpYmxlV2lkdGggJiYgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCkgPyBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IHNlY3Rpb25Db25maWcuZXhwYW5kUm93cyxcbiAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiBmYWxzZSxcbiAgICAgICAgICAgIHJvd1N5bmNIZWlnaHRzOiBbXSxcbiAgICAgICAgICAgIHJlcG9ydFJvd0hlaWdodENoYW5nZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgICAgICB9LCBpc0hlYWRlcik7XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoJyA6ICd0ZCcsIHtcbiAgICAgICAgICAgIHJlZjogY2h1bmtDb25maWcuZWxSZWYsXG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxlci1oYXJuZXNzXCIgKyAoaXNMaXF1aWQgPyAnIGZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkJyA6ICcnKSB9LFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcbiAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLl9oYW5kbGVTY3JvbGxlckVsID0gZnVuY3Rpb24gKHNjcm9sbGVyRWwsIGtleSkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGdldFNlY3Rpb25CeUtleSh0aGlzLnByb3BzLnNlY3Rpb25zLCBrZXkpO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgc2V0UmVmKHNlY3Rpb24uY2h1bmsuc2Nyb2xsZXJFbFJlZiwgc2Nyb2xsZXJFbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wdXRlU2hyaW5rV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYXNTaHJpbmtXaWR0aCh0aGlzLnByb3BzLmNvbHMpXG4gICAgICAgICAgICA/IGNvbXB1dGVTaHJpbmtXaWR0aCh0aGlzLnNjcm9sbGVyRWxSZWZzLmdldEFsbCgpKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVyRGltcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHNjcm9sbGVyUmVmcyA9IF9hLnNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgPSBfYS5zY3JvbGxlckVsUmVmcztcbiAgICAgICAgdmFyIGZvcmNlWVNjcm9sbGJhcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNjcm9sbGVyQ2xpZW50V2lkdGhzID0ge307XG4gICAgICAgIHZhciBzY3JvbGxlckNsaWVudEhlaWdodHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgc2VjdGlvbktleSBpbiBzY3JvbGxlclJlZnMuY3VycmVudE1hcCkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbGVyID0gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIubmVlZHNZU2Nyb2xsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gdGhpcy5wcm9wcy5zZWN0aW9uczsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gX2JbX2ldO1xuICAgICAgICAgICAgdmFyIHNlY3Rpb25LZXkgPSBzZWN0aW9uLmtleTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlckVsID0gc2Nyb2xsZXJFbFJlZnMuY3VycmVudE1hcFtzZWN0aW9uS2V5XTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhcm5lc3NFbCA9IHNjcm9sbGVyRWwucGFyZW50Tm9kZTsgLy8gVE9ETzogd2VpcmQgd2F5IHRvIGdldCB0aGlzLiBuZWVkIGhhcm5lc3MgYi9jIGRvZXNuJ3QgaW5jbHVkZSB0YWJsZSBib3JkZXJzXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIChmb3JjZVlTY3JvbGxiYXJzXG4gICAgICAgICAgICAgICAgICAgID8gc2Nyb2xsYmFyV2lkdGgueSAvLyB1c2UgZ2xvYmFsIGJlY2F1c2Ugc2Nyb2xsZXIgbWlnaHQgbm90IGhhdmUgc2Nyb2xsYmFycyB5ZXQgYnV0IHdpbGwgbmVlZCB0aGVtIGluIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgICA6IDApKTtcbiAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcmNlWVNjcm9sbGJhcnM6IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiBzY3JvbGxlckNsaWVudEhlaWdodHMgfTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVTY3JvbGxHcmlkO1xufShCYXNlQ29tcG9uZW50KSk7XG5TaW1wbGVTY3JvbGxHcmlkLmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBpc1Byb3BzRXF1YWwsXG4gICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGdldFNlY3Rpb25CeUtleShzZWN0aW9ucywga2V5KSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzZWN0aW9uc18xID0gc2VjdGlvbnM7IF9pIDwgc2VjdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBzZWN0aW9uc18xW19pXTtcbiAgICAgICAgaWYgKHNlY3Rpb24ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgRXZlbnRSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudFJvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxSZWYgPSB2ZG9tX2Nqcy5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudFJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgc2VnID0gcHJvcHMuc2VnO1xuICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICB2YXIgdWkgPSBldmVudFJhbmdlLnVpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB0aW1lVGV4dDogcHJvcHMudGltZVRleHQsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHVpLnRleHRDb2xvcixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgaXNEcmFnZ2FibGU6ICFwcm9wcy5kaXNhYmxlRHJhZ2dpbmcgJiYgY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNTdGFydFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzRW5kUmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnKSxcbiAgICAgICAgICAgIGlzTWlycm9yOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcgfHwgcHJvcHMuaXNSZXNpemluZyB8fCBwcm9wcy5pc0RhdGVTZWxlY3RpbmcpLFxuICAgICAgICAgICAgaXNTdGFydDogQm9vbGVhbihzZWcuaXNTdGFydCksXG4gICAgICAgICAgICBpc0VuZDogQm9vbGVhbihzZWcuaXNFbmQpLFxuICAgICAgICAgICAgaXNQYXN0OiBCb29sZWFuKHByb3BzLmlzUGFzdCksXG4gICAgICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksXG4gICAgICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogQm9vbGVhbihwcm9wcy5pc1NlbGVjdGVkKSxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyksXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBCb29sZWFuKHByb3BzLmlzUmVzaXppbmcpLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RhbmRhcmRDbGFzc05hbWVzID0gZ2V0RXZlbnRDbGFzc05hbWVzKGhvb2tQcm9wcykuY29uY2F0KHVpLmNsYXNzTmFtZXMpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZXZlbnRDb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQsIGRpZE1vdW50OiBvcHRpb25zLmV2ZW50RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmV2ZW50V2lsbFVubW91bnQsIGVsUmVmOiB0aGlzLmVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBzdGFuZGFyZENsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcyk7IH0pKTtcbiAgICB9O1xuICAgIEV2ZW50Um9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEVsU2VnKHRoaXMuZWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgIH07XG4gICAgLypcbiAgICBuZWVkIHRvIHJlLWFzc2lnbiBzZWcgdG8gdGhlIGVsZW1lbnQgaWYgc2VnIGNoYW5nZXMsIGV2ZW4gaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWVcbiAgICAqL1xuICAgIEV2ZW50Um9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgc2VnID0gdGhpcy5wcm9wcy5zZWc7XG4gICAgICAgIGlmIChzZWcgIT09IHByZXZQcm9wcy5zZWcpIHtcbiAgICAgICAgICAgIHNldEVsU2VnKHRoaXMuZWxSZWYuY3VycmVudCwgc2VnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50Um9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxudmFyIFN0YW5kYXJkRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFN0YW5kYXJkRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhbmRhcmRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTdGFuZGFyZEV2ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnID0gcHJvcHMuc2VnO1xuICAgICAgICB2YXIgdGltZUZvcm1hdCA9IGNvbnRleHQub3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdFRpbWVGb3JtYXQ7XG4gICAgICAgIHZhciB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChFdmVudFJvb3QsIHsgc2VnOiBzZWcsIHRpbWVUZXh0OiB0aW1lVGV4dCwgZGlzYWJsZURyYWdnaW5nOiBwcm9wcy5kaXNhYmxlRHJhZ2dpbmcsIGRpc2FibGVSZXNpemluZzogcHJvcHMuZGlzYWJsZVJlc2l6aW5nLCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQgfHwgcmVuZGVySW5uZXJDb250ZW50JDEsIGlzRHJhZ2dpbmc6IHByb3BzLmlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IHByb3BzLmlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogcHJvcHMuaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBwcm9wcy5pc1NlbGVjdGVkLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyBjbGFzc05hbWU6IHByb3BzLmV4dHJhQ2xhc3NOYW1lcy5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBob29rUHJvcHMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfSwgcmVmOiByb290RWxSZWYgfSwgZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSksXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LW1haW5cIiwgcmVmOiBpbm5lckVsUmVmLCBzdHlsZTogeyBjb2xvcjogaG9va1Byb3BzLnRleHRDb2xvciB9IH0sIGlubmVyQ29udGVudCksXG4gICAgICAgICAgICBob29rUHJvcHMuaXNTdGFydFJlc2l6YWJsZSAmJlxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgfSksXG4gICAgICAgICAgICBob29rUHJvcHMuaXNFbmRSZXNpemFibGUgJiZcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhbmRhcmRFdmVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDEoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluLWZyYW1lXCIgfSxcbiAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgdmRvbV9janMuY3JlYXRlRWxlbWVudCh2ZG9tX2Nqcy5GcmFnbWVudCwgbnVsbCwgXCJcXHUwMEEwXCIpKSkpKTtcbn1cblxudmFyIE5vd0luZGljYXRvclJvb3QgPSBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcbiAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgIH07XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMubm93SW5kaWNhdG9yQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JDb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn0pKTsgfTtcblxudmFyIERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSk7XG52YXIgRGF5Q2VsbENvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheUNlbGxDb250ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUNlbGxDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIERheUNlbGxDb250ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHJlZmluZURheUNlbGxIb29rUHJvcHMoe1xuICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICAgICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgICAgICAgZXh0cmFQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoQ29udGVudEhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUNlbGxDb250ZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZWZpbmVEYXlDZWxsSG9va1Byb3BzKHJhdykge1xuICAgIHZhciBkYXRlID0gcmF3LmRhdGUsIGRhdGVFbnYgPSByYXcuZGF0ZUVudjtcbiAgICB2YXIgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHJhdy50b2RheVJhbmdlLCBudWxsLCByYXcuZGF0ZVByb2ZpbGUpO1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiByYXcudmlld0FwaSB9LCBkYXlNZXRhKSwgeyBkYXlOdW1iZXJUZXh0OiByYXcuc2hvd0RheU51bWJlciA/IGRhdGVFbnYuZm9ybWF0KGRhdGUsIERBWV9OVU1fRk9STUFUKSA6ICcnIH0pLCByYXcuZXh0cmFQcm9wcyk7XG59XG5cbnZhciBEYXlDZWxsUm9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5Q2VsbFJvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5Q2VsbFJvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWZpbmVIb29rUHJvcHMgPSBtZW1vaXplT2JqQXJnKHJlZmluZURheUNlbGxIb29rUHJvcHMpO1xuICAgICAgICBfdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzID0gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5Q2VsbFJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gdGhpcy5yZWZpbmVIb29rUHJvcHMoe1xuICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICAgICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgICAgICAgZXh0cmFQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsXG4gICAgICAgICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGdldERheUNsYXNzTmFtZXMoaG9va1Byb3BzLCBjb250ZXh0LnRoZW1lKS5jb25jYXQoaG9va1Byb3BzLmlzRGlzYWJsZWRcbiAgICAgICAgICAgID8gW10gLy8gZG9uJ3QgdXNlIGN1c3RvbSBjbGFzc05hbWVzIGlmIGRpc2FibGVkXG4gICAgICAgICAgICA6IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBob29rUHJvcHMpKTtcbiAgICAgICAgdmFyIGRhdGFBdHRycyA9IGhvb2tQcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7XG4gICAgICAgICAgICAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlDZWxsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudCwgZWxSZWY6IHByb3BzLmVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgZGF0YUF0dHJzLCBob29rUHJvcHMuaXNEaXNhYmxlZCk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlDZWxsUm9vdDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiByZW5kZXJGaWxsKGZpbGxUeXBlKSB7XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLVwiICsgZmlsbFR5cGUgfSkpO1xufVxudmFyIEJnRXZlbnQgPSBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KEV2ZW50Um9vdCwgeyBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXJDb250ZW50LCBzZWc6IHByb3BzLnNlZyAvKiB1c2VsZXNzcyBpIHRoaW5rICovLCB0aW1lVGV4dDogXCJcIiwgZGlzYWJsZURyYWdnaW5nOiB0cnVlLCBkaXNhYmxlUmVzaXppbmc6IHRydWUsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXkgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy1iZy1ldmVudCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaG9va1Byb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICB9IH0sIGlubmVyQ29udGVudCkpOyB9KSk7IH07XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgdGl0bGUgPSBwcm9wcy5ldmVudC50aXRsZTtcbiAgICByZXR1cm4gdGl0bGUgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCBwcm9wcy5ldmVudC50aXRsZSkpO1xufVxuXG52YXIgV2Vla051bWJlclJvb3QgPSBmdW5jdGlvbiAocHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZGF0ZSA9IHByb3BzLmRhdGU7XG4gICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMud2Vla051bWJlckZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0Rm9ybWF0O1xuICAgIHZhciBudW0gPSBkYXRlRW52LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUpOyAvLyBUT0RPOiBzb21laG93IHVzZSBmb3IgZm9ybWF0dGluZyBhcyB3ZWxsP1xuICAgIHZhciB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgZm9ybWF0KTtcbiAgICB2YXIgaG9va1Byb3BzID0geyBudW06IG51bSwgdGV4dDogdGV4dCwgZGF0ZTogZGF0ZSB9O1xuICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLndlZWtOdW1iZXJDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLndlZWtOdW1iZXJDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXIsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSk7XG59KSk7IH07XG5mdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcbn1cblxudmFyIFBBRERJTkdfRlJPTV9WSUVXUE9SVCA9IDEwO1xudmFyIFBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFBvcG92ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9wb3ZlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGl0bGVJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSBlbDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgICAgICAgICAgIHNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuICAgICAgICBfdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KTtcbiAgICAgICAgICAgIGlmICghX3RoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURvY3VtZW50S2V5RG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsb3NlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb25DbG9zZSA9IF90aGlzLnByb3BzLm9uQ2xvc2U7XG4gICAgICAgICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgdGhlbWUgPSBfYS50aGVtZSwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMsIHByb3BzID0gX2IucHJvcHMsIHN0YXRlID0gX2Iuc3RhdGU7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXBvcG92ZXInLFxuICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcbiAgICAgICAgXS5jb25jYXQocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZVBvcnRhbCh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHRzbGliLl9fYXNzaWduKHsgaWQ6IHByb3BzLmlkLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImFyaWEtbGFiZWxsZWRieVwiOiBzdGF0ZS50aXRsZUlkIH0sIHByb3BzLmV4dHJhQXR0cnMsIHsgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlRG93bik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5RG93bik7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlzUnRsID0gdGhpcy5jb250ZXh0LmlzUnRsO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBhbGlnbm1lbnRFbCA9IF9hLmFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3AgPSBfYS5hbGlnbkdyaWRUb3A7XG4gICAgICAgIHZhciByb290RWwgPSB0aGlzLnJvb3RFbDtcbiAgICAgICAgdmFyIGFsaWdubWVudFJlY3QgPSBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoYWxpZ25tZW50RWwpO1xuICAgICAgICBpZiAoYWxpZ25tZW50UmVjdCkge1xuICAgICAgICAgICAgdmFyIHBvcG92ZXJEaW1zID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gcmVsYXRpdmUgdG8gdmlld3BvcnRcbiAgICAgICAgICAgIHZhciBwb3BvdmVyVG9wID0gYWxpZ25HcmlkVG9wXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50Q2xvc2VzdChhbGlnbm1lbnRFbCwgJy5mYy1zY3JvbGxncmlkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgICAgICAgOiBhbGlnbm1lbnRSZWN0LnRvcDtcbiAgICAgICAgICAgIHZhciBwb3BvdmVyTGVmdCA9IGlzUnRsID8gYWxpZ25tZW50UmVjdC5yaWdodCAtIHBvcG92ZXJEaW1zLndpZHRoIDogYWxpZ25tZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgLy8gY29uc3RyYWluXG4gICAgICAgICAgICBwb3BvdmVyVG9wID0gTWF0aC5tYXgocG9wb3ZlclRvcCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5taW4ocG9wb3ZlckxlZnQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIFBBRERJTkdfRlJPTV9WSUVXUE9SVCAtIHBvcG92ZXJEaW1zLndpZHRoKTtcbiAgICAgICAgICAgIHBvcG92ZXJMZWZ0ID0gTWF0aC5tYXgocG9wb3ZlckxlZnQsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luXzEgPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW5fMS50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcG9wb3ZlckxlZnQgLSBvcmlnaW5fMS5sZWZ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQb3BvdmVyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbnZhciBNb3JlUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTW9yZVBvcG92ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9yZVBvcG92ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAocm9vdEVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb3JlUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkYXRlRW52ID0gX2EuZGF0ZUVudjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IHByb3BzLnN0YXJ0RGF0ZSwgdG9kYXlSYW5nZSA9IHByb3BzLnRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciB0aXRsZSA9IGRhdGVFbnYuZm9ybWF0KHN0YXJ0RGF0ZSwgb3B0aW9ucy5kYXlQb3BvdmVyRm9ybWF0KTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KERheUNlbGxSb290LCB7IGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgZGF5Q2xhc3NOYW1lcywgZGF0YUF0dHJzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChQb3BvdmVyLCB7IGVsUmVmOiByb290RWxSZWYsIGlkOiBwcm9wcy5pZCwgdGl0bGU6IHRpdGxlLCBleHRyYUNsYXNzTmFtZXM6IFsnZmMtbW9yZS1wb3BvdmVyJ10uY29uY2F0KGRheUNsYXNzTmFtZXMpLCBleHRyYUF0dHJzOiBkYXRhQXR0cnMgLyogVE9ETzogbWFrZSB0aGVzZSB0aW1lLWJhc2VkIHdoZW4gbm90IHdob2xlLWRheT8gKi8sIHBhcmVudEVsOiBwcm9wcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgb25DbG9zZTogcHJvcHMub25DbG9zZSB9LFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGVudCwgeyBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoaW5uZXJDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1tb3JlLXBvcG92ZXItbWlzY1wiLCByZWY6IGlubmVyRWxSZWYgfSwgaW5uZXJDb250ZW50KSk7IH0pLFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4pKTsgfSkpO1xuICAgIH07XG4gICAgTW9yZVBvcG92ZXIucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3AsIGVsV2lkdGgsIGVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJvb3RFbCA9IF9hLnJvb3RFbCwgcHJvcHMgPSBfYS5wcm9wcztcbiAgICAgICAgaWYgKHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IHRzbGliLl9fYXNzaWduKHsgYWxsRGF5OiB0cnVlLCByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBlbEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAxLCAvLyBpbXBvcnRhbnQgd2hlbiBjb21wYXJpbmcgd2l0aCBoaXRzIGZyb20gb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNb3JlUG9wb3Zlcjtcbn0oRGF0ZUNvbXBvbmVudCkpO1xuXG52YXIgTW9yZUxpbmtSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhNb3JlTGlua1Jvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9yZUxpbmtSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlua0VsUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXG4gICAgICAgICAgICBwb3BvdmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgbW9yZUxpbmtDbGljayA9IGNvbnRleHQub3B0aW9ucy5tb3JlTGlua0NsaWNrO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0O1xuICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWJsaWNTZWcoc2VnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gc2VnLmV2ZW50UmFuZ2UsIGRlZiA9IF9hLmRlZiwgaW5zdGFuY2UgPSBfYS5pbnN0YW5jZSwgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbW9yZUxpbmtDbGljayA9IG1vcmVMaW5rQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGxEYXk6IEJvb2xlYW4ocHJvcHMuYWxsRGF5RGF0ZSksXG4gICAgICAgICAgICAgICAgICAgIGFsbFNlZ3M6IHByb3BzLmFsbFNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtb3JlTGlua0NsaWNrIHx8IG1vcmVMaW5rQ2xpY2sgPT09ICdwb3BvdmVyJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vcmVMaW5rUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHZpZXdBcGkgPSBjb250ZXh0LnZpZXdBcGksIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnMsIGNhbGVuZGFyQXBpID0gY29udGV4dC5jYWxlbmRhckFwaTtcbiAgICAgICAgICAgIHZhciBtb3JlTGlua1RleHQgPSBvcHRpb25zLm1vcmVMaW5rVGV4dDtcbiAgICAgICAgICAgIHZhciBtb3JlQ250ID0gcHJvcHMubW9yZUNudDtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGNvbXB1dGVSYW5nZShwcm9wcyk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHR5cGVvZiBtb3JlTGlua1RleHQgPT09ICdmdW5jdGlvbicgLy8gVE9ETzogZXZlbnR1YWxseSB1c2UgZm9ybWF0V2l0aE9yZGluYWxzXG4gICAgICAgICAgICAgICAgPyBtb3JlTGlua1RleHQuY2FsbChjYWxlbmRhckFwaSwgbW9yZUNudClcbiAgICAgICAgICAgICAgICA6IFwiK1wiICsgbW9yZUNudCArIFwiIFwiICsgbW9yZUxpbmtUZXh0O1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubW9yZUxpbmtIaW50LCBbbW9yZUNudF0sIHRleHQpO1xuICAgICAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBudW06IG1vcmVDbnQsXG4gICAgICAgICAgICAgICAgc2hvcnRUZXh0OiBcIitcIiArIG1vcmVDbnQsXG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudCh2ZG9tX2Nqcy5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgZWxSZWY6IF90aGlzLmxpbmtFbFJlZiwgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLm1vcmVMaW5rQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlck1vcmVMaW5rSW5uZXIsIGRpZE1vdW50OiBvcHRpb25zLm1vcmVMaW5rRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm1vcmVMaW5rV2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIFsnZmMtbW9yZS1saW5rJ10uY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIF90aGlzLmhhbmRsZUNsaWNrLCB0aXRsZSwgc3RhdGUuaXNQb3BvdmVyT3Blbiwgc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnKTsgfSkpLFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTW9yZVBvcG92ZXIsIHsgaWQ6IHN0YXRlLnBvcG92ZXJJZCwgc3RhcnREYXRlOiByYW5nZS5zdGFydCwgZW5kRGF0ZTogcmFuZ2UuZW5kLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBhcmVudEVsOiBfdGhpcy5wYXJlbnRFbCwgYWxpZ25tZW50RWw6IHByb3BzLmFsaWdubWVudEVsUmVmLmN1cnJlbnQsIGFsaWduR3JpZFRvcDogcHJvcHMuYWxpZ25HcmlkVG9wLCBvbkNsb3NlOiBfdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgfSwgcHJvcHMucG9wb3ZlckNvbnRlbnQoKSkpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIE1vcmVMaW5rUm9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9O1xuICAgIE1vcmVMaW5rUm9vdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfTtcbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLnVwZGF0ZVBhcmVudEVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5rRWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRFbCA9IGVsZW1lbnRDbG9zZXN0KHRoaXMubGlua0VsUmVmLmN1cnJlbnQsICcuZmMtdmlldy1oYXJuZXNzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb3JlTGlua1Jvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZShwcm9wcykge1xuICAgIGlmIChwcm9wcy5hbGxEYXlEYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogcHJvcHMuYWxsRGF5RGF0ZSxcbiAgICAgICAgICAgIGVuZDogYWRkRGF5cyhwcm9wcy5hbGxEYXlEYXRlLCAxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGhpZGRlblNlZ3MgPSBwcm9wcy5oaWRkZW5TZWdzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSxcbiAgICAgICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tFYXJsaWVzdFN0YXJ0KS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0O1xufVxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPCBzZWcxLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQgPyBzZWcwIDogc2VnMTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMYXRlc3RTZWdFbmQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrTGF0ZXN0RW5kKS5ldmVudFJhbmdlLnJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIHBpY2tMYXRlc3RFbmQoc2VnMCwgc2VnMSkge1xuICAgIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxO1xufVxuXG4vLyBleHBvcnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHZlcnNpb24gPSAnNS4xMS4zJzsgLy8gaW1wb3J0YW50IHRvIHR5cGUgaXQsIHNvIC5kLnRzIGhhcyBnZW5lcmljIHN0cmluZ1xuXG5leHBvcnRzLkJBU0VfT1BUSU9OX0RFRkFVTFRTID0gQkFTRV9PUFRJT05fREVGQVVMVFM7XG5leHBvcnRzLkJBU0VfT1BUSU9OX1JFRklORVJTID0gQkFTRV9PUFRJT05fUkVGSU5FUlM7XG5leHBvcnRzLkJhc2VDb21wb25lbnQgPSBCYXNlQ29tcG9uZW50O1xuZXhwb3J0cy5CZ0V2ZW50ID0gQmdFdmVudDtcbmV4cG9ydHMuQ2FsZW5kYXJBcGkgPSBDYWxlbmRhckFwaTtcbmV4cG9ydHMuQ2FsZW5kYXJDb250ZW50ID0gQ2FsZW5kYXJDb250ZW50O1xuZXhwb3J0cy5DYWxlbmRhckRhdGFNYW5hZ2VyID0gQ2FsZW5kYXJEYXRhTWFuYWdlcjtcbmV4cG9ydHMuQ2FsZW5kYXJEYXRhUHJvdmlkZXIgPSBDYWxlbmRhckRhdGFQcm92aWRlcjtcbmV4cG9ydHMuQ2FsZW5kYXJSb290ID0gQ2FsZW5kYXJSb290O1xuZXhwb3J0cy5Db250ZW50SG9vayA9IENvbnRlbnRIb29rO1xuZXhwb3J0cy5DdXN0b21Db250ZW50UmVuZGVyQ29udGV4dCA9IEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0O1xuZXhwb3J0cy5EYXRlQ29tcG9uZW50ID0gRGF0ZUNvbXBvbmVudDtcbmV4cG9ydHMuRGF0ZUVudiA9IERhdGVFbnY7XG5leHBvcnRzLkRhdGVQcm9maWxlR2VuZXJhdG9yID0gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG5leHBvcnRzLkRheUNlbGxDb250ZW50ID0gRGF5Q2VsbENvbnRlbnQ7XG5leHBvcnRzLkRheUNlbGxSb290ID0gRGF5Q2VsbFJvb3Q7XG5leHBvcnRzLkRheUhlYWRlciA9IERheUhlYWRlcjtcbmV4cG9ydHMuRGF5U2VyaWVzTW9kZWwgPSBEYXlTZXJpZXNNb2RlbDtcbmV4cG9ydHMuRGF5VGFibGVNb2RlbCA9IERheVRhYmxlTW9kZWw7XG5leHBvcnRzLkRlbGF5ZWRSdW5uZXIgPSBEZWxheWVkUnVubmVyO1xuZXhwb3J0cy5FbGVtZW50RHJhZ2dpbmcgPSBFbGVtZW50RHJhZ2dpbmc7XG5leHBvcnRzLkVsZW1lbnRTY3JvbGxDb250cm9sbGVyID0gRWxlbWVudFNjcm9sbENvbnRyb2xsZXI7XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuZXhwb3J0cy5FdmVudEFwaSA9IEV2ZW50QXBpO1xuZXhwb3J0cy5FdmVudFJvb3QgPSBFdmVudFJvb3Q7XG5leHBvcnRzLkV2ZW50U291cmNlQXBpID0gRXZlbnRTb3VyY2VBcGk7XG5leHBvcnRzLkludGVyYWN0aW9uID0gSW50ZXJhY3Rpb247XG5leHBvcnRzLk1vcmVMaW5rUm9vdCA9IE1vcmVMaW5rUm9vdDtcbmV4cG9ydHMuTW91bnRIb29rID0gTW91bnRIb29rO1xuZXhwb3J0cy5OYW1lZFRpbWVab25lSW1wbCA9IE5hbWVkVGltZVpvbmVJbXBsO1xuZXhwb3J0cy5Ob3dJbmRpY2F0b3JSb290ID0gTm93SW5kaWNhdG9yUm9vdDtcbmV4cG9ydHMuTm93VGltZXIgPSBOb3dUaW1lcjtcbmV4cG9ydHMuUG9zaXRpb25DYWNoZSA9IFBvc2l0aW9uQ2FjaGU7XG5leHBvcnRzLlJlZk1hcCA9IFJlZk1hcDtcbmV4cG9ydHMuUmVuZGVySG9vayA9IFJlbmRlckhvb2s7XG5leHBvcnRzLlNjcm9sbENvbnRyb2xsZXIgPSBTY3JvbGxDb250cm9sbGVyO1xuZXhwb3J0cy5TY3JvbGxSZXNwb25kZXIgPSBTY3JvbGxSZXNwb25kZXI7XG5leHBvcnRzLlNjcm9sbGVyID0gU2Nyb2xsZXI7XG5leHBvcnRzLlNlZ0hpZXJhcmNoeSA9IFNlZ0hpZXJhcmNoeTtcbmV4cG9ydHMuU2ltcGxlU2Nyb2xsR3JpZCA9IFNpbXBsZVNjcm9sbEdyaWQ7XG5leHBvcnRzLlNsaWNlciA9IFNsaWNlcjtcbmV4cG9ydHMuU3BsaXR0ZXIgPSBTcGxpdHRlcjtcbmV4cG9ydHMuU3RhbmRhcmRFdmVudCA9IFN0YW5kYXJkRXZlbnQ7XG5leHBvcnRzLlRhYmxlRGF0ZUNlbGwgPSBUYWJsZURhdGVDZWxsO1xuZXhwb3J0cy5UYWJsZURvd0NlbGwgPSBUYWJsZURvd0NlbGw7XG5leHBvcnRzLlRoZW1lID0gVGhlbWU7XG5leHBvcnRzLlZpZXdBcGkgPSBWaWV3QXBpO1xuZXhwb3J0cy5WaWV3Q29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGU7XG5leHBvcnRzLlZpZXdSb290ID0gVmlld1Jvb3Q7XG5leHBvcnRzLldlZWtOdW1iZXJSb290ID0gV2Vla051bWJlclJvb3Q7XG5leHBvcnRzLldpbmRvd1Njcm9sbENvbnRyb2xsZXIgPSBXaW5kb3dTY3JvbGxDb250cm9sbGVyO1xuZXhwb3J0cy5hZGREYXlzID0gYWRkRGF5cztcbmV4cG9ydHMuYWRkRHVyYXRpb25zID0gYWRkRHVyYXRpb25zO1xuZXhwb3J0cy5hZGRNcyA9IGFkZE1zO1xuZXhwb3J0cy5hZGRXZWVrcyA9IGFkZFdlZWtzO1xuZXhwb3J0cy5hbGxvd0NvbnRleHRNZW51ID0gYWxsb3dDb250ZXh0TWVudTtcbmV4cG9ydHMuYWxsb3dTZWxlY3Rpb24gPSBhbGxvd1NlbGVjdGlvbjtcbmV4cG9ydHMuYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmU7XG5leHBvcnRzLmFwcGx5U3R5bGUgPSBhcHBseVN0eWxlO1xuZXhwb3J0cy5hcHBseVN0eWxlUHJvcCA9IGFwcGx5U3R5bGVQcm9wO1xuZXhwb3J0cy5hc0NsZWFuRGF5cyA9IGFzQ2xlYW5EYXlzO1xuZXhwb3J0cy5hc1JvdWdoTWludXRlcyA9IGFzUm91Z2hNaW51dGVzO1xuZXhwb3J0cy5hc1JvdWdoTXMgPSBhc1JvdWdoTXM7XG5leHBvcnRzLmFzUm91Z2hTZWNvbmRzID0gYXNSb3VnaFNlY29uZHM7XG5leHBvcnRzLmJpbmFyeVNlYXJjaCA9IGJpbmFyeVNlYXJjaDtcbmV4cG9ydHMuYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyID0gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyO1xuZXhwb3J0cy5idWlsZEVudHJ5S2V5ID0gYnVpbGRFbnRyeUtleTtcbmV4cG9ydHMuYnVpbGRFdmVudEFwaXMgPSBidWlsZEV2ZW50QXBpcztcbmV4cG9ydHMuYnVpbGRFdmVudFJhbmdlS2V5ID0gYnVpbGRFdmVudFJhbmdlS2V5O1xuZXhwb3J0cy5idWlsZEhhc2hGcm9tQXJyYXkgPSBidWlsZEhhc2hGcm9tQXJyYXk7XG5leHBvcnRzLmJ1aWxkSXNvU3RyaW5nID0gYnVpbGRJc29TdHJpbmc7XG5leHBvcnRzLmJ1aWxkTmF2TGlua0F0dHJzID0gYnVpbGROYXZMaW5rQXR0cnM7XG5leHBvcnRzLmJ1aWxkU2VnQ29tcGFyZU9iaiA9IGJ1aWxkU2VnQ29tcGFyZU9iajtcbmV4cG9ydHMuYnVpbGRTZWdUaW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQ7XG5leHBvcnRzLmNvbGxlY3RGcm9tSGFzaCA9IGNvbGxlY3RGcm9tSGFzaDtcbmV4cG9ydHMuY29tYmluZUV2ZW50VWlzID0gY29tYmluZUV2ZW50VWlzO1xuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWMgPSBjb21wYXJlQnlGaWVsZFNwZWM7XG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xuZXhwb3J0cy5jb21wYXJlTnVtYmVycyA9IGNvbXBhcmVOdW1iZXJzO1xuZXhwb3J0cy5jb21wYXJlT2JqcyA9IGNvbXBhcmVPYmpzO1xuZXhwb3J0cy5jb21wdXRlRWFybGllc3RTZWdTdGFydCA9IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0O1xuZXhwb3J0cy5jb21wdXRlRWRnZXMgPSBjb21wdXRlRWRnZXM7XG5leHBvcnRzLmNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCA9IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdDtcbmV4cG9ydHMuY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMgPSBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucztcbmV4cG9ydHMuY29tcHV0ZUlubmVyUmVjdCA9IGNvbXB1dGVJbm5lclJlY3Q7XG5leHBvcnRzLmNvbXB1dGVSZWN0ID0gY29tcHV0ZVJlY3Q7XG5leHBvcnRzLmNvbXB1dGVTZWdEcmFnZ2FibGUgPSBjb21wdXRlU2VnRHJhZ2dhYmxlO1xuZXhwb3J0cy5jb21wdXRlU2VnRW5kUmVzaXphYmxlID0gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZTtcbmV4cG9ydHMuY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlID0gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlO1xuZXhwb3J0cy5jb21wdXRlU2hyaW5rV2lkdGggPSBjb21wdXRlU2hyaW5rV2lkdGg7XG5leHBvcnRzLmNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCA9IGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aDtcbmV4cG9ydHMuY29tcHV0ZVZpc2libGVEYXlSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2U7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcbmV4cG9ydHMuY29uc3RyYWluUG9pbnQgPSBjb25zdHJhaW5Qb2ludDtcbmV4cG9ydHMuY3JlYXRlQXJpYUNsaWNrQXR0cnMgPSBjcmVhdGVBcmlhQ2xpY2tBdHRycztcbmV4cG9ydHMuY3JlYXRlRHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcbmV4cG9ydHMuY3JlYXRlRW1wdHlFdmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlO1xuZXhwb3J0cy5jcmVhdGVFdmVudEluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZTtcbmV4cG9ydHMuY3JlYXRlRXZlbnRVaSA9IGNyZWF0ZUV2ZW50VWk7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlUGx1Z2luID0gY3JlYXRlUGx1Z2luO1xuZXhwb3J0cy5kaWZmRGF0ZXMgPSBkaWZmRGF0ZXM7XG5leHBvcnRzLmRpZmZEYXlBbmRUaW1lID0gZGlmZkRheUFuZFRpbWU7XG5leHBvcnRzLmRpZmZEYXlzID0gZGlmZkRheXM7XG5leHBvcnRzLmRpZmZQb2ludHMgPSBkaWZmUG9pbnRzO1xuZXhwb3J0cy5kaWZmV2Vla3MgPSBkaWZmV2Vla3M7XG5leHBvcnRzLmRpZmZXaG9sZURheXMgPSBkaWZmV2hvbGVEYXlzO1xuZXhwb3J0cy5kaWZmV2hvbGVXZWVrcyA9IGRpZmZXaG9sZVdlZWtzO1xuZXhwb3J0cy5kaXNhYmxlQ3Vyc29yID0gZGlzYWJsZUN1cnNvcjtcbmV4cG9ydHMuZWxlbWVudENsb3Nlc3QgPSBlbGVtZW50Q2xvc2VzdDtcbmV4cG9ydHMuZWxlbWVudE1hdGNoZXMgPSBlbGVtZW50TWF0Y2hlcztcbmV4cG9ydHMuZW5hYmxlQ3Vyc29yID0gZW5hYmxlQ3Vyc29yO1xuZXhwb3J0cy5ldmVudFR1cGxlVG9TdG9yZSA9IGV2ZW50VHVwbGVUb1N0b3JlO1xuZXhwb3J0cy5maWx0ZXJFdmVudFN0b3JlRGVmcyA9IGZpbHRlckV2ZW50U3RvcmVEZWZzO1xuZXhwb3J0cy5maWx0ZXJIYXNoID0gZmlsdGVySGFzaDtcbmV4cG9ydHMuZmluZERpcmVjdENoaWxkcmVuID0gZmluZERpcmVjdENoaWxkcmVuO1xuZXhwb3J0cy5maW5kRWxlbWVudHMgPSBmaW5kRWxlbWVudHM7XG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IGZsZXhpYmxlQ29tcGFyZTtcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG5leHBvcnRzLmZvcm1hdERheVN0cmluZyA9IGZvcm1hdERheVN0cmluZztcbmV4cG9ydHMuZm9ybWF0SXNvVGltZVN0cmluZyA9IGZvcm1hdElzb1RpbWVTdHJpbmc7XG5leHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XG5leHBvcnRzLmdldEFsbG93WVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZztcbmV4cG9ydHMuZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsID0gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsO1xuZXhwb3J0cy5nZXRDbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHM7XG5leHBvcnRzLmdldERhdGVNZXRhID0gZ2V0RGF0ZU1ldGE7XG5leHBvcnRzLmdldERheUNsYXNzTmFtZXMgPSBnZXREYXlDbGFzc05hbWVzO1xuZXhwb3J0cy5nZXREZWZhdWx0RXZlbnRFbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQ7XG5leHBvcnRzLmdldEVsUm9vdCA9IGdldEVsUm9vdDtcbmV4cG9ydHMuZ2V0RWxTZWcgPSBnZXRFbFNlZztcbmV4cG9ydHMuZ2V0RW50cnlTcGFuRW5kID0gZ2V0RW50cnlTcGFuRW5kO1xuZXhwb3J0cy5nZXRFdmVudENsYXNzTmFtZXMgPSBnZXRFdmVudENsYXNzTmFtZXM7XG5leHBvcnRzLmdldEV2ZW50VGFyZ2V0VmlhUm9vdCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdDtcbmV4cG9ydHMuZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdDtcbmV4cG9ydHMuZ2V0UmVjdENlbnRlciA9IGdldFJlY3RDZW50ZXI7XG5leHBvcnRzLmdldFJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHM7XG5leHBvcnRzLmdldFNjcm9sbEdyaWRDbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXM7XG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcbmV4cG9ydHMuZ2V0U2VjdGlvbkNsYXNzTmFtZXMgPSBnZXRTZWN0aW9uQ2xhc3NOYW1lcztcbmV4cG9ydHMuZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCA9IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQ7XG5leHBvcnRzLmdldFNlZ0FuY2hvckF0dHJzID0gZ2V0U2VnQW5jaG9yQXR0cnM7XG5leHBvcnRzLmdldFNlZ01ldGEgPSBnZXRTZWdNZXRhO1xuZXhwb3J0cy5nZXRTbG90Q2xhc3NOYW1lcyA9IGdldFNsb3RDbGFzc05hbWVzO1xuZXhwb3J0cy5nZXRTdGlja3lGb290ZXJTY3JvbGxiYXIgPSBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXI7XG5leHBvcnRzLmdldFN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXM7XG5leHBvcnRzLmdldFVuZXF1YWxQcm9wcyA9IGdldFVuZXF1YWxQcm9wcztcbmV4cG9ydHMuZ2V0VW5pcXVlRG9tSWQgPSBnZXRVbmlxdWVEb21JZDtcbmV4cG9ydHMuZ2xvYmFsTG9jYWxlcyA9IGdsb2JhbExvY2FsZXM7XG5leHBvcnRzLmdsb2JhbFBsdWdpbnMgPSBnbG9iYWxQbHVnaW5zO1xuZXhwb3J0cy5ncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3I7XG5leHBvcnRzLmdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcztcbmV4cG9ydHMuZ3VpZCA9IGd1aWQ7XG5leHBvcnRzLmhhc0JnUmVuZGVyaW5nID0gaGFzQmdSZW5kZXJpbmc7XG5leHBvcnRzLmhhc1Nocmlua1dpZHRoID0gaGFzU2hyaW5rV2lkdGg7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZTtcbmV4cG9ydHMuaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUgPSBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZTtcbmV4cG9ydHMuaW50ZXJzZWN0UmFuZ2VzID0gaW50ZXJzZWN0UmFuZ2VzO1xuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IGludGVyc2VjdFJlY3RzO1xuZXhwb3J0cy5pbnRlcnNlY3RTcGFucyA9IGludGVyc2VjdFNwYW5zO1xuZXhwb3J0cy5pc0FycmF5c0VxdWFsID0gaXNBcnJheXNFcXVhbDtcbmV4cG9ydHMuaXNDb2xQcm9wc0VxdWFsID0gaXNDb2xQcm9wc0VxdWFsO1xuZXhwb3J0cy5pc0RhdGVTZWxlY3Rpb25WYWxpZCA9IGlzRGF0ZVNlbGVjdGlvblZhbGlkO1xuZXhwb3J0cy5pc0RhdGVTcGFuc0VxdWFsID0gaXNEYXRlU3BhbnNFcXVhbDtcbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcbmV4cG9ydHMuaXNJbnRlcmFjdGlvblZhbGlkID0gaXNJbnRlcmFjdGlvblZhbGlkO1xuZXhwb3J0cy5pc011bHRpRGF5UmFuZ2UgPSBpc011bHRpRGF5UmFuZ2U7XG5leHBvcnRzLmlzUHJvcHNFcXVhbCA9IGlzUHJvcHNFcXVhbDtcbmV4cG9ydHMuaXNQcm9wc1ZhbGlkID0gaXNQcm9wc1ZhbGlkO1xuZXhwb3J0cy5pc1ZhbGlkRGF0ZSA9IGlzVmFsaWREYXRlO1xuZXhwb3J0cy5qb2luU3BhbnMgPSBqb2luU3BhbnM7XG5leHBvcnRzLmxpc3RlbkJ5U2VsZWN0b3IgPSBsaXN0ZW5CeVNlbGVjdG9yO1xuZXhwb3J0cy5tYXBIYXNoID0gbWFwSGFzaDtcbmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemU7XG5leHBvcnRzLm1lbW9pemVBcnJheWxpa2UgPSBtZW1vaXplQXJyYXlsaWtlO1xuZXhwb3J0cy5tZW1vaXplSGFzaGxpa2UgPSBtZW1vaXplSGFzaGxpa2U7XG5leHBvcnRzLm1lbW9pemVPYmpBcmcgPSBtZW1vaXplT2JqQXJnO1xuZXhwb3J0cy5tZXJnZUV2ZW50U3RvcmVzID0gbWVyZ2VFdmVudFN0b3JlcztcbmV4cG9ydHMubXVsdGlwbHlEdXJhdGlvbiA9IG11bHRpcGx5RHVyYXRpb247XG5leHBvcnRzLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG5leHBvcnRzLnBhcnNlQnVzaW5lc3NIb3VycyA9IHBhcnNlQnVzaW5lc3NIb3VycztcbmV4cG9ydHMucGFyc2VDbGFzc05hbWVzID0gcGFyc2VDbGFzc05hbWVzO1xuZXhwb3J0cy5wYXJzZURyYWdNZXRhID0gcGFyc2VEcmFnTWV0YTtcbmV4cG9ydHMucGFyc2VFdmVudERlZiA9IHBhcnNlRXZlbnREZWY7XG5leHBvcnRzLnBhcnNlRmllbGRTcGVjcyA9IHBhcnNlRmllbGRTcGVjcztcbmV4cG9ydHMucGFyc2VNYXJrZXIgPSBwYXJzZTtcbmV4cG9ydHMucG9pbnRJbnNpZGVSZWN0ID0gcG9pbnRJbnNpZGVSZWN0O1xuZXhwb3J0cy5wcmV2ZW50Q29udGV4dE1lbnUgPSBwcmV2ZW50Q29udGV4dE1lbnU7XG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG5leHBvcnRzLnByZXZlbnRTZWxlY3Rpb24gPSBwcmV2ZW50U2VsZWN0aW9uO1xuZXhwb3J0cy5yYW5nZUNvbnRhaW5zTWFya2VyID0gcmFuZ2VDb250YWluc01hcmtlcjtcbmV4cG9ydHMucmFuZ2VDb250YWluc1JhbmdlID0gcmFuZ2VDb250YWluc1JhbmdlO1xuZXhwb3J0cy5yYW5nZXNFcXVhbCA9IHJhbmdlc0VxdWFsO1xuZXhwb3J0cy5yYW5nZXNJbnRlcnNlY3QgPSByYW5nZXNJbnRlcnNlY3Q7XG5leHBvcnRzLnJlZmluZUV2ZW50RGVmID0gcmVmaW5lRXZlbnREZWY7XG5leHBvcnRzLnJlZmluZVByb3BzID0gcmVmaW5lUHJvcHM7XG5leHBvcnRzLnJlbW92ZUVsZW1lbnQgPSByZW1vdmVFbGVtZW50O1xuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHJlbW92ZUV4YWN0O1xuZXhwb3J0cy5yZW5kZXJDaHVua0NvbnRlbnQgPSByZW5kZXJDaHVua0NvbnRlbnQ7XG5leHBvcnRzLnJlbmRlckZpbGwgPSByZW5kZXJGaWxsO1xuZXhwb3J0cy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gcmVuZGVyTWljcm9Db2xHcm91cDtcbmV4cG9ydHMucmVuZGVyU2Nyb2xsU2hpbSA9IHJlbmRlclNjcm9sbFNoaW07XG5leHBvcnRzLnJlcXVlc3RKc29uID0gcmVxdWVzdEpzb247XG5leHBvcnRzLnNhbml0aXplU2hyaW5rV2lkdGggPSBzYW5pdGl6ZVNocmlua1dpZHRoO1xuZXhwb3J0cy5zZXRFbFNlZyA9IHNldEVsU2VnO1xuZXhwb3J0cy5zZXRSZWYgPSBzZXRSZWY7XG5leHBvcnRzLnNsaWNlRXZlbnRTdG9yZSA9IHNsaWNlRXZlbnRTdG9yZTtcbmV4cG9ydHMuc2xpY2VFdmVudHMgPSBzbGljZUV2ZW50cztcbmV4cG9ydHMuc29ydEV2ZW50U2VncyA9IHNvcnRFdmVudFNlZ3M7XG5leHBvcnRzLnN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5O1xuZXhwb3J0cy50cmFuc2xhdGVSZWN0ID0gdHJhbnNsYXRlUmVjdDtcbmV4cG9ydHMudHJpZ2dlckRhdGVTZWxlY3QgPSB0cmlnZ2VyRGF0ZVNlbGVjdDtcbmV4cG9ydHMudW5wcm9taXNpZnkgPSB1bnByb21pc2lmeTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLndoZW5UcmFuc2l0aW9uRG9uZSA9IHdoZW5UcmFuc2l0aW9uRG9uZTtcbmV4cG9ydHMud2hvbGVEaXZpZGVEdXJhdGlvbnMgPSB3aG9sZURpdmlkZUR1cmF0aW9ucztcbk9iamVjdC5rZXlzKHZkb21fY2pzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmRvbV9janNba107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWIiLCJyZXF1aXJlIiwidmRvbV9janMiLCJFdmVudFNvdXJjZUFwaSIsImNvbnRleHQiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicHJvdG90eXBlIiwicmVtb3ZlIiwiZGlzcGF0Y2giLCJ0eXBlIiwic291cmNlSWQiLCJyZWZldGNoIiwic291cmNlSWRzIiwiaXNSZWZldGNoIiwiZ2V0IiwicHVibGljSWQiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwibWV0YSIsInVybCIsImZvcm1hdCIsInJlbW92ZUVsZW1lbnQiLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVsZW1lbnRDbG9zZXN0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjb250YWlucyIsImVsZW1lbnRNYXRjaGVzIiwicGFyZW50RWxlbWVudCIsIm5vZGVUeXBlIiwibWV0aG9kIiwibWF0Y2hlcyIsIm1hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiY2FsbCIsImZpbmRFbGVtZW50cyIsImNvbnRhaW5lciIsImNvbnRhaW5lcnMiLCJIVE1MRWxlbWVudCIsImFsbE1hdGNoZXMiLCJpIiwibGVuZ3RoIiwicXVlcnlTZWxlY3RvckFsbCIsImoiLCJwdXNoIiwiZmluZERpcmVjdENoaWxkcmVuIiwicGFyZW50IiwicGFyZW50cyIsImNoaWxkTm9kZXMiLCJjaGlsZHJlbiIsImNoaWxkTm9kZSIsIlBJWEVMX1BST1BfUkUiLCJhcHBseVN0eWxlIiwicHJvcHMiLCJwcm9wTmFtZSIsImFwcGx5U3R5bGVQcm9wIiwibmFtZSIsInZhbCIsInN0eWxlIiwidGVzdCIsImdldEV2ZW50VGFyZ2V0VmlhUm9vdCIsImV2IiwiX2EiLCJfYiIsImNvbXBvc2VkUGF0aCIsInRhcmdldCIsImdldEVsUm9vdCIsImdldFJvb3ROb2RlIiwiZ3VpZCQxIiwiZ2V0VW5pcXVlRG9tSWQiLCJwcmV2ZW50RGVmYXVsdCIsImJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIiLCJoYW5kbGVyIiwibWF0Y2hlZENoaWxkIiwibGlzdGVuQnlTZWxlY3RvciIsImV2ZW50VHlwZSIsImF0dGFjaGVkSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwibW91c2VPdmVyRXYiLCJyZWFsT25Nb3VzZUxlYXZlXzEiLCJtb3VzZUxlYXZlRXYiLCJ0cmFuc2l0aW9uRXZlbnROYW1lcyIsIndoZW5UcmFuc2l0aW9uRG9uZSIsImNhbGxiYWNrIiwicmVhbENhbGxiYWNrIiwiZm9yRWFjaCIsImV2ZW50TmFtZSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiX19hc3NpZ24iLCJvbkNsaWNrIiwiY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMiLCJ0YWJJbmRleCIsIm9uS2V5RG93biIsImtleSIsImd1aWROdW1iZXIiLCJndWlkIiwiU3RyaW5nIiwiZGlzYWJsZUN1cnNvciIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJlbmFibGVDdXJzb3IiLCJwcmV2ZW50U2VsZWN0aW9uIiwiYWxsb3dTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJhbGxvd0NvbnRleHRNZW51IiwicGFyc2VGaWVsZFNwZWNzIiwiaW5wdXQiLCJzcGVjcyIsInRva2VucyIsInRva2VuIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJjaGFyQXQiLCJmaWVsZCIsInN1YnN0cmluZyIsIm9yZGVyIiwiZnVuYyIsImNvbXBhcmVCeUZpZWxkU3BlY3MiLCJvYmowIiwib2JqMSIsImZpZWxkU3BlY3MiLCJjbXAiLCJjb21wYXJlQnlGaWVsZFNwZWMiLCJmaWVsZFNwZWMiLCJmbGV4aWJsZUNvbXBhcmUiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJwYWRTdGFydCIsImxlbiIsInMiLCJzdWJzdHIiLCJmb3JtYXRXaXRoT3JkaW5hbHMiLCJmb3JtYXR0ZXIiLCJhcmdzIiwiZmFsbGJhY2tUZXh0IiwiYXBwbHkiLCJyZWR1Y2UiLCJzdHIiLCJhcmciLCJpbmRleCIsInJlcGxhY2UiLCJjb21wYXJlTnVtYmVycyIsImlzSW50IiwibiIsImNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aCIsImNlbGxFbCIsImFsbFdpZHRoRWwiLCJxdWVyeVNlbGVjdG9yIiwiY29udGVudFdpZHRoRWwiLCJFcnJvciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiREFZX0lEUyIsImFkZFdlZWtzIiwibSIsImRhdGVUb1V0Y0FycmF5IiwiYXJyYXlUb1V0Y0RhdGUiLCJhZGREYXlzIiwiYWRkTXMiLCJkaWZmV2Vla3MiLCJtMCIsIm0xIiwiZGlmZkRheXMiLCJ2YWx1ZU9mIiwiZGlmZkhvdXJzIiwiZGlmZk1pbnV0ZXMiLCJkaWZmU2Vjb25kcyIsImRpZmZEYXlBbmRUaW1lIiwibTBkYXkiLCJzdGFydE9mRGF5IiwibTFkYXkiLCJ5ZWFycyIsIm1vbnRocyIsImRheXMiLCJNYXRoIiwicm91bmQiLCJtaWxsaXNlY29uZHMiLCJkaWZmV2hvbGVXZWVrcyIsImQiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsInkiLCJ3Iiwid2Vla09mR2l2ZW5ZZWFyIiwibmV4dFciLCJtaW4iLCJ5ZWFyIiwiZmlyc3RXZWVrU3RhcnQiLCJmaXJzdFdlZWtPZmZzZXQiLCJkYXlTdGFydCIsImZsb29yIiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXRlVG9Mb2NhbEFycmF5IiwiZGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImFycmF5VG9Mb2NhbERhdGUiLCJEYXRlIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY29uY2F0IiwiVVRDIiwiaXNWYWxpZERhdGUiLCJpc05hTiIsImNyZWF0ZUV2ZW50SW5zdGFuY2UiLCJkZWZJZCIsInJhbmdlIiwiZm9yY2VkU3RhcnRUem8iLCJmb3JjZWRFbmRUem8iLCJpbnN0YW5jZUlkIiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZVByb3BzIiwicHJvcE9ianMiLCJjb21wbGV4UHJvcHNNYXAiLCJkZXN0IiwibmFtZV8xIiwiY29tcGxleE9ianMiLCJ1bnNoaWZ0IiwidW5kZWZpbmVkIiwibmFtZV8yIiwiZmlsdGVySGFzaCIsImhhc2giLCJmaWx0ZXJlZCIsIm1hcEhhc2giLCJuZXdIYXNoIiwiYXJyYXlUb0hhc2giLCJfaSIsImFfMSIsIml0ZW0iLCJidWlsZEhhc2hGcm9tQXJyYXkiLCJ0dXBsZSIsImhhc2hWYWx1ZXNUb0FycmF5Iiwib2JqIiwiaXNQcm9wc0VxdWFsIiwiZ2V0VW5lcXVhbFByb3BzIiwia2V5cyIsImNvbXBhcmVPYmpzIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsImVxdWFsaXR5RnVuY3MiLCJpc09ialZhbHNFcXVhbCIsInZhbDAiLCJ2YWwxIiwiY29tcGFyYXRvciIsImNvbGxlY3RGcm9tSGFzaCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInN0ZXAiLCJyZXMiLCJwYXJzZVJlY3VycmluZyIsInJlZmluZWQiLCJkZWZhdWx0QWxsRGF5IiwiZGF0ZUVudiIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwicGFyc2UiLCJhbGxEYXkiLCJhbGxEYXlHdWVzcyIsImR1cmF0aW9uIiwidHlwZURhdGEiLCJ0eXBlSWQiLCJleHBhbmRSZWN1cnJpbmciLCJldmVudFN0b3JlIiwiZnJhbWluZ1JhbmdlIiwicGx1Z2luSG9va3MiLCJvcHRpb25zIiwiZGVmcyIsImluc3RhbmNlcyIsImluc3RhbmNlIiwicmVjdXJyaW5nRGVmIiwiZGVmIiwiZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24iLCJkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uIiwic3RhcnRzIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwic3RhcnRzXzEiLCJzdGFydCIsImVuZCIsImV2ZW50RGVmIiwidHlwZURlZiIsIm1hcmtlcnMiLCJleHBhbmQiLCJzdWJ0cmFjdCIsIm1hcCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwiZXhlYyIsInNpZ24iLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91cnMiLCJob3VyIiwibWludXRlcyIsIm1pbnV0ZSIsInNlY29uZHMiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsIm1zIiwid2Vla3MiLCJ3ZWVrIiwic3BlY2lmaWVkV2Vla3MiLCJkdXJhdGlvbnNFcXVhbCIsImQwIiwiZDEiLCJhc0NsZWFuRGF5cyIsImR1ciIsImFkZER1cmF0aW9ucyIsInN1YnRyYWN0RHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFzUm91Z2hZZWFycyIsImFzUm91Z2hEYXlzIiwiYXNSb3VnaE1vbnRocyIsImFzUm91Z2hNcyIsImFzUm91Z2hNaW51dGVzIiwiYXNSb3VnaFNlY29uZHMiLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwibG9jYWxSZXMiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJidWlsZElzb1N0cmluZyIsInRpbWVab25lT2Zmc2V0Iiwic3RyaXBaZXJvVGltZSIsInRvSVNPU3RyaW5nIiwiZm9ybWF0VGltZVpvbmVPZmZzZXQiLCJmb3JtYXREYXlTdHJpbmciLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiZG9Jc28iLCJhYnMiLCJtaW5zIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250Iiwic3BsaWNlIiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJlcXVhbGl0eUZ1bmMiLCJtZW1vaXplIiwid29ya2VyRnVuYyIsInJlc0VxdWFsaXR5IiwidGVhcmRvd25GdW5jIiwiY3VycmVudEFyZ3MiLCJjdXJyZW50UmVzIiwibmV3QXJncyIsImFyZ3VtZW50cyIsIm1lbW9pemVPYmpBcmciLCJfdGhpcyIsImN1cnJlbnRBcmciLCJuZXdBcmciLCJtZW1vaXplQXJyYXlsaWtlIiwiY3VycmVudEFyZ1NldHMiLCJjdXJyZW50UmVzdWx0cyIsIm5ld0FyZ1NldHMiLCJjdXJyZW50TGVuIiwibmV3TGVuIiwibWVtb2l6ZUhhc2hsaWtlIiwiY3VycmVudEFyZ0hhc2giLCJjdXJyZW50UmVzSGFzaCIsIm5ld0FyZ0hhc2giLCJuZXdSZXNIYXNoIiwiRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMiLCJzZXBhcmF0b3IiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwib21pdENvbW1hcyIsIlNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTIiwidGltZVpvbmVOYW1lIiwiZXJhIiwid2Vla2RheSIsIk1FUklESUVNX1JFIiwiQ09NTUFfUkUiLCJNVUxUSV9TUEFDRV9SRSIsIkxUUl9SRSIsIlVUQ19SRSIsIk5hdGl2ZUZvcm1hdHRlciIsImZvcm1hdFNldHRpbmdzIiwic3RhbmRhcmREYXRlUHJvcHMiLCJleHRlbmRlZFNldHRpbmdzIiwic2V2ZXJpdHkiLCJtYXgiLCJidWlsZEZvcm1hdHRpbmdGdW5jIiwiZm9ybWF0UmFuZ2UiLCJiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIiwiZGlmZlNldmVyaXR5IiwiY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eSIsImNhbGVuZGFyU3lzdGVtIiwiYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsIiwiZnVsbDAiLCJmdWxsMSIsInBhcnRpYWxEYXRlUHJvcHMiLCJjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zIiwicGFydGlhbEZvcm1hdHRpbmdGdW5jIiwicGFydGlhbDAiLCJwYXJ0aWFsMSIsImluc2VydGlvbiIsImZpbmRDb21tb25JbnNlcnRpb24iLCJkZWZhdWx0U2VwYXJhdG9yIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRMYXJnZXN0VW5pdCIsInN0YW5kYXJkRGF0ZVByb3BDbnQiLCJmb3JtYXRXZWVrTnVtYmVyIiwiY29tcHV0ZVdlZWtOdW1iZXIiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImxvY2FsZSIsImJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMiLCJzYW5pdGl6ZVNldHRpbmdzIiwidGltZVpvbmUiLCJub3JtYWxGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJjb2RlcyIsInplcm9Gb3JtYXQiLCJ6ZXJvUHJvcHMiLCJwb3N0UHJvY2VzcyIsImluamVjdFR6b1N0ciIsInRyaW0iLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInR6b1N0ciIsInJlcGxhY2VkIiwibnVtIiwiZGlzcGxheSIsInBhcnRzIiwic2ltcGxlTnVtYmVyRm9ybWF0IiwiZGlyZWN0aW9uIiwicmV2ZXJzZSIsImpvaW4iLCJjYSIsImdldE1hcmtlclllYXIiLCJnZXRNYXJrZXJNb250aCIsImdldE1hcmtlckRheSIsImJpZ2dlc3RVbml0IiwicGFydGlhbE9wdGlvbnMiLCJpMCIsImZvdW5kMCIsImluZGV4T2YiLCJiZWZvcmUwIiwiYWZ0ZXIwIiwiaTEiLCJmb3VuZDEiLCJiZWZvcmUxIiwiYWZ0ZXIxIiwiZXhwYW5kWm9uZWRNYXJrZXIiLCJkYXRlSW5mbyIsIm1hcmtlclRvQXJyYXkiLCJjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyIsInN0YXJ0SW5mbyIsImVuZEluZm8iLCJsb2NhbGVDb2RlcyIsIkNtZEZvcm1hdHRlciIsImNtZFN0ciIsImNtZEZvcm1hdHRlciIsIkZ1bmNGb3JtYXR0ZXIiLCJjcmVhdGVGb3JtYXR0ZXIiLCJCQVNFX09QVElPTl9SRUZJTkVSUyIsIm5hdkxpbmtEYXlDbGljayIsImlkZW50aXR5IiwibmF2TGlua1dlZWtDbGljayIsImJvb3RzdHJhcEZvbnRBd2Vzb21lIiwiYnV0dG9uSWNvbnMiLCJjdXN0b21CdXR0b25zIiwibmV4dERheVRocmVzaG9sZCIsInNjcm9sbFRpbWUiLCJzY3JvbGxUaW1lUmVzZXQiLCJCb29sZWFuIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsImRheVBvcG92ZXJGb3JtYXQiLCJzbG90RHVyYXRpb24iLCJzbmFwRHVyYXRpb24iLCJoZWFkZXJUb29sYmFyIiwiZm9vdGVyVG9vbGJhciIsImRlZmF1bHRSYW5nZVNlcGFyYXRvciIsInRpdGxlUmFuZ2VTZXBhcmF0b3IiLCJmb3JjZUV2ZW50RHVyYXRpb24iLCJkYXlIZWFkZXJzIiwiZGF5SGVhZGVyRm9ybWF0IiwiZGF5SGVhZGVyQ2xhc3NOYW1lcyIsImRheUhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJEaWRNb3VudCIsImRheUhlYWRlcldpbGxVbm1vdW50IiwiZGF5Q2VsbENsYXNzTmFtZXMiLCJkYXlDZWxsQ29udGVudCIsImRheUNlbGxEaWRNb3VudCIsImRheUNlbGxXaWxsVW5tb3VudCIsImluaXRpYWxWaWV3IiwiYXNwZWN0UmF0aW8iLCJOdW1iZXIiLCJ3ZWVrZW5kcyIsIndlZWtOdW1iZXJDYWxjdWxhdGlvbiIsIndlZWtOdW1iZXJzIiwid2Vla051bWJlckNsYXNzTmFtZXMiLCJ3ZWVrTnVtYmVyQ29udGVudCIsIndlZWtOdW1iZXJEaWRNb3VudCIsIndlZWtOdW1iZXJXaWxsVW5tb3VudCIsImVkaXRhYmxlIiwidmlld0NsYXNzTmFtZXMiLCJ2aWV3RGlkTW91bnQiLCJ2aWV3V2lsbFVubW91bnQiLCJub3dJbmRpY2F0b3IiLCJub3dJbmRpY2F0b3JDbGFzc05hbWVzIiwibm93SW5kaWNhdG9yQ29udGVudCIsIm5vd0luZGljYXRvckRpZE1vdW50Iiwibm93SW5kaWNhdG9yV2lsbFVubW91bnQiLCJzaG93Tm9uQ3VycmVudERhdGVzIiwibGF6eUZldGNoaW5nIiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwidGltZVpvbmVQYXJhbSIsImxvY2FsZXMiLCJ0aGVtZVN5c3RlbSIsImRyYWdSZXZlcnREdXJhdGlvbiIsImRyYWdTY3JvbGwiLCJhbGxEYXlNYWludGFpbkR1cmF0aW9uIiwidW5zZWxlY3RBdXRvIiwiZHJvcEFjY2VwdCIsImV2ZW50T3JkZXIiLCJldmVudE9yZGVyU3RyaWN0IiwiaGFuZGxlV2luZG93UmVzaXplIiwid2luZG93UmVzaXplRGVsYXkiLCJsb25nUHJlc3NEZWxheSIsImV2ZW50RHJhZ01pbkRpc3RhbmNlIiwiZXhwYW5kUm93cyIsImhlaWdodCIsImNvbnRlbnRIZWlnaHQiLCJ3ZWVrTnVtYmVyRm9ybWF0IiwiZXZlbnRSZXNpemFibGVGcm9tU3RhcnQiLCJkaXNwbGF5RXZlbnRUaW1lIiwiZGlzcGxheUV2ZW50RW5kIiwicHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZyIsImJ1c2luZXNzSG91cnMiLCJpbml0aWFsRGF0ZSIsIm5vdyIsImV2ZW50RGF0YVRyYW5zZm9ybSIsInN0aWNreUhlYWRlckRhdGVzIiwic3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwidmlld0hlaWdodCIsImV2ZW50U291cmNlRmFpbHVyZSIsImV2ZW50U291cmNlU3VjY2VzcyIsImV2ZW50RGlzcGxheSIsImV2ZW50U3RhcnRFZGl0YWJsZSIsImV2ZW50RHVyYXRpb25FZGl0YWJsZSIsImV2ZW50T3ZlcmxhcCIsImV2ZW50Q29uc3RyYWludCIsImV2ZW50QWxsb3ciLCJldmVudEJhY2tncm91bmRDb2xvciIsImV2ZW50Qm9yZGVyQ29sb3IiLCJldmVudFRleHRDb2xvciIsImV2ZW50Q29sb3IiLCJldmVudENsYXNzTmFtZXMiLCJldmVudENvbnRlbnQiLCJldmVudERpZE1vdW50IiwiZXZlbnRXaWxsVW5tb3VudCIsInNlbGVjdENvbnN0cmFpbnQiLCJzZWxlY3RPdmVybGFwIiwic2VsZWN0QWxsb3ciLCJkcm9wcGFibGUiLCJ1bnNlbGVjdENhbmNlbCIsInNsb3RMYWJlbEZvcm1hdCIsInNsb3RMYW5lQ2xhc3NOYW1lcyIsInNsb3RMYW5lQ29udGVudCIsInNsb3RMYW5lRGlkTW91bnQiLCJzbG90TGFuZVdpbGxVbm1vdW50Iiwic2xvdExhYmVsQ2xhc3NOYW1lcyIsInNsb3RMYWJlbENvbnRlbnQiLCJzbG90TGFiZWxEaWRNb3VudCIsInNsb3RMYWJlbFdpbGxVbm1vdW50IiwiZGF5TWF4RXZlbnRzIiwiZGF5TWF4RXZlbnRSb3dzIiwiZGF5TWluV2lkdGgiLCJzbG90TGFiZWxJbnRlcnZhbCIsImFsbERheVRleHQiLCJhbGxEYXlDbGFzc05hbWVzIiwiYWxsRGF5Q29udGVudCIsImFsbERheURpZE1vdW50IiwiYWxsRGF5V2lsbFVubW91bnQiLCJzbG90TWluV2lkdGgiLCJuYXZMaW5rcyIsImV2ZW50VGltZUZvcm1hdCIsInJlcmVuZGVyRGVsYXkiLCJtb3JlTGlua1RleHQiLCJtb3JlTGlua0hpbnQiLCJzZWxlY3RNaW5EaXN0YW5jZSIsInNlbGVjdGFibGUiLCJzZWxlY3RMb25nUHJlc3NEZWxheSIsImV2ZW50TG9uZ1ByZXNzRGVsYXkiLCJzZWxlY3RNaXJyb3IiLCJldmVudE1heFN0YWNrIiwiZXZlbnRNaW5IZWlnaHQiLCJldmVudE1pbldpZHRoIiwiZXZlbnRTaG9ydEhlaWdodCIsInNsb3RFdmVudE92ZXJsYXAiLCJwbHVnaW5zIiwiZmlyc3REYXkiLCJkYXlDb3VudCIsImRhdGVBbGlnbm1lbnQiLCJkYXRlSW5jcmVtZW50IiwiaGlkZGVuRGF5cyIsIm1vbnRoTW9kZSIsImZpeGVkV2Vla0NvdW50IiwidmFsaWRSYW5nZSIsInZpc2libGVSYW5nZSIsInRpdGxlRm9ybWF0IiwiZXZlbnRJbnRlcmFjdGl2ZSIsIm5vRXZlbnRzVGV4dCIsInZpZXdIaW50IiwibmF2TGlua0hpbnQiLCJjbG9zZUhpbnQiLCJ0aW1lSGludCIsImV2ZW50SGludCIsIm1vcmVMaW5rQ2xpY2siLCJtb3JlTGlua0NsYXNzTmFtZXMiLCJtb3JlTGlua0NvbnRlbnQiLCJtb3JlTGlua0RpZE1vdW50IiwibW9yZUxpbmtXaWxsVW5tb3VudCIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiY2VudGVyIiwiQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMiLCJkYXRlc1NldCIsImV2ZW50c1NldCIsImV2ZW50QWRkIiwiZXZlbnRDaGFuZ2UiLCJldmVudFJlbW92ZSIsIndpbmRvd1Jlc2l6ZSIsImV2ZW50Q2xpY2siLCJldmVudE1vdXNlRW50ZXIiLCJldmVudE1vdXNlTGVhdmUiLCJzZWxlY3QiLCJ1bnNlbGVjdCIsImxvYWRpbmciLCJfdW5tb3VudCIsIl9iZWZvcmVwcmludCIsIl9hZnRlcnByaW50IiwiX25vRXZlbnREcm9wIiwiX25vRXZlbnRSZXNpemUiLCJfcmVzaXplIiwiX3Njcm9sbFJlcXVlc3QiLCJDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMiLCJidXR0b25UZXh0IiwiYnV0dG9uSGludHMiLCJ2aWV3cyIsImluaXRpYWxFdmVudHMiLCJldmVudHMiLCJldmVudFNvdXJjZXMiLCJDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyIsImlzTWF5YmVPYmplY3RzRXF1YWwiLCJWSUVXX09QVElPTl9SRUZJTkVSUyIsImNvbXBvbmVudCIsImJ1dHRvblRleHRLZXkiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwidXNlc01pbk1heFRpbWUiLCJjbGFzc05hbWVzIiwiY29udGVudCIsImRpZE1vdW50Iiwid2lsbFVubW91bnQiLCJtZXJnZVJhd09wdGlvbnMiLCJvcHRpb25TZXRzIiwicmVmaW5lUHJvcHMiLCJyZWZpbmVycyIsImV4dHJhIiwicmF3IiwicGFyc2VFdmVudHMiLCJyYXdFdmVudHMiLCJldmVudFNvdXJjZSIsImFsbG93T3BlblJhbmdlIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwiZXZlbnRSZWZpbmVycyIsImJ1aWxkRXZlbnRSZWZpbmVycyIsInJhd0V2ZW50c18xIiwicmF3RXZlbnQiLCJwYXJzZUV2ZW50IiwiZXZlbnRUdXBsZVRvU3RvcmUiLCJnZXRSZWxldmFudEV2ZW50cyIsImRlZl8xIiwibmV3U3RvcmUiLCJmaWx0ZXJFdmVudFN0b3JlRGVmcyIsImxvb2tEZWYiLCJpc0V2ZW50RGVmc0dyb3VwZWQiLCJkZWYwIiwiZGVmMSIsImdyb3VwSWQiLCJtZXJnZUV2ZW50U3RvcmVzIiwic3RvcmUwIiwic3RvcmUxIiwiZmlsdGVyRnVuYyIsImV4Y2x1ZGVTdWJFdmVudFN0b3JlIiwibWFzdGVyIiwic3ViIiwiZmlsdGVyZWREZWZzIiwiZmlsdGVyZWRJbnN0YW5jZXMiLCJub3JtYWxpemVDb25zdHJhaW50IiwicGFyc2VDbGFzc05hbWVzIiwiRVZFTlRfVUlfUkVGSU5FUlMiLCJzdGFydEVkaXRhYmxlIiwiZHVyYXRpb25FZGl0YWJsZSIsImNvbnN0cmFpbnQiLCJvdmVybGFwIiwiYWxsb3ciLCJjbGFzc05hbWUiLCJjb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwidGV4dENvbG9yIiwiRU1QVFlfRVZFTlRfVUkiLCJjb25zdHJhaW50cyIsImFsbG93cyIsImNyZWF0ZUV2ZW50VWkiLCJjb21iaW5lRXZlbnRVaXMiLCJ1aXMiLCJjb21iaW5lVHdvRXZlbnRVaXMiLCJpdGVtMCIsIml0ZW0xIiwiRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMiLCJpZCIsInRpdGxlIiwiaW50ZXJhY3RpdmUiLCJFVkVOVF9EQVRFX1JFRklORVJTIiwiRVZFTlRfUkVGSU5FUlMiLCJleHRlbmRlZFByb3BzIiwicmVmaW5lRXZlbnREZWYiLCJjb21wdXRlSXNEZWZhdWx0QWxsRGF5IiwicmVjdXJyaW5nUmVzIiwicGFyc2VFdmVudERlZiIsInNpbmdsZVJlcyIsInBhcnNlU2luZ2xlIiwiaGFzRW5kIiwidWkiLCJldmVudERlZk1lbWJlckFkZGVycyIsIm1lbWJlckFkZGVyIiwiZnJlZXplIiwic3RhcnRNZXRhIiwic3RhcnRNYXJrZXIiLCJlbmRNZXRhIiwiZW5kTWFya2VyIiwic3RhcnRJbnB1dCIsImNyZWF0ZU1hcmtlck1ldGEiLCJpc1RpbWVVbnNwZWNpZmllZCIsImZvcmNlZFR6byIsImNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UiLCJ0aW1lZFJhbmdlIiwiZGF5Q250IiwiY29tcHV0ZVZpc2libGVEYXlSYW5nZSIsInN0YXJ0RGF5IiwiZW5kRGF5IiwiZW5kVGltZU1TIiwiaXNNdWx0aURheVJhbmdlIiwiZGlmZkRhdGVzIiwiZGF0ZTAiLCJkYXRlMSIsImxhcmdlVW5pdCIsImRpZmZXaG9sZVllYXJzIiwiZGlmZldob2xlTW9udGhzIiwicGFyc2VSYW5nZSIsImNyZWF0ZU1hcmtlciIsImludmVydFJhbmdlcyIsInJhbmdlcyIsImNvbnN0cmFpbnRSYW5nZSIsImludmVydGVkUmFuZ2VzIiwiZGF0ZVJhbmdlIiwic29ydCIsImNvbXBhcmVSYW5nZXMiLCJyYW5nZTAiLCJyYW5nZTEiLCJpbnRlcnNlY3RSYW5nZXMiLCJuZXdSYW5nZSIsInJhbmdlc0VxdWFsIiwicmFuZ2VzSW50ZXJzZWN0IiwicmFuZ2VDb250YWluc1JhbmdlIiwib3V0ZXJSYW5nZSIsImlubmVyUmFuZ2UiLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwiY29uc3RyYWluTWFya2VyVG9SYW5nZSIsInNsaWNlRXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsImludmVyc2VCZ0J5R3JvdXBJZCIsImludmVyc2VCZ0J5RGVmSWQiLCJkZWZCeUdyb3VwSWQiLCJiZ1JhbmdlcyIsImZnUmFuZ2VzIiwiZXZlbnRVaXMiLCJjb21waWxlRXZlbnRVaXMiLCJvcmlnUmFuZ2UiLCJub3JtYWxSYW5nZSIsInNsaWNlZFJhbmdlIiwiaXNTdGFydCIsImlzRW5kIiwiaW52ZXJ0ZWRSYW5nZXNfMSIsImludmVydGVkUmFuZ2UiLCJpbnZlcnRlZFJhbmdlc18yIiwiYmciLCJmZyIsImhhc0JnUmVuZGVyaW5nIiwic2V0RWxTZWciLCJzZWciLCJmY1NlZyIsImdldEVsU2VnIiwiZXZlbnREZWZzIiwiY29tcGlsZUV2ZW50VWkiLCJzb3J0RXZlbnRTZWdzIiwic2VncyIsImV2ZW50T3JkZXJTcGVjcyIsIm9ianMiLCJidWlsZFNlZ0NvbXBhcmVPYmoiLCJjIiwiX3NlZyIsImV2ZW50UmFuZ2UiLCJjb21wdXRlU2VnRHJhZ2dhYmxlIiwidHJhbnNmb3JtZXJzIiwiaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMiLCJ0cmFuc2Zvcm1lcnNfMSIsInRyYW5zZm9ybWVyIiwiY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlIiwiY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSIsImJ1aWxkU2VnVGltZVRleHQiLCJ0aW1lRm9ybWF0IiwiZGVmYXVsdERpc3BsYXlFdmVudFRpbWUiLCJkZWZhdWx0RGlzcGxheUV2ZW50RW5kIiwic3RhcnRPdmVycmlkZSIsImVuZE92ZXJyaWRlIiwiZXZlbnRJbnN0YW5jZSIsIndob2xlRXZlbnRTdGFydCIsIndob2xlRXZlbnRFbmQiLCJzZWdTdGFydCIsInNlZ0VuZCIsImlzU3RhcnREYXkiLCJpc0VuZERheSIsImdldFNlZ01ldGEiLCJ0b2RheVJhbmdlIiwibm93RGF0ZSIsInNlZ1JhbmdlIiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJpc1RvZGF5IiwiZ2V0RXZlbnRDbGFzc05hbWVzIiwiaXNNaXJyb3IiLCJpc0RyYWdnYWJsZSIsImlzU3RhcnRSZXNpemFibGUiLCJpc0VuZFJlc2l6YWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNTZWxlY3RlZCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaHJlZiIsImVtaXR0ZXIiLCJoYXNIYW5kbGVycyIsInRyaWdnZXIiLCJldmVudCIsIkV2ZW50QXBpIiwianNFdmVudCIsInZpZXciLCJ2aWV3QXBpIiwiU1RBTkRBUkRfUFJPUFMiLCJwYXJzZURhdGVTcGFuIiwiZGVmYXVsdER1cmF0aW9uIiwic3BhbiIsInBhcnNlT3BlbkRhdGVTcGFuIiwic3RhbmRhcmRQcm9wcyIsImlzRGF0ZVNwYW5zRXF1YWwiLCJzcGFuMCIsInNwYW4xIiwiaXNTcGFuUHJvcHNFcXVhbCIsImJ1aWxkRGF0ZVNwYW5BcGkiLCJidWlsZFJhbmdlQXBpIiwiYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZSIsIm9taXRUaW1lIiwidG9EYXRlIiwic3RhcnRTdHIiLCJmb3JtYXRJc28iLCJlbmRTdHIiLCJmYWJyaWNhdGVFdmVudFJhbmdlIiwiZGF0ZVNwYW4iLCJ0cmlnZ2VyRGF0ZVNlbGVjdCIsInNlbGVjdGlvbiIsInBldiIsImJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dCIsIm9yaWdFdmVudCIsImNhbGVuZGFyQXBpIiwidHJpZ2dlckRhdGVVbnNlbGVjdCIsImRhdGVTcGFuVHJhbnNmb3JtcyIsInRyYW5zZm9ybSIsImdldERlZmF1bHRFdmVudEVuZCIsImFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUiLCJldmVudENvbmZpZ0Jhc2UiLCJtdXRhdGlvbiIsImV2ZW50Q29uZmlncyIsImFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZSIsImV2ZW50Q29uZmlnIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiY29weSIsImV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyIsImFwcGxpZXIiLCJmb3JjZUFsbERheSIsImNsZWFyRW5kIiwiZGF0ZXNEZWx0YSIsIlZpZXdBcGkiLCJnZXRDdXJyZW50RGF0YSIsInZpZXdUaXRsZSIsImRhdGVQcm9maWxlIiwiYWN0aXZlUmFuZ2UiLCJjdXJyZW50UmFuZ2UiLCJnZXRPcHRpb24iLCJFVkVOVF9TT1VSQ0VfUkVGSU5FUlMiLCJzdWNjZXNzIiwiZmFpbHVyZSIsInBhcnNlRXZlbnRTb3VyY2UiLCJidWlsZEV2ZW50U291cmNlUmVmaW5lcnMiLCJyYXdPYmoiLCJtZXRhUmVzIiwiYnVpbGRFdmVudFNvdXJjZU1ldGEiLCJfcmF3IiwiaXNGZXRjaGluZyIsImxhdGVzdEZldGNoSWQiLCJmZXRjaFJhbmdlIiwic291cmNlRGVmSWQiLCJldmVudFNvdXJjZVJlZmluZXJzIiwiZXZlbnRTb3VyY2VEZWZzIiwicGFyc2VNZXRhIiwicmVkdWNlQ3VycmVudERhdGUiLCJjdXJyZW50RGF0ZSIsImFjdGlvbiIsImRhdGVNYXJrZXIiLCJnZXRJbml0aWFsRGF0ZSIsImluaXRpYWxEYXRlSW5wdXQiLCJnZXROb3ciLCJub3dJbnB1dCIsImNyZWF0ZU5vd01hcmtlciIsIkNhbGVuZGFyQXBpIiwiY3VycmVudERhdGFNYW5hZ2VyIiwiYmF0Y2hSZW5kZXJpbmciLCJ1cGRhdGVTaXplIiwic2V0T3B0aW9uIiwib3B0aW9uTmFtZSIsInJhd09wdGlvblZhbHVlIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0IiwiZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMiLCJhdmFpbGFibGVSYXdMb2NhbGVzIiwib24iLCJoYW5kbGVyTmFtZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyIsImNvbnNvbGUiLCJ3YXJuIiwib2ZmIiwiX19zcHJlYWRBcnJheSIsImNoYW5nZVZpZXciLCJ2aWV3VHlwZSIsImRhdGVPclJhbmdlIiwiem9vbVRvIiwic3RhdGUiLCJzcGVjIiwidmlld1NwZWNzIiwiZ2V0VW5pdFZpZXdTcGVjIiwidG9vbGJhckNvbmZpZyIsInZpZXdUeXBlcyIsImhlYWRlciIsInZpZXdzV2l0aEJ1dHRvbnMiLCJmb290ZXIiLCJzaW5nbGVVbml0IiwicHJldiIsIm5leHQiLCJwcmV2WWVhciIsImFkZFllYXJzIiwibmV4dFllYXIiLCJ0b2RheSIsImNhbGVuZGFyT3B0aW9ucyIsImdvdG9EYXRlIiwiem9uZWREYXRlSW5wdXQiLCJpbmNyZW1lbnREYXRlIiwiZGVsdGFJbnB1dCIsImRlbHRhIiwiZm9ybWF0RGF0ZSIsInNldHRpbmdzIiwiZGF0ZU9yT2JqIiwiZW5kRGF0ZSIsInNlbGVjdGlvbklucHV0IiwiZGF0ZVNlbGVjdGlvbiIsImFkZEV2ZW50IiwiZXZlbnRJbnB1dCIsInNvdXJjZUlucHV0IiwiX2RlZiIsIl9pbnN0YW5jZSIsImN1cnJlbnREYXRhIiwidHJpZ2dlckV2ZW50QWRkIiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwibmV3RXZlbnRBcGkiLCJldmVudEFwaSIsInJlbGF0ZWRFdmVudHMiLCJyZXZlcnQiLCJldmVudEFwaVRvU3RvcmUiLCJnZXRFdmVudEJ5SWQiLCJnZXRFdmVudHMiLCJidWlsZEV2ZW50QXBpcyIsInJlbW92ZUFsbEV2ZW50cyIsImdldEV2ZW50U291cmNlcyIsInNvdXJjZUhhc2giLCJzb3VyY2VBcGlzIiwiaW50ZXJuYWxJZCIsImFkZEV2ZW50U291cmNlIiwic291cmNlcyIsInJlbW92ZUFsbEV2ZW50U291cmNlcyIsInJlZmV0Y2hFdmVudHMiLCJzY3JvbGxUb1RpbWUiLCJ0aW1lSW5wdXQiLCJ0aW1lIiwiX2NvbnRleHQiLCJzZXRQcm9wIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsImNvbnRleHRfMSIsImV2ZW50U3RvcmVfMSIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJhc1N0b3JlIiwidG9QbGFpbk9iamVjdCIsImNvbGxhcHNlQ29sb3IiLCJjb2xsYXBzZUV4dGVuZGVkUHJvcHMiLCJ0b0pTT04iLCJleGNsdWRlSW5zdGFuY2UiLCJldmVudEFwaXMiLCJleGNsdWRlSW5zdGFuY2VJZCIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsIkRhdGVFbnYiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwidGltZXN0YW1wVG9NYXJrZXIiLCJnZXRZZWFyIiwiYWRkTW9udGhzIiwiZ3JlYXRlc3RXaG9sZVVuaXQiLCJjb3VudER1cmF0aW9uc0JldHdlZW4iLCJkaWZmIiwic3RhcnRPZiIsInN0YXJ0T2ZZZWFyIiwic3RhcnRPZk1vbnRoIiwic3RhcnRPZldlZWsiLCJkYXRlT3B0aW9ucyIsIm9mZnNldEZvck1hcmtlciIsImlzRW5kRXhjbHVzaXZlIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0IiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJnbG9iYWxMb2NhbGVzIiwiTUlOSU1BTF9SQVdfRU5fTE9DQUxFIiwiY29kZSIsImxpc3QiLCJSQVdfRU5fTE9DQUxFIiwiZXZlbnRDbnQiLCJvcmdhbml6ZVJhd0xvY2FsZXMiLCJleHBsaWNpdFJhd0xvY2FsZXMiLCJkZWZhdWx0Q29kZSIsImFsbFJhd0xvY2FsZXMiLCJyYXdMb2NhbGVNYXAiLCJlbiIsImFsbFJhd0xvY2FsZXNfMSIsInJhd0xvY2FsZSIsImJ1aWxkTG9jYWxlIiwiaW5wdXRTaW5ndWxhciIsImF2YWlsYWJsZSIsInBhcnNlTG9jYWxlIiwicXVlcnlMb2NhbGUiLCJjb2RlQXJnIiwicXVlcnlSYXdMb2NhbGUiLCJzaW1wbGVJZCIsInNsaWNlIiwibWVyZ2VkIiwiTnVtYmVyRm9ybWF0IiwiZGF0ZUlucHV0IiwiYnVpbGREYXRlRW52JDEiLCJkYXRlTWV0YSIsIkRFRl9ERUZBVUxUUyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkYXlzT2ZXZWVrIiwicGFyc2VCdXNpbmVzc0hvdXJzIiwicmVmaW5lSW5wdXRzIiwicmF3RGVmcyIsImZpbHRlciIsInJhd0RlZiIsInBvaW50SW5zaWRlUmVjdCIsInBvaW50IiwicmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImludGVyc2VjdFJlY3RzIiwicmVjdDEiLCJyZWN0MiIsInRyYW5zbGF0ZVJlY3QiLCJkZWx0YVgiLCJkZWx0YVkiLCJjb25zdHJhaW5Qb2ludCIsImdldFJlY3RDZW50ZXIiLCJkaWZmUG9pbnRzIiwicG9pbnQxIiwicG9pbnQyIiwiY2FuVkdyb3dXaXRoaW5DZWxsIiwiZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIiwiY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCIsImNyZWF0ZUVsZW1lbnQiLCJwb3NpdGlvbiIsImlubmVySFRNTCIsImFwcGVuZENoaWxkIiwiZGl2IiwicG9zc2libGUiLCJvZmZzZXRIZWlnaHQiLCJFTVBUWV9FVkVOVF9TVE9SRSIsIlNwbGl0dGVyIiwiZ2V0S2V5c0ZvckV2ZW50RGVmcyIsIl9nZXRLZXlzRm9yRXZlbnREZWZzIiwic3BsaXREYXRlU2VsZWN0aW9uIiwiX3NwbGl0RGF0ZVNwYW4iLCJzcGxpdEV2ZW50U3RvcmUiLCJfc3BsaXRFdmVudFN0b3JlIiwic3BsaXRJbmRpdmlkdWFsVWkiLCJfc3BsaXRJbmRpdmlkdWFsVWkiLCJzcGxpdEV2ZW50RHJhZyIsIl9zcGxpdEludGVyYWN0aW9uIiwic3BsaXRFdmVudFJlc2l6ZSIsImV2ZW50VWlCdWlsZGVycyIsInNwbGl0UHJvcHMiLCJrZXlJbmZvcyIsImdldEtleUluZm8iLCJkZWZLZXlzIiwiZGF0ZVNlbGVjdGlvbnMiLCJpbmRpdmlkdWFsVWkiLCJldmVudFN0b3JlcyIsImV2ZW50RHJhZ3MiLCJldmVudERyYWciLCJldmVudFJlc2l6ZXMiLCJldmVudFJlc2l6ZSIsImluZm8iLCJidWlsZEV2ZW50VWlGb3JLZXkiLCJrZXlJbmZvIiwiYnVpbGRFdmVudFVpIiwiZXZlbnRTZWxlY3Rpb24iLCJkYXRlU3BhbnMiLCJnZXRLZXlzRm9yRGF0ZVNwYW4iLCJrZXlzXzEiLCJnZXRLZXlzRm9yRXZlbnREZWYiLCJzcGxpdFN0b3JlcyIsIl9jIiwic3BsaXRIYXNoZXMiLCJpbnRlcmFjdGlvbiIsInNwbGl0U3RhdGVzIiwiYWZmZWN0ZWRTdG9yZXNfMSIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEtleXNCeURlZklkIiwibXV0YXRlZEV2ZW50cyIsIm11dGF0ZWRTdG9yZXNfMSIsInBvcHVsYXRlIiwiaXNFdmVudCIsImFsbFVpIiwiZXZlbnRVaUZvcktleSIsImJhc2VQYXJ0cyIsInN0dWZmIiwiZ2V0RGF0ZU1ldGEiLCJpc0Rpc2FibGVkIiwiaXNPdGhlciIsImdldERheUNsYXNzTmFtZXMiLCJ0aGVtZSIsImdldENsYXNzIiwiZ2V0U2xvdENsYXNzTmFtZXMiLCJEQVlfRk9STUFUIiwiV0VFS19GT1JNQVQiLCJidWlsZE5hdkxpbmtBdHRycyIsImlzVGFiYmFibGUiLCJkYXRlU3RyIiwiem9uZWREYXRlIiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJjdXN0b21BY3Rpb24iLCJfaXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCIsImNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCIsIm91dGVyRWwiLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJpbm5lckVsIiwiZmlyc3RDaGlsZCIsIl9zY3JvbGxiYXJXaWR0aHMiLCJnZXRTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIiwieCIsImNsaWVudEhlaWdodCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJjb21wdXRlRWRnZXMiLCJnZXRQYWRkaW5nIiwiY29tcHV0ZWRTdHlsZSIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJhZFNjcm9sbGJhcldpZHRocyIsInNjcm9sbGJhckxlZnRSaWdodCIsInNjcm9sbGJhckJvdHRvbSIsInNjcm9sbGJhckxlZnQiLCJzY3JvbGxiYXJSaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJjb21wdXRlSW5uZXJSZWN0IiwiZ29XaXRoaW5QYWRkaW5nIiwiZG9Gcm9tV2luZG93Vmlld3BvcnQiLCJvdXRlclJlY3QiLCJjb21wdXRlUmVjdCIsImVkZ2VzIiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdCIsImNsaXBwaW5nUGFyZW50cyIsImdldENsaXBwaW5nUGFyZW50cyIsImNsaXBwaW5nUGFyZW50c18xIiwiY2xpcHBpbmdQYXJlbnQiLCJpbnRlcnNlY3Rpb24iLCJjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyIsImNvbXB1dGVWTWFyZ2lucyIsImNvbXB1dGVkIiwibWFyZ2luVG9wIiwibWFyZ2luQm90dG9tIiwib3ZlcmZsb3dZIiwib3ZlcmZsb3dYIiwidW5wcm9taXNpZnkiLCJpc1Jlc29sdmVkIiwid3JhcHBlZFN1Y2Nlc3MiLCJ3cmFwcGVkRmFpbHVyZSIsInRoZW4iLCJFbWl0dGVyIiwiaGFuZGxlcnMiLCJ0aGlzQ29udGV4dCIsInNldFRoaXNDb250ZXh0Iiwic2V0T3B0aW9ucyIsImFkZFRvSGFzaCIsInJlbW92ZUZyb21IYXNoIiwiYXR0YWNoZWRIYW5kbGVycyIsIm9wdGlvbkhhbmRsZXIiLCJoYW5kbGVyc18xIiwiUG9zaXRpb25DYWNoZSIsIm9yaWdpbkVsIiwiZWxzIiwiaXNIb3Jpem9udGFsIiwiaXNWZXJ0aWNhbCIsIm9yaWdpbkNsaWVudFJlY3QiLCJidWlsZEVsSG9yaXpvbnRhbHMiLCJidWlsZEVsVmVydGljYWxzIiwib3JpZ2luQ2xpZW50TGVmdCIsImxlZnRzIiwicmlnaHRzIiwib3JpZ2luQ2xpZW50VG9wIiwidG9wcyIsImJvdHRvbXMiLCJsZWZ0VG9JbmRleCIsImxlZnRQb3NpdGlvbiIsInRvcFRvSW5kZXgiLCJ0b3BQb3NpdGlvbiIsImdldFdpZHRoIiwibGVmdEluZGV4IiwiZ2V0SGVpZ2h0IiwidG9wSW5kZXgiLCJTY3JvbGxDb250cm9sbGVyIiwiZ2V0TWF4U2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiZ2V0TWF4U2Nyb2xsTGVmdCIsImdldFNjcm9sbFdpZHRoIiwiZ2V0Q2xpZW50V2lkdGgiLCJjYW5TY3JvbGxWZXJ0aWNhbGx5IiwiY2FuU2Nyb2xsSG9yaXpvbnRhbGx5IiwiY2FuU2Nyb2xsVXAiLCJnZXRTY3JvbGxUb3AiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsIkVsZW1lbnRTY3JvbGxDb250cm9sbGVyIiwiX3N1cGVyIiwiX19leHRlbmRzIiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsInNldFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsIldpbmRvd1Njcm9sbENvbnRyb2xsZXIiLCJzY3JvbGwiLCJUaGVtZSIsImljb25PdmVycmlkZU9wdGlvbiIsInNldEljb25PdmVycmlkZSIsImljb25PdmVycmlkZUhhc2giLCJpY29uQ2xhc3Nlc0NvcHkiLCJidXR0b25OYW1lIiwiaWNvbkNsYXNzZXMiLCJhcHBseUljb25PdmVycmlkZVByZWZpeCIsInByZWZpeCIsImljb25PdmVycmlkZVByZWZpeCIsImNsYXNzZXMiLCJnZXRJY29uQ2xhc3MiLCJpc1J0bCIsInJ0bEljb25DbGFzc2VzIiwiYmFzZUljb25DbGFzcyIsImdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyIsImN1c3RvbUJ1dHRvblByb3BzIiwiaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uIiwiU2Nyb2xsUmVzcG9uZGVyIiwiZXhlY0Z1bmMiLCJoYW5kbGVTY3JvbGxSZXF1ZXN0IiwicmVxdWVzdCIsInF1ZXVlZFJlcXVlc3QiLCJkcmFpbiIsImZpcmVJbml0aWFsU2Nyb2xsIiwiZGV0YWNoIiwidXBkYXRlIiwiaXNEYXRlc05ldyIsIlZpZXdDb250ZXh0VHlwZSIsImNyZWF0ZUNvbnRleHQiLCJidWlsZFZpZXdDb250ZXh0Iiwidmlld1NwZWMiLCJ2aWV3T3B0aW9ucyIsImRhdGVQcm9maWxlR2VuZXJhdG9yIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImFkZFJlc2l6ZUhhbmRsZXIiLCJyZW1vdmVSZXNpemVIYW5kbGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwiUHVyZUNvbXBvbmVudCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsIm5leHRQcm9wcyIsIm5leHRTdGF0ZSIsImRlYnVnIiwibG9nIiwicHJvcEVxdWFsaXR5Iiwic3RhdGVFcXVhbGl0eSIsInNhZmVTZXRTdGF0ZSIsIm5ld1N0YXRlIiwic2V0U3RhdGUiLCJhZGRQcm9wc0VxdWFsaXR5IiwiYWRkU3RhdGVFcXVhbGl0eSIsImNvbnRleHRUeXBlIiwiQ29tcG9uZW50IiwiQmFzZUNvbXBvbmVudCIsImNyZWF0ZSIsInNldFJlZiIsInJlZiIsImN1cnJlbnQiLCJEYXRlQ29tcG9uZW50IiwidWlkIiwicHJlcGFyZUhpdHMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwiZWxXaWR0aCIsImVsSGVpZ2h0IiwiaXNWYWxpZFNlZ0Rvd25FbCIsImlzVmFsaWREYXRlRG93bkVsIiwiY3JlYXRlUGx1Z2luIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNMb2FkaW5nRnVuY3MiLCJjb250ZXh0SW5pdCIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyIsImRhdGVQb2ludFRyYW5zZm9ybXMiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJpc1Byb3BzVmFsaWQiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvbkNoYW5nZUhhbmRsZXJzIiwic2Nyb2xsR3JpZEltcGwiLCJjb250ZW50VHlwZUhhbmRsZXJzIiwibGlzdGVuZXJSZWZpbmVycyIsIm9wdGlvblJlZmluZXJzIiwicHJvcFNldEhhbmRsZXJzIiwiYnVpbGRQbHVnaW5Ib29rcyIsInBsdWdpbkRlZnMiLCJnbG9iYWxEZWZzIiwiaXNBZGRlZCIsImhvb2tzIiwiYWRkRGVmcyIsImRlZnNfMSIsImNvbWJpbmVIb29rcyIsImJ1aWxkQnVpbGRQbHVnaW5Ib29rcyIsImN1cnJlbnRPdmVycmlkZURlZnMiLCJjdXJyZW50R2xvYmFsRGVmcyIsImN1cnJlbnRIb29rcyIsIm92ZXJyaWRlRGVmcyIsImhvb2tzMCIsImhvb2tzMSIsIlN0YW5kYXJkVGhlbWUiLCJyb290IiwidGFibGVDZWxsU2hhZGVkIiwiYnV0dG9uR3JvdXAiLCJidXR0b24iLCJidXR0b25BY3RpdmUiLCJjbG9zZSIsImNvbXBpbGVWaWV3RGVmcyIsImRlZmF1bHRDb25maWdzIiwib3ZlcnJpZGVDb25maWdzIiwiZW5zdXJlVmlld0RlZiIsInZpZXdEZWYiLCJidWlsZFZpZXdEZWYiLCJkZWZhdWx0Q29uZmlnIiwib3ZlcnJpZGVDb25maWciLCJxdWVyeVByb3AiLCJ0aGVDb21wb25lbnQiLCJzdXBlclR5cGUiLCJzdXBlckRlZiIsImRlZmF1bHRzIiwicmF3T3B0aW9ucyIsIm92ZXJyaWRlcyIsIlJlbmRlckhvb2siLCJyb290RWxSZWYiLCJjcmVhdGVSZWYiLCJoYW5kbGVSb290RWwiLCJlbFJlZiIsInJlbmRlciIsImhvb2tQcm9wcyIsIk1vdW50SG9vayIsIkNvbnRlbnRIb29rIiwiZGVmYXVsdENvbnRlbnQiLCJiYWNrdXBFbFJlZiIsImlubmVyRWxSZWYiLCJpbm5lckNvbnRlbnQiLCJub3JtYWxpemVDbGFzc05hbWVzIiwiQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQiLCJDb25zdW1lciIsInJlbmRlcklkIiwiQ29udGVudEhvb2tJbm5lciIsInJlbmRlcklubmVyQ29udGVudCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlQ3VzdG9tQ29udGVudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY3VzdG9tQ29udGVudEluZm8iLCJkZXN0cm95IiwiZ2V0SW5uZXJDb250ZW50IiwiZ2V0Q29udGVudE1ldGEiLCJjb250ZW50S2V5IiwiY29udGVudFZhbCIsImJ1aWxkTGlmZWN5Y2xlRnVuY3MiLCJub3JtYWxpemVDb250ZW50Iiwic2VhcmNoS2V5Iiwicm9vdEVsIiwiYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyIiwiY3VycmVudEdlbmVyYXRvciIsImN1cnJlbnRIb29rUHJvcHMiLCJjdXJyZW50Q2xhc3NOYW1lcyIsImdlbmVyYXRvciIsIlZpZXdSb290IiwiY3VzdG9tQ2xhc3NOYW1lcyIsInBhcnNlVmlld0NvbmZpZ3MiLCJpbnB1dHMiLCJwYXJzZVZpZXdDb25maWciLCJjcmVhdGVWaWV3SG9va0NvbXBvbmVudCIsInZpZXdQcm9wcyIsInZpZXdFbFJlZiIsImJ1aWxkVmlld1NwZWNzIiwiZGVmYXVsdElucHV0cyIsIm9wdGlvbk92ZXJyaWRlcyIsImR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJsb2NhbGVEZWZhdWx0cyIsInZpZXdEZWZzIiwiYnVpbGRWaWV3U3BlYyIsImR1cmF0aW9uSW5wdXQiLCJkdXJhdGlvblVuaXQiLCJzaW5nbGVVbml0T3ZlcnJpZGVzIiwiY3JlYXRlRHVyYXRpb25DYWNoZWQiLCJkZW5vbSIsInF1ZXJ5QnV0dG9uVGV4dCIsIm9wdGlvbnNTdWJzZXQiLCJidXR0b25UZXh0TWFwIiwicXVlcnlCdXR0b25UaXRsZSIsImJ1dHRvbktleSIsIm9wdGlvbkRlZmF1bHRzIiwiYnV0dG9uVGV4dE92ZXJyaWRlIiwiYnV0dG9uVGV4dERlZmF1bHQiLCJidXR0b25UaXRsZU92ZXJyaWRlIiwiYnV0dG9uSGludCIsImJ1dHRvblRpdGxlRGVmYXVsdCIsImR1cmF0aW9uSW5wdXRNYXAiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJmb3JjZVRvVmFsaWQiLCJwcmV2RGF0ZSIsImN1cnJlbnRSYW5nZVVuaXQiLCJidWlsZCIsImJ1aWxkTmV4dCIsIm5leHREYXRlIiwiY3VycmVudEluZm8iLCJpc1JhbmdlQWxsRGF5IiwicmVuZGVyUmFuZ2UiLCJpc1ZhbGlkIiwiYnVpbGRWYWxpZFJhbmdlIiwidHJpbUhpZGRlbkRheXMiLCJidWlsZEN1cnJlbnRSYW5nZUluZm8iLCJidWlsZFJlbmRlclJhbmdlIiwiYWRqdXN0QWN0aXZlUmFuZ2UiLCJidWlsZERhdGVJbmNyZW1lbnQiLCJ2YWxpZFJhbmdlSW5wdXQiLCJzaW1wbGVJbnB1dCIsInJlZmluZVJhbmdlIiwiYnVpbGRSYW5nZUZyb21EdXJhdGlvbiIsImJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQiLCJidWlsZEN1c3RvbVZpc2libGVSYW5nZSIsImdldEZhbGxiYWNrRHVyYXRpb24iLCJpc0hpZGRlbkRheSIsInNraXBIaWRkZW5EYXlzIiwiY29tcHV0ZVJlcyIsInJ1bm5pbmdDb3VudCIsInZpc2libGVSYW5nZUlucHV0IiwiZmFsbGJhY2siLCJjdXN0b21BbGlnbm1lbnQiLCJyYW5nZUlucHV0IiwiaXNIaWRkZW5EYXlIYXNoIiwiaW5jIiwiaXNFeGNsdXNpdmUiLCJyZWR1Y2VWaWV3VHlwZSIsInJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJyZWR1Y2VEYXRlUHJvZmlsZSIsImRwIiwiaW5pdEV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJwYXJzZUluaXRpYWxTb3VyY2VzIiwicmVkdWNlRXZlbnRTb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwiZmV0Y2hJZCIsInJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lIiwiY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmciLCJldmVudFNvdXJjZUhhc2giLCJzb3VyY2VzXzEiLCJzb3VyY2UiLCJpc1NvdXJjZURpcnR5IiwiZG9lc1NvdXJjZU5lZWRSYW5nZSIsInByZXZTb3VyY2VzIiwic291cmNlSWRIYXNoIiwibmV4dFNvdXJjZXMiLCJmZXRjaFNvdXJjZSIsInNvdXJjZURlZiIsImZldGNoIiwieGhyIiwiZXJyb3IiLCJtZXNzYWdlIiwicmF3U291cmNlcyIsInJhd1NvdXJjZXNfMSIsInJhd1NvdXJjZSIsImlnbm9yZVJhbmdlIiwicmVkdWNlRXZlbnRTdG9yZSIsInJlY2VpdmVSYXdFdmVudHMiLCJleGNsdWRlRXZlbnRzQnlTb3VyY2VJZCIsInN1YnNldCIsInRyYW5zZm9ybVJhd0V2ZW50cyIsImNhbEVhY2hUcmFuc2Zvcm0iLCJzb3VyY2VFYWNoVHJhbnNmb3JtIiwidHJhbnNmb3JtRWFjaFJhd0V2ZW50IiwicmVmaW5lZEV2ZW50cyIsInJlZmluZWRFdmVudCIsImV4cGFuZFJhbmdlIiwicmV6b25lRXZlbnRTdG9yZURhdGVzIiwib2xkRGF0ZUVudiIsIm5ld0RhdGVFbnYiLCJleGNsdWRlSW5zdGFuY2VzIiwicmVtb3ZhbHMiLCJyZWR1Y2VEYXRlU2VsZWN0aW9uIiwiY3VycmVudFNlbGVjdGlvbiIsInJlZHVjZVNlbGVjdGVkRXZlbnQiLCJjdXJyZW50SW5zdGFuY2VJZCIsImV2ZW50SW5zdGFuY2VJZCIsInJlZHVjZUV2ZW50RHJhZyIsImN1cnJlbnREcmFnIiwibmV3RHJhZyIsInJlZHVjZUV2ZW50UmVzaXplIiwiY3VycmVudFJlc2l6ZSIsIm5ld1Jlc2l6ZSIsInBhcnNlVG9vbGJhcnMiLCJjYWxlbmRhck9wdGlvbk92ZXJyaWRlcyIsInBhcnNlVG9vbGJhciIsInNlY3Rpb25TdHJIYXNoIiwic2VjdGlvbldpZGdldHMiLCJoYXNUaXRsZSIsInNlY3Rpb25OYW1lIiwic2VjdGlvblN0ciIsInNlY3Rpb25SZXMiLCJwYXJzZVNlY3Rpb24iLCJ3aWRnZXRzIiwiY2FsZW5kYXJDdXN0b21CdXR0b25zIiwiY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25UZXh0IiwiY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzIiwiY2FsZW5kYXJCdXR0b25IaW50cyIsInNlY3Rpb25TdWJzdHJzIiwiYnV0dG9uR3JvdXBTdHIiLCJidXR0b25DbGljayIsImJ1dHRvbkljb24iLCJjbGljayIsInRleHQiLCJoaW50IiwidGV4dEZhbGxiYWNrIiwicHJldk9yTmV4dCIsIm5hdlVuaXQiLCJldmVudFNvdXJjZURlZiQyIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJiaW5kIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwicmVxdWVzdEpzb24iLCJwYXJhbXMiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJ0b1VwcGVyQ2FzZSIsImluamVjdFF1ZXJ5U3RyaW5nUGFyYW1zIiwiZW5jb2RlUGFyYW1zIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ubG9hZCIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsImVyciIsIm9uZXJyb3IiLCJzZW5kIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsImV4dHJhUGFyYW1zIiwiZXZlbnRTb3VyY2VEZWYiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwiZXJyb3JNZXNzYWdlIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwic3RhcnRSZWN1ciIsImVuZFJlY3VyIiwicmVjdXJyaW5nIiwicmVjdXJyaW5nRGF0YSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwibmV3SW5wdXRzIiwiaW5wdXRzXzEiLCJpbnB1dEZvdW5kIiwidW5mb3VuZFNvdXJjZXNfMSIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dHNfMSIsIm5ld0lucHV0IiwiaGFuZGxlRGF0ZVByb2ZpbGUiLCJoYW5kbGVFdmVudFN0b3JlIiwiZ2xvYmFsUGx1Z2lucyIsImh0bWwiLCJidWlsZEh0bWxSZW5kZXJlciIsImRvbU5vZGVzIiwiYnVpbGREb21Ob2RlUmVuZGVyZXIiLCJjdXJyZW50RWwiLCJjdXJyZW50SHRtbCIsImN1cnJlbnREb21Ob2RlcyIsIm5ld0RvbU5vZGVzIiwibmV3RG9tTm9kZXNfMSIsIm5ld05vZGUiLCJEZWxheWVkUnVubmVyIiwiZHJhaW5lZE9wdGlvbiIsImlzUnVubmluZyIsImlzRGlydHkiLCJwYXVzZURlcHRocyIsInRpbWVvdXRJZCIsImRlbGF5IiwiaXNQYXVzZWQiLCJjbGVhclRpbWVvdXQiLCJ0cnlEcmFpbiIsInNldFRpbWVvdXQiLCJwYXVzZSIsInNjb3BlIiwicmVzdW1lIiwiZm9yY2UiLCJkZXB0aCIsImRyYWluZWQiLCJjbGVhciIsIlRhc2tSdW5uZXIiLCJydW5UYXNrT3B0aW9uIiwicXVldWUiLCJkZWxheWVkUnVubmVyIiwidGFzayIsImNvbXBsZXRlZFRhc2tzIiwic2hpZnQiLCJydW5UYXNrIiwiYnVpbGRUaXRsZSIsImJ1aWxkVGl0bGVGb3JtYXQiLCJDYWxlbmRhckRhdGFNYW5hZ2VyIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiX2NvbXB1dGVPcHRpb25zRGF0YSIsImNvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkVGhlbWUiLCJidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRWaWV3QXBpIiwiYnVpbGRWaWV3VWlQcm9wcyIsImJ1aWxkRXZlbnRVaUJ5U291cmNlIiwiYnVpbGRFdmVudFVpQmFzZXMiLCJwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzIiwiYWN0aW9uUnVubmVyIiwiX2hhbmRsZUFjdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRWaWV3T3B0aW9uc0lucHV0IiwiY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCIsImRhdGEiLCJvcHRpb25zRGF0YSIsImN1cnJlbnRWaWV3VHlwZSIsImN1cnJlbnRWaWV3RGF0YSIsImNhbGVuZGFyQ29udGV4dCIsImluaXRpYWxTdGF0ZSIsInJlbmRlcmFibGVFdmVudFN0b3JlIiwic2VsZWN0aW9uQ29uZmlnIiwiY29udGV4dEFuZFN0YXRlIiwicmVkdWNlciIsImNvbXB1dGVJc0xvYWRpbmciLCJyZXNldE9wdGlvbnMiLCJhcHBlbmQiLCJpc0V2ZW50c0xvYWRpbmciLCJldmVudFVpU2luZ2xlQmFzZSIsImV2ZW50VWlCeVNvdXJjZSIsIndhc0xvYWRpbmciLCJpc0xvYWRpbmciLCJvbkFjdGlvbiIsIm9sZERhdGEiLCJjaGFuZ2VIYW5kbGVycyIsIm9sZENhbGVuZGFyT3B0aW9ucyIsIm5ld0NhbGVuZGFyT3B0aW9ucyIsIm9uRGF0YSIsInByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMiLCJyZWZpbmVkT3B0aW9ucyIsImF2YWlsYWJsZUxvY2FsZURhdGEiLCJ3YXJuVW5rbm93bk9wdGlvbnMiLCJjdXJyZW50UmF3IiwiY3VycmVudFJlZmluZWQiLCJhbnlDaGFuZ2VzIiwicHJvY2Vzc1Jhd1ZpZXdPcHRpb25zIiwiZXhwbGljaXRMb2NhbGUiLCJUaGVtZUNsYXNzIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsImlzTG9hZGluZ0Z1bmMiLCJ2aWV3TmFtZSIsIkNhbGVuZGFyRGF0YVByb3ZpZGVyIiwiaGFuZGxlRGF0YSIsImRhdGFNYW5hZ2VyIiwicHJldlByb3BzIiwibmV3T3B0aW9uT3ZlcnJpZGVzIiwic2xpY2VFdmVudHMiLCJOYW1lZFRpbWVab25lSW1wbCIsIlNlZ0hpZXJhcmNoeSIsInN0cmljdE9yZGVyIiwiYWxsb3dSZXNsaWNpbmciLCJtYXhDb29yZCIsIm1heFN0YWNrQ250IiwibGV2ZWxDb29yZHMiLCJlbnRyaWVzQnlMZXZlbCIsInN0YWNrQ250cyIsImFkZFNlZ3MiLCJoaWRkZW5FbnRyaWVzIiwiaW5zZXJ0RW50cnkiLCJlbnRyeSIsImZpbmRJbnNlcnRpb24iLCJpc0luc2VydGlvblZhbGlkIiwiaW5zZXJ0RW50cnlBdCIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJsZXZlbENvb3JkIiwidGhpY2tuZXNzIiwic3RhY2tDbnQiLCJ0b3VjaGluZ0VudHJ5Iiwic3BsaXRFbnRyeSIsImJhcnJpZXIiLCJwYXJ0Q250Iiwic3BsaXRIaWRkZW5FbnRyaWVzIiwiZW50cnlTcGFuIiwiYmFycmllclNwYW4iLCJpbnRlcnNlY3RTcGFucyIsImxhdGVyYWwiLCJpbnNlcnRBdCIsImxldmVsIiwiYnVpbGRFbnRyeUtleSIsIm5ld0VudHJ5IiwibGV2ZWxDbnQiLCJjYW5kaWRhdGVDb29yZCIsInRvdWNoaW5nTGV2ZWwiLCJ0b3VjaGluZ0xhdGVyYWwiLCJ0cmFja2luZ0xldmVsIiwidHJhY2tpbmdDb29yZCIsInRyYWNraW5nRW50cmllcyIsInRyYWNraW5nRW50cnkiLCJzZWFyY2hSZXMiLCJiaW5hcnlTZWFyY2giLCJnZXRFbnRyeVNwYW5FbmQiLCJsYXRlcmFsSW5kZXgiLCJ0cmFja2luZ0VudHJ5Qm90dG9tIiwiZGVzdExldmVsIiwiZGVzdExhdGVyYWwiLCJ0b1JlY3RzIiwicmVjdHMiLCJlbnRyaWVzIiwiZW50cmllc18xIiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwibWVyZ2VzIiwiZW50cmllc18yIiwiZmlsdGVyZWRNZXJnZXMiLCJodW5ncnlNZXJnZSIsIm1lcmdlc18xIiwibWVyZ2UiLCJqb2luU3BhbnMiLCJzZWFyY2hWYWwiLCJnZXRJdGVtVmFsIiwibWlkZGxlSW5kZXgiLCJtaWRkbGVWYWwiLCJJbnRlcmFjdGlvbiIsImlzSGl0Q29tYm9BbGxvd2VkIiwicGFyc2VJbnRlcmFjdGlvblNldHRpbmdzIiwidXNlRXZlbnRDZW50ZXIiLCJpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSIsImludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSIsIkVsZW1lbnREcmFnZ2luZyIsInNldE1pcnJvcklzVmlzaWJsZSIsImJvb2wiLCJzZXRNaXJyb3JOZWVkc1JldmVydCIsInNldEF1dG9TY3JvbGxFbmFibGVkIiwiY29uZmlnIiwiRFJBR19NRVRBX1JFRklORVJTIiwicGFyc2VEcmFnTWV0YSIsImxlZnRvdmVyUHJvcHMiLCJUb29sYmFyU2VjdGlvbiIsIndpZGdldEdyb3VwcyIsIndpZGdldEdyb3VwIiwicmVuZGVyV2lkZ2V0R3JvdXAiLCJpc09ubHlCdXR0b25zIiwid2lkZ2V0R3JvdXBfMSIsIndpZGdldCIsInRpdGxlSWQiLCJpc1ByZXNzZWQiLCJhY3RpdmVCdXR0b24iLCJpc1RvZGF5RW5hYmxlZCIsImlzUHJldkVuYWJsZWQiLCJpc05leHRFbmFibGVkIiwiYnV0dG9uQ2xhc3NlcyIsImRpc2FibGVkIiwiZ3JvdXBDbGFzc05hbWUiLCJUb29sYmFyIiwibW9kZWwiLCJleHRyYUNsYXNzTmFtZSIsImZvcmNlTHRyIiwic3RhcnRDb250ZW50IiwiZW5kQ29udGVudCIsImNlbnRlckNvbnRlbnQiLCJyZW5kZXJTZWN0aW9uIiwiVmlld0NvbnRhaW5lciIsImF2YWlsYWJsZVdpZHRoIiwiaGFuZGxlRWwiLCJ1cGRhdGVBdmFpbGFibGVXaWR0aCIsImhhbmRsZVJlc2l6ZSIsImxpcXVpZCIsImxhYmVsZWRCeUlkIiwiRXZlbnRDbGlja2luZyIsImhhbmRsZVNlZ0NsaWNrIiwic2VnRWwiLCJoYXNVcmxDb250YWluZXIiLCJkZWZhdWx0UHJldmVudGVkIiwibG9jYXRpb24iLCJFdmVudEhvdmVyaW5nIiwiaGFuZGxlRXZlbnRFbFJlbW92ZSIsImN1cnJlbnRTZWdFbCIsImhhbmRsZVNlZ0xlYXZlIiwiaGFuZGxlU2VnRW50ZXIiLCJ0cmlnZ2VyRXZlbnQiLCJyZW1vdmVIb3Zlckxpc3RlbmVycyIsInB1YmxpY0V2TmFtZSIsIkNhbGVuZGFyQ29udGVudCIsImJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMiLCJidWlsZFRvb2xiYXJQcm9wcyIsImhlYWRlclJlZiIsImZvb3RlclJlZiIsImludGVyYWN0aW9uc1N0b3JlIiwidmlld0xhYmVsSWQiLCJzZXR0aW5nc0lucHV0IiwiREVGQVVMVF9JTlRFUkFDVElPTlMiLCJpbnRlcmFjdGlvbkNsYXNzZXMiLCJpbnRlcmFjdGlvbnMiLCJUaGVJbnRlcmFjdGlvbkNsYXNzIiwibGlzdGVuZXJzIiwibGlzdGVuZXJzXzEiLCJsaXN0ZW5lciIsInJlc2l6ZVJ1bm5lciIsInRvb2xiYXJQcm9wcyIsInZpZXdWR3JvdyIsInZpZXdBc3BlY3RSYXRpbyIsImlzSGVpZ2h0QXV0byIsImZvclByaW50Iiwidmlld0NvbnRleHQiLCJQcm92aWRlciIsInJlbmRlclZpZXciLCJidWlsZEFwcGVuZENvbnRlbnQiLCJDYWxlbmRhckludGVyYWN0aW9uQ2xhc3MiLCJGcmFnbWVudCIsIlZpZXdDb21wb25lbnQiLCJ0b2RheUluZm8iLCJwcmV2SW5mbyIsIm5leHRJbmZvIiwidGhlQ2xhc3NlcyIsIlRoZUNsYXNzIiwiQ2FsZW5kYXJSb290IiwiaGFuZGxlQmVmb3JlUHJpbnQiLCJoYW5kbGVBZnRlclByaW50IiwiY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0IiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJDTEFTU19OQU1FIiwicmVuZGVySW5uZXIkMSIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwiZXh0cmFIb29rUHJvcHMiLCJyb2xlIiwiY29sU3BhbiIsImV4dHJhRGF0YUF0dHJzIiwiaXNTdGlja3kiLCJXRUVLREFZX0ZPUk1BVCIsIlRhYmxlRG93Q2VsbCIsImV4dHJhQ2xhc3NOYW1lcyIsIk5vd1RpbWVyIiwiaW5pdGlhbE5vd0RhdGUiLCJpbml0aWFsTm93UXVlcmllZE1zIiwiY29tcHV0ZVRpbWluZyIsImN1cnJlbnRTdGF0ZSIsInVucm91bmRlZE5vdyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0Iiwid2FpdE1zIiwiYnVpbGREYXlSYW5nZSIsIkRheUhlYWRlciIsImNyZWF0ZURheUhlYWRlckZvcm1hdHRlciIsImRhdGVzIiwicmVuZGVySW50cm8iLCJleHBsaWNpdEZvcm1hdCIsImRhdGVDbnQiLCJEYXlTZXJpZXNNb2RlbCIsImluZGljZXMiLCJkYXlJbmRleCIsImNudCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY2VpbCIsImRheU9mZnNldCIsIkRheVRhYmxlTW9kZWwiLCJkYXlTZXJpZXMiLCJicmVha09uV2Vla3MiLCJkYXlzUGVyUm93Iiwicm93Q250IiwiY2VsbHMiLCJidWlsZENlbGxzIiwiaGVhZGVyRGF0ZXMiLCJidWlsZEhlYWRlckRhdGVzIiwicm93cyIsInJvdyIsImNvbCIsImJ1aWxkQ2VsbCIsInNlcmllc1NlZyIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsIlNsaWNlciIsInNsaWNlQnVzaW5lc3NIb3VycyIsIl9zbGljZUJ1c2luZXNzSG91cnMiLCJzbGljZURhdGVTZWxlY3Rpb24iLCJfc2xpY2VEYXRlU3BhbiIsIl9zbGljZUV2ZW50U3RvcmUiLCJzbGljZUV2ZW50RHJhZyIsIl9zbGljZUludGVyYWN0aW9uIiwic2xpY2VFdmVudFJlc2l6ZSIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VOb3dEYXRlIiwiY29tcHV0ZUFjdGl2ZVJhbmdlIiwicmFuZ2VSZXMiLCJzbGljZUV2ZW50UmFuZ2VzIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJzZWdzXzEiLCJldmVudFJhbmdlcyIsImV2ZW50UmFuZ2VzXzEiLCJzbGljZUV2ZW50UmFuZ2UiLCJzZWdzXzIiLCJpc0NvbXBvbmVudEFsbERheSIsImlzSW50ZXJhY3Rpb25WYWxpZCIsImlzTmV3UHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiY2FsZW5kYXJTdGF0ZSIsImRhdGVTcGFuTWV0YSIsImZpbHRlckNvbmZpZyIsImlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZCIsInN1YmplY3RFdmVudFN0b3JlIiwic3ViamVjdERlZnMiLCJzdWJqZWN0SW5zdGFuY2VzIiwic3ViamVjdENvbmZpZ3MiLCJvdGhlckV2ZW50U3RvcmUiLCJvdGhlckRlZnMiLCJvdGhlckluc3RhbmNlcyIsIm90aGVyQ29uZmlncyIsInN1YmplY3RJbnN0YW5jZUlkIiwic3ViamVjdEluc3RhbmNlIiwic3ViamVjdFJhbmdlIiwic3ViamVjdENvbmZpZyIsInN1YmplY3REZWYiLCJhbGxDb25zdHJhaW50c1Bhc3MiLCJldmVudE92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvblJhbmdlIiwic2VsZWN0T3ZlcmxhcEZ1bmMiLCJyZWxldmFudEluc3RhbmNlSWQiLCJyZWxldmFudEluc3RhbmNlIiwic2VsZWN0aW9uQWxsb3ciLCJmdWxsRGF0ZVNwYW4iLCJidXNpbmVzc0hvdXJzVW5leHBhbmRlZCIsImNvbnN0cmFpbnRzXzEiLCJhbnlSYW5nZXNDb250YWluUmFuZ2UiLCJjb25zdHJhaW50VG9SYW5nZXMiLCJldmVudFN0b3JlVG9SYW5nZXMiLCJvdXRlclJhbmdlcyIsIm91dGVyUmFuZ2VzXzEiLCJWSVNJQkxFX0hJRERFTl9SRSIsIlNjcm9sbGVyIiwibGlxdWlkSXNBYnNvbHV0ZSIsImlzQWJzb2x1dGUiLCJvdmVyY29tZUxlZnQiLCJvdmVyY29tZVJpZ2h0Iiwib3ZlcmNvbWVCb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXhIZWlnaHQiLCJuZWVkc1hTY3JvbGxpbmciLCJyZWFsQ2xpZW50V2lkdGgiLCJnZXRZU2Nyb2xsYmFyV2lkdGgiLCJjaGlsZEVsIiwibmVlZHNZU2Nyb2xsaW5nIiwicmVhbENsaWVudEhlaWdodCIsImdldFhTY3JvbGxiYXJXaWR0aCIsIlJlZk1hcCIsIm1hc3RlckNhbGxiYWNrIiwiY3VycmVudE1hcCIsImRlcHRocyIsImNhbGxiYWNrTWFwIiwiaGFuZGxlVmFsdWUiLCJyZW1vdmVkIiwiYWRkZWQiLCJyZWZDYWxsYmFjayIsImNvbGxlY3QiLCJnZXRBbGwiLCJjb21wdXRlU2hyaW5rV2lkdGgiLCJjaHVua0VscyIsInNocmlua0NlbGxzIiwibGFyZ2VzdFdpZHRoIiwic2hyaW5rQ2VsbHNfMSIsInNocmlua0NlbGwiLCJnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0Iiwic2VjdGlvbkNvbmZpZyIsImdldEFsbG93WVNjcm9sbGluZyIsInJlbmRlckNodW5rQ29udGVudCIsImNodW5rQ29uZmlnIiwiaXNIZWFkZXIiLCJ0YWJsZUNsYXNzTmFtZSIsInN5bmNSb3dIZWlnaHRzIiwibWluV2lkdGgiLCJ0YWJsZU1pbldpZHRoIiwidGFibGVDb2xHcm91cE5vZGUiLCJyb3dDb250ZW50IiwiaXNDb2xQcm9wc0VxdWFsIiwiY29sczAiLCJjb2xzMSIsInJlbmRlck1pY3JvQ29sR3JvdXAiLCJjb2xzIiwic2hyaW5rV2lkdGgiLCJjb2xOb2RlcyIsImNvbHNfMSIsImNvbFByb3BzIiwic2FuaXRpemVTaHJpbmtXaWR0aCIsImhhc1Nocmlua1dpZHRoIiwiY29sc18yIiwiZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMiLCJnZXRTZWN0aW9uQ2xhc3NOYW1lcyIsIndob2xlVGFibGVWR3JvdyIsInJlbmRlclNjcm9sbFNoaW0iLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsIlNpbXBsZVNjcm9sbEdyaWQiLCJwcm9jZXNzQ29scyIsInNjcm9sbGVyUmVmcyIsInNjcm9sbGVyRWxSZWZzIiwiX2hhbmRsZVNjcm9sbGVyRWwiLCJmb3JjZVlTY3JvbGxiYXJzIiwic2Nyb2xsZXJDbGllbnRXaWR0aHMiLCJzY3JvbGxlckNsaWVudEhlaWdodHMiLCJoYW5kbGVTaXppbmciLCJjb21wdXRlU2Nyb2xsZXJEaW1zIiwic2VjdGlvbkNvbmZpZ3MiLCJzZWN0aW9ucyIsIm1pY3JvQ29sR3JvdXBOb2RlIiwiY29sbGFwc2libGVXaWR0aCIsImNvbmZpZ0NudCIsImNvbmZpZ0kiLCJjdXJyZW50Q29uZmlnIiwiaGVhZFNlY3Rpb25Ob2RlcyIsImJvZHlTZWN0aW9uTm9kZXMiLCJmb290U2VjdGlvbk5vZGVzIiwiaXNCdWdneSIsInJvbGVBdHRycyIsIm91dGVyQ29udGVudCIsInJlbmRlckNodW5rVGQiLCJjaHVuayIsImlzTGlxdWlkIiwic2VjdGlvbktleSIsInJvd1N5bmNIZWlnaHRzIiwicmVwb3J0Um93SGVpZ2h0Q2hhbmdlIiwic2Nyb2xsZXJFbCIsInNlY3Rpb24iLCJnZXRTZWN0aW9uQnlLZXkiLCJzY3JvbGxlckVsUmVmIiwic2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxlciIsImhhcm5lc3NFbCIsInNlY3Rpb25zXzEiLCJFdmVudFJvb3QiLCJ0aW1lVGV4dCIsImRpc2FibGVEcmFnZ2luZyIsImRpc2FibGVSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsInN0YW5kYXJkQ2xhc3NOYW1lcyIsIlN0YW5kYXJkRXZlbnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsInJlbmRlcklubmVyQ29udGVudCQxIiwiaW5uZXJQcm9wcyIsIk5vd0luZGljYXRvclJvb3QiLCJpc0F4aXMiLCJEQVlfTlVNX0ZPUk1BVCIsIkRheUNlbGxDb250ZW50IiwicmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyIsInNob3dEYXlOdW1iZXIiLCJleHRyYVByb3BzIiwiZGF5TnVtYmVyVGV4dCIsIkRheUNlbGxSb290IiwicmVmaW5lSG9va1Byb3BzIiwiZGF0YUF0dHJzIiwicmVuZGVyRmlsbCIsImZpbGxUeXBlIiwiQmdFdmVudCIsIldlZWtOdW1iZXJSb290IiwiZGVmYXVsdEZvcm1hdCIsInJlbmRlcklubmVyIiwiUEFERElOR19GUk9NX1ZJRVdQT1JUIiwiUG9wb3ZlciIsImhhbmRsZURvY3VtZW50TW91c2VEb3duIiwiaGFuZGxlQ2xvc2VDbGljayIsImhhbmRsZURvY3VtZW50S2V5RG93biIsIm9uQ2xvc2UiLCJjcmVhdGVQb3J0YWwiLCJleHRyYUF0dHJzIiwicGFyZW50RWwiLCJhbGlnbm1lbnRFbCIsImFsaWduR3JpZFRvcCIsImFsaWdubWVudFJlY3QiLCJwb3BvdmVyRGltcyIsInBvcG92ZXJUb3AiLCJwb3BvdmVyTGVmdCIsIm9yaWdpbl8xIiwib2Zmc2V0UGFyZW50IiwiTW9yZVBvcG92ZXIiLCJzdGFydERhdGUiLCJkYXlDbGFzc05hbWVzIiwiZXh0cmFEYXRlU3BhbiIsImRheUVsIiwibGF5ZXIiLCJNb3JlTGlua1Jvb3QiLCJsaW5rRWxSZWYiLCJpc1BvcG92ZXJPcGVuIiwicG9wb3ZlcklkIiwiaGFuZGxlQ2xpY2siLCJjb21wdXRlUmFuZ2UiLCJidWlsZFB1YmxpY1NlZyIsImFsbERheURhdGUiLCJhbGxTZWdzIiwiaGlkZGVuU2VncyIsImhhbmRsZVBvcG92ZXJDbG9zZSIsIm1vcmVDbnQiLCJzaG9ydFRleHQiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiYWxpZ25tZW50RWxSZWYiLCJwb3BvdmVyQ29udGVudCIsInVwZGF0ZVBhcmVudEVsIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJjb21wdXRlTGF0ZXN0U2VnRW5kIiwicGlja0VhcmxpZXN0U3RhcnQiLCJzZWcwIiwic2VnMSIsInBpY2tMYXRlc3RFbmQiLCJ2ZXJzaW9uIiwicGFyc2VNYXJrZXIiLCJrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === \"undefined\") {\n    throw new Error(\"Please import the top-level fullcalendar lib before attempting to import a plugin.\");\n}\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushSync = FullCalendarVDom.flushSync;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */ exports.Component = Component;\nexports.Fragment = Fragment;\nexports.createContext = createContext;\nexports.createElement = createElement;\nexports.createPortal = createPortal;\nexports.createRef = createRef;\nexports.flushSync = flushSync;\nexports.render = render;\nexports.unmountComponentAtNode = unmountComponentAtNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU8sSUFBSTtBQUFDLENBQUMsRUFBQztBQUU3RCxtREFBbUQ7QUFDbkQsSUFBSSxPQUFPQyxxQkFBcUIsYUFBYTtJQUN6QyxNQUFNLElBQUlDLE1BQU0sc0ZBQXNGO0FBQzFHLENBQUM7QUFDRCxJQUFJQyxZQUFZRixpQkFBaUJFLFNBQVM7QUFDMUMsSUFBSUMsZ0JBQWdCSCxpQkFBaUJHLGFBQWE7QUFDbEQsSUFBSUMsU0FBU0osaUJBQWlCSSxNQUFNO0FBQ3BDLElBQUlDLFlBQVlMLGlCQUFpQkssU0FBUztBQUMxQyxJQUFJQyxXQUFXTixpQkFBaUJNLFFBQVE7QUFDeEMsSUFBSUMsZ0JBQWdCUCxpQkFBaUJPLGFBQWE7QUFDbEQsSUFBSUMsZUFBZVIsaUJBQWlCUSxZQUFZO0FBQ2hELElBQUlDLFlBQVlULGlCQUFpQlMsU0FBUztBQUMxQyxJQUFJQyx5QkFBeUJWLGlCQUFpQlUsc0JBQXNCO0FBQ3BFLGlCQUFpQixHQUVqQlosaUJBQWlCLEdBQUdJO0FBQ3BCSixnQkFBZ0IsR0FBR1E7QUFDbkJSLHFCQUFxQixHQUFHUztBQUN4QlQscUJBQXFCLEdBQUdLO0FBQ3hCTCxvQkFBb0IsR0FBR1U7QUFDdkJWLGlCQUFpQixHQUFHTztBQUNwQlAsaUJBQWlCLEdBQUdXO0FBQ3BCWCxjQUFjLEdBQUdNO0FBQ2pCTiw4QkFBOEIsR0FBR1kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAtZnVsbGNhbGVuZGFyLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL3Zkb20uY2pzLmpzPzM3MjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkBmdWxsY2FsZW5kYXIvY29yZS1wcmVhY3RcIiAvPlxuaWYgKHR5cGVvZiBGdWxsQ2FsZW5kYXJWRG9tID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGltcG9ydCB0aGUgdG9wLWxldmVsIGZ1bGxjYWxlbmRhciBsaWIgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW1wb3J0IGEgcGx1Z2luLicpO1xufVxudmFyIENvbXBvbmVudCA9IEZ1bGxDYWxlbmRhclZEb20uQ29tcG9uZW50O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUVsZW1lbnQ7XG52YXIgcmVuZGVyID0gRnVsbENhbGVuZGFyVkRvbS5yZW5kZXI7XG52YXIgY3JlYXRlUmVmID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVSZWY7XG52YXIgRnJhZ21lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLkZyYWdtZW50O1xudmFyIGNyZWF0ZUNvbnRleHQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUNvbnRleHQ7XG52YXIgY3JlYXRlUG9ydGFsID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVQb3J0YWw7XG52YXIgZmx1c2hTeW5jID0gRnVsbENhbGVuZGFyVkRvbS5mbHVzaFN5bmM7XG52YXIgdW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IEZ1bGxDYWxlbmRhclZEb20udW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZ1bGxDYWxlbmRhclZEb20iLCJFcnJvciIsIkNvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJyZW5kZXIiLCJjcmVhdGVSZWYiLCJGcmFnbWVudCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.cjs.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n;\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nvar TableView = /** @class */ function(_super) {\n    tslib.__extends(TableView, _super);\n    function TableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.headerElRef = common.createRef();\n        return _this;\n    }\n    TableView.prototype.renderSimpleLayout = function(headerRowContent, bodyContent) {\n        var _a = this, props = _a.props, context = _a.context;\n        var sections = [];\n        var stickyHeaderDates = common.getStickyHeaderDates(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, common.createElement(common.SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [],\n                sections: sections\n            }));\n        });\n    };\n    TableView.prototype.renderHScrollLayout = function(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        var _a = this, props = _a.props, context = _a.context;\n        var stickyHeaderDates = !props.forPrint && common.getStickyHeaderDates(context.options);\n        var stickyFooterScrollbar = !props.forPrint && common.getStickyFooterScrollbar(context.options);\n        var sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: common.renderScrollShim\n                    }\n                ]\n            });\n        }\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, common.createElement(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                colGroups: [\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    return TableView;\n}(common.DateComponent);\nfunction splitSegsByRow(segs, rowCnt) {\n    var byRow = [];\n    for(var i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n        var seg = segs_1[_i];\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    var byCol = [];\n    for(var i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n        var seg = segs_2[_i];\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    var byRow = [];\n    if (!ui) {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){\n            var seg = _a[_i];\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nvar TableCellTop = /** @class */ function(_super) {\n    tslib.__extends(TableCellTop, _super);\n    function TableCellTop() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableCellTop.prototype.render = function() {\n        var props = this.props;\n        var navLinkAttrs = common.buildNavLinkAttrs(this.context, props.date);\n        return common.createElement(common.DayCellContent, {\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            defaultContent: renderTopInner\n        }, function(innerElRef, innerContent) {\n            return (innerContent || props.forceDayTop) && common.createElement(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                ref: innerElRef\n            }, common.createElement(\"a\", tslib.__assign({\n                id: props.dayNumberId,\n                className: \"fc-daygrid-day-number\"\n            }, navLinkAttrs), innerContent || common.createElement(common.Fragment, null, \"\\xa0\")));\n        });\n    };\n    return TableCellTop;\n}(common.BaseComponent);\nfunction renderTopInner(props) {\n    return props.dayNumberText;\n}\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = common.createFormatter({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    var display = seg.eventRange.ui.display;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nvar TableBlockEvent = /** @class */ function(_super) {\n    tslib.__extends(TableBlockEvent, _super);\n    function TableBlockEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableBlockEvent.prototype.render = function() {\n        var props = this.props;\n        return common.createElement(common.StandardEvent, tslib.__assign({}, props, {\n            extraClassNames: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    };\n    return TableBlockEvent;\n}(common.BaseComponent);\nvar TableListItemEvent = /** @class */ function(_super) {\n    tslib.__extends(TableListItemEvent, _super);\n    function TableListItemEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableListItemEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        var timeText = common.buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return common.createElement(common.EventRoot, {\n            seg: props.seg,\n            timeText: timeText,\n            defaultContent: renderInnerContent,\n            isDragging: props.isDragging,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent) {\n            return common.createElement(\"a\", tslib.__assign({\n                className: [\n                    \"fc-daygrid-event\",\n                    \"fc-daygrid-dot-event\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, common.getSegAnchorAttrs(props.seg, context)), innerContent);\n        });\n    };\n    return TableListItemEvent;\n}(common.BaseComponent);\nfunction renderInnerContent(innerProps) {\n    return common.createElement(common.Fragment, null, common.createElement(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: innerProps.borderColor || innerProps.backgroundColor\n        }\n    }), innerProps.timeText && common.createElement(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), common.createElement(\"div\", {\n        className: \"fc-event-title\"\n    }, innerProps.event.title || common.createElement(common.Fragment, null, \"\\xa0\")));\n}\nvar TableCellMoreLink = /** @class */ function(_super) {\n    tslib.__extends(TableCellMoreLink, _super);\n    function TableCellMoreLink() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.compileSegs = common.memoize(compileSegs);\n        return _this;\n    }\n    TableCellMoreLink.prototype.render = function() {\n        var props = this.props;\n        var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;\n        return common.createElement(common.MoreLinkRoot, {\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: function() {\n                var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return common.createElement(common.Fragment, null, allSegs.map(function(seg) {\n                    var instanceId = seg.eventRange.instance.instanceId;\n                    return common.createElement(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, common.getSegMeta(seg, props.todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, common.getSegMeta(seg, props.todayRange))));\n                }));\n            }\n        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n            return common.createElement(\"a\", tslib.__assign({\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid-more-link\"\n                ].concat(classNames).join(\" \"),\n                title: title,\n                \"aria-expanded\": isExpanded,\n                \"aria-controls\": popoverId\n            }, common.createAriaClickAttrs(handleClick)), innerContent);\n        });\n    };\n    return TableCellMoreLink;\n}(common.BaseComponent);\nfunction compileSegs(singlePlacements) {\n    var allSegs = [];\n    var invisibleSegs = [];\n    for(var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++){\n        var placement = singlePlacements_1[_i];\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs: allSegs,\n        invisibleSegs: invisibleSegs\n    };\n}\nvar DEFAULT_WEEK_NUM_FORMAT = common.createFormatter({\n    week: \"narrow\"\n});\nvar TableCell = /** @class */ function(_super) {\n    tslib.__extends(TableCell, _super);\n    function TableCell() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = common.createRef();\n        _this.state = {\n            dayNumberId: common.getUniqueDomId()\n        };\n        _this.handleRootEl = function(el) {\n            common.setRef(_this.rootElRef, el);\n            common.setRef(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    TableCell.prototype.render = function() {\n        var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;\n        var date = props.date, dateProfile = props.dateProfile;\n        var navLinkAttrs = common.buildNavLinkAttrs(context, date, \"week\");\n        return common.createElement(common.DayCellRoot, {\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            elRef: this.handleRootEl\n        }, function(dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n            return common.createElement(\"td\", tslib.__assign({\n                ref: dayElRef,\n                role: \"gridcell\",\n                className: [\n                    \"fc-daygrid-day\"\n                ].concat(dayClassNames, props.extraClassNames || []).join(\" \")\n            }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                ref: props.innerElRef /* different from hook system! RENAME */ \n            }, props.showWeekNumber && common.createElement(common.WeekNumberRoot, {\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }, function(weekElRef, weekClassNames, innerElRef, innerContent) {\n                return common.createElement(\"a\", tslib.__assign({\n                    ref: weekElRef,\n                    className: [\n                        \"fc-daygrid-week-number\"\n                    ].concat(weekClassNames).join(\" \")\n                }, navLinkAttrs), innerContent);\n            }), !isDisabled && common.createElement(TableCellTop, {\n                date: date,\n                dateProfile: dateProfile,\n                showDayNumber: props.showDayNumber,\n                dayNumberId: state.dayNumberId,\n                forceDayTop: props.forceDayTop,\n                todayRange: props.todayRange,\n                extraHookProps: props.extraHookProps\n            }), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, common.createElement(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, common.createElement(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n        });\n    };\n    return TableCell;\n}(common.DateComponent);\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n    var hierarchy = new DayGridSegHierarchy();\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    var segInputs = [];\n    var unknownHeightSegs = [];\n    for(var i = 0; i < segs.length; i += 1){\n        var seg = segs[i];\n        var instanceId = seg.eventRange.instance.instanceId;\n        var eventHeight = eventInstanceHeights[instanceId];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                thickness: eventHeight,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    var hiddenEntries = hierarchy.addSegs(segInputs);\n    var segRects = hierarchy.toRects();\n    var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;\n    var moreCnts = [];\n    var moreMarginTops = [];\n    // add segs with unknown heights\n    for(var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++){\n        var seg = unknownHeightSegs_1[_i];\n        multiColPlacements[seg.firstCol].push({\n            seg: seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(var col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for(var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++){\n        var hiddenEntry = hiddenEntries_1[_b];\n        var seg = segs[hiddenEntry.index];\n        var hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(var col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        moreCnts: moreCnts,\n        moreMarginTops: moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    var singleColPlacements = [];\n    var multiColPlacements = [];\n    var leftoverMargins = [];\n    for(var col = 0; col < cells.length; col += 1){\n        var rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        var singlePlacements = [];\n        var currentHeight = 0;\n        var currentMarginTop = 0;\n        for(var _i = 0, rects_1 = rects; _i < rects_1.length; _i++){\n            var rect = rects_1[_i];\n            var seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        var multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for(var _a = 0, rects_2 = rects; _a < rects_2.length; _a++){\n            var rect = rects_2[_a];\n            var seg = segs[rect.index];\n            var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            var isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        leftoverMargins: leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    var rectsByEachCol = [];\n    for(var col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for(var _i = 0, rects_3 = rects; _i < rects_3.length; _i++){\n        var rect = rects_3[_i];\n        for(var col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    var eventRange = seg.eventRange;\n    var origRange = eventRange.range;\n    var slicedRange = common.intersectRanges(origRange, {\n        start: cells[spanStart].date,\n        end: common.addDays(cells[spanEnd - 1].date, 1)\n    });\n    return tslib.__assign(tslib.__assign({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: tslib.__assign(tslib.__assign({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nvar DayGridSegHierarchy = /** @class */ function(_super) {\n    tslib.__extends(DayGridSegHierarchy, _super);\n    function DayGridSegHierarchy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // config\n        _this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        _this.forceHidden = {};\n        return _this;\n    }\n    DayGridSegHierarchy.prototype.addSegs = function(segInputs) {\n        var _this = this;\n        var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n        var entriesByLevel = this.entriesByLevel;\n        var excludeHidden = function(entry) {\n            return !_this.forceHidden[common.buildEntryKey(entry)];\n        };\n        // remove the forced-hidden segs\n        for(var level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    };\n    DayGridSegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;\n        var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;\n        if (this.hiddenConsumes && touchingEntry) {\n            var touchingEntryId = common.buildEntryKey(touchingEntry);\n            // if not already hidden\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    var placeholderEntry = tslib.__assign(tslib.__assign({}, touchingEntry), {\n                        span: common.intersectSpans(touchingEntry.span, entry.span)\n                    });\n                    var placeholderEntryId = common.buildEntryKey(placeholderEntry);\n                    forceHidden[placeholderEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                    this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n    };\n    return DayGridSegHierarchy;\n}(common.SegHierarchy);\nvar TableRow = /** @class */ function(_super) {\n    tslib.__extends(TableRow, _super);\n    function TableRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.cellElRefs = new common.RefMap(); // the <td>\n        _this.frameElRefs = new common.RefMap(); // the fc-daygrid-day-frame\n        _this.fgElRefs = new common.RefMap(); // the fc-daygrid-day-events\n        _this.segHarnessRefs = new common.RefMap(); // indexed by \"instanceId:firstCol\"\n        _this.rootElRef = common.createRef();\n        _this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            eventInstanceHeights: {}\n        };\n        return _this;\n    }\n    TableRow.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var options = context.options;\n        var colCnt = props.cells.length;\n        var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        var _b = computeFgSegPlacement(common.sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;\n        var isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return common.createElement(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map(function(cell, col) {\n            var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return common.createElement(TableCell, {\n                key: cell.key,\n                elRef: _this.cellElRefs.createRef(cell.key),\n                innerElRef: _this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraHookProps: cell.extraHookProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: _this.fgElRefs.createRef(cell.key),\n                fgContent: common.createElement(common.Fragment, null, common.createElement(common.Fragment, null, normalFgNodes), common.createElement(common.Fragment, null, mirrorFgNodes)),\n                bgContent: common.createElement(common.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), _this.renderFillSegs(businessHoursByCol[col], \"non-business\"), _this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\"))\n            });\n        }));\n    };\n    TableRow.prototype.componentDidMount = function() {\n        this.updateSizing(true);\n    };\n    TableRow.prototype.componentDidUpdate = function(prevProps, prevState) {\n        var currentProps = this.props;\n        this.updateSizing(!common.isPropsEqual(prevProps, currentProps));\n    };\n    TableRow.prototype.getHighlightSegs = function() {\n        var props = this.props;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    };\n    TableRow.prototype.getMirrorSegs = function() {\n        var props = this.props;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    };\n    TableRow.prototype.renderFgSegs = function(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        var context = this.context;\n        var eventSelection = this.props.eventSelection;\n        var framePositions = this.state.framePositions;\n        var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++){\n                var placement = segPlacements_1[_i];\n                var seg = placement.seg;\n                var instanceId = seg.eventRange.instance.instanceId;\n                var key = instanceId + \":\" + col;\n                var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                var isAbsolute = placement.isAbsolute;\n                var left = \"\";\n                var right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push(common.createElement(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: key,\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left: left,\n                        right: right\n                    }\n                }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, common.getSegMeta(seg, todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, common.getSegMeta(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    };\n    TableRow.prototype.renderFillSegs = function(segs, fillType) {\n        var isRtl = this.context.isRtl;\n        var todayRange = this.props.todayRange;\n        var framePositions = this.state.framePositions;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n                var seg = segs_1[_i];\n                var leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push(common.createElement(\"div\", {\n                    key: common.buildEventRangeKey(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? common.createElement(common.BgEvent, tslib.__assign({\n                    seg: seg\n                }, common.getSegMeta(seg, todayRange))) : common.renderFill(fillType)));\n            }\n        }\n        return common.createElement.apply(void 0, tslib.__spreadArray([\n            common.Fragment,\n            {}\n        ], nodes));\n    };\n    TableRow.prototype.updateSizing = function(isExternalSizingChange) {\n        var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                var frameEls = props.cells.map(function(cell) {\n                    return frameElRefs.currentMap[cell.key];\n                });\n                if (frameEls.length) {\n                    var originEl = this.rootElRef.current;\n                    this.setState({\n                        framePositions: new common.PositionCache(originEl, frameEls, true, false)\n                    });\n                }\n            }\n            var oldInstanceHeights = this.state.eventInstanceHeights;\n            var newInstanceHeights = this.queryEventInstanceHeights();\n            var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                eventInstanceHeights: tslib.__assign(tslib.__assign({}, oldInstanceHeights), newInstanceHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    };\n    TableRow.prototype.queryEventInstanceHeights = function() {\n        var segElMap = this.segHarnessRefs.currentMap;\n        var eventInstanceHeights = {};\n        // get the max height amongst instance segs\n        for(var key in segElMap){\n            var height = Math.round(segElMap[key].getBoundingClientRect().height);\n            var instanceId = key.split(\":\")[0]; // deconstruct how renderFgSegs makes the key\n            eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n        }\n        return eventInstanceHeights;\n    };\n    TableRow.prototype.computeMaxContentHeight = function() {\n        var firstKey = this.props.cells[0].key;\n        var cellEl = this.cellElRefs.currentMap[firstKey];\n        var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    };\n    TableRow.prototype.getCellEls = function() {\n        var elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map(function(cell) {\n            return elMap[cell.key];\n        });\n    };\n    return TableRow;\n}(common.DateComponent);\nTableRow.addStateEquality({\n    eventInstanceHeights: common.isPropsEqual\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map(function(seg) {\n        return {\n            seg: seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        };\n    });\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    var topsByInstanceId = {};\n    for(var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++){\n        var placements = colPlacements_1[_i];\n        for(var _a = 0, placements_1 = placements; _a < placements_1.length; _a++){\n            var placement = placements_1[_a];\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nvar Table = /** @class */ function(_super) {\n    tslib.__extends(Table, _super);\n    function Table() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.splitBusinessHourSegs = common.memoize(splitSegsByRow);\n        _this.splitBgEventSegs = common.memoize(splitSegsByRow);\n        _this.splitFgEventSegs = common.memoize(splitSegsByRow);\n        _this.splitDateSelectionSegs = common.memoize(splitSegsByRow);\n        _this.splitEventDrag = common.memoize(splitInteractionByRow);\n        _this.splitEventResize = common.memoize(splitInteractionByRow);\n        _this.rowRefs = new common.RefMap();\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    isHitComboAllowed: _this.props.isHitComboAllowed\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    Table.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;\n        var rowCnt = props.cells.length;\n        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        var classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return common.createElement(\"div\", {\n            className: classNames.join(\" \"),\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, common.createElement(common.NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return common.createElement(common.Fragment, null, common.createElement(\"table\", {\n                role: \"presentation\",\n                className: \"fc-scrollgrid-sync-table\",\n                style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : \"\"\n                }\n            }, props.colGroupNode, common.createElement(\"tbody\", {\n                role: \"presentation\"\n            }, props.cells.map(function(cells, row) {\n                return common.createElement(TableRow, {\n                    ref: _this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: dayMaxEvents,\n                    dayMaxEventRows: dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    forPrint: props.forPrint\n                });\n            }))));\n        }));\n    };\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    Table.prototype.prepareHits = function() {\n        this.rowPositions = new common.PositionCache(this.rootEl, this.rowRefs.collect().map(function(rowObj) {\n            return rowObj.getCellEls()[0];\n        }), false, true);\n        this.colPositions = new common.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    };\n    Table.prototype.queryHit = function(positionLeft, positionTop) {\n        var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;\n        var col = colPositions.leftToIndex(positionLeft);\n        var row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            var cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: tslib.__assign({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    };\n    Table.prototype.getCellEl = function(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    };\n    Table.prototype.getCellRange = function(row, col) {\n        var start = this.props.cells[row][col].date;\n        var end = common.addDays(start, 1);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return Table;\n}(common.DateComponent);\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nvar DayTableSlicer = /** @class */ function(_super) {\n    tslib.__extends(DayTableSlicer, _super);\n    function DayTableSlicer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.forceDayIfListItem = true;\n        return _this;\n    }\n    DayTableSlicer.prototype.sliceRange = function(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    };\n    return DayTableSlicer;\n}(common.Slicer);\nvar DayTable = /** @class */ function(_super) {\n    tslib.__extends(DayTable, _super);\n    function DayTable() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.slicer = new DayTableSlicer();\n        _this.tableRef = common.createRef();\n        return _this;\n    }\n    DayTable.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        return common.createElement(Table, tslib.__assign({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    };\n    return DayTable;\n}(common.DateComponent);\nvar DayTableView = /** @class */ function(_super) {\n    tslib.__extends(DayTableView, _super);\n    function DayTableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildDayTableModel = common.memoize(buildDayTableModel);\n        _this.headerRef = common.createRef();\n        _this.tableRef = common.createRef();\n        return _this;\n    }\n    DayTableView.prototype.render = function() {\n        var _this = this;\n        var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;\n        var props = this.props;\n        var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        var headerContent = options.dayHeaders && common.createElement(common.DayHeader, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        var bodyContent = function(contentArg) {\n            return common.createElement(DayTable, {\n                ref: _this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: _this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        };\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    };\n    return DayTableView;\n}(TableView);\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    var daySeries = new common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new common.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nvar TableDateProfileGenerator = /** @class */ function(_super) {\n    tslib.__extends(TableDateProfileGenerator, _super);\n    function TableDateProfileGenerator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // Computes the date range that will be rendered.\n    TableDateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        var dateEnv = this.props.dateEnv;\n        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n        var start = renderRange.start;\n        var end = renderRange.end;\n        var endOfWeek;\n        // year and month views should be aligned with weeks. this is already done for week\n        if (/^(year|month)$/.test(currentRangeUnit)) {\n            start = dateEnv.startOfWeek(start);\n            // make end-of-week if not already\n            endOfWeek = dateEnv.startOfWeek(end);\n            if (endOfWeek.valueOf() !== end.valueOf()) {\n                end = common.addWeeks(endOfWeek, 1);\n            }\n        }\n        // ensure 6 weeks\n        if (this.props.monthMode && this.props.fixedWeekCount) {\n            var rowCnt = Math.ceil(common.diffWeeks(start, end));\n            end = common.addWeeks(end, 6 - rowCnt);\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return TableDateProfileGenerator;\n}(common.DateProfileGenerator);\nvar main = common.createPlugin({\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: DayTableView,\n            dateProfileGeneratorClass: TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            monthMode: true,\n            fixedWeekCount: true\n        }\n    }\n});\nexports.DayGridView = DayTableView;\nexports.DayTable = DayTable;\nexports.DayTableSlicer = DayTableSlicer;\nexports.Table = Table;\nexports.TableView = TableView;\nexports.buildDayTableModel = buildDayTableModel;\nexports[\"default\"] = main;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0FBSUEsR0FDQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTyxJQUFJO0FBQUMsQ0FBQyxFQUFDO0FBRTdELElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDOztBQUdwQjtzSEFDc0gsR0FDdEgsa0ZBQWtGO0FBQ2xGLCtDQUErQztBQUMvQyxJQUFJRSxZQUFZLFdBQVcsR0FBSSxTQUFVQyxNQUFNLEVBQUU7SUFDN0NGLE1BQU1HLFNBQVMsQ0FBQ0YsV0FBV0M7SUFDM0IsU0FBU0QsWUFBWTtRQUNqQixJQUFJRyxRQUFRRixXQUFXLElBQUksSUFBSUEsT0FBT0csS0FBSyxDQUFDLElBQUksRUFBRUMsY0FBYyxJQUFJO1FBQ3BFRixNQUFNRyxXQUFXLEdBQUdULE9BQU9VLFNBQVM7UUFDcEMsT0FBT0o7SUFDWDtJQUNBSCxVQUFVUSxTQUFTLENBQUNDLGtCQUFrQixHQUFHLFNBQVVDLGdCQUFnQixFQUFFQyxXQUFXLEVBQUU7UUFDOUUsSUFBSUMsS0FBSyxJQUFJLEVBQUVDLFFBQVFELEdBQUdDLEtBQUssRUFBRUMsVUFBVUYsR0FBR0UsT0FBTztRQUNyRCxJQUFJQyxXQUFXLEVBQUU7UUFDakIsSUFBSUMsb0JBQW9CbkIsT0FBT29CLG9CQUFvQixDQUFDSCxRQUFRSSxPQUFPO1FBQ25FLElBQUlSLGtCQUFrQjtZQUNsQkssU0FBU0ksSUFBSSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOQyxLQUFLO2dCQUNMQyxVQUFVTjtnQkFDVk8sT0FBTztvQkFDSEMsT0FBTyxJQUFJLENBQUNsQixXQUFXO29CQUN2Qm1CLGdCQUFnQjtvQkFDaEJDLFlBQVloQjtnQkFDaEI7WUFDSjtRQUNKLENBQUM7UUFDREssU0FBU0ksSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRLElBQUk7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QWM7WUFDVmhjLE1BQU07WUFDTjRiLFVBQVU7Z0JBQUVLLFFBQVE7WUFBRTtZQUN0QmxCLFdBQVcsSUFBSTtZQUNmQyxnQkFBZ0IsSUFBSTtRQUN4QjtJQUNKO0FBQ0o7QUFFQXpjLG1CQUFtQixHQUFHeWE7QUFDdEJ6YSxnQkFBZ0IsR0FBR21hO0FBQ25CbmEsc0JBQXNCLEdBQUc2WjtBQUN6QjdaLGFBQWEsR0FBRzhXO0FBQ2hCOVcsaUJBQWlCLEdBQUdLO0FBQ3BCTCwwQkFBMEIsR0FBRzBhO0FBQzdCMWEsa0JBQWUsR0FBRzZjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLWZ1bGxjYWxlbmRhci8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5janMuanM/YjdhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMS4zXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMiBBZGFtIFNoYXdcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvbW1vbicpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbjtcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG52YXIgVGFibGVWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGVhZGVyRWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGVWaWV3LnByb3RvdHlwZS5yZW5kZXJTaW1wbGVMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSBjb21tb24uZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5TaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbXSAvKiBUT0RPOiBtYWtlIG9wdGlvbmFsPyAqLywgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIFRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVySFNjcm9sbExheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCkge1xuICAgICAgICB2YXIgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGNvbW1vbi5nZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGNvbW1vbi5nZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbW1vbi5yZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVWaWV3O1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzLCByb3dDbnQpIHtcbiAgICB2YXIgYnlSb3cgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Um93W2ldID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzXzFbX2ldO1xuICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XG4gICAgdmFyIGJ5Q29sID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieUNvbFtpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMiA9IHNlZ3M7IF9pIDwgc2Vnc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnID0gc2Vnc18yW19pXTtcbiAgICAgICAgYnlDb2xbc2VnLmZpcnN0Q29sXS5wdXNoKHNlZyk7XG4gICAgfVxuICAgIHJldHVybiBieUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aSwgcm93Q250KSB7XG4gICAgdmFyIGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdWkuc2VnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbnZhciBUYWJsZUNlbGxUb3AgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlQ2VsbFRvcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVDZWxsVG9wLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSBjb21tb24uYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBwcm9wcy5kYXRlKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbENvbnRlbnQsIHsgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsIGRlZmF1bHRDb250ZW50OiByZW5kZXJUb3BJbm5lciB9LCBmdW5jdGlvbiAoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoKGlubmVyQ29udGVudCB8fCBwcm9wcy5mb3JjZURheVRvcCkgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCByZWY6IGlubmVyRWxSZWYgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IGlkOiBwcm9wcy5kYXlOdW1iZXJJZCwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCB8fCBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGxUb3A7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0O1xufVxuXG52YXIgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ25hcnJvdycsXG59KTtcbmZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpIHtcbiAgICB2YXIgZGlzcGxheSA9IHNlZy5ldmVudFJhbmdlLnVpLmRpc3BsYXk7XG4gICAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAgICAgIXNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgJiZcbiAgICAgICAgc2VnLmZpcnN0Q29sID09PSBzZWcubGFzdENvbCAmJiAvLyBjYW4ndCBiZSBtdWx0aS1kYXlcbiAgICAgICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICAgICAgc2VnLmlzRW5kIC8vIFwiXG4gICAgKTtcbn1cblxudmFyIFRhYmxlQmxvY2tFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVCbG9ja0V2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQmxvY2tFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUJsb2NrRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uU3RhbmRhcmRFdmVudCwgdHNsaWIuX19hc3NpZ24oe30sIHByb3BzLCB7IGV4dHJhQ2xhc3NOYW1lczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQmxvY2tFdmVudDtcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcblxudmFyIFRhYmxlTGlzdEl0ZW1FdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVMaXN0SXRlbUV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlTGlzdEl0ZW1FdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUxpc3RJdGVtRXZlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB0aW1lRm9ybWF0ID0gY29udGV4dC5vcHRpb25zLmV2ZW50VGltZUZvcm1hdCB8fCBERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUO1xuICAgICAgICB2YXIgdGltZVRleHQgPSBjb21tb24uYnVpbGRTZWdUaW1lVGV4dChwcm9wcy5zZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRydWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5FdmVudFJvb3QsIHsgc2VnOiBwcm9wcy5zZWcsIHRpbWVUZXh0OiB0aW1lVGV4dCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgaXNEcmFnZ2luZzogcHJvcHMuaXNEcmFnZ2luZywgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IHByb3BzLmlzU2VsZWN0ZWQsIGlzUGFzdDogcHJvcHMuaXNQYXN0LCBpc0Z1dHVyZTogcHJvcHMuaXNGdXR1cmUsIGlzVG9kYXk6IHByb3BzLmlzVG9kYXkgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoIC8vIHdlIGRvbid0IHVzZSBzdHlsZXMhXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IGNsYXNzTmFtZTogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSwgY29tbW9uLmdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCkpLCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlTGlzdEl0ZW1FdmVudDtcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChpbm5lclByb3BzKSB7XG4gICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtZG90XCIsIHN0eWxlOiB7IGJvcmRlckNvbG9yOiBpbm5lclByb3BzLmJvcmRlckNvbG9yIHx8IGlubmVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCBpbm5lclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKTtcbn1cblxudmFyIFRhYmxlQ2VsbE1vcmVMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZUNlbGxNb3JlTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGxNb3JlTGluaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbXBpbGVTZWdzID0gY29tbW9uLm1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbE1vcmVMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyksIGFsbFNlZ3MgPSBfYS5hbGxTZWdzLCBpbnZpc2libGVTZWdzID0gX2EuaW52aXNpYmxlU2VncztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uTW9yZUxpbmtSb290LCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCwgYWxsU2Vncy5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzXCIsIGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpIDogKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2ssIHRpdGxlLCBpc0V4cGFuZGVkLCBwb3BvdmVySWQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgdGl0bGU6IHRpdGxlLCBcImFyaWEtZXhwYW5kZWRcIjogaXNFeHBhbmRlZCwgXCJhcmlhLWNvbnRyb2xzXCI6IHBvcG92ZXJJZCB9LCBjb21tb24uY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlQ2xpY2spKSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGxNb3JlTGluaztcbn0oY29tbW9uLkJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICB2YXIgYWxsU2VncyA9IFtdO1xuICAgIHZhciBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzaW5nbGVQbGFjZW1lbnRzXzEgPSBzaW5nbGVQbGFjZW1lbnRzOyBfaSA8IHNpbmdsZVBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNpbmdsZVBsYWNlbWVudHNfMVtfaV07XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VnczogYWxsU2VncywgaW52aXNpYmxlU2VnczogaW52aXNpYmxlU2VncyB9O1xufVxuXG52YXIgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjb21tb24uY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ25hcnJvdycgfSk7XG52YXIgVGFibGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRheU51bWJlcklkOiBjb21tb24uZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBjb21tb24uc2V0UmVmKF90aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgY29tbW9uLnNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb250ZXh0ID0gX2EuY29udGV4dCwgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgcm9vdEVsUmVmID0gX2Eucm9vdEVsUmVmO1xuICAgICAgICB2YXIgZGF0ZSA9IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSBjb21tb24uYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbFJvb3QsIHsgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsIGVsUmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9LCBmdW5jdGlvbiAoZGF5RWxSZWYsIGRheUNsYXNzTmFtZXMsIHJvb3REYXRhQXR0cnMsIGlzRGlzYWJsZWQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBkYXlFbFJlZiwgcm9sZTogXCJncmlkY2VsbFwiLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1kYXknXS5jb25jYXQoZGF5Q2xhc3NOYW1lcywgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKS5qb2luKCcgJykgfSwgcm9vdERhdGFBdHRycywgcHJvcHMuZXh0cmFEYXRhQXR0cnMsIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1mcmFtZSBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgcmVmOiBwcm9wcy5pbm5lckVsUmVmIC8qIGRpZmZlcmVudCBmcm9tIGhvb2sgc3lzdGVtISBSRU5BTUUgKi8gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLldlZWtOdW1iZXJSb290LCB7IGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uICh3ZWVrRWxSZWYsIHdlZWtDbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHdlZWtFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXS5jb25jYXQod2Vla0NsYXNzTmFtZXMpLmpvaW4oJyAnKSB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQpKTsgfSkpLFxuICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkICYmIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUNlbGxUb3AsIHsgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLCBkYXlOdW1iZXJJZDogc3RhdGUuZGF5TnVtYmVySWQsIGZvcmNlRGF5VG9wOiBwcm9wcy5mb3JjZURheVRvcCwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0pKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiLCBzdHlsZTogeyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChzZWdzLCAvLyBhc3N1bWVkIGFscmVhZHkgc29ydGVkXG5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cywgc3RyaWN0T3JkZXIsIGV2ZW50SW5zdGFuY2VIZWlnaHRzLCBtYXhDb250ZW50SGVpZ2h0LCBjZWxscykge1xuICAgIHZhciBoaWVyYXJjaHkgPSBuZXcgRGF5R3JpZFNlZ0hpZXJhcmNoeSgpO1xuICAgIGhpZXJhcmNoeS5hbGxvd1Jlc2xpY2luZyA9IHRydWU7XG4gICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heENvb3JkID0gbWF4Q29udGVudEhlaWdodDtcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRSb3dzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBzZWdJbnB1dHMgb25seSBmb3Igc2VncyB3aXRoIGtub3duIGhlaWdodHNcbiAgICB2YXIgc2VnSW5wdXRzID0gW107XG4gICAgdmFyIHVua25vd25IZWlnaHRTZWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHZhciBldmVudEhlaWdodCA9IGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdO1xuICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZXZlbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIHZhciBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XG4gICAgdmFyIF9hID0gcGxhY2VSZWN0cyhzZWdSZWN0cywgc2VncywgY2VsbHMpLCBzaW5nbGVDb2xQbGFjZW1lbnRzID0gX2Euc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzID0gX2EubXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgPSBfYS5sZWZ0b3Zlck1hcmdpbnM7XG4gICAgdmFyIG1vcmVDbnRzID0gW107XG4gICAgdmFyIG1vcmVNYXJnaW5Ub3BzID0gW107XG4gICAgLy8gYWRkIHNlZ3Mgd2l0aCB1bmtub3duIGhlaWdodHNcbiAgICBmb3IgKHZhciBfaSA9IDAsIHVua25vd25IZWlnaHRTZWdzXzEgPSB1bmtub3duSGVpZ2h0U2VnczsgX2kgPCB1bmtub3duSGVpZ2h0U2Vnc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnID0gdW5rbm93bkhlaWdodFNlZ3NfMVtfaV07XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1tzZWcuZmlyc3RDb2xdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiBzZWcsXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gc2VnLmZpcnN0Q29sOyBjb2wgPD0gc2VnLmxhc3RDb2w7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIGhpZGRlbiBlbnRyaWVzXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlQ250cy5wdXNoKDApO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYiA9IDAsIGhpZGRlbkVudHJpZXNfMSA9IGhpZGRlbkVudHJpZXM7IF9iIDwgaGlkZGVuRW50cmllc18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgaGlkZGVuRW50cnkgPSBoaWRkZW5FbnRyaWVzXzFbX2JdO1xuICAgICAgICB2YXIgc2VnID0gc2Vnc1toaWRkZW5FbnRyeS5pbmRleF07XG4gICAgICAgIHZhciBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhbjtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBoaWRkZW5TcGFuLnN0YXJ0OyBjb2wgPCBoaWRkZW5TcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIG1vcmVDbnRzW2NvbF0gKz0gMTtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlYWwgd2l0aCBsZWZ0b3ZlciBtYXJnaW5zXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICBtb3JlTWFyZ2luVG9wcy5wdXNoKGxlZnRvdmVyTWFyZ2luc1tjb2xdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzOiBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzOiBtb3JlQ250cywgbW9yZU1hcmdpblRvcHM6IG1vcmVNYXJnaW5Ub3BzIH07XG59XG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xuICAgIHZhciByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XG4gICAgdmFyIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XG4gICAgdmFyIGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgdmFyIHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcbiAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgICAgICB2YXIgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZWN0c18xID0gcmVjdHM7IF9pIDwgcmVjdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVjdHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHNpbmdsZVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBtaXhlZCBzdGF0aWMvYWJzb2x1dGUgc2VncyBpbiBtdWx0aVBsYWNlbWVudHNcbiAgICAgICAgdmFyIG11bHRpUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcmVjdHNfMiA9IHJlY3RzOyBfYSA8IHJlY3RzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlY3RzXzJbX2FdO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHJlY3Quc3Bhbi5lbmQgLSByZWN0LnNwYW4uc3RhcnQgPiAxOyAvLyBtdWx0aS1jb2x1bW4/XG4gICAgICAgICAgICB2YXIgaXNGaXJzdENvbCA9IHJlY3Quc3Bhbi5zdGFydCA9PT0gY29sO1xuICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LmxldmVsQ29vcmQgLSBjdXJyZW50SGVpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2Ugc2luY2UgYm90dG9tIG9mIHByZXZpb3VzIHNlZ1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzOyAvLyBoZWlnaHQgd2lsbCBub3cgYmUgYm90dG9tIG9mIGN1cnJlbnQgc2VnXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC50aGlja25lc3M7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgcmVjdC5zcGFuLnN0YXJ0LCByZWN0LnNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogY3VycmVudE1hcmdpblRvcCwgLy8gY2xhaW0gdGhlIG1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHMucHVzaChzaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzLnB1c2gobXVsdGlQbGFjZW1lbnRzKTtcbiAgICAgICAgbGVmdG92ZXJNYXJnaW5zLnB1c2goY3VycmVudE1hcmdpblRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50czogbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnM6IGxlZnRvdmVyTWFyZ2lucyB9O1xufVxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0cywgY29sQ250KSB7XG4gICAgdmFyIHJlY3RzQnlFYWNoQ29sID0gW107XG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICByZWN0c0J5RWFjaENvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCByZWN0c18zID0gcmVjdHM7IF9pIDwgcmVjdHNfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHJlY3QgPSByZWN0c18zW19pXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcbn1cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XG4gICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH1cbiAgICB2YXIgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIHZhciBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgIHZhciBzbGljZWRSYW5nZSA9IGNvbW1vbi5pbnRlcnNlY3RSYW5nZXMob3JpZ1JhbmdlLCB7XG4gICAgICAgIHN0YXJ0OiBjZWxsc1tzcGFuU3RhcnRdLmRhdGUsXG4gICAgICAgIGVuZDogY29tbW9uLmFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxudmFyIERheUdyaWRTZWdIaWVyYXJjaHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheUdyaWRTZWdIaWVyYXJjaHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5R3JpZFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICBfdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICBfdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUdyaWRTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoc2VnSW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoaWRkZW5TZWdzID0gX3N1cGVyLnByb3RvdHlwZS5hZGRTZWdzLmNhbGwodGhpcywgc2VnSW5wdXRzKTtcbiAgICAgICAgdmFyIGVudHJpZXNCeUxldmVsID0gdGhpcy5lbnRyaWVzQnlMZXZlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVIaWRkZW4gPSBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5mb3JjZUhpZGRlbltjb21tb24uYnVpbGRFbnRyeUtleShlbnRyeSldOyB9O1xuICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgICAgICBmb3IgKHZhciBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xuICAgIH07XG4gICAgRGF5R3JpZFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbiA9IGZ1bmN0aW9uIChpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVudHJpZXNCeUxldmVsID0gX2EuZW50cmllc0J5TGV2ZWwsIGZvcmNlSGlkZGVuID0gX2EuZm9yY2VIaWRkZW47XG4gICAgICAgIHZhciB0b3VjaGluZ0VudHJ5ID0gaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIHRvdWNoaW5nTGV2ZWwgPSBpbnNlcnRpb24udG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsID0gaW5zZXJ0aW9uLnRvdWNoaW5nTGF0ZXJhbDtcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuQ29uc3VtZXMgJiYgdG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgdmFyIHRvdWNoaW5nRW50cnlJZCA9IGNvbW1vbi5idWlsZEVudHJ5S2V5KHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IGFscmVhZHkgaGlkZGVuXG4gICAgICAgICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJFbnRyeSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0b3VjaGluZ0VudHJ5KSwgeyBzcGFuOiBjb21tb24uaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnlJZCA9IGNvbW1vbi5idWlsZEVudHJ5S2V5KHBsYWNlaG9sZGVyRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlbltwbGFjZWhvbGRlckVudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbdG91Y2hpbmdMZXZlbF1bdG91Y2hpbmdMYXRlcmFsXSA9IHBsYWNlaG9sZGVyRW50cnk7IC8vIHJlcGxhY2UgdG91Y2hpbmdFbnRyeSB3aXRoIG91ciBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0RW50cnkodG91Y2hpbmdFbnRyeSwgZW50cnksIGhpZGRlbkVudHJpZXMpOyAvLyBzcGxpdCB1cCB0aGUgdG91Y2hpbmdFbnRyeSwgcmVpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2godG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUludmFsaWRJbnNlcnRpb24uY2FsbCh0aGlzLCBpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlHcmlkU2VnSGllcmFyY2h5O1xufShjb21tb24uU2VnSGllcmFyY2h5KSk7XG5cbnZhciBUYWJsZVJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVSb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVSb3coKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jZWxsRWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgX3RoaXMuZnJhbWVFbFJlZnMgPSBuZXcgY29tbW9uLlJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZnJhbWVcbiAgICAgICAgX3RoaXMuZmdFbFJlZnMgPSBuZXcgY29tbW9uLlJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gICAgICAgIF90aGlzLnNlZ0hhcm5lc3NSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICBtYXhDb250ZW50SGVpZ2h0OiBudWxsLFxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlUm93LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJ1c2luZXNzSG91cnNCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgdmFyIG1pcnJvclNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRNaXJyb3JTZWdzKCksIGNvbENudCk7XG4gICAgICAgIHZhciBfYiA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudChjb21tb24uc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSwgcHJvcHMuZGF5TWF4RXZlbnRzLCBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCwgc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHMsIHN0YXRlLm1heENvbnRlbnRIZWlnaHQsIHByb3BzLmNlbGxzKSwgc2luZ2xlQ29sUGxhY2VtZW50cyA9IF9iLnNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cyA9IF9iLm11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMgPSBfYi5tb3JlQ250cywgbW9yZU1hcmdpblRvcHMgPSBfYi5tb3JlTWFyZ2luVG9wcztcbiAgICAgICAgdmFyIGlzRm9yY2VkSW52aXNpYmxlID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1pcnJvckZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IF90aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgaW5uZXJFbFJlZjogX3RoaXMuZnJhbWVFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSAvKiBGRiA8dGQ+IHByb2JsZW0sIGJ1dCBva2F5IHRvIHVzZSBmb3IgbGVmdC9yaWdodC4gVE9ETzogcmVuYW1lIHByb3AgKi8sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVycywgc2hvd1dlZWtOdW1iZXI6IHByb3BzLnNob3dXZWVrTnVtYmVycyAmJiBjb2wgPT09IDAsIGZvcmNlRGF5VG9wOiBwcm9wcy5zaG93V2Vla051bWJlcnMgLyogZXZlbiBkaXNwbGF5aW5nIHdlZWtudW0gZm9yIHJvdywgbm90IG5lY2Vzc2FyaWx5IGRheSAqLywgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBleHRyYUhvb2tQcm9wczogY2VsbC5leHRyYUhvb2tQcm9wcywgZXh0cmFEYXRhQXR0cnM6IGNlbGwuZXh0cmFEYXRhQXR0cnMsIGV4dHJhQ2xhc3NOYW1lczogY2VsbC5leHRyYUNsYXNzTmFtZXMsIGV4dHJhRGF0ZVNwYW46IGNlbGwuZXh0cmFEYXRlU3BhbiwgbW9yZUNudDogbW9yZUNudHNbY29sXSwgbW9yZU1hcmdpblRvcDogbW9yZU1hcmdpblRvcHNbY29sXSwgc2luZ2xlUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLCBmZ0NvbnRlbnRFbFJlZjogX3RoaXMuZmdFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIG5vcm1hbEZnTm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLCBtaXJyb3JGZ05vZGVzKSkpLCBiZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpIH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWNvbW1vbi5pc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5nZXRIaWdobGlnaHRTZWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50RHJhZy5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldE1pcnJvclNlZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChjb2wsIHNlZ1BsYWNlbWVudHMsIHRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBldmVudFNlbGVjdGlvbiA9IHRoaXMucHJvcHMuZXZlbnRTZWxlY3Rpb247XG4gICAgICAgIHZhciBmcmFtZVBvc2l0aW9ucyA9IHRoaXMuc3RhdGUuZnJhbWVQb3NpdGlvbnM7XG4gICAgICAgIHZhciBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxuICAgICAgICB2YXIgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ1BsYWNlbWVudHNfMSA9IHNlZ1BsYWNlbWVudHM7IF9pIDwgc2VnUGxhY2VtZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBzZWdQbGFjZW1lbnRzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBwbGFjZW1lbnQuc2VnO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW5zdGFuY2VJZCArICc6JyArIGNvbDtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gcGxhY2VtZW50LmlzVmlzaWJsZSAmJiAhaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBwbGFjZW1lbnQuaXNBYnNvbHV0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9ICcnO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgICAgICAgICB0b2RvOiBpbiBwcmludCB2aWV3LCBmb3IgbXVsdGktZGF5IGV2ZW50cywgZG9uJ3QgZGlzcGxheSB0aXRsZSB3aXRoaW4gbm9uLXN0YXJ0L2VuZCBzZWdzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKSwga2V5OiBrZXksIHJlZjogaXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoa2V5KSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICcnIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGlzQWJzb2x1dGUgPyAnJyA6IHBsYWNlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGlzQWJzb2x1dGUgPyBwbGFjZW1lbnQuYWJzb2x1dGVUb3AgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGNvbW1vbi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmlsbFNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgdmFyIGlzUnRsID0gdGhpcy5jb250ZXh0LmlzUnRsO1xuICAgICAgICB2YXIgdG9kYXlSYW5nZSA9IHRoaXMucHJvcHMudG9kYXlSYW5nZTtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBjb21tb24uYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkJnRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLnJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vbi5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbY29tbW9uLkZyYWdtZW50LCB7fV0sIG5vZGVzKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUudXBkYXRlU2l6aW5nID0gZnVuY3Rpb24gKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgZnJhbWVFbFJlZnMgPSBfYS5mcmFtZUVsUmVmcztcbiAgICAgICAgaWYgKCFwcm9wcy5mb3JQcmludCAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gcG9zaXRpb25pbmcgcmVhZHk/XG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVQb3NpdGlvbnM6IG5ldyBjb21tb24uUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkSW5zdGFuY2VIZWlnaHRzID0gdGhpcy5zdGF0ZS5ldmVudEluc3RhbmNlSGVpZ2h0cztcbiAgICAgICAgICAgIHZhciBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcbiAgICAgICAgICAgIHZhciBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyB0byBwcmV2ZW50IG9zY2lsbGF0aW9ucyBvZiBldmVudHMgYmVpbmcgc2hvd24vaGlkZGVuIGZyb20gbWF4LWV2ZW50LXJvd3NcbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSwgb25jZSB5b3UgY29tcHV0ZSBhbiBlbGVtZW50J3MgaGVpZ2h0LCBuZXZlciBudWxsLW91dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbHdheXMgZGlzcGxheSBhbGwgZXZlbnRzLCBhcyB2aXNpYmlsaXR5OmhpZGRlbj9cbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0czogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9sZEluc3RhbmNlSGVpZ2h0cyksIG5ld0luc3RhbmNlSGVpZ2h0cyksXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5xdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHZhciBldmVudEluc3RhbmNlSGVpZ2h0cyA9IHt9O1xuICAgICAgICAvLyBnZXQgdGhlIG1heCBoZWlnaHQgYW1vbmdzdCBpbnN0YW5jZSBzZWdzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWdFbE1hcCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoc2VnRWxNYXBba2V5XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBrZXkuc3BsaXQoJzonKVswXTsgLy8gZGVjb25zdHJ1Y3QgaG93IHJlbmRlckZnU2VncyBtYWtlcyB0aGUga2V5XG4gICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSA9IE1hdGgubWF4KGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdIHx8IDAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VIZWlnaHRzO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlyc3RLZXkgPSB0aGlzLnByb3BzLmNlbGxzWzBdLmtleTtcbiAgICAgICAgdmFyIGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgdmFyIGZjQ29udGFpbmVyRWwgPSB0aGlzLmZnRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGZjQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldENlbGxFbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGVsTWFwW2NlbGwua2V5XTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVSb3c7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5UYWJsZVJvdy5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBldmVudEluc3RhbmNlSGVpZ2h0czogY29tbW9uLmlzUHJvcHNFcXVhbCxcbn0pO1xuZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcbiAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XG4gICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHsgcmV0dXJuICh7XG4gICAgICAgIHNlZzogc2VnLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGFic29sdXRlVG9wOiB0b3BzQnlJbnN0YW5jZUlkW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykge1xuICAgIHZhciB0b3BzQnlJbnN0YW5jZUlkID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb2xQbGFjZW1lbnRzXzEgPSBjb2xQbGFjZW1lbnRzOyBfaSA8IGNvbFBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudHMgPSBjb2xQbGFjZW1lbnRzXzFbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHBsYWNlbWVudHNfMSA9IHBsYWNlbWVudHM7IF9hIDwgcGxhY2VtZW50c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNfMVtfYV07XG4gICAgICAgICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wc0J5SW5zdGFuY2VJZDtcbn1cblxudmFyIFRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudERyYWcgPSBjb21tb24ubWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gY29tbW9uLm1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgX3RoaXMucm93UmVmcyA9IG5ldyBjb21tb24uUmVmTWFwKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChyb290RWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IF90aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlLCBkYXlNYXhFdmVudFJvd3MgPSBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cyA9IHByb3BzLmRheU1heEV2ZW50cywgZXhwYW5kUm93cyA9IHByb3BzLmV4cGFuZFJvd3M7XG4gICAgICAgIHZhciByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KTtcbiAgICAgICAgdmFyIGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIHJvd0NudCk7XG4gICAgICAgIHZhciBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxuICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXG4gICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Ob3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIGZ1bmN0aW9uIChub3dEYXRlLCB0b2RheVJhbmdlKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgcHJvcHMuY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxscywgcm93KSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVSb3csIHsgcmVmOiBfdGhpcy5yb3dSZWZzLmNyZWF0ZVJlZihyb3cpLCBrZXk6IGNlbGxzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2VsbHNbMF0uZGF0ZS50b0lTT1N0cmluZygpIC8qIGJlc3Q/IG9yIHB1dCBrZXkgb24gY2VsbD8gb3IgdXNlIGRpZmYgZm9ybWF0dGVyPyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcm93IC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNlbGxzIChsaWtlIHdoZW4gcmVzb3VyY2UgdmlldyBpcyBsb2FkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLCBzaG93RGF5TnVtYmVyczogcm93Q250ID4gMSwgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgY2VsbHM6IGNlbGxzLCByZW5kZXJJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tyb3ddLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGJnRXZlbnRTZWdzOiBiZ0V2ZW50U2Vnc0J5Um93W3Jvd10uZmlsdGVyKGlzU2VnQWxsRGF5KSAvKiBoYWNrICovLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tyb3ddLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tyb3ddLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W3Jvd10sIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZUJ5Um93W3Jvd10sIGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfSkpKSkpOyB9KSkpO1xuICAgIH07XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBUYWJsZS5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucm93UG9zaXRpb25zID0gbmV3IGNvbW1vbi5Qb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcChmdW5jdGlvbiAocm93T2JqKSB7IHJldHVybiByb3dPYmouZ2V0Q2VsbEVscygpWzBdOyB9KSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcbiAgICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxuICAgICAgICBmYWxzZSk7XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBjb2xQb3NpdGlvbnMgPSBfYS5jb2xQb3NpdGlvbnMsIHJvd1Bvc2l0aW9ucyA9IF9hLnJvd1Bvc2l0aW9ucztcbiAgICAgICAgdmFyIGNvbCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xuICAgICAgICB2YXIgcm93ID0gcm93UG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiB0c2xpYi5fX2Fzc2lnbih7IHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksIGFsbERheTogdHJ1ZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q2VsbEVsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFtyb3ddLmdldENlbGxFbHMoKVtjb2xdOyAvLyBUT0RPOiBub3Qgb3B0aW1hbFxuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldENlbGxSYW5nZSA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXS5kYXRlO1xuICAgICAgICB2YXIgZW5kID0gY29tbW9uLmFkZERheXMoc3RhcnQsIDEpO1xuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGU7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbn1cblxudmFyIERheVRhYmxlU2xpY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlUYWJsZVNsaWNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUYWJsZVNsaWNlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5VGFibGVTbGljZXIucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZVNsaWNlcjtcbn0oY29tbW9uLlNsaWNlcikpO1xuXG52YXIgRGF5VGFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheVRhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRhYmxlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2xpY2VyID0gbmV3IERheVRhYmxlU2xpY2VyKCk7XG4gICAgICAgIF90aGlzLnRhYmxlUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogdGhpcy50YWJsZVJlZiB9LCB0aGlzLnNsaWNlci5zbGljZVByb3BzKHByb3BzLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMubmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgcHJvcHMuZGF5VGFibGVNb2RlbCksIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuZGF5VGFibGVNb2RlbC5jZWxscywgY29sR3JvdXBOb2RlOiBwcm9wcy5jb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgaGVhZGVyQWxpZ25FbFJlZjogcHJvcHMuaGVhZGVyQWxpZ25FbFJlZiwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGU7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5cbnZhciBEYXlUYWJsZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheVRhYmxlVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUYWJsZVZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBjb21tb24ubWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpO1xuICAgICAgICBfdGhpcy5oZWFkZXJSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnRhYmxlUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciA9IF9hLmRhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsKHByb3BzLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHZhciBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5SGVhZGVyLCB7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZU1vZGVsLnJvd0NudCA9PT0gMSB9KSk7XG4gICAgICAgIHZhciBib2R5Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50QXJnKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIHsgcmVmOiBfdGhpcy50YWJsZVJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBkYXlNYXhFdmVudHM6IG9wdGlvbnMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IG9wdGlvbnMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IG9wdGlvbnMud2Vla051bWJlcnMsIGV4cGFuZFJvd3M6ICFwcm9wcy5pc0hlaWdodEF1dG8sIGhlYWRlckFsaWduRWxSZWY6IF90aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF5TWluV2lkdGhcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgb3B0aW9ucy5kYXlNaW5XaWR0aClcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRhYmxlVmlldztcbn0oVGFibGVWaWV3KSk7XG5mdW5jdGlvbiBidWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgdmFyIGRheVNlcmllcyA9IG5ldyBjb21tb24uRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICByZXR1cm4gbmV3IGNvbW1vbi5EYXlUYWJsZU1vZGVsKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG59XG5cbnZhciBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgcmVuZGVyUmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UuY2FsbCh0aGlzLCBjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICB2YXIgc3RhcnQgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJlbmRlclJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGVuZE9mV2VlaztcbiAgICAgICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gY29tbW9uLmFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubW9udGhNb2RlICYmXG4gICAgICAgICAgICB0aGlzLnByb3BzLmZpeGVkV2Vla0NvdW50KSB7XG4gICAgICAgICAgICB2YXIgcm93Q250ID0gTWF0aC5jZWlsKC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcbiAgICAgICAgICAgIGNvbW1vbi5kaWZmV2Vla3Moc3RhcnQsIGVuZCkpO1xuICAgICAgICAgICAgZW5kID0gY29tbW9uLmFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG59KGNvbW1vbi5EYXRlUHJvZmlsZUdlbmVyYXRvcikpO1xuXG52YXIgbWFpbiA9IGNvbW1vbi5jcmVhdGVQbHVnaW4oe1xuICAgIGluaXRpYWxWaWV3OiAnZGF5R3JpZE1vbnRoJyxcbiAgICB2aWV3czoge1xuICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IERheVRhYmxlVmlldyxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF5R3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGhzOiAxIH0sXG4gICAgICAgICAgICBtb250aE1vZGU6IHRydWUsXG4gICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydHMuRGF5R3JpZFZpZXcgPSBEYXlUYWJsZVZpZXc7XG5leHBvcnRzLkRheVRhYmxlID0gRGF5VGFibGU7XG5leHBvcnRzLkRheVRhYmxlU2xpY2VyID0gRGF5VGFibGVTbGljZXI7XG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG5leHBvcnRzLlRhYmxlVmlldyA9IFRhYmxlVmlldztcbmV4cG9ydHMuYnVpbGREYXlUYWJsZU1vZGVsID0gYnVpbGREYXlUYWJsZU1vZGVsO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1vbiIsInJlcXVpcmUiLCJ0c2xpYiIsIlRhYmxlVmlldyIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsIl90aGlzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJoZWFkZXJFbFJlZiIsImNyZWF0ZVJlZiIsInByb3RvdHlwZSIsInJlbmRlclNpbXBsZUxheW91dCIsImhlYWRlclJvd0NvbnRlbnQiLCJib2R5Q29udGVudCIsIl9hIiwicHJvcHMiLCJjb250ZXh0Iiwic2VjdGlvbnMiLCJzdGlja3lIZWFkZXJEYXRlcyIsImdldFN0aWNreUhlYWRlckRhdGVzIiwib3B0aW9ucyIsInB1c2giLCJ0eXBlIiwia2V5IiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50IiwibGlxdWlkIiwiY29udGVudCIsImNyZWF0ZUVsZW1lbnQiLCJWaWV3Um9vdCIsInZpZXdTcGVjIiwicm9vdEVsUmVmIiwiY2xhc3NOYW1lcyIsInJlZiIsImNsYXNzTmFtZSIsImNvbmNhdCIsImpvaW4iLCJTaW1wbGVTY3JvbGxHcmlkIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsInJlbmRlckhTY3JvbGxMYXlvdXQiLCJjb2xDbnQiLCJkYXlNaW5XaWR0aCIsIlNjcm9sbEdyaWQiLCJwbHVnaW5Ib29rcyIsInNjcm9sbEdyaWRJbXBsIiwiRXJyb3IiLCJzdGlja3lGb290ZXJTY3JvbGxiYXIiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJjaHVua3MiLCJyZW5kZXJTY3JvbGxTaGltIiwiY29sR3JvdXBzIiwic3BhbiIsIm1pbldpZHRoIiwiRGF0ZUNvbXBvbmVudCIsInNwbGl0U2Vnc0J5Um93Iiwic2VncyIsInJvd0NudCIsImJ5Um93IiwiaSIsIl9pIiwic2Vnc18xIiwibGVuZ3RoIiwic2VnIiwicm93Iiwic3BsaXRTZWdzQnlGaXJzdENvbCIsImJ5Q29sIiwic2Vnc18yIiwiZmlyc3RDb2wiLCJzcGxpdEludGVyYWN0aW9uQnlSb3ciLCJ1aSIsImFmZmVjdGVkSW5zdGFuY2VzIiwiaXNFdmVudCIsIlRhYmxlQ2VsbFRvcCIsInJlbmRlciIsIm5hdkxpbmtBdHRycyIsImJ1aWxkTmF2TGlua0F0dHJzIiwiZGF0ZSIsIkRheUNlbGxDb250ZW50IiwiZGF0ZVByb2ZpbGUiLCJ0b2RheVJhbmdlIiwic2hvd0RheU51bWJlciIsImV4dHJhSG9va1Byb3BzIiwiZGVmYXVsdENvbnRlbnQiLCJyZW5kZXJUb3BJbm5lciIsImlubmVyRWxSZWYiLCJpbm5lckNvbnRlbnQiLCJmb3JjZURheVRvcCIsIl9fYXNzaWduIiwiaWQiLCJkYXlOdW1iZXJJZCIsIkZyYWdtZW50IiwiQmFzZUNvbXBvbmVudCIsImRheU51bWJlclRleHQiLCJERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIiwiY3JlYXRlRm9ybWF0dGVyIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJkaXNwbGF5IiwiZXZlbnRSYW5nZSIsImRlZiIsImFsbERheSIsImxhc3RDb2wiLCJpc1N0YXJ0IiwiaXNFbmQiLCJUYWJsZUJsb2NrRXZlbnQiLCJTdGFuZGFyZEV2ZW50IiwiZXh0cmFDbGFzc05hbWVzIiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJkZWZhdWx0RGlzcGxheUV2ZW50RW5kIiwiZGlzYWJsZVJlc2l6aW5nIiwiVGFibGVMaXN0SXRlbUV2ZW50IiwidGltZUZvcm1hdCIsImV2ZW50VGltZUZvcm1hdCIsInRpbWVUZXh0IiwiYnVpbGRTZWdUaW1lVGV4dCIsIkV2ZW50Um9vdCIsInJlbmRlcklubmVyQ29udGVudCIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwiaXNTZWxlY3RlZCIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaW5uZXJQcm9wcyIsInN0eWxlIiwiYm9yZGVyQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJldmVudCIsInRpdGxlIiwiVGFibGVDZWxsTW9yZUxpbmsiLCJjb21waWxlU2VncyIsIm1lbW9pemUiLCJzaW5nbGVQbGFjZW1lbnRzIiwiYWxsU2VncyIsImludmlzaWJsZVNlZ3MiLCJNb3JlTGlua1Jvb3QiLCJhbGxEYXlEYXRlIiwibW9yZUNudCIsImhpZGRlblNlZ3MiLCJhbGlnbm1lbnRFbFJlZiIsImFsaWduR3JpZFRvcCIsImV4dHJhRGF0ZVNwYW4iLCJwb3BvdmVyQ29udGVudCIsImlzRm9yY2VkSW52aXNpYmxlIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemUiLCJtYXAiLCJpbnN0YW5jZUlkIiwiaW5zdGFuY2UiLCJ2aXNpYmlsaXR5IiwiZXZlbnRTZWxlY3Rpb24iLCJnZXRTZWdNZXRhIiwiaGFuZGxlQ2xpY2siLCJpc0V4cGFuZGVkIiwicG9wb3ZlcklkIiwiY3JlYXRlQXJpYUNsaWNrQXR0cnMiLCJzaW5nbGVQbGFjZW1lbnRzXzEiLCJwbGFjZW1lbnQiLCJpc1Zpc2libGUiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJUYWJsZUNlbGwiLCJzdGF0ZSIsImdldFVuaXF1ZURvbUlkIiwiaGFuZGxlUm9vdEVsIiwiZWwiLCJzZXRSZWYiLCJEYXlDZWxsUm9vdCIsImRheUVsUmVmIiwiZGF5Q2xhc3NOYW1lcyIsInJvb3REYXRhQXR0cnMiLCJpc0Rpc2FibGVkIiwicm9sZSIsImV4dHJhRGF0YUF0dHJzIiwic2hvd1dlZWtOdW1iZXIiLCJXZWVrTnVtYmVyUm9vdCIsImRlZmF1bHRGb3JtYXQiLCJ3ZWVrRWxSZWYiLCJ3ZWVrQ2xhc3NOYW1lcyIsImZnQ29udGVudEVsUmVmIiwiZmdDb250ZW50IiwibWFyZ2luVG9wIiwibW9yZU1hcmdpblRvcCIsImJnQ29udGVudCIsImNvbXB1dGVGZ1NlZ1BsYWNlbWVudCIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsInN0cmljdE9yZGVyIiwiZXZlbnRJbnN0YW5jZUhlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiY2VsbHMiLCJoaWVyYXJjaHkiLCJEYXlHcmlkU2VnSGllcmFyY2h5IiwiYWxsb3dSZXNsaWNpbmciLCJtYXhDb29yZCIsImhpZGRlbkNvbnN1bWVzIiwibWF4U3RhY2tDbnQiLCJzZWdJbnB1dHMiLCJ1bmtub3duSGVpZ2h0U2VncyIsImV2ZW50SGVpZ2h0IiwiaW5kZXgiLCJ0aGlja25lc3MiLCJzdGFydCIsImVuZCIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwic2VnUmVjdHMiLCJ0b1JlY3RzIiwicGxhY2VSZWN0cyIsInNpbmdsZUNvbFBsYWNlbWVudHMiLCJtdWx0aUNvbFBsYWNlbWVudHMiLCJsZWZ0b3Zlck1hcmdpbnMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwidW5rbm93bkhlaWdodFNlZ3NfMSIsImlzQWJzb2x1dGUiLCJhYnNvbHV0ZVRvcCIsImNvbCIsInJlc2xpY2VTZWciLCJfYiIsImhpZGRlbkVudHJpZXNfMSIsImhpZGRlbkVudHJ5IiwiaGlkZGVuU3BhbiIsImFsbFJlY3RzIiwicmVjdHNCeUVhY2hDb2wiLCJncm91cFJlY3RzQnlFYWNoQ29sIiwicmVjdHMiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsInJlY3RzXzEiLCJyZWN0IiwibGV2ZWxDb29yZCIsIm11bHRpUGxhY2VtZW50cyIsInJlY3RzXzIiLCJpc0ZpcnN0Q29sIiwicmVjdHNfMyIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJvcmlnUmFuZ2UiLCJyYW5nZSIsInNsaWNlZFJhbmdlIiwiaW50ZXJzZWN0UmFuZ2VzIiwiYWRkRGF5cyIsImR1cmF0aW9uRWRpdGFibGUiLCJ2YWx1ZU9mIiwiZm9yY2VIaWRkZW4iLCJjYWxsIiwiZW50cmllc0J5TGV2ZWwiLCJleGNsdWRlSGlkZGVuIiwiZW50cnkiLCJidWlsZEVudHJ5S2V5IiwibGV2ZWwiLCJmaWx0ZXIiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwiaW5zZXJ0aW9uIiwidG91Y2hpbmdFbnRyeSIsInRvdWNoaW5nTGV2ZWwiLCJ0b3VjaGluZ0xhdGVyYWwiLCJ0b3VjaGluZ0VudHJ5SWQiLCJwbGFjZWhvbGRlckVudHJ5IiwiaW50ZXJzZWN0U3BhbnMiLCJwbGFjZWhvbGRlckVudHJ5SWQiLCJzcGxpdEVudHJ5IiwiU2VnSGllcmFyY2h5IiwiVGFibGVSb3ciLCJjZWxsRWxSZWZzIiwiUmVmTWFwIiwiZnJhbWVFbFJlZnMiLCJmZ0VsUmVmcyIsInNlZ0hhcm5lc3NSZWZzIiwiZnJhbWVQb3NpdGlvbnMiLCJidXNpbmVzc0hvdXJzQnlDb2wiLCJidXNpbmVzc0hvdXJTZWdzIiwiYmdFdmVudFNlZ3NCeUNvbCIsImJnRXZlbnRTZWdzIiwiaGlnaGxpZ2h0U2Vnc0J5Q29sIiwiZ2V0SGlnaGxpZ2h0U2VncyIsIm1pcnJvclNlZ3NCeUNvbCIsImdldE1pcnJvclNlZ3MiLCJzb3J0RXZlbnRTZWdzIiwiZmdFdmVudFNlZ3MiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsInJlbmRlckludHJvIiwiY2VsbCIsIm5vcm1hbEZnTm9kZXMiLCJyZW5kZXJGZ1NlZ3MiLCJtaXJyb3JGZ05vZGVzIiwiYnVpbGRNaXJyb3JQbGFjZW1lbnRzIiwiQm9vbGVhbiIsInNob3dEYXlOdW1iZXJzIiwic2hvd1dlZWtOdW1iZXJzIiwicmVuZGVyRmlsbFNlZ3MiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZVNpemluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsImN1cnJlbnRQcm9wcyIsImlzUHJvcHNFcXVhbCIsImRhdGVTZWxlY3Rpb25TZWdzIiwic2VnUGxhY2VtZW50cyIsImlzTWlycm9yIiwibm9kZXMiLCJzZWdQbGFjZW1lbnRzXzEiLCJsZWZ0IiwicmlnaHQiLCJpc1J0bCIsImxlZnRzIiwicmlnaHRzIiwidG9wIiwiZmlsbFR5cGUiLCJsZWZ0UmlnaHRDc3MiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJCZ0V2ZW50IiwicmVuZGVyRmlsbCIsIl9fc3ByZWFkQXJyYXkiLCJpc0V4dGVybmFsU2l6aW5nQ2hhbmdlIiwiY2xpZW50V2lkdGgiLCJmcmFtZUVscyIsImN1cnJlbnRNYXAiLCJvcmlnaW5FbCIsImN1cnJlbnQiLCJzZXRTdGF0ZSIsIlBvc2l0aW9uQ2FjaGUiLCJvbGRJbnN0YW5jZUhlaWdodHMiLCJuZXdJbnN0YW5jZUhlaWdodHMiLCJxdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzIiwibGltaXRCeUNvbnRlbnRIZWlnaHQiLCJzYWZlU2V0U3RhdGUiLCJjb21wdXRlTWF4Q29udGVudEhlaWdodCIsInNlZ0VsTWFwIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic3BsaXQiLCJtYXgiLCJmaXJzdEtleSIsImNlbGxFbCIsImZjQ29udGFpbmVyRWwiLCJib3R0b20iLCJnZXRDZWxsRWxzIiwiZWxNYXAiLCJhZGRTdGF0ZUVxdWFsaXR5IiwibWlycm9yU2VncyIsImNvbFBsYWNlbWVudHMiLCJ0b3BzQnlJbnN0YW5jZUlkIiwiYnVpbGRBYnNvbHV0ZVRvcEhhc2giLCJjb2xQbGFjZW1lbnRzXzEiLCJwbGFjZW1lbnRzIiwicGxhY2VtZW50c18xIiwiVGFibGUiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdEJnRXZlbnRTZWdzIiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MiLCJzcGxpdEV2ZW50RHJhZyIsInNwbGl0RXZlbnRSZXNpemUiLCJyb3dSZWZzIiwicm9vdEVsIiwicmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImlzSGl0Q29tYm9BbGxvd2VkIiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiZXhwYW5kUm93cyIsImJ1c2luZXNzSG91clNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJmZ0V2ZW50U2Vnc0J5Um93IiwiZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyIsImV2ZW50RHJhZ0J5Um93IiwiZXZlbnRSZXNpemVCeVJvdyIsImxpbWl0VmlhQmFsYW5jZWQiLCJ3aWR0aCIsInRhYmxlTWluV2lkdGgiLCJOb3dUaW1lciIsInVuaXQiLCJub3dEYXRlIiwiY2xpZW50SGVpZ2h0IiwiY29sR3JvdXBOb2RlIiwidG9JU09TdHJpbmciLCJyZW5kZXJSb3dJbnRybyIsImlzU2VnQWxsRGF5IiwicHJlcGFyZUhpdHMiLCJyb3dQb3NpdGlvbnMiLCJjb2xsZWN0Iiwicm93T2JqIiwiY29sUG9zaXRpb25zIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImxlZnRUb0luZGV4IiwidG9wVG9JbmRleCIsImRhdGVTcGFuIiwiZ2V0Q2VsbFJhbmdlIiwiZGF5RWwiLCJnZXRDZWxsRWwiLCJ0b3BzIiwiYm90dG9tcyIsImxheWVyIiwiRGF5VGFibGVTbGljZXIiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJzbGljZVJhbmdlIiwiZGF0ZVJhbmdlIiwiZGF5VGFibGVNb2RlbCIsIlNsaWNlciIsIkRheVRhYmxlIiwic2xpY2VyIiwidGFibGVSZWYiLCJzbGljZVByb3BzIiwibmV4dERheVRocmVzaG9sZCIsImhlYWRlckFsaWduRWxSZWYiLCJEYXlUYWJsZVZpZXciLCJidWlsZERheVRhYmxlTW9kZWwiLCJoZWFkZXJSZWYiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiRGF5SGVhZGVyIiwiZGF0ZXMiLCJoZWFkZXJEYXRlcyIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwiY29udGVudEFyZyIsImJ1c2luZXNzSG91cnMiLCJkYXRlU2VsZWN0aW9uIiwiZXZlbnRTdG9yZSIsImV2ZW50VWlCYXNlcyIsInRhYmxlQ29sR3JvdXBOb2RlIiwid2Vla051bWJlcnMiLCJkYXlTZXJpZXMiLCJEYXlTZXJpZXNNb2RlbCIsInJlbmRlclJhbmdlIiwiRGF5VGFibGVNb2RlbCIsInRlc3QiLCJjdXJyZW50UmFuZ2VVbml0IiwiVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciIsImJ1aWxkUmVuZGVyUmFuZ2UiLCJjdXJyZW50UmFuZ2UiLCJpc1JhbmdlQWxsRGF5IiwiZGF0ZUVudiIsImVuZE9mV2VlayIsInN0YXJ0T2ZXZWVrIiwiYWRkV2Vla3MiLCJtb250aE1vZGUiLCJmaXhlZFdlZWtDb3VudCIsImNlaWwiLCJkaWZmV2Vla3MiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsIm1haW4iLCJjcmVhdGVQbHVnaW4iLCJpbml0aWFsVmlldyIsInZpZXdzIiwiZGF5R3JpZCIsImNvbXBvbmVudCIsImRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJkYXlHcmlkRGF5IiwiZHVyYXRpb24iLCJkYXlzIiwiZGF5R3JpZFdlZWsiLCJ3ZWVrcyIsImRheUdyaWRNb250aCIsIm1vbnRocyIsIkRheUdyaWRWaWV3IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/interaction/main.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/main.cjs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\ncommon.config.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/ var PointerDragging = /** @class */ function() {\n    function PointerDragging(containerEl) {\n        var _this = this;\n        this.subjectEl = null;\n        // options that can be directly assigned by caller\n        this.selector = \"\"; // will cause subjectEl in all emitted events to be this element\n        this.handleSelector = \"\";\n        this.shouldIgnoreMove = false;\n        this.shouldWatchScroll = true; // for simulating pointermove on scroll\n        // internal states\n        this.isDragging = false;\n        this.isTouchDragging = false;\n        this.wasTouchScroll = false;\n        // Mouse\n        // ----------------------------------------------------------------------------------------------------\n        this.handleMouseDown = function(ev) {\n            if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {\n                var pev = _this.createEventFromMouse(ev, true);\n                _this.emitter.trigger(\"pointerdown\", pev);\n                _this.initScrollWatch(pev);\n                if (!_this.shouldIgnoreMove) {\n                    document.addEventListener(\"mousemove\", _this.handleMouseMove);\n                }\n                document.addEventListener(\"mouseup\", _this.handleMouseUp);\n            }\n        };\n        this.handleMouseMove = function(ev) {\n            var pev = _this.createEventFromMouse(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleMouseUp = function(ev) {\n            document.removeEventListener(\"mousemove\", _this.handleMouseMove);\n            document.removeEventListener(\"mouseup\", _this.handleMouseUp);\n            _this.emitter.trigger(\"pointerup\", _this.createEventFromMouse(ev));\n            _this.cleanup(); // call last so that pointerup has access to props\n        };\n        // Touch\n        // ----------------------------------------------------------------------------------------------------\n        this.handleTouchStart = function(ev) {\n            if (_this.tryStart(ev)) {\n                _this.isTouchDragging = true;\n                var pev = _this.createEventFromTouch(ev, true);\n                _this.emitter.trigger(\"pointerdown\", pev);\n                _this.initScrollWatch(pev);\n                // unlike mouse, need to attach to target, not document\n                // https://stackoverflow.com/a/45760014\n                var targetEl = ev.target;\n                if (!_this.shouldIgnoreMove) {\n                    targetEl.addEventListener(\"touchmove\", _this.handleTouchMove);\n                }\n                targetEl.addEventListener(\"touchend\", _this.handleTouchEnd);\n                targetEl.addEventListener(\"touchcancel\", _this.handleTouchEnd); // treat it as a touch end\n                // attach a handler to get called when ANY scroll action happens on the page.\n                // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                // http://stackoverflow.com/a/32954565/96342\n                window.addEventListener(\"scroll\", _this.handleTouchScroll, true);\n            }\n        };\n        this.handleTouchMove = function(ev) {\n            var pev = _this.createEventFromTouch(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleTouchEnd = function(ev) {\n            if (_this.isDragging) {\n                var targetEl = ev.target;\n                targetEl.removeEventListener(\"touchmove\", _this.handleTouchMove);\n                targetEl.removeEventListener(\"touchend\", _this.handleTouchEnd);\n                targetEl.removeEventListener(\"touchcancel\", _this.handleTouchEnd);\n                window.removeEventListener(\"scroll\", _this.handleTouchScroll, true); // useCaptured=true\n                _this.emitter.trigger(\"pointerup\", _this.createEventFromTouch(ev));\n                _this.cleanup(); // call last so that pointerup has access to props\n                _this.isTouchDragging = false;\n                startIgnoringMouse();\n            }\n        };\n        this.handleTouchScroll = function() {\n            _this.wasTouchScroll = true;\n        };\n        this.handleScroll = function(ev) {\n            if (!_this.shouldIgnoreMove) {\n                var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;\n                var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;\n                _this.emitter.trigger(\"pointermove\", {\n                    origEvent: ev,\n                    isTouch: _this.isTouchDragging,\n                    subjectEl: _this.subjectEl,\n                    pageX: pageX,\n                    pageY: pageY,\n                    deltaX: pageX - _this.origPageX,\n                    deltaY: pageY - _this.origPageY\n                });\n            }\n        };\n        this.containerEl = containerEl;\n        this.emitter = new common.Emitter();\n        containerEl.addEventListener(\"mousedown\", this.handleMouseDown);\n        containerEl.addEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerCreated();\n    }\n    PointerDragging.prototype.destroy = function() {\n        this.containerEl.removeEventListener(\"mousedown\", this.handleMouseDown);\n        this.containerEl.removeEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerDestroyed();\n    };\n    PointerDragging.prototype.tryStart = function(ev) {\n        var subjectEl = this.querySubjectEl(ev);\n        var downEl = ev.target;\n        if (subjectEl && (!this.handleSelector || common.elementClosest(downEl, this.handleSelector))) {\n            this.subjectEl = subjectEl;\n            this.isDragging = true; // do this first so cancelTouchScroll will work\n            this.wasTouchScroll = false;\n            return true;\n        }\n        return false;\n    };\n    PointerDragging.prototype.cleanup = function() {\n        isWindowTouchMoveCancelled = false;\n        this.isDragging = false;\n        this.subjectEl = null;\n        // keep wasTouchScroll around for later access\n        this.destroyScrollWatch();\n    };\n    PointerDragging.prototype.querySubjectEl = function(ev) {\n        if (this.selector) {\n            return common.elementClosest(ev.target, this.selector);\n        }\n        return this.containerEl;\n    };\n    PointerDragging.prototype.shouldIgnoreMouse = function() {\n        return ignoreMouseDepth || this.isTouchDragging;\n    };\n    // can be called by user of this class, to cancel touch-based scrolling for the current drag\n    PointerDragging.prototype.cancelTouchScroll = function() {\n        if (this.isDragging) {\n            isWindowTouchMoveCancelled = true;\n        }\n    };\n    // Scrolling that simulates pointermoves\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.initScrollWatch = function(ev) {\n        if (this.shouldWatchScroll) {\n            this.recordCoords(ev);\n            window.addEventListener(\"scroll\", this.handleScroll, true); // useCapture=true\n        }\n    };\n    PointerDragging.prototype.recordCoords = function(ev) {\n        if (this.shouldWatchScroll) {\n            this.prevPageX = ev.pageX;\n            this.prevPageY = ev.pageY;\n            this.prevScrollX = window.pageXOffset;\n            this.prevScrollY = window.pageYOffset;\n        }\n    };\n    PointerDragging.prototype.destroyScrollWatch = function() {\n        if (this.shouldWatchScroll) {\n            window.removeEventListener(\"scroll\", this.handleScroll, true); // useCaptured=true\n        }\n    };\n    // Event Normalization\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.createEventFromMouse = function(ev, isFirst) {\n        var deltaX = 0;\n        var deltaY = 0;\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = ev.pageX;\n            this.origPageY = ev.pageY;\n        } else {\n            deltaX = ev.pageX - this.origPageX;\n            deltaY = ev.pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: false,\n            subjectEl: this.subjectEl,\n            pageX: ev.pageX,\n            pageY: ev.pageY,\n            deltaX: deltaX,\n            deltaY: deltaY\n        };\n    };\n    PointerDragging.prototype.createEventFromTouch = function(ev, isFirst) {\n        var touches = ev.touches;\n        var pageX;\n        var pageY;\n        var deltaX = 0;\n        var deltaY = 0;\n        // if touch coords available, prefer,\n        // because FF would give bad ev.pageX ev.pageY\n        if (touches && touches.length) {\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        } else {\n            pageX = ev.pageX;\n            pageY = ev.pageY;\n        }\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = pageX;\n            this.origPageY = pageY;\n        } else {\n            deltaX = pageX - this.origPageX;\n            deltaY = pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: true,\n            subjectEl: this.subjectEl,\n            pageX: pageX,\n            pageY: pageY,\n            deltaX: deltaX,\n            deltaY: deltaY\n        };\n    };\n    return PointerDragging;\n}();\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n    return ev.button === 0 && !ev.ctrlKey;\n}\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\nfunction startIgnoringMouse() {\n    ignoreMouseDepth += 1;\n    setTimeout(function() {\n        ignoreMouseDepth -= 1;\n    }, common.config.touchMouseIgnoreWait);\n}\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\nfunction listenerCreated() {\n    listenerCnt += 1;\n    if (listenerCnt === 1) {\n        window.addEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction listenerDestroyed() {\n    listenerCnt -= 1;\n    if (!listenerCnt) {\n        window.removeEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction onWindowTouchMove(ev) {\n    if (isWindowTouchMoveCancelled) {\n        ev.preventDefault();\n    }\n}\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/ var ElementMirror = /** @class */ function() {\n    function ElementMirror() {\n        this.isVisible = false; // must be explicitly enabled\n        this.sourceEl = null;\n        this.mirrorEl = null;\n        this.sourceElRect = null; // screen coords relative to viewport\n        // options that can be set directly by caller\n        this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n        this.zIndex = 9999;\n        this.revertDuration = 0;\n    }\n    ElementMirror.prototype.start = function(sourceEl, pageX, pageY) {\n        this.sourceEl = sourceEl;\n        this.sourceElRect = this.sourceEl.getBoundingClientRect();\n        this.origScreenX = pageX - window.pageXOffset;\n        this.origScreenY = pageY - window.pageYOffset;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.updateElPosition();\n    };\n    ElementMirror.prototype.handleMove = function(pageX, pageY) {\n        this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n        this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n        this.updateElPosition();\n    };\n    // can be called before start\n    ElementMirror.prototype.setIsVisible = function(bool) {\n        if (bool) {\n            if (!this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = \"\";\n                }\n                this.isVisible = bool; // needs to happen before updateElPosition\n                this.updateElPosition(); // because was not updating the position while invisible\n            }\n        } else if (this.isVisible) {\n            if (this.mirrorEl) {\n                this.mirrorEl.style.display = \"none\";\n            }\n            this.isVisible = bool;\n        }\n    };\n    // always async\n    ElementMirror.prototype.stop = function(needsRevertAnimation, callback) {\n        var _this = this;\n        var done = function() {\n            _this.cleanup();\n            callback();\n        };\n        if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work\n        (this.deltaX || this.deltaY // if same coords, transition won't work\n        )) {\n            this.doRevertAnimation(done, this.revertDuration);\n        } else {\n            setTimeout(done, 0);\n        }\n    };\n    ElementMirror.prototype.doRevertAnimation = function(callback, revertDuration) {\n        var mirrorEl = this.mirrorEl;\n        var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n        mirrorEl.style.transition = \"top \" + revertDuration + \"ms,\" + \"left \" + revertDuration + \"ms\";\n        common.applyStyle(mirrorEl, {\n            left: finalSourceElRect.left,\n            top: finalSourceElRect.top\n        });\n        common.whenTransitionDone(mirrorEl, function() {\n            mirrorEl.style.transition = \"\";\n            callback();\n        });\n    };\n    ElementMirror.prototype.cleanup = function() {\n        if (this.mirrorEl) {\n            common.removeElement(this.mirrorEl);\n            this.mirrorEl = null;\n        }\n        this.sourceEl = null;\n    };\n    ElementMirror.prototype.updateElPosition = function() {\n        if (this.sourceEl && this.isVisible) {\n            common.applyStyle(this.getMirrorEl(), {\n                left: this.sourceElRect.left + this.deltaX,\n                top: this.sourceElRect.top + this.deltaY\n            });\n        }\n    };\n    ElementMirror.prototype.getMirrorEl = function() {\n        var sourceElRect = this.sourceElRect;\n        var mirrorEl = this.mirrorEl;\n        if (!mirrorEl) {\n            mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n            // we don't want long taps or any mouse interaction causing selection/menus.\n            // would use preventSelection(), but that prevents selectstart, causing problems.\n            mirrorEl.classList.add(\"fc-unselectable\");\n            mirrorEl.classList.add(\"fc-event-dragging\");\n            common.applyStyle(mirrorEl, {\n                position: \"fixed\",\n                zIndex: this.zIndex,\n                visibility: \"\",\n                boxSizing: \"border-box\",\n                width: sourceElRect.right - sourceElRect.left,\n                height: sourceElRect.bottom - sourceElRect.top,\n                right: \"auto\",\n                bottom: \"auto\",\n                margin: 0\n            });\n            this.parentNode.appendChild(mirrorEl);\n        }\n        return mirrorEl;\n    };\n    return ElementMirror;\n}();\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/ var ScrollGeomCache = /** @class */ function(_super) {\n    tslib.__extends(ScrollGeomCache, _super);\n    function ScrollGeomCache(scrollController, doesListening) {\n        var _this = _super.call(this) || this;\n        _this.handleScroll = function() {\n            _this.scrollTop = _this.scrollController.getScrollTop();\n            _this.scrollLeft = _this.scrollController.getScrollLeft();\n            _this.handleScrollChange();\n        };\n        _this.scrollController = scrollController;\n        _this.doesListening = doesListening;\n        _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n        _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n        _this.scrollWidth = scrollController.getScrollWidth();\n        _this.scrollHeight = scrollController.getScrollHeight();\n        _this.clientWidth = scrollController.getClientWidth();\n        _this.clientHeight = scrollController.getClientHeight();\n        _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n        if (_this.doesListening) {\n            _this.getEventTarget().addEventListener(\"scroll\", _this.handleScroll);\n        }\n        return _this;\n    }\n    ScrollGeomCache.prototype.destroy = function() {\n        if (this.doesListening) {\n            this.getEventTarget().removeEventListener(\"scroll\", this.handleScroll);\n        }\n    };\n    ScrollGeomCache.prototype.getScrollTop = function() {\n        return this.scrollTop;\n    };\n    ScrollGeomCache.prototype.getScrollLeft = function() {\n        return this.scrollLeft;\n    };\n    ScrollGeomCache.prototype.setScrollTop = function(top) {\n        this.scrollController.setScrollTop(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.setScrollLeft = function(top) {\n        this.scrollController.setScrollLeft(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.getClientWidth = function() {\n        return this.clientWidth;\n    };\n    ScrollGeomCache.prototype.getClientHeight = function() {\n        return this.clientHeight;\n    };\n    ScrollGeomCache.prototype.getScrollWidth = function() {\n        return this.scrollWidth;\n    };\n    ScrollGeomCache.prototype.getScrollHeight = function() {\n        return this.scrollHeight;\n    };\n    ScrollGeomCache.prototype.handleScrollChange = function() {};\n    return ScrollGeomCache;\n}(common.ScrollController);\nvar ElementScrollGeomCache = /** @class */ function(_super) {\n    tslib.__extends(ElementScrollGeomCache, _super);\n    function ElementScrollGeomCache(el, doesListening) {\n        return _super.call(this, new common.ElementScrollController(el), doesListening) || this;\n    }\n    ElementScrollGeomCache.prototype.getEventTarget = function() {\n        return this.scrollController.el;\n    };\n    ElementScrollGeomCache.prototype.computeClientRect = function() {\n        return common.computeInnerRect(this.scrollController.el);\n    };\n    return ElementScrollGeomCache;\n}(ScrollGeomCache);\nvar WindowScrollGeomCache = /** @class */ function(_super) {\n    tslib.__extends(WindowScrollGeomCache, _super);\n    function WindowScrollGeomCache(doesListening) {\n        return _super.call(this, new common.WindowScrollController(), doesListening) || this;\n    }\n    WindowScrollGeomCache.prototype.getEventTarget = function() {\n        return window;\n    };\n    WindowScrollGeomCache.prototype.computeClientRect = function() {\n        return {\n            left: this.scrollLeft,\n            right: this.scrollLeft + this.clientWidth,\n            top: this.scrollTop,\n            bottom: this.scrollTop + this.clientHeight\n        };\n    };\n    // the window is the only scroll object that changes it's rectangle relative\n    // to the document's topleft as it scrolls\n    WindowScrollGeomCache.prototype.handleScrollChange = function() {\n        this.clientRect = this.computeClientRect();\n    };\n    return WindowScrollGeomCache;\n}(ScrollGeomCache);\n// If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nvar getTime = typeof performance === \"function\" ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/ var AutoScroller = /** @class */ function() {\n    function AutoScroller() {\n        var _this = this;\n        // options that can be set by caller\n        this.isEnabled = true;\n        this.scrollQuery = [\n            window,\n            \".fc-scroller\"\n        ];\n        this.edgeThreshold = 50; // pixels\n        this.maxVelocity = 300; // pixels per second\n        // internal state\n        this.pointerScreenX = null;\n        this.pointerScreenY = null;\n        this.isAnimating = false;\n        this.scrollCaches = null;\n        // protect against the initial pointerdown being too close to an edge and starting the scroll\n        this.everMovedUp = false;\n        this.everMovedDown = false;\n        this.everMovedLeft = false;\n        this.everMovedRight = false;\n        this.animate = function() {\n            if (_this.isAnimating) {\n                var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n                if (edge) {\n                    var now = getTime();\n                    _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n                    _this.requestAnimation(now);\n                } else {\n                    _this.isAnimating = false; // will stop animation\n                }\n            }\n        };\n    }\n    AutoScroller.prototype.start = function(pageX, pageY, scrollStartEl) {\n        if (this.isEnabled) {\n            this.scrollCaches = this.buildCaches(scrollStartEl);\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.handleMove(pageX, pageY);\n        }\n    };\n    AutoScroller.prototype.handleMove = function(pageX, pageY) {\n        if (this.isEnabled) {\n            var pointerScreenX = pageX - window.pageXOffset;\n            var pointerScreenY = pageY - window.pageYOffset;\n            var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n            var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n            if (yDelta < 0) {\n                this.everMovedUp = true;\n            } else if (yDelta > 0) {\n                this.everMovedDown = true;\n            }\n            if (xDelta < 0) {\n                this.everMovedLeft = true;\n            } else if (xDelta > 0) {\n                this.everMovedRight = true;\n            }\n            this.pointerScreenX = pointerScreenX;\n            this.pointerScreenY = pointerScreenY;\n            if (!this.isAnimating) {\n                this.isAnimating = true;\n                this.requestAnimation(getTime());\n            }\n        }\n    };\n    AutoScroller.prototype.stop = function() {\n        if (this.isEnabled) {\n            this.isAnimating = false; // will stop animation\n            for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n                var scrollCache = _a[_i];\n                scrollCache.destroy();\n            }\n            this.scrollCaches = null;\n        }\n    };\n    AutoScroller.prototype.requestAnimation = function(now) {\n        this.msSinceRequest = now;\n        requestAnimationFrame(this.animate);\n    };\n    AutoScroller.prototype.handleSide = function(edge, seconds) {\n        var scrollCache = edge.scrollCache;\n        var edgeThreshold = this.edgeThreshold;\n        var invDistance = edgeThreshold - edge.distance;\n        var velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n        this.maxVelocity * seconds;\n        var sign = 1;\n        switch(edge.name){\n            case \"left\":\n                sign = -1;\n            // falls through\n            case \"right\":\n                scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                break;\n            case \"top\":\n                sign = -1;\n            // falls through\n            case \"bottom\":\n                scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                break;\n        }\n    };\n    // left/top are relative to document topleft\n    AutoScroller.prototype.computeBestEdge = function(left, top) {\n        var edgeThreshold = this.edgeThreshold;\n        var bestSide = null;\n        var scrollCaches = this.scrollCaches || [];\n        for(var _i = 0, scrollCaches_1 = scrollCaches; _i < scrollCaches_1.length; _i++){\n            var scrollCache = scrollCaches_1[_i];\n            var rect = scrollCache.clientRect;\n            var leftDist = left - rect.left;\n            var rightDist = rect.right - left;\n            var topDist = top - rect.top;\n            var bottomDist = rect.bottom - top;\n            // completely within the rect?\n            if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"top\",\n                        distance: topDist\n                    };\n                }\n                if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"bottom\",\n                        distance: bottomDist\n                    };\n                }\n                if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"left\",\n                        distance: leftDist\n                    };\n                }\n                if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"right\",\n                        distance: rightDist\n                    };\n                }\n            }\n        }\n        return bestSide;\n    };\n    AutoScroller.prototype.buildCaches = function(scrollStartEl) {\n        return this.queryScrollEls(scrollStartEl).map(function(el) {\n            if (el === window) {\n                return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n            }\n            return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n        });\n    };\n    AutoScroller.prototype.queryScrollEls = function(scrollStartEl) {\n        var els = [];\n        for(var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++){\n            var query = _a[_i];\n            if (typeof query === \"object\") {\n                els.push(query);\n            } else {\n                els.push.apply(els, Array.prototype.slice.call(common.getElRoot(scrollStartEl).querySelectorAll(query)));\n            }\n        }\n        return els;\n    };\n    return AutoScroller;\n}();\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/ var FeaturefulElementDragging = /** @class */ function(_super) {\n    tslib.__extends(FeaturefulElementDragging, _super);\n    function FeaturefulElementDragging(containerEl, selector) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.containerEl = containerEl;\n        // options that can be directly set by caller\n        // the caller can also set the PointerDragging's options as well\n        _this.delay = null;\n        _this.minDistance = 0;\n        _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n        _this.mirrorNeedsRevert = false;\n        _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n        _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n        _this.isDelayEnded = false;\n        _this.isDistanceSurpassed = false;\n        _this.delayTimeoutId = null;\n        _this.onPointerDown = function(ev) {\n            if (!_this.isDragging) {\n                _this.isInteracting = true;\n                _this.isDelayEnded = false;\n                _this.isDistanceSurpassed = false;\n                common.preventSelection(document.body);\n                common.preventContextMenu(document.body);\n                // prevent links from being visited if there's an eventual drag.\n                // also prevents selection in older browsers (maybe?).\n                // not necessary for touch, besides, browser would complain about passiveness.\n                if (!ev.isTouch) {\n                    ev.origEvent.preventDefault();\n                }\n                _this.emitter.trigger(\"pointerdown\", ev);\n                if (_this.isInteracting && // not destroyed via pointerdown handler\n                !_this.pointer.shouldIgnoreMove) {\n                    // actions related to initiating dragstart+dragmove+dragend...\n                    _this.mirror.setIsVisible(false); // reset. caller must set-visible\n                    _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                    _this.startDelay(ev);\n                    if (!_this.minDistance) {\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n            }\n        };\n        _this.onPointerMove = function(ev) {\n            if (_this.isInteracting) {\n                _this.emitter.trigger(\"pointermove\", ev);\n                if (!_this.isDistanceSurpassed) {\n                    var minDistance = _this.minDistance;\n                    var distanceSq = void 0; // current distance from the origin, squared\n                    var deltaX = ev.deltaX, deltaY = ev.deltaY;\n                    distanceSq = deltaX * deltaX + deltaY * deltaY;\n                    if (distanceSq >= minDistance * minDistance) {\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n                if (_this.isDragging) {\n                    // a real pointer move? (not one simulated by scrolling)\n                    if (ev.origEvent.type !== \"scroll\") {\n                        _this.mirror.handleMove(ev.pageX, ev.pageY);\n                        _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                    }\n                    _this.emitter.trigger(\"dragmove\", ev);\n                }\n            }\n        };\n        _this.onPointerUp = function(ev) {\n            if (_this.isInteracting) {\n                _this.isInteracting = false;\n                common.allowSelection(document.body);\n                common.allowContextMenu(document.body);\n                _this.emitter.trigger(\"pointerup\", ev); // can potentially set mirrorNeedsRevert\n                if (_this.isDragging) {\n                    _this.autoScroller.stop();\n                    _this.tryStopDrag(ev); // which will stop the mirror\n                }\n                if (_this.delayTimeoutId) {\n                    clearTimeout(_this.delayTimeoutId);\n                    _this.delayTimeoutId = null;\n                }\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", _this.onPointerDown);\n        pointer.emitter.on(\"pointermove\", _this.onPointerMove);\n        pointer.emitter.on(\"pointerup\", _this.onPointerUp);\n        if (selector) {\n            pointer.selector = selector;\n        }\n        _this.mirror = new ElementMirror();\n        _this.autoScroller = new AutoScroller();\n        return _this;\n    }\n    FeaturefulElementDragging.prototype.destroy = function() {\n        this.pointer.destroy();\n        // HACK: simulate a pointer-up to end the current drag\n        // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n        this.onPointerUp({});\n    };\n    FeaturefulElementDragging.prototype.startDelay = function(ev) {\n        var _this = this;\n        if (typeof this.delay === \"number\") {\n            this.delayTimeoutId = setTimeout(function() {\n                _this.delayTimeoutId = null;\n                _this.handleDelayEnd(ev);\n            }, this.delay); // not assignable to number!\n        } else {\n            this.handleDelayEnd(ev);\n        }\n    };\n    FeaturefulElementDragging.prototype.handleDelayEnd = function(ev) {\n        this.isDelayEnded = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.handleDistanceSurpassed = function(ev) {\n        this.isDistanceSurpassed = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.tryStartDrag = function(ev) {\n        if (this.isDelayEnded && this.isDistanceSurpassed) {\n            if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                this.isDragging = true;\n                this.mirrorNeedsRevert = false;\n                this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                this.emitter.trigger(\"dragstart\", ev);\n                if (this.touchScrollAllowed === false) {\n                    this.pointer.cancelTouchScroll();\n                }\n            }\n        }\n    };\n    FeaturefulElementDragging.prototype.tryStopDrag = function(ev) {\n        // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n        // that come from the document to fire beforehand. much more convenient this way.\n        this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n    };\n    FeaturefulElementDragging.prototype.stopDrag = function(ev) {\n        this.isDragging = false;\n        this.emitter.trigger(\"dragend\", ev);\n    };\n    // fill in the implementations...\n    FeaturefulElementDragging.prototype.setIgnoreMove = function(bool) {\n        this.pointer.shouldIgnoreMove = bool;\n    };\n    FeaturefulElementDragging.prototype.setMirrorIsVisible = function(bool) {\n        this.mirror.setIsVisible(bool);\n    };\n    FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function(bool) {\n        this.mirrorNeedsRevert = bool;\n    };\n    FeaturefulElementDragging.prototype.setAutoScrollEnabled = function(bool) {\n        this.autoScroller.isEnabled = bool;\n    };\n    return FeaturefulElementDragging;\n}(common.ElementDragging);\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/ var OffsetTracker = /** @class */ function() {\n    function OffsetTracker(el) {\n        this.origRect = common.computeRect(el);\n        // will work fine for divs that have overflow:hidden\n        this.scrollCaches = common.getClippingParents(el).map(function(scrollEl) {\n            return new ElementScrollGeomCache(scrollEl, true);\n        });\n    }\n    OffsetTracker.prototype.destroy = function() {\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            scrollCache.destroy();\n        }\n    };\n    OffsetTracker.prototype.computeLeft = function() {\n        var left = this.origRect.left;\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n        }\n        return left;\n    };\n    OffsetTracker.prototype.computeTop = function() {\n        var top = this.origRect.top;\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n        }\n        return top;\n    };\n    OffsetTracker.prototype.isWithinClipping = function(pageX, pageY) {\n        var point = {\n            left: pageX,\n            top: pageY\n        };\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            if (!isIgnoredClipping(scrollCache.getEventTarget()) && !common.pointInsideRect(point, scrollCache.clientRect)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return OffsetTracker;\n}();\n// certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node) {\n    var tagName = node.tagName;\n    return tagName === \"HTML\" || tagName === \"BODY\";\n}\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/ var HitDragging = /** @class */ function() {\n    function HitDragging(dragging, droppableStore) {\n        var _this = this;\n        // options that can be set by caller\n        this.useSubjectCenter = false;\n        this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n        this.initialHit = null;\n        this.movingHit = null;\n        this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n        this.handlePointerDown = function(ev) {\n            var dragging = _this.dragging;\n            _this.initialHit = null;\n            _this.movingHit = null;\n            _this.finalHit = null;\n            _this.prepareHits();\n            _this.processFirstCoord(ev);\n            if (_this.initialHit || !_this.requireInitial) {\n                dragging.setIgnoreMove(false);\n                // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                _this.emitter.trigger(\"pointerdown\", ev);\n            } else {\n                dragging.setIgnoreMove(true);\n            }\n        };\n        this.handleDragStart = function(ev) {\n            _this.emitter.trigger(\"dragstart\", ev);\n            _this.handleMove(ev, true); // force = fire even if initially null\n        };\n        this.handleDragMove = function(ev) {\n            _this.emitter.trigger(\"dragmove\", ev);\n            _this.handleMove(ev);\n        };\n        this.handlePointerUp = function(ev) {\n            _this.releaseHits();\n            _this.emitter.trigger(\"pointerup\", ev);\n        };\n        this.handleDragEnd = function(ev) {\n            if (_this.movingHit) {\n                _this.emitter.trigger(\"hitupdate\", null, true, ev);\n            }\n            _this.finalHit = _this.movingHit;\n            _this.movingHit = null;\n            _this.emitter.trigger(\"dragend\", ev);\n        };\n        this.droppableStore = droppableStore;\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        dragging.emitter.on(\"dragmove\", this.handleDragMove);\n        dragging.emitter.on(\"pointerup\", this.handlePointerUp);\n        dragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.dragging = dragging;\n        this.emitter = new common.Emitter();\n    }\n    // sets initialHit\n    // sets coordAdjust\n    HitDragging.prototype.processFirstCoord = function(ev) {\n        var origPoint = {\n            left: ev.pageX,\n            top: ev.pageY\n        };\n        var adjustedPoint = origPoint;\n        var subjectEl = ev.subjectEl;\n        var subjectRect;\n        if (subjectEl instanceof HTMLElement) {\n            subjectRect = common.computeRect(subjectEl);\n            adjustedPoint = common.constrainPoint(adjustedPoint, subjectRect);\n        }\n        var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n        if (initialHit) {\n            if (this.useSubjectCenter && subjectRect) {\n                var slicedSubjectRect = common.intersectRects(subjectRect, initialHit.rect);\n                if (slicedSubjectRect) {\n                    adjustedPoint = common.getRectCenter(slicedSubjectRect);\n                }\n            }\n            this.coordAdjust = common.diffPoints(adjustedPoint, origPoint);\n        } else {\n            this.coordAdjust = {\n                left: 0,\n                top: 0\n            };\n        }\n    };\n    HitDragging.prototype.handleMove = function(ev, forceHandle) {\n        var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n        if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n            this.movingHit = hit;\n            this.emitter.trigger(\"hitupdate\", hit, false, ev);\n        }\n    };\n    HitDragging.prototype.prepareHits = function() {\n        this.offsetTrackers = common.mapHash(this.droppableStore, function(interactionSettings) {\n            interactionSettings.component.prepareHits();\n            return new OffsetTracker(interactionSettings.el);\n        });\n    };\n    HitDragging.prototype.releaseHits = function() {\n        var offsetTrackers = this.offsetTrackers;\n        for(var id in offsetTrackers){\n            offsetTrackers[id].destroy();\n        }\n        this.offsetTrackers = {};\n    };\n    HitDragging.prototype.queryHitForOffset = function(offsetLeft, offsetTop) {\n        var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;\n        var bestHit = null;\n        for(var id in droppableStore){\n            var component = droppableStore[id].component;\n            var offsetTracker = offsetTrackers[id];\n            if (offsetTracker && // wasn't destroyed mid-drag\n            offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                var originLeft = offsetTracker.computeLeft();\n                var originTop = offsetTracker.computeTop();\n                var positionLeft = offsetLeft - originLeft;\n                var positionTop = offsetTop - originTop;\n                var origRect = offsetTracker.origRect;\n                var width = origRect.right - origRect.left;\n                var height = origRect.bottom - origRect.top;\n                if (// must be within the element's bounds\n                positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n                    var hit = component.queryHit(positionLeft, positionTop, width, height);\n                    if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n                    common.rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n                        hit.componentId = id;\n                        hit.context = component.context;\n                        // TODO: better way to re-orient rectangle\n                        hit.rect.left += originLeft;\n                        hit.rect.right += originLeft;\n                        hit.rect.top += originTop;\n                        hit.rect.bottom += originTop;\n                        bestHit = hit;\n                    }\n                }\n            }\n        }\n        return bestHit;\n    };\n    return HitDragging;\n}();\nfunction isHitsEqual(hit0, hit1) {\n    if (!hit0 && !hit1) {\n        return true;\n    }\n    if (Boolean(hit0) !== Boolean(hit1)) {\n        return false;\n    }\n    return common.isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);\n}\nfunction buildDatePointApiWithContext(dateSpan, context) {\n    var props = {};\n    for(var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        tslib.__assign(props, transform(dateSpan, context));\n    }\n    tslib.__assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n    return props;\n}\nfunction buildDatePointApi(span, dateEnv) {\n    return {\n        date: dateEnv.toDate(span.range.start),\n        dateStr: dateEnv.formatIso(span.range.start, {\n            omitTime: span.allDay\n        }),\n        allDay: span.allDay\n    };\n}\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/ var DateClicking = /** @class */ function(_super) {\n    tslib.__extends(DateClicking, _super);\n    function DateClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handlePointerDown = function(pev) {\n            var dragging = _this.dragging;\n            var downEl = pev.origEvent.target;\n            // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n            dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n        };\n        // won't even fire if moving was ignored\n        _this.handleDragEnd = function(ev) {\n            var component = _this.component;\n            var pointer = _this.dragging.pointer;\n            if (!pointer.wasTouchScroll) {\n                var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;\n                if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                    var context = component.context;\n                    var arg = tslib.__assign(tslib.__assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n                        dayEl: initialHit.dayEl,\n                        jsEvent: ev.origEvent,\n                        view: context.viewApi || context.calendarApi.view\n                    });\n                    context.emitter.trigger(\"dateClick\", arg);\n                }\n            }\n        };\n        // we DO want to watch pointer moves because otherwise finalHit won't get populated\n        _this.dragging = new FeaturefulElementDragging(settings.el);\n        _this.dragging.autoScroller.isEnabled = false;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, common.interactionSettingsToStore(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    DateClicking.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return DateClicking;\n}(common.Interaction);\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/ var DateSelecting = /** @class */ function(_super) {\n    tslib.__extends(DateSelecting, _super);\n    function DateSelecting(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.dragSelection = null;\n        _this.handlePointerDown = function(ev) {\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var options = component.context.options;\n            var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n            // don't bother to watch expensive moves if component won't do selection\n            dragging.setIgnoreMove(!canSelect);\n            // if touch, require user to hold down\n            dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n        };\n        _this.handleDragStart = function(ev) {\n            _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n        };\n        _this.handleHitUpdate = function(hit, isFinal) {\n            var context = _this.component.context;\n            var dragSelection = null;\n            var isInvalid = false;\n            if (hit) {\n                var initialHit = _this.hitDragging.initialHit;\n                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                }\n                if (!dragSelection || !common.isDateSelectionValid(dragSelection, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    dragSelection = null;\n                }\n            }\n            if (dragSelection) {\n                context.dispatch({\n                    type: \"SELECT_DATES\",\n                    selection: dragSelection\n                });\n            } else if (!isFinal) {\n                context.dispatch({\n                    type: \"UNSELECT_DATES\"\n                });\n            }\n            if (!isInvalid) {\n                common.enableCursor();\n            } else {\n                common.disableCursor();\n            }\n            if (!isFinal) {\n                _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n            }\n        };\n        _this.handlePointerUp = function(pev) {\n            if (_this.dragSelection) {\n                // selection is already rendered, so just need to report selection\n                common.triggerDateSelect(_this.dragSelection, pev, _this.component.context);\n                _this.dragSelection = null;\n            }\n        };\n        var component = settings.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.touchScrollAllowed = false;\n        dragging.minDistance = options.selectMinDistance || 0;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, common.interactionSettingsToStore(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", _this.handlePointerUp);\n        return _this;\n    }\n    DateSelecting.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return DateSelecting;\n}(common.Interaction);\nfunction getComponentTouchDelay$1(component) {\n    var options = component.context.options;\n    var delay = options.selectLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var ms = [\n        dateSpan0.range.start,\n        dateSpan0.range.end,\n        dateSpan1.range.start,\n        dateSpan1.range.end\n    ];\n    ms.sort(common.compareNumbers);\n    var props = {};\n    for(var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++){\n        var transformer = dateSelectionTransformers_1[_i];\n        var res = transformer(hit0, hit1);\n        if (res === false) {\n            return null;\n        }\n        if (res) {\n            tslib.__assign(props, res);\n        }\n    }\n    props.range = {\n        start: ms[0],\n        end: ms[3]\n    };\n    props.allDay = dateSpan0.allDay;\n    return props;\n}\nvar EventDragging = /** @class */ function(_super) {\n    tslib.__extends(EventDragging, _super);\n    function EventDragging(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.subjectEl = null;\n        _this.subjectSeg = null; // the seg being selected/dragged\n        _this.isDragging = false;\n        _this.eventRange = null;\n        _this.relevantEvents = null; // the events being dragged\n        _this.receivingContext = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function(ev) {\n            var origTarget = ev.origEvent.target;\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var mirror = dragging.mirror;\n            var options = component.context.options;\n            var initialContext = component.context;\n            _this.subjectEl = ev.subjectEl;\n            var subjectSeg = _this.subjectSeg = common.getElSeg(ev.subjectEl);\n            var eventRange = _this.eventRange = subjectSeg.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            _this.relevantEvents = common.getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);\n            dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n            dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n            ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n            if (options.fixedMirrorParent) {\n                mirror.parentNode = options.fixedMirrorParent;\n            } else {\n                mirror.parentNode = common.elementClosest(origTarget, \".fc\");\n            }\n            mirror.revertDuration = options.dragRevertDuration;\n            var isValid = component.isValidSegDownEl(origTarget) && !common.elementClosest(origTarget, \".fc-event-resizer\"); // NOT on a resizer\n            dragging.setIgnoreMove(!isValid);\n            // disable dragging for elements that are resizable (ie, selectable)\n            // but are not draggable\n            _this.isDragging = isValid && ev.subjectEl.classList.contains(\"fc-event-draggable\");\n        };\n        _this.handleDragStart = function(ev) {\n            var initialContext = _this.component.context;\n            var eventRange = _this.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            if (ev.isTouch) {\n                // need to select a different event?\n                if (eventInstanceId !== _this.component.props.eventSelection) {\n                    initialContext.dispatch({\n                        type: \"SELECT_EVENT\",\n                        eventInstanceId: eventInstanceId\n                    });\n                }\n            } else {\n                // if now using mouse, but was previous touch interaction, clear selected event\n                initialContext.dispatch({\n                    type: \"UNSELECT_EVENT\"\n                });\n            }\n            if (_this.isDragging) {\n                initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                initialContext.emitter.trigger(\"eventDragStart\", {\n                    el: _this.subjectEl,\n                    event: new common.EventApi(initialContext, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: initialContext.viewApi\n                });\n            }\n        };\n        _this.handleHitUpdate = function(hit, isFinal) {\n            if (!_this.isDragging) {\n                return;\n            }\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var initialContext = _this.component.context;\n            // states based on new hit\n            var receivingContext = null;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: common.createEmptyEventStore(),\n                isEvent: true\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                var receivingOptions = receivingContext.options;\n                if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n                    mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                    if (mutation) {\n                        mutatedRelevantEvents = common.applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                        interaction.mutatedEvents = mutatedRelevantEvents;\n                        if (!common.isInteractionValid(interaction, hit.dateProfile, receivingContext)) {\n                            isInvalid = true;\n                            mutation = null;\n                            mutatedRelevantEvents = null;\n                            interaction.mutatedEvents = common.createEmptyEventStore();\n                        }\n                    }\n                } else {\n                    receivingContext = null;\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            if (!isInvalid) {\n                common.enableCursor();\n            } else {\n                common.disableCursor();\n            }\n            if (!isFinal) {\n                if (initialContext === receivingContext && // TODO: write test for this\n                isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.dragging.setMirrorNeedsRevert(!mutation);\n                // render the mirror if no already-rendered mirror\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                _this.dragging.setMirrorIsVisible(!hit || !common.getElRoot(_this.subjectEl).querySelector(\".fc-event-mirror\"));\n                // assign states based on new hit\n                _this.receivingContext = receivingContext;\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handlePointerUp = function() {\n            if (!_this.isDragging) {\n                _this.cleanup(); // because handleDragEnd won't fire\n            }\n        };\n        _this.handleDragEnd = function(ev) {\n            if (_this.isDragging) {\n                var initialContext_1 = _this.component.context;\n                var initialView = initialContext_1.viewApi;\n                var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;\n                var eventDef = _this.eventRange.def;\n                var eventInstance = _this.eventRange.instance;\n                var eventApi = new common.EventApi(initialContext_1, eventDef, eventInstance);\n                var relevantEvents_1 = _this.relevantEvents;\n                var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n                var finalHit = _this.hitDragging.finalHit;\n                _this.clearDrag(); // must happen after revert animation\n                initialContext_1.emitter.trigger(\"eventDragStop\", {\n                    el: _this.subjectEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: initialView\n                });\n                if (validMutation) {\n                    // dropped within same calendar\n                    if (receivingContext_1 === initialContext_1) {\n                        var updatedEventApi = new common.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n                        initialContext_1.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents_1\n                        });\n                        var eventChangeArg = {\n                            oldEvent: eventApi,\n                            event: updatedEventApi,\n                            relatedEvents: common.buildEventApis(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n                            revert: function() {\n                                initialContext_1.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents_1\n                                });\n                            }\n                        };\n                        var transformed = {};\n                        for(var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++){\n                            var transformer = _b[_i];\n                            tslib.__assign(transformed, transformer(validMutation, initialContext_1));\n                        }\n                        initialContext_1.emitter.trigger(\"eventDrop\", tslib.__assign(tslib.__assign(tslib.__assign({}, eventChangeArg), transformed), {\n                            el: ev.subjectEl,\n                            delta: validMutation.datesDelta,\n                            jsEvent: ev.origEvent,\n                            view: initialView\n                        }));\n                        initialContext_1.emitter.trigger(\"eventChange\", eventChangeArg);\n                    // dropped in different calendar\n                    } else if (receivingContext_1) {\n                        var eventRemoveArg = {\n                            event: eventApi,\n                            relatedEvents: common.buildEventApis(relevantEvents_1, initialContext_1, eventInstance),\n                            revert: function() {\n                                initialContext_1.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents_1\n                                });\n                            }\n                        };\n                        initialContext_1.emitter.trigger(\"eventLeave\", tslib.__assign(tslib.__assign({}, eventRemoveArg), {\n                            draggedEl: ev.subjectEl,\n                            view: initialView\n                        }));\n                        initialContext_1.dispatch({\n                            type: \"REMOVE_EVENTS\",\n                            eventStore: relevantEvents_1\n                        });\n                        initialContext_1.emitter.trigger(\"eventRemove\", eventRemoveArg);\n                        var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n                        var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n                        var addedEventApi = new common.EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n                        receivingContext_1.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents_1\n                        });\n                        var eventAddArg = {\n                            event: addedEventApi,\n                            relatedEvents: common.buildEventApis(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n                            revert: function() {\n                                receivingContext_1.dispatch({\n                                    type: \"REMOVE_EVENTS\",\n                                    eventStore: mutatedRelevantEvents_1\n                                });\n                            }\n                        };\n                        receivingContext_1.emitter.trigger(\"eventAdd\", eventAddArg);\n                        if (ev.isTouch) {\n                            receivingContext_1.dispatch({\n                                type: \"SELECT_EVENT\",\n                                eventInstanceId: eventInstance.instanceId\n                            });\n                        }\n                        receivingContext_1.emitter.trigger(\"drop\", tslib.__assign(tslib.__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {\n                            draggedEl: ev.subjectEl,\n                            jsEvent: ev.origEvent,\n                            view: finalHit.context.viewApi\n                        }));\n                        receivingContext_1.emitter.trigger(\"eventReceive\", tslib.__assign(tslib.__assign({}, eventAddArg), {\n                            draggedEl: ev.subjectEl,\n                            view: finalHit.context.viewApi\n                        }));\n                    }\n                } else {\n                    initialContext_1.emitter.trigger(\"_noEventDrop\");\n                }\n            }\n            _this.cleanup();\n        };\n        var component = _this.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = EventDragging.SELECTOR;\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, common.interactionSettingsStore);\n        hitDragging.useSubjectCenter = settings.useEventCenter;\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", _this.handlePointerUp);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    EventDragging.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    // render a drag state on the next receivingCalendar\n    EventDragging.prototype.displayDrag = function(nextContext, state) {\n        var initialContext = this.component.context;\n        var prevContext = this.receivingContext;\n        // does the previous calendar need to be cleared?\n        if (prevContext && prevContext !== nextContext) {\n            // does the initial calendar need to be cleared?\n            // if so, don't clear all the way. we still need to to hide the affectedEvents\n            if (prevContext === initialContext) {\n                prevContext.dispatch({\n                    type: \"SET_EVENT_DRAG\",\n                    state: {\n                        affectedEvents: state.affectedEvents,\n                        mutatedEvents: common.createEmptyEventStore(),\n                        isEvent: true\n                    }\n                });\n            // completely clear the old calendar if it wasn't the initial\n            } else {\n                prevContext.dispatch({\n                    type: \"UNSET_EVENT_DRAG\"\n                });\n            }\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state: state\n            });\n        }\n    };\n    EventDragging.prototype.clearDrag = function() {\n        var initialCalendar = this.component.context;\n        var receivingContext = this.receivingContext;\n        if (receivingContext) {\n            receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        // the initial calendar might have an dummy drag state from displayDrag\n        if (initialCalendar !== receivingContext) {\n            initialCalendar.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    };\n    EventDragging.prototype.cleanup = function() {\n        this.subjectSeg = null;\n        this.isDragging = false;\n        this.eventRange = null;\n        this.relevantEvents = null;\n        this.receivingContext = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n    };\n    // TODO: test this in IE11\n    // QUESTION: why do we need it on the resizable???\n    EventDragging.SELECTOR = \".fc-event-draggable, .fc-event-resizable\";\n    return EventDragging;\n}(common.Interaction);\nfunction computeEventMutation(hit0, hit1, massagers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var date0 = dateSpan0.range.start;\n    var date1 = dateSpan1.range.start;\n    var standardProps = {};\n    if (dateSpan0.allDay !== dateSpan1.allDay) {\n        standardProps.allDay = dateSpan1.allDay;\n        standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n        if (dateSpan1.allDay) {\n            // means date1 is already start-of-day,\n            // but date0 needs to be converted\n            date0 = common.startOfDay(date0);\n        }\n    }\n    var delta = common.diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n    if (delta.milliseconds) {\n        standardProps.allDay = false;\n    }\n    var mutation = {\n        datesDelta: delta,\n        standardProps: standardProps\n    };\n    for(var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++){\n        var massager = massagers_1[_i];\n        massager(mutation, hit0, hit1);\n    }\n    return mutation;\n}\nfunction getComponentTouchDelay(component) {\n    var options = component.context.options;\n    var delay = options.eventLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nvar EventResizing = /** @class */ function(_super) {\n    tslib.__extends(EventResizing, _super);\n    function EventResizing(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.draggingSegEl = null;\n        _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n        _this.eventRange = null;\n        _this.relevantEvents = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function(ev) {\n            var component = _this.component;\n            var segEl = _this.querySegEl(ev);\n            var seg = common.getElSeg(segEl);\n            var eventRange = _this.eventRange = seg.eventRange;\n            _this.dragging.minDistance = component.context.options.eventDragMinDistance;\n            // if touch, need to be working with a selected event\n            _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);\n        };\n        _this.handleDragStart = function(ev) {\n            var context = _this.component.context;\n            var eventRange = _this.eventRange;\n            _this.relevantEvents = common.getRelevantEvents(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n            var segEl = _this.querySegEl(ev);\n            _this.draggingSegEl = segEl;\n            _this.draggingSeg = common.getElSeg(segEl);\n            context.calendarApi.unselect();\n            context.emitter.trigger(\"eventResizeStart\", {\n                el: segEl,\n                event: new common.EventApi(context, eventRange.def, eventRange.instance),\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n        };\n        _this.handleHitUpdate = function(hit, isFinal, ev) {\n            var context = _this.component.context;\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var eventInstance = _this.eventRange.instance;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: common.createEmptyEventStore(),\n                isEvent: true\n            };\n            if (hit) {\n                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains(\"fc-event-resizer-start\"), eventInstance.range);\n                }\n            }\n            if (mutation) {\n                mutatedRelevantEvents = common.applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                interaction.mutatedEvents = mutatedRelevantEvents;\n                if (!common.isInteractionValid(interaction, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    mutation = null;\n                    mutatedRelevantEvents = null;\n                    interaction.mutatedEvents = null;\n                }\n            }\n            if (mutatedRelevantEvents) {\n                context.dispatch({\n                    type: \"SET_EVENT_RESIZE\",\n                    state: interaction\n                });\n            } else {\n                context.dispatch({\n                    type: \"UNSET_EVENT_RESIZE\"\n                });\n            }\n            if (!isInvalid) {\n                common.enableCursor();\n            } else {\n                common.disableCursor();\n            }\n            if (!isFinal) {\n                if (mutation && isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handleDragEnd = function(ev) {\n            var context = _this.component.context;\n            var eventDef = _this.eventRange.def;\n            var eventInstance = _this.eventRange.instance;\n            var eventApi = new common.EventApi(context, eventDef, eventInstance);\n            var relevantEvents = _this.relevantEvents;\n            var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n            context.emitter.trigger(\"eventResizeStop\", {\n                el: _this.draggingSegEl,\n                event: eventApi,\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n            if (_this.validMutation) {\n                var updatedEventApi = new common.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: mutatedRelevantEvents\n                });\n                var eventChangeArg = {\n                    oldEvent: eventApi,\n                    event: updatedEventApi,\n                    relatedEvents: common.buildEventApis(mutatedRelevantEvents, context, eventInstance),\n                    revert: function() {\n                        context.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: relevantEvents\n                        });\n                    }\n                };\n                context.emitter.trigger(\"eventResize\", tslib.__assign(tslib.__assign({}, eventChangeArg), {\n                    el: _this.draggingSegEl,\n                    startDelta: _this.validMutation.startDelta || common.createDuration(0),\n                    endDelta: _this.validMutation.endDelta || common.createDuration(0),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                }));\n                context.emitter.trigger(\"eventChange\", eventChangeArg);\n            } else {\n                context.emitter.trigger(\"_noEventResize\");\n            }\n            // reset all internal state\n            _this.draggingSeg = null;\n            _this.relevantEvents = null;\n            _this.validMutation = null;\n        // okay to keep eventInstance around. useful to set it in handlePointerDown\n        };\n        var component = settings.component;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = \".fc-event-resizer\";\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, common.interactionSettingsToStore(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    EventResizing.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    EventResizing.prototype.querySegEl = function(ev) {\n        return common.elementClosest(ev.subjectEl, \".fc-event\");\n    };\n    return EventResizing;\n}(common.Interaction);\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n    var dateEnv = hit0.context.dateEnv;\n    var date0 = hit0.dateSpan.range.start;\n    var date1 = hit1.dateSpan.range.start;\n    var delta = common.diffDates(date0, date1, dateEnv, hit0.largeUnit);\n    if (isFromStart) {\n        if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n            return {\n                startDelta: delta\n            };\n        }\n    } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n        return {\n            endDelta: delta\n        };\n    }\n    return null;\n}\nvar UnselectAuto = /** @class */ function() {\n    function UnselectAuto(context) {\n        var _this = this;\n        this.context = context;\n        this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n        this.matchesCancel = false;\n        this.matchesEvent = false;\n        this.onSelect = function(selectInfo) {\n            if (selectInfo.jsEvent) {\n                _this.isRecentPointerDateSelect = true;\n            }\n        };\n        this.onDocumentPointerDown = function(pev) {\n            var unselectCancel = _this.context.options.unselectCancel;\n            var downEl = common.getEventTargetViaRoot(pev.origEvent);\n            _this.matchesCancel = !!common.elementClosest(downEl, unselectCancel);\n            _this.matchesEvent = !!common.elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?\n        };\n        this.onDocumentPointerUp = function(pev) {\n            var context = _this.context;\n            var documentPointer = _this.documentPointer;\n            var calendarState = context.getCurrentData();\n            // touch-scrolling should never unfocus any type of selection\n            if (!documentPointer.wasTouchScroll) {\n                if (calendarState.dateSelection && // an existing date selection?\n                !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                ) {\n                    var unselectAuto = context.options.unselectAuto;\n                    if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n                        context.calendarApi.unselect(pev);\n                    }\n                }\n                if (calendarState.eventSelection && // an existing event selected?\n                !_this.matchesEvent // interaction DIDN'T start on an event\n                ) {\n                    context.dispatch({\n                        type: \"UNSELECT_EVENT\"\n                    });\n                }\n            }\n            _this.isRecentPointerDateSelect = false;\n        };\n        var documentPointer = this.documentPointer = new PointerDragging(document);\n        documentPointer.shouldIgnoreMove = true;\n        documentPointer.shouldWatchScroll = false;\n        documentPointer.emitter.on(\"pointerdown\", this.onDocumentPointerDown);\n        documentPointer.emitter.on(\"pointerup\", this.onDocumentPointerUp);\n        /*\n        TODO: better way to know about whether there was a selection with the pointer\n        */ context.emitter.on(\"select\", this.onSelect);\n    }\n    UnselectAuto.prototype.destroy = function() {\n        this.context.emitter.off(\"select\", this.onSelect);\n        this.documentPointer.destroy();\n    };\n    return UnselectAuto;\n}();\nvar OPTION_REFINERS = {\n    fixedMirrorParent: common.identity\n};\nvar LISTENER_REFINERS = {\n    dateClick: common.identity,\n    eventDragStart: common.identity,\n    eventDragStop: common.identity,\n    eventDrop: common.identity,\n    eventResizeStart: common.identity,\n    eventResizeStop: common.identity,\n    eventResize: common.identity,\n    drop: common.identity,\n    eventReceive: common.identity,\n    eventLeave: common.identity\n};\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/ var ExternalElementDragging = /** @class */ function() {\n    function ExternalElementDragging(dragging, suppliedDragMeta) {\n        var _this = this;\n        this.receivingContext = null;\n        this.droppableEvent = null; // will exist for all drags, even if create:false\n        this.suppliedDragMeta = null;\n        this.dragMeta = null;\n        this.handleDragStart = function(ev) {\n            _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n        };\n        this.handleHitUpdate = function(hit, isFinal, ev) {\n            var dragging = _this.hitDragging.dragging;\n            var receivingContext = null;\n            var droppableEvent = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: common.createEmptyEventStore(),\n                mutatedEvents: common.createEmptyEventStore(),\n                isEvent: _this.dragMeta.create\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                    droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n                    interaction.mutatedEvents = common.eventTupleToStore(droppableEvent);\n                    isInvalid = !common.isInteractionValid(interaction, hit.dateProfile, receivingContext);\n                    if (isInvalid) {\n                        interaction.mutatedEvents = common.createEmptyEventStore();\n                        droppableEvent = null;\n                    }\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n            // TODO: wish we could somehow wait for dispatch to guarantee render\n            dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector(\".fc-event-mirror\"));\n            if (!isInvalid) {\n                common.enableCursor();\n            } else {\n                common.disableCursor();\n            }\n            if (!isFinal) {\n                dragging.setMirrorNeedsRevert(!droppableEvent);\n                _this.receivingContext = receivingContext;\n                _this.droppableEvent = droppableEvent;\n            }\n        };\n        this.handleDragEnd = function(pev) {\n            var _a = _this, receivingContext = _a.receivingContext, droppableEvent = _a.droppableEvent;\n            _this.clearDrag();\n            if (receivingContext && droppableEvent) {\n                var finalHit = _this.hitDragging.finalHit;\n                var finalView = finalHit.context.viewApi;\n                var dragMeta = _this.dragMeta;\n                receivingContext.emitter.trigger(\"drop\", tslib.__assign(tslib.__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                    draggedEl: pev.subjectEl,\n                    jsEvent: pev.origEvent,\n                    view: finalView\n                }));\n                if (dragMeta.create) {\n                    var addingEvents_1 = common.eventTupleToStore(droppableEvent);\n                    receivingContext.dispatch({\n                        type: \"MERGE_EVENTS\",\n                        eventStore: addingEvents_1\n                    });\n                    if (pev.isTouch) {\n                        receivingContext.dispatch({\n                            type: \"SELECT_EVENT\",\n                            eventInstanceId: droppableEvent.instance.instanceId\n                        });\n                    }\n                    // signal that an external event landed\n                    receivingContext.emitter.trigger(\"eventReceive\", {\n                        event: new common.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n                        relatedEvents: [],\n                        revert: function() {\n                            receivingContext.dispatch({\n                                type: \"REMOVE_EVENTS\",\n                                eventStore: addingEvents_1\n                            });\n                        },\n                        draggedEl: pev.subjectEl,\n                        view: finalView\n                    });\n                }\n            }\n            _this.receivingContext = null;\n            _this.droppableEvent = null;\n        };\n        var hitDragging = this.hitDragging = new HitDragging(dragging, common.interactionSettingsStore);\n        hitDragging.requireInitial = false; // will start outside of a component\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.suppliedDragMeta = suppliedDragMeta;\n    }\n    ExternalElementDragging.prototype.buildDragMeta = function(subjectEl) {\n        if (typeof this.suppliedDragMeta === \"object\") {\n            return common.parseDragMeta(this.suppliedDragMeta);\n        }\n        if (typeof this.suppliedDragMeta === \"function\") {\n            return common.parseDragMeta(this.suppliedDragMeta(subjectEl));\n        }\n        return getDragMetaFromEl(subjectEl);\n    };\n    ExternalElementDragging.prototype.displayDrag = function(nextContext, state) {\n        var prevContext = this.receivingContext;\n        if (prevContext && prevContext !== nextContext) {\n            prevContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state: state\n            });\n        }\n    };\n    ExternalElementDragging.prototype.clearDrag = function() {\n        if (this.receivingContext) {\n            this.receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    };\n    ExternalElementDragging.prototype.canDropElOnCalendar = function(el, receivingContext) {\n        var dropAccept = receivingContext.options.dropAccept;\n        if (typeof dropAccept === \"function\") {\n            return dropAccept.call(receivingContext.calendarApi, el);\n        }\n        if (typeof dropAccept === \"string\" && dropAccept) {\n            return Boolean(common.elementMatches(el, dropAccept));\n        }\n        return true;\n    };\n    return ExternalElementDragging;\n}();\n// Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n    var defProps = tslib.__assign({}, dragMeta.leftoverProps);\n    for(var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        tslib.__assign(defProps, transform(dateSpan, dragMeta));\n    }\n    var _b = common.refineEventDef(defProps, context), refined = _b.refined, extra = _b.extra;\n    var def = common.parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);\n    var start = dateSpan.range.start;\n    // only rely on time info if drop zone is all-day,\n    // otherwise, we already know the time\n    if (dateSpan.allDay && dragMeta.startTime) {\n        start = context.dateEnv.add(start, dragMeta.startTime);\n    }\n    var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : common.getDefaultEventEnd(dateSpan.allDay, start, context);\n    var instance = common.createEventInstance(def.defId, {\n        start: start,\n        end: end\n    });\n    return {\n        def: def,\n        instance: instance\n    };\n}\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\nfunction getDragMetaFromEl(el) {\n    var str = getEmbeddedElData(el, \"event\");\n    var obj = str ? JSON.parse(str) : {\n        create: false\n    }; // if no embedded data, assume no event creation\n    return common.parseDragMeta(obj);\n}\ncommon.config.dataAttrPrefix = \"\";\nfunction getEmbeddedElData(el, name) {\n    var prefix = common.config.dataAttrPrefix;\n    var prefixedName = (prefix ? prefix + \"-\" : \"\") + name;\n    return el.getAttribute(\"data-\" + prefixedName) || \"\";\n}\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/ var ExternalDraggable = /** @class */ function() {\n    function ExternalDraggable(el, settings) {\n        var _this = this;\n        if (settings === void 0) {\n            settings = {};\n        }\n        this.handlePointerDown = function(ev) {\n            var dragging = _this.dragging;\n            var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;\n            dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : common.BASE_OPTION_DEFAULTS.eventDragMinDistance;\n            dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : common.BASE_OPTION_DEFAULTS.longPressDelay : 0;\n        };\n        this.handleDragStart = function(ev) {\n            if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains(\"fc-event\")) {\n                _this.dragging.mirror.getMirrorEl().classList.add(\"fc-event-selected\");\n            }\n        };\n        this.settings = settings;\n        var dragging = this.dragging = new FeaturefulElementDragging(el);\n        dragging.touchScrollAllowed = false;\n        if (settings.itemSelector != null) {\n            dragging.pointer.selector = settings.itemSelector;\n        }\n        if (settings.appendTo != null) {\n            dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n        }\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ExternalDraggable.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return ExternalDraggable;\n}();\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/ var InferredElementDragging = /** @class */ function(_super) {\n    tslib.__extends(InferredElementDragging, _super);\n    function InferredElementDragging(containerEl) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.shouldIgnoreMove = false;\n        _this.mirrorSelector = \"\";\n        _this.currentMirrorEl = null;\n        _this.handlePointerDown = function(ev) {\n            _this.emitter.trigger(\"pointerdown\", ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragstart right away. does not support delay or min-distance\n                _this.emitter.trigger(\"dragstart\", ev);\n            }\n        };\n        _this.handlePointerMove = function(ev) {\n            if (!_this.shouldIgnoreMove) {\n                _this.emitter.trigger(\"dragmove\", ev);\n            }\n        };\n        _this.handlePointerUp = function(ev) {\n            _this.emitter.trigger(\"pointerup\", ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragend right away. does not support a revert animation\n                _this.emitter.trigger(\"dragend\", ev);\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        pointer.emitter.on(\"pointermove\", _this.handlePointerMove);\n        pointer.emitter.on(\"pointerup\", _this.handlePointerUp);\n        return _this;\n    }\n    InferredElementDragging.prototype.destroy = function() {\n        this.pointer.destroy();\n    };\n    InferredElementDragging.prototype.setIgnoreMove = function(bool) {\n        this.shouldIgnoreMove = bool;\n    };\n    InferredElementDragging.prototype.setMirrorIsVisible = function(bool) {\n        if (bool) {\n            // restore a previously hidden element.\n            // use the reference in case the selector class has already been removed.\n            if (this.currentMirrorEl) {\n                this.currentMirrorEl.style.visibility = \"\";\n                this.currentMirrorEl = null;\n            }\n        } else {\n            var mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;\n            if (mirrorEl) {\n                this.currentMirrorEl = mirrorEl;\n                mirrorEl.style.visibility = \"hidden\";\n            }\n        }\n    };\n    return InferredElementDragging;\n}(common.ElementDragging);\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/ var ThirdPartyDraggable = /** @class */ function() {\n    function ThirdPartyDraggable(containerOrSettings, settings) {\n        var containerEl = document;\n        if (// wish we could just test instanceof EventTarget, but doesn't work in IE11\n        containerOrSettings === document || containerOrSettings instanceof Element) {\n            containerEl = containerOrSettings;\n            settings = settings || {};\n        } else {\n            settings = containerOrSettings || {};\n        }\n        var dragging = this.dragging = new InferredElementDragging(containerEl);\n        if (typeof settings.itemSelector === \"string\") {\n            dragging.pointer.selector = settings.itemSelector;\n        } else if (containerEl === document) {\n            dragging.pointer.selector = \"[data-event]\";\n        }\n        if (typeof settings.mirrorSelector === \"string\") {\n            dragging.mirrorSelector = settings.mirrorSelector;\n        }\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ThirdPartyDraggable.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return ThirdPartyDraggable;\n}();\nvar main = common.createPlugin({\n    componentInteractions: [\n        DateClicking,\n        DateSelecting,\n        EventDragging,\n        EventResizing\n    ],\n    calendarInteractions: [\n        UnselectAuto\n    ],\n    elementDraggingImpl: FeaturefulElementDragging,\n    optionRefiners: OPTION_REFINERS,\n    listenerRefiners: LISTENER_REFINERS\n});\nexports.Draggable = ExternalDraggable;\nexports.FeaturefulElementDragging = FeaturefulElementDragging;\nexports.PointerDragging = PointerDragging;\nexports.ThirdPartyDraggable = ThirdPartyDraggable;\nexports[\"default\"] = main;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9tYWluLmNqcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBQ0E7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU8sSUFBSTtBQUFDLENBQUMsRUFBQztBQUU3RCxJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVwQkQsT0FBT0csTUFBTSxDQUFDQyxvQkFBb0IsR0FBRztBQUNyQyxJQUFJQyxtQkFBbUI7QUFDdkIsSUFBSUMsY0FBYztBQUNsQixJQUFJQyw2QkFBNkIsS0FBSztBQUN0Qzs7Ozs7Ozs7Ozs7O0FBWUEsR0FDQSxJQUFJQyxrQkFBa0IsV0FBVyxHQUFJLFdBQVk7SUFDN0MsU0FBU0EsZ0JBQWdCQyxXQUFXLEVBQUU7UUFDbEMsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUk7UUFDckIsa0RBQWtEO1FBQ2xELElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksZ0VBQWdFO1FBQ3BGLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsS0FBSztRQUM3QixJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUksRUFBRSx1Q0FBdUM7UUFDdEUsa0JBQWtCO1FBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEtBQUs7UUFDdkIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsS0FBSztRQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBRyxLQUFLO1FBQzNCLFFBQVE7UUFDUix1R0FBdUc7UUFDdkcsSUFBSSxDQUFDQyxlQUFlLEdBQUcsU0FBVUMsRUFBRSxFQUFFO1lBQ2pDLElBQUksQ0FBQ1YsTUFBTVcsaUJBQWlCLE1BQ3hCQyxxQkFBcUJGLE9BQ3JCVixNQUFNYSxRQUFRLENBQUNILEtBQUs7Z0JBQ3BCLElBQUlJLE1BQU1kLE1BQU1lLG9CQUFvQixDQUFDTCxJQUFJLElB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QyxPQUFPLENBQUMzTixRQUFRLEdBQUd1VSxTQUFTdU4sWUFBWTtRQUNyRCxPQUNLLElBQUlqaUIsZ0JBQWdCb0IsVUFBVTtZQUMvQitPLFNBQVNyQyxPQUFPLENBQUMzTixRQUFRLEdBQUc7UUFDaEMsQ0FBQztRQUNELElBQUksT0FBT3VVLFNBQVMyTixjQUFjLEtBQUssVUFBVTtZQUM3Q2xTLFNBQVNrUyxjQUFjLEdBQUczTixTQUFTMk4sY0FBYztRQUNyRCxDQUFDO1FBQ0QsSUFBSTNDLHdCQUF3QnZQLFVBQVV1RSxTQUFTeU4sU0FBUyxHQUFHLDZCQUE2QjtJQUM1RjtJQUNBSyxvQkFBb0JsZixTQUFTLENBQUNDLE9BQU8sR0FBRyxXQUFZO1FBQ2hELElBQUksQ0FBQzRNLFFBQVEsQ0FBQzVNLE9BQU87SUFDekI7SUFDQSxPQUFPaWY7QUFDWDtBQUVBLElBQUlHLE9BQU9wakIsT0FBT3FqQixZQUFZLENBQUM7SUFDM0JDLHVCQUF1QjtRQUFDcE87UUFBY1k7UUFBZWlDO1FBQWU0RjtLQUFjO0lBQ2xGNEYsc0JBQXNCO1FBQUNoRjtLQUFhO0lBQ3BDaUYscUJBQXFCN1Y7SUFDckI4VixnQkFBZ0JuRTtJQUNoQm9FLGtCQUFrQmxFO0FBQ3RCO0FBRUExZixpQkFBaUIsR0FBRzBpQjtBQUNwQjFpQixpQ0FBaUMsR0FBRzZOO0FBQ3BDN04sdUJBQXVCLEdBQUdVO0FBQzFCViwyQkFBMkIsR0FBR21qQjtBQUM5Qm5qQixrQkFBZSxHQUFHc2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwLWZ1bGxjYWxlbmRhci8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uL21haW4uY2pzLmpzPzk4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5GdWxsQ2FsZW5kYXIgdjUuMTEuM1xuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuKGMpIDIwMjIgQWRhbSBTaGF3XG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9jb21tb24nKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG5cbmNvbW1vbi5jb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQgPSA1MDA7XG52YXIgaWdub3JlTW91c2VEZXB0aCA9IDA7XG52YXIgbGlzdGVuZXJDbnQgPSAwO1xudmFyIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4vKlxuVXNlcyBhIFwicG9pbnRlclwiIGFic3RyYWN0aW9uLCB3aGljaCBtb25pdG9ycyBVSSBldmVudHMgZm9yIGJvdGggbW91c2UgYW5kIHRvdWNoLlxuVHJhY2tzIHdoZW4gdGhlIHBvaW50ZXIgXCJkcmFnc1wiIG9uIGEgY2VydGFpbiBlbGVtZW50LCBtZWFuaW5nIGRvd24rbW92ZSt1cC5cblxuQWxzbywgdHJhY2tzIGlmIHRoZXJlIHdhcyB0b3VjaC1zY3JvbGxpbmcuXG5BbHNvLCBjYW4gcHJldmVudCB0b3VjaC1zY3JvbGxpbmcgZnJvbSBoYXBwZW5pbmcuXG5BbHNvLCBjYW4gZmlyZSBwb2ludGVybW92ZSBldmVudHMgd2hlbiBzY3JvbGxpbmcgaGFwcGVucyB1bmRlcm5lYXRoLCBldmVuIHdoZW4gbm8gcmVhbCBwb2ludGVyIG1vdmVtZW50LlxuXG5lbWl0czpcbi0gcG9pbnRlcmRvd25cbi0gcG9pbnRlcm1vdmVcbi0gcG9pbnRlcnVwXG4qL1xudmFyIFBvaW50ZXJEcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJyc7IC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRXYXRjaFNjcm9sbCA9IHRydWU7IC8vIGZvciBzaW11bGF0aW5nIHBvaW50ZXJtb3ZlIG9uIHNjcm9sbFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZXNcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgLy8gTW91c2VcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpICYmXG4gICAgICAgICAgICAgICAgaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpICYmXG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5U3RhcnQoZXYpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0U2Nyb2xsV2F0Y2gocGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KTtcbiAgICAgICAgICAgIF90aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpKTtcbiAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVG91Y2hcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBwZXYgPSBfdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIHBldik7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XG4gICAgICAgICAgICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfdGhpcy5oYW5kbGVUb3VjaEVuZCk7IC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLmhhbmRsZVRvdWNoU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBwZXYgPSBfdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldik7XG4gICAgICAgICAgICBfdGhpcy5yZWNvcmRDb29yZHMocGV2KTtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBfdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTsgLy8gY2FsbCBsYXN0IHNvIHRoYXQgcG9pbnRlcnVwIGhhcyBhY2Nlc3MgdG8gcHJvcHNcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGFydElnbm9yaW5nTW91c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYWdlWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgLSBfdGhpcy5wcmV2U2Nyb2xsWCkgKyBfdGhpcy5wcmV2UGFnZVg7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VZID0gKHdpbmRvdy5wYWdlWU9mZnNldCAtIF90aGlzLnByZXZTY3JvbGxZKSArIF90aGlzLnByZXZQYWdlWTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywge1xuICAgICAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoOiBfdGhpcy5pc1RvdWNoRHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RFbDogX3RoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYOiBwYWdlWCAtIF90aGlzLm9yaWdQYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFZOiBwYWdlWSAtIF90aGlzLm9yaWdQYWdlWSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgY29tbW9uLkVtaXR0ZXIoKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyQ3JlYXRlZCgpO1xuICAgIH1cbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgbGlzdGVuZXJEZXN0cm95ZWQoKTtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUudHJ5U3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHN1YmplY3RFbCA9IHRoaXMucXVlcnlTdWJqZWN0RWwoZXYpO1xuICAgICAgICB2YXIgZG93bkVsID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoc3ViamVjdEVsICYmXG4gICAgICAgICAgICAoIXRoaXMuaGFuZGxlU2VsZWN0b3IgfHwgY29tbW9uLmVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7IC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgd2FzVG91Y2hTY3JvbGwgYXJvdW5kIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKTtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUucXVlcnlTdWJqZWN0RWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCB0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbDtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVNb3VzZURlcHRoIHx8IHRoaXMuaXNUb3VjaERyYWdnaW5nO1xuICAgIH07XG4gICAgLy8gY2FuIGJlIGNhbGxlZCBieSB1c2VyIG9mIHRoaXMgY2xhc3MsIHRvIGNhbmNlbCB0b3VjaC1iYXNlZCBzY3JvbGxpbmcgZm9yIHRoZSBjdXJyZW50IGRyYWdcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNhbmNlbFRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFNjcm9sbGluZyB0aGF0IHNpbXVsYXRlcyBwb2ludGVybW92ZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5pbml0U2Nyb2xsV2F0Y2ggPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKGV2KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmU9dHJ1ZVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLnJlY29yZENvb3JkcyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMucHJldlBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95U2Nyb2xsV2F0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5jcmVhdGVFdmVudEZyb21Nb3VzZSA9IGZ1bmN0aW9uIChldiwgaXNGaXJzdCkge1xuICAgICAgICB2YXIgZGVsdGFYID0gMDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2LnBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBldi5wYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgcGFnZVg6IGV2LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2LnBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVk6IGRlbHRhWSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuY3JlYXRlRXZlbnRGcm9tVG91Y2ggPSBmdW5jdGlvbiAoZXYsIGlzRmlyc3QpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzO1xuICAgICAgICB2YXIgcGFnZVg7XG4gICAgICAgIHZhciBwYWdlWTtcbiAgICAgICAgdmFyIGRlbHRhWCA9IDA7XG4gICAgICAgIHZhciBkZWx0YVkgPSAwO1xuICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcbiAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogcGFnZVksXG4gICAgICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50ZXJEcmFnZ2luZztcbn0oKSk7XG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XG4gICAgcmV0dXJuIGV2LmJ1dHRvbiA9PT0gMCAmJiAhZXYuY3RybEtleTtcbn1cbi8vIElnbm9yaW5nIGZha2UgbW91c2UgZXZlbnRzIGdlbmVyYXRlZCBieSB0b3VjaFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RhcnRJZ25vcmluZ01vdXNlKCkge1xuICAgIGlnbm9yZU1vdXNlRGVwdGggKz0gMTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWdub3JlTW91c2VEZXB0aCAtPSAxO1xuICAgIH0sIGNvbW1vbi5jb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQpO1xufVxuLy8gV2Ugd2FudCB0byBhdHRhY2ggdG91Y2htb3ZlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBTYWZhcmlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGxpc3RlbmVyQ3JlYXRlZCgpIHtcbiAgICBsaXN0ZW5lckNudCArPSAxO1xuICAgIGlmIChsaXN0ZW5lckNudCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJEZXN0cm95ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgLT0gMTtcbiAgICBpZiAoIWxpc3RlbmVyQ250KSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbldpbmRvd1RvdWNoTW92ZShldikge1xuICAgIGlmIChpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLypcbkFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cblRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cbk11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbnZhciBFbGVtZW50TWlycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRNaXJyb3IoKSB7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7IC8vIG11c3QgYmUgZXhwbGljaXRseSBlbmFibGVkXG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xuICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VFbFJlY3QgPSBudWxsOyAvLyBzY3JlZW4gY29vcmRzIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGRpcmVjdGx5IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBkb2N1bWVudC5ib2R5OyAvLyBISUdITFkgU1VHR0VTVEVEIHRvIHNldCB0aGlzIHRvIHNpZGVzdGVwIFNoYWRvd0RPTSBpc3N1ZXNcbiAgICAgICAgdGhpcy56SW5kZXggPSA5OTk5O1xuICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoc291cmNlRWwsIHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB0aGlzLnNvdXJjZUVsID0gc291cmNlRWw7XG4gICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YVkgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHRoaXMuZGVsdGFYID0gKHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblg7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH07XG4gICAgLy8gY2FuIGJlIGNhbGxlZCBiZWZvcmUgc3RhcnRcbiAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5zZXRJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yRWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2w7IC8vIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdXBkYXRlRWxQb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpOyAvLyBiZWNhdXNlIHdhcyBub3QgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIGludmlzaWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gYWx3YXlzIGFzeW5jXG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChuZWVkc1JldmVydEFuaW1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXG4gICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmRvUmV2ZXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrLCByZXZlcnREdXJhdGlvbikge1xuICAgICAgICB2YXIgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xuICAgICAgICB2YXIgZmluYWxTb3VyY2VFbFJlY3QgPSB0aGlzLnNvdXJjZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBiZWNhdXNlIGF1dG9zY3JvbGxpbmcgbWlnaHQgaGF2ZSBoYXBwZW5lZFxuICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID1cbiAgICAgICAgICAgICd0b3AgJyArIHJldmVydER1cmF0aW9uICsgJ21zLCcgK1xuICAgICAgICAgICAgICAgICdsZWZ0ICcgKyByZXZlcnREdXJhdGlvbiArICdtcyc7XG4gICAgICAgIGNvbW1vbi5hcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgIH0pO1xuICAgICAgICBjb21tb24ud2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgICAgICBjb21tb24ucmVtb3ZlRWxlbWVudCh0aGlzLm1pcnJvckVsKTtcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xuICAgIH07XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUudXBkYXRlRWxQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGNvbW1vbi5hcHBseVN0eWxlKHRoaXMuZ2V0TWlycm9yRWwoKSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc291cmNlRWxSZWN0LmxlZnQgKyB0aGlzLmRlbHRhWCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc291cmNlRWxSZWN0LnRvcCArIHRoaXMuZGVsdGFZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmdldE1pcnJvckVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3Q7XG4gICAgICAgIHZhciBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGlmICghbWlycm9yRWwpIHtcbiAgICAgICAgICAgIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCA9IHRoaXMuc291cmNlRWwuY2xvbmVOb2RlKHRydWUpOyAvLyBjbG9uZUNoaWxkcmVuPXRydWVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJyk7XG4gICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgY29tbW9uLmFwcGx5U3R5bGUobWlycm9yRWwsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VFbFJlY3QucmlnaHQgLSBzb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZUVsUmVjdC5ib3R0b20gLSBzb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobWlycm9yRWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXJyb3JFbDtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50TWlycm9yO1xufSgpKTtcblxuLypcbklzIGEgY2FjaGUgZm9yIGEgZ2l2ZW4gZWxlbWVudCdzIHNjcm9sbCBpbmZvcm1hdGlvbiAoYWxsIHRoZSBpbmZvIHRoYXQgU2Nyb2xsQ29udHJvbGxlciBzdG9yZXMpXG5pbiBhZGRpdGlvbiB0aGUgXCJjbGllbnQgcmVjdGFuZ2xlXCIgb2YgdGhlIGVsZW1lbnQuLiB0aGUgYXJlYSB3aXRoaW4gdGhlIHNjcm9sbGJhcnMuXG5cblRoZSBjYWNoZSBjYW4gYmUgaW4gb25lIG9mIHR3byBtb2Rlczpcbi0gZG9lc0xpc3RlbmluZzpmYWxzZSAtIGlnbm9yZXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIHNjcm9sbGVkIGJ5IHNvbWVvbmUgZWxzZVxuLSBkb2VzTGlzdGVuaW5nOnRydWUgLSB3YXRjaCBmb3Igc2Nyb2xsaW5nIGFuZCB1cGRhdGUgdGhlIGNhY2hlXG4qL1xudmFyIFNjcm9sbEdlb21DYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU2Nyb2xsR2VvbUNhY2hlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjcm9sbEdlb21DYWNoZShzY3JvbGxDb250cm9sbGVyLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IF90aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gX3RoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsQ29udHJvbGxlciA9IHNjcm9sbENvbnRyb2xsZXI7XG4gICAgICAgIF90aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xuICAgICAgICBfdGhpcy5zY3JvbGxUb3AgPSBfdGhpcy5vcmlnU2Nyb2xsVG9wID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsTGVmdCA9IF90aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIF90aGlzLnNjcm9sbFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxXaWR0aCgpO1xuICAgICAgICBfdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xuICAgICAgICBfdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKTtcbiAgICAgICAgX3RoaXMuY2xpZW50SGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRIZWlnaHQoKTtcbiAgICAgICAgX3RoaXMuY2xpZW50UmVjdCA9IF90aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7IC8vIGRvIGxhc3QgaW4gY2FzZSBpdCBuZWVkcyBjYWNoZWQgdmFsdWVzXG4gICAgICAgIGlmIChfdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICBfdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICh0b3ApIHtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbFRvcCh0b3ApO1xuICAgICAgICBpZiAoIXRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCByZWx5aW5nIG9uIHRoZSBlbGVtZW50IHRvIG5vcm1hbGl6ZSBvdXQtb2YtYm91bmRzIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2FuaXRpemUgb3Vyc2VsdmVzXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSksIDApO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsTGVmdCh0b3ApO1xuICAgICAgICBpZiAoIXRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCByZWx5aW5nIG9uIHRoZSBlbGVtZW50IHRvIG5vcm1hbGl6ZSBvdXQtb2YtYm91bmRzIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2FuaXRpemUgb3Vyc2VsdmVzXG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRXaWR0aDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRIZWlnaHQ7XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmdldFNjcm9sbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmhhbmRsZVNjcm9sbENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxHZW9tQ2FjaGU7XG59KGNvbW1vbi5TY3JvbGxDb250cm9sbGVyKSk7XG5cbnZhciBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFbGVtZW50U2Nyb2xsR2VvbUNhY2hlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoZWwsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBjb21tb24uRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uLmNvbXB1dGVJbm5lclJlY3QodGhpcy5zY3JvbGxDb250cm9sbGVyLmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlO1xufShTY3JvbGxHZW9tQ2FjaGUpKTtcblxudmFyIFdpbmRvd1Njcm9sbEdlb21DYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoV2luZG93U2Nyb2xsR2VvbUNhY2hlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd1Njcm9sbEdlb21DYWNoZShkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgY29tbW9uLldpbmRvd1Njcm9sbENvbnRyb2xsZXIoKSwgZG9lc0xpc3RlbmluZykgfHwgdGhpcztcbiAgICB9XG4gICAgV2luZG93U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuY29tcHV0ZUNsaWVudFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICByaWdodDogdGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgICBib3R0b206IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5jbGllbnRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXG4gICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXG4gICAgV2luZG93U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5oYW5kbGVTY3JvbGxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dTY3JvbGxHZW9tQ2FjaGU7XG59KFNjcm9sbEdlb21DYWNoZSkpO1xuXG4vLyBJZiBhdmFpbGFibGUgd2UgYXJlIHVzaW5nIG5hdGl2ZSBcInBlcmZvcm1hbmNlXCIgQVBJIGluc3RlYWQgb2YgXCJEYXRlXCJcbi8vIFJlYWQgbW9yZSBhYm91dCBpdCBvbiBNRE46XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGVyZm9ybWFuY2VcbnZhciBnZXRUaW1lID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnZnVuY3Rpb24nID8gcGVyZm9ybWFuY2Uubm93IDogRGF0ZS5ub3c7XG4vKlxuRm9yIGEgcG9pbnRlciBpbnRlcmFjdGlvbiwgYXV0b21hdGljYWxseSBzY3JvbGxzIGNlcnRhaW4gc2Nyb2xsIGNvbnRhaW5lcnMgd2hlbiB0aGUgcG9pbnRlclxuYXBwcm9hY2hlcyB0aGUgZWRnZS5cblxuVGhlIGNhbGxlciBtdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG52YXIgQXV0b1Njcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dG9TY3JvbGxlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY3JvbGxRdWVyeSA9IFt3aW5kb3csICcuZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgdGhpcy5lZGdlVGhyZXNob2xkID0gNTA7IC8vIHBpeGVsc1xuICAgICAgICB0aGlzLm1heFZlbG9jaXR5ID0gMzAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBudWxsO1xuICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3QgdGhlIGluaXRpYWwgcG9pbnRlcmRvd24gYmVpbmcgdG9vIGNsb3NlIHRvIGFuIGVkZ2UgYW5kIHN0YXJ0aW5nIHRoZSBzY3JvbGxcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzQW5pbWF0aW5nKSB7IC8vIHdhc24ndCBjYW5jZWxsZWQgYmV0d2VlbiBhbmltYXRpb24gY2FsbHNcbiAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzLmNvbXB1dGVCZXN0RWRnZShfdGhpcy5wb2ludGVyU2NyZWVuWCArIHdpbmRvdy5wYWdlWE9mZnNldCwgX3RoaXMucG9pbnRlclNjcmVlblkgKyB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIF90aGlzLm1zU2luY2VSZXF1ZXN0KSAvIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKG5vdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSwgc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gdGhpcy5idWlsZENhY2hlcyhzY3JvbGxTdGFydEVsKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRlclNjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHZhciBwb2ludGVyU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHlEZWx0YSA9IHRoaXMucG9pbnRlclNjcmVlblkgPT09IG51bGwgPyAwIDogcG9pbnRlclNjcmVlblkgLSB0aGlzLnBvaW50ZXJTY3JlZW5ZO1xuICAgICAgICAgICAgdmFyIHhEZWx0YSA9IHRoaXMucG9pbnRlclNjcmVlblggPT09IG51bGwgPyAwIDogcG9pbnRlclNjcmVlblggLSB0aGlzLnBvaW50ZXJTY3JlZW5YO1xuICAgICAgICAgICAgaWYgKHlEZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHlEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHhEZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeERlbHRhID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IHBvaW50ZXJTY3JlZW5YO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IHBvaW50ZXJTY3JlZW5ZO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKGdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIHdpbGwgc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQ2FjaGUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnJlcXVlc3RBbmltYXRpb24gPSBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgIHRoaXMubXNTaW5jZVJlcXVlc3QgPSBub3c7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpO1xuICAgIH07XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5oYW5kbGVTaWRlID0gZnVuY3Rpb24gKGVkZ2UsIHNlY29uZHMpIHtcbiAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gZWRnZS5zY3JvbGxDYWNoZTtcbiAgICAgICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSB0aGlzLmVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBpbnZEaXN0YW5jZSA9IGVkZ2VUaHJlc2hvbGQgLSBlZGdlLmRpc3RhbmNlO1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSAvLyB0aGUgY2xvc2VyIHRvIHRoZSBlZGdlLCB0aGUgZmFzdGVyIHdlIHNjcm9sbFxuICAgICAgICAgKChpbnZEaXN0YW5jZSAqIGludkRpc3RhbmNlKSAvIChlZGdlVGhyZXNob2xkICogZWRnZVRocmVzaG9sZCkpICogLy8gcXVhZHJhdGljXG4gICAgICAgICAgICB0aGlzLm1heFZlbG9jaXR5ICogc2Vjb25kcztcbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICBzd2l0Y2ggKGVkZ2UubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLnNldFNjcm9sbExlZnQoc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsTGVmdCgpICsgdmVsb2NpdHkgKiBzaWduKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxUb3Aoc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCkgKyB2ZWxvY2l0eSAqIHNpZ24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuY29tcHV0ZUJlc3RFZGdlID0gZnVuY3Rpb24gKGxlZnQsIHRvcCkge1xuICAgICAgICB2YXIgZWRnZVRocmVzaG9sZCA9IHRoaXMuZWRnZVRocmVzaG9sZDtcbiAgICAgICAgdmFyIGJlc3RTaWRlID0gbnVsbDtcbiAgICAgICAgdmFyIHNjcm9sbENhY2hlcyA9IHRoaXMuc2Nyb2xsQ2FjaGVzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNjcm9sbENhY2hlc18xID0gc2Nyb2xsQ2FjaGVzOyBfaSA8IHNjcm9sbENhY2hlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gc2Nyb2xsQ2FjaGVzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzY3JvbGxDYWNoZS5jbGllbnRSZWN0O1xuICAgICAgICAgICAgdmFyIGxlZnREaXN0ID0gbGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIHZhciByaWdodERpc3QgPSByZWN0LnJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIHZhciB0b3BEaXN0ID0gdG9wIC0gcmVjdC50b3A7XG4gICAgICAgICAgICB2YXIgYm90dG9tRGlzdCA9IHJlY3QuYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgLy8gY29tcGxldGVseSB3aXRoaW4gdGhlIHJlY3Q/XG4gICAgICAgICAgICBpZiAobGVmdERpc3QgPj0gMCAmJiByaWdodERpc3QgPj0gMCAmJiB0b3BEaXN0ID49IDAgJiYgYm90dG9tRGlzdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFVwICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFVwKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHRvcERpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZExlZnQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsTGVmdCgpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBsZWZ0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlOiBzY3JvbGxDYWNoZSwgbmFtZTogJ2xlZnQnLCBkaXN0YW5jZTogbGVmdERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkUmlnaHQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsUmlnaHQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gcmlnaHREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcbiAgICB9O1xuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuYnVpbGRDYWNoZXMgPSBmdW5jdGlvbiAoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnF1ZXJ5U2Nyb2xsRWxzID0gZnVuY3Rpb24gKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgdmFyIGVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxRdWVyeTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2gocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2guYXBwbHkoZWxzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb21tb24uZ2V0RWxSb290KHNjcm9sbFN0YXJ0RWwpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9O1xuICAgIHJldHVybiBBdXRvU2Nyb2xsZXI7XG59KCkpO1xuXG4vKlxuTW9uaXRvcnMgZHJhZ2dpbmcgb24gYW4gZWxlbWVudC4gSGFzIGEgbnVtYmVyIG9mIGhpZ2gtbGV2ZWwgZmVhdHVyZXM6XG4tIG1pbmltdW0gZGlzdGFuY2UgcmVxdWlyZWQgYmVmb3JlIGRyYWdnaW5nXG4tIG1pbmltdW0gd2FpdCB0aW1lIChcImRlbGF5XCIpIGJlZm9yZSBkcmFnZ2luZ1xuLSBhIG1pcnJvciBlbGVtZW50IHRoYXQgZm9sbG93cyB0aGUgcG9pbnRlclxuKi9cbnZhciBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lckVsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICBfdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIF90aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgX3RoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIF90aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTsgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIF90aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29tbW9uLnByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgY29tbW9uLnByZXZlbnRDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGxpbmtzIGZyb20gYmVpbmcgdmlzaXRlZCBpZiB0aGVyZSdzIGFuIGV2ZW50dWFsIGRyYWcuXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBwcmV2ZW50cyBzZWxlY3Rpb24gaW4gb2xkZXIgYnJvd3NlcnMgKG1heWJlPykuXG4gICAgICAgICAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgdG91Y2gsIGJlc2lkZXMsIGJyb3dzZXIgd291bGQgY29tcGxhaW4gYWJvdXQgcGFzc2l2ZW5lc3MuXG4gICAgICAgICAgICAgICAgaWYgKCFldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2Lm9yaWdFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY3Rpb25zIHJlbGF0ZWQgdG8gaW5pdGlhdGluZyBkcmFnc3RhcnQrZHJhZ21vdmUrZHJhZ2VuZC4uLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGZhbHNlKTsgLy8gcmVzZXQuIGNhbGxlciBtdXN0IHNldC12aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydERlbGF5KGV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IF90aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VTcSA9IHZvaWQgMDsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGV2LmRlbHRhWCwgZGVsdGFZID0gZXYuZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVNxID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSByZWFsIHBvaW50ZXIgbW92ZT8gKG5vdCBvbmUgc2ltdWxhdGVkIGJ5IHNjcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2Lm9yaWdFdmVudC50eXBlICE9PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWlycm9yLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb21tb24uYWxsb3dTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgY29tbW9uLmFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7IC8vIGNhbiBwb3RlbnRpYWxseSBzZXQgbWlycm9yTmVlZHNSZXZlcnRcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cnlTdG9wRHJhZyhldik7IC8vIHdoaWNoIHdpbGwgc3RvcCB0aGUgbWlycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZWxheVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuZGVsYXlUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgX3RoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMub25Qb2ludGVyVXApO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHBvaW50ZXIuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xuICAgICAgICBfdGhpcy5hdXRvU2Nyb2xsZXIgPSBuZXcgQXV0b1Njcm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXG4gICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zdGFydERlbGF5ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVEZWxheUVuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnRyeVN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUudHJ5U3RvcERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgLy8gLnN0b3AoKSBpcyBBTFdBWVMgYXN5bmNocm9ub3VzLCB3aGljaCB3ZSBORUVEIGJlY2F1c2Ugd2Ugd2FudCBhbGwgcG9pbnRlcnVwIGV2ZW50c1xuICAgICAgICAvLyB0aGF0IGNvbWUgZnJvbSB0aGUgZG9jdW1lbnQgdG8gZmlyZSBiZWZvcmVoYW5kLiBtdWNoIG1vcmUgY29udmVuaWVudCB0aGlzIHdheS5cbiAgICAgICAgdGhpcy5taXJyb3Iuc3RvcCh0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0LCB0aGlzLnN0b3BEcmFnLmJpbmQodGhpcywgZXYpKTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICB9O1xuICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldElnbm9yZU1vdmUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICB0aGlzLm1pcnJvci5zZXRJc1Zpc2libGUoYm9vbCk7XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBib29sO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0QXV0b1Njcm9sbEVuYWJsZWQgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xuICAgIH07XG4gICAgcmV0dXJuIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmc7XG59KGNvbW1vbi5FbGVtZW50RHJhZ2dpbmcpKTtcblxuLypcbldoZW4gdGhpcyBjbGFzcyBpcyBpbnN0YW50aWF0ZWQsIGl0IHJlY29yZHMgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IChyZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG9wbGVmdCksXG5hbmQgY29udGludWVzIHRvIG1vbml0b3Igc2Nyb2xsaW5nLCB1cGRhdGluZyB0aGUgY2FjaGVkIGNvb3JkaW5hdGVzIGlmIGl0IG5lZWRzIHRvLlxuRG9lcyBub3QgYWNjZXNzIHRoZSBET00gYWZ0ZXIgaW5zdGFudGlhdGlvbiwgc28gaGlnaGx5IHBlcmZvcm1hbnQuXG5cbkFsc28ga2VlcHMgdHJhY2sgb2YgYWxsIHNjcm9sbGluZy9vdmVyZmxvdzpoaWRkZW4gY29udGFpbmVycyB0aGF0IGFyZSBwYXJlbnRzIG9mIHRoZSBnaXZlbiBlbGVtZW50XG5hbmQgYW4gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBjb21iaW5lZCBjbGlwcGluZyByZWN0YW5nbGUuXG4qL1xudmFyIE9mZnNldFRyYWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2Zmc2V0VHJhY2tlcihlbCkge1xuICAgICAgICB0aGlzLm9yaWdSZWN0ID0gY29tbW9uLmNvbXB1dGVSZWN0KGVsKTtcbiAgICAgICAgLy8gd2lsbCB3b3JrIGZpbmUgZm9yIGRpdnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlblxuICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IGNvbW1vbi5nZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcChmdW5jdGlvbiAoc2Nyb2xsRWwpIHsgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKTsgfSk7XG4gICAgfVxuICAgIE9mZnNldFRyYWNrZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2Zmc2V0VHJhY2tlci5wcm90b3R5cGUuY29tcHV0ZUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxDYWNoZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ2FjaGUgPSBfYVtfaV07XG4gICAgICAgICAgICBsZWZ0ICs9IHNjcm9sbENhY2hlLm9yaWdTY3JvbGxMZWZ0IC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG4gICAgT2Zmc2V0VHJhY2tlci5wcm90b3R5cGUuY29tcHV0ZVRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMub3JpZ1JlY3QudG9wO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxDYWNoZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ2FjaGUgPSBfYVtfaV07XG4gICAgICAgICAgICB0b3AgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbFRvcCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3A7XG4gICAgfTtcbiAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5pc1dpdGhpbkNsaXBwaW5nID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB2YXIgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmICghaXNJZ25vcmVkQ2xpcHBpbmcoc2Nyb2xsQ2FjaGUuZ2V0RXZlbnRUYXJnZXQoKSkgJiZcbiAgICAgICAgICAgICAgICAhY29tbW9uLnBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gT2Zmc2V0VHJhY2tlcjtcbn0oKSk7XG4vLyBjZXJ0YWluIGNsaXBwaW5nIGNvbnRhaW5lcnMgc2hvdWxkIG5ldmVyIGNvbnN0cmFpbiBpbnRlcmFjdGlvbnMsIGxpa2UgPGh0bWw+IGFuZCA8Ym9keT5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mdWxsY2FsZW5kYXIvZnVsbGNhbGVuZGFyL2lzc3Vlcy8zNjE1XG5mdW5jdGlvbiBpc0lnbm9yZWRDbGlwcGluZyhub2RlKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG4gICAgcmV0dXJuIHRhZ05hbWUgPT09ICdIVE1MJyB8fCB0YWdOYW1lID09PSAnQk9EWSc7XG59XG5cbi8qXG5UcmFja3MgbW92ZW1lbnQgb3ZlciBtdWx0aXBsZSBkcm9wcGFibGUgYXJlYXMgKGFrYSBcImhpdHNcIilcbnRoYXQgZXhpc3QgaW4gb25lIG9yIG1vcmUgRGF0ZUNvbXBvbmVudHMuXG5SZWxpZXMgb24gYW4gZXhpc3RpbmcgZHJhZ2dhYmxlLlxuXG5lbWl0czpcbi0gcG9pbnRlcmRvd25cbi0gZHJhZ3N0YXJ0XG4tIGhpdGNoYW5nZSAtIGZpcmVzIGluaXRpYWxseSwgZXZlbiBpZiBub3Qgb3ZlciBhIGhpdFxuLSBwb2ludGVydXBcbi0gKGhpdGNoYW5nZSAtIGFnYWluLCB0byBudWxsLCBpZiBlbmRlZCBvdmVyIGEgaGl0KVxuLSBkcmFnZW5kXG4qL1xudmFyIEhpdERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhpdERyYWdnaW5nKGRyYWdnaW5nLCBkcm9wcGFibGVTdG9yZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBieSBjYWxsZXJcbiAgICAgICAgdGhpcy51c2VTdWJqZWN0Q2VudGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxdWlyZUluaXRpYWwgPSB0cnVlOyAvLyBpZiBkb2Vzbid0IHN0YXJ0IG91dCBvbiBhIGhpdCwgd29uJ3QgZW1pdCBhbnkgZXZlbnRzXG4gICAgICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGw7XG4gICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbEhpdCA9IG51bGw7IC8vIHdvbid0IGV2ZXIgYmUgcG9wdWxhdGVkIGlmIHNob3VsZElnbm9yZU1vdmVcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICBfdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5maW5hbEhpdCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgX3RoaXMucHJvY2Vzc0ZpcnN0Q29vcmQoZXYpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmluaXRpYWxIaXQgfHwgIV90aGlzLnJlcXVpcmVJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZmlyZSB0aGlzIGJlZm9yZSBjb21wdXRpbmcgcHJvY2Vzc0ZpcnN0Q29vcmQsIHNvIGxpc3RlbmVycyBjYW4gY2FuY2VsLiB0aGlzIGdldHMgZmlyZWQgYnkgYWxtb3N0IGV2ZXJ5IGhhbmRsZXIgOihcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW92ZShldiwgdHJ1ZSk7IC8vIGZvcmNlID0gZmlyZSBldmVuIGlmIGluaXRpYWxseSBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ01vdmUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVNb3ZlKGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbGVhc2VIaXRzKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMubW92aW5nSGl0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBudWxsLCB0cnVlLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5maW5hbEhpdCA9IF90aGlzLm1vdmluZ0hpdDtcbiAgICAgICAgICAgIF90aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZHJvcHBhYmxlU3RvcmUgPSBkcm9wcGFibGVTdG9yZTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnbW92ZScsIHRoaXMuaGFuZGxlRHJhZ01vdmUpO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmc7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBjb21tb24uRW1pdHRlcigpO1xuICAgIH1cbiAgICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnByb2Nlc3NGaXJzdENvb3JkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIHZhciBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICB2YXIgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICB2YXIgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tbW9uLmNvbXB1dGVSZWN0KHN1YmplY3RFbCk7XG4gICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gY29tbW9uLmNvbnN0cmFpblBvaW50KGFkanVzdGVkUG9pbnQsIHN1YmplY3RSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdGlhbEhpdCA9IHRoaXMuaW5pdGlhbEhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoYWRqdXN0ZWRQb2ludC5sZWZ0LCBhZGp1c3RlZFBvaW50LnRvcCk7XG4gICAgICAgIGlmIChpbml0aWFsSGl0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdWJqZWN0Q2VudGVyICYmIHN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWNlZFN1YmplY3RSZWN0ID0gY29tbW9uLmludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gY29tbW9uLmdldFJlY3RDZW50ZXIoc2xpY2VkU3ViamVjdFJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSBjb21tb24uZGlmZlBvaW50cyhhZGp1c3RlZFBvaW50LCBvcmlnUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhpdERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGV2LCBmb3JjZUhhbmRsZSkge1xuICAgICAgICB2YXIgaGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChldi5wYWdlWCArIHRoaXMuY29vcmRBZGp1c3QubGVmdCwgZXYucGFnZVkgKyB0aGlzLmNvb3JkQWRqdXN0LnRvcCk7XG4gICAgICAgIGlmIChmb3JjZUhhbmRsZSB8fCAhaXNIaXRzRXF1YWwodGhpcy5tb3ZpbmdIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gaGl0O1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIGhpdCwgZmFsc2UsIGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0gY29tbW9uLm1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgZnVuY3Rpb24gKGludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0VHJhY2tlcnMgPSB0aGlzLm9mZnNldFRyYWNrZXJzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0ge307XG4gICAgfTtcbiAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucXVlcnlIaXRGb3JPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRyb3BwYWJsZVN0b3JlID0gX2EuZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzID0gX2Eub2Zmc2V0VHJhY2tlcnM7XG4gICAgICAgIHZhciBiZXN0SGl0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9mZnNldFRyYWNrZXIgPSBvZmZzZXRUcmFja2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAob2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5pc1dpdGhpbkNsaXBwaW5nKG9mZnNldExlZnQsIG9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luTGVmdCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZUxlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luVG9wID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlVG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uTGVmdCA9IG9mZnNldExlZnQgLSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblRvcCA9IG9mZnNldFRvcCAtIG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ1JlY3QgPSBvZmZzZXRUcmFja2VyLm9yaWdSZWN0O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHdpdGhpbiB0aGUgZWxlbWVudCdzIGJvdW5kc1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxuICAgICAgICAgICAgICAgICAgICBjb21tb24ucmFuZ2VDb250YWluc1JhbmdlKGhpdC5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgaGl0LmRhdGVTcGFuLnJhbmdlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghYmVzdEhpdCB8fCBoaXQubGF5ZXIgPiBiZXN0SGl0LmxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LmNvbXBvbmVudElkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYmV0dGVyIHdheSB0byByZS1vcmllbnQgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5sZWZ0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5yaWdodCArPSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QudG9wICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmJvdHRvbSArPSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0SGl0ID0gaGl0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0SGl0O1xuICAgIH07XG4gICAgcmV0dXJuIEhpdERyYWdnaW5nO1xufSgpKTtcbmZ1bmN0aW9uIGlzSGl0c0VxdWFsKGhpdDAsIGhpdDEpIHtcbiAgICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChCb29sZWFuKGhpdDApICE9PSBCb29sZWFuKGhpdDEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vbi5pc0RhdGVTcGFuc0VxdWFsKGhpdDAuZGF0ZVNwYW4sIGhpdDEuZGF0ZVNwYW4pO1xufVxuXG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVBvaW50VHJhbnNmb3JtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hW19pXTtcbiAgICAgICAgdHNsaWIuX19hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICB0c2xpYi5fX2Fzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXksXG4gICAgfTtcbn1cblxuLypcbk1vbml0b3JzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgc3BlY2lmaWMgZGF0ZS90aW1lIG9mIGEgY29tcG9uZW50LlxuQSBwb2ludGVyZG93bitwb2ludGVydXAgb24gdGhlIHNhbWUgXCJoaXRcIiBjb25zdGl0dXRlcyBhIGNsaWNrLlxuKi9cbnZhciBEYXRlQ2xpY2tpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERhdGVDbGlja2luZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlQ2xpY2tpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgZG93bkVsID0gcGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluIHBvaW50ZXJkb3duIChub3QgZHJhZ2VuZCkgYmVjYXVzZSBET00gbWlnaHQgYmUgbXV0YXRlZCBieSB0aGUgdGltZSBkcmFnZW5kIGlzIGZpcmVkXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFfdGhpcy5jb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZG93bkVsKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdvbid0IGV2ZW4gZmlyZSBpZiBtb3Zpbmcgd2FzIGlnbm9yZWRcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMuZHJhZ2dpbmcucG9pbnRlcjtcbiAgICAgICAgICAgIGlmICghcG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhpdERyYWdnaW5nLCBpbml0aWFsSGl0ID0gX2EuaW5pdGlhbEhpdCwgZmluYWxIaXQgPSBfYS5maW5hbEhpdDtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGluaXRpYWxIaXQuZGF0ZVNwYW4sIGNvbnRleHQpKSwgeyBkYXlFbDogaW5pdGlhbEhpdC5kYXlFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZUNsaWNrJywgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIERPIHdhbnQgdG8gd2F0Y2ggcG9pbnRlciBtb3ZlcyBiZWNhdXNlIG90aGVyd2lzZSBmaW5hbEhpdCB3b24ndCBnZXQgcG9wdWxhdGVkXG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBfdGhpcy5kcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBoaXREcmFnZ2luZyA9IF90aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKF90aGlzLmRyYWdnaW5nLCBjb21tb24uaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcbn0oY29tbW9uLkludGVyYWN0aW9uKSk7XG5cbi8qXG5UcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxuY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4qL1xudmFyIERhdGVTZWxlY3RpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERhdGVTZWxlY3RpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZVNlbGVjdGluZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBkcmFnZ2luZyA9IF9hLmRyYWdnaW5nO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGNhblNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciB0byB3YXRjaCBleHBlbnNpdmUgbW92ZXMgaWYgY29tcG9uZW50IHdvbid0IGRvIHNlbGVjdGlvblxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghY2FuU2VsZWN0KTtcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoLCByZXF1aXJlIHVzZXIgdG8gaG9sZCBkb3duXG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9IGV2LmlzVG91Y2ggPyBnZXRDb21wb25lbnRUb3VjaERlbGF5JDEoY29tcG9uZW50KSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCBwcmV2aW91cyBzZWxlY3Rpb25zXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IGZ1bmN0aW9uIChoaXQsIGlzRmluYWwpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxIaXQgPSBfdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgICAgIHZhciBkaXNhbGxvd2VkID0gaGl0LmNvbXBvbmVudElkID09PSBpbml0aWFsSGl0LmNvbXBvbmVudElkXG4gICAgICAgICAgICAgICAgICAgICYmIF90aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICFfdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnU2VsZWN0aW9uID0gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGluaXRpYWxIaXQsIGhpdCwgY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkcmFnU2VsZWN0aW9uIHx8ICFjb21tb24uaXNEYXRlU2VsZWN0aW9uVmFsaWQoZHJhZ1NlbGVjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRmluYWwpIHsgLy8gb25seSB1bnNlbGVjdCBpZiBtb3ZlZCBhd2F5IHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbW1vbi5lbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1vbi5kaXNhYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnU2VsZWN0aW9uID0gZHJhZ1NlbGVjdGlvbjsgLy8gb25seSBjbGVhciBpZiBtb3ZlZCBhd2F5IGZyb20gYWxsIGhpdHMgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gaXMgYWxyZWFkeSByZW5kZXJlZCwgc28ganVzdCBuZWVkIHRvIHJlcG9ydCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICBjb21tb24udHJpZ2dlckRhdGVTZWxlY3QoX3RoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCBfdGhpcy5jb21wb25lbnQuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IG9wdGlvbnMuc2VsZWN0TWluRGlzdGFuY2UgfHwgMDtcbiAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IG9wdGlvbnMuZHJhZ1Njcm9sbDtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGNvbW1vbi5pbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgX3RoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlU2VsZWN0aW5nO1xufShjb21tb24uSW50ZXJhY3Rpb24pKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5zZWxlY3RMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cbmZ1bmN0aW9uIGpvaW5IaXRzSW50b1NlbGVjdGlvbihoaXQwLCBoaXQxLCBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSB7XG4gICAgdmFyIGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW47XG4gICAgdmFyIGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW47XG4gICAgdmFyIG1zID0gW1xuICAgICAgICBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQsXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5lbmQsXG4gICAgICAgIGRhdGVTcGFuMS5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLmVuZCxcbiAgICBdO1xuICAgIG1zLnNvcnQoY29tbW9uLmNvbXBhcmVOdW1iZXJzKTtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnNfMSA9IGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM7IF9pIDwgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzXzFbX2ldO1xuICAgICAgICB2YXIgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbihwcm9wcywgcmVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5yYW5nZSA9IHsgc3RhcnQ6IG1zWzBdLCBlbmQ6IG1zWzNdIH07XG4gICAgcHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4wLmFsbERheTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbnZhciBFdmVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudERyYWdnaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50RHJhZ2dpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIF90aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgX3RoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIF90aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICBfdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIG9yaWdUYXJnZXQgPSBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIGNvbXBvbmVudCA9IF9hLmNvbXBvbmVudCwgZHJhZ2dpbmcgPSBfYS5kcmFnZ2luZztcbiAgICAgICAgICAgIHZhciBtaXJyb3IgPSBkcmFnZ2luZy5taXJyb3I7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbENvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIF90aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcbiAgICAgICAgICAgIHZhciBzdWJqZWN0U2VnID0gX3RoaXMuc3ViamVjdFNlZyA9IGNvbW1vbi5nZXRFbFNlZyhldi5zdWJqZWN0RWwpO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gY29tbW9uLmdldFJlbGV2YW50RXZlbnRzKGluaXRpYWxDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSwgZXZlbnRJbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gZXYuaXNUb3VjaCA/IDAgOiBvcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZG8gYSB0b3VjaCBkZWxheSBpZiB0b3VjaCBhbmQgdGhpcyBldmVudCBoYXNuJ3QgYmVlbiBzZWxlY3RlZCB5ZXRcbiAgICAgICAgICAgICAgICAoZXYuaXNUb3VjaCAmJiBldmVudEluc3RhbmNlSWQgIT09IGNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbikgP1xuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkgOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZml4ZWRNaXJyb3JQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaXJyb3IucGFyZW50Tm9kZSA9IG9wdGlvbnMuZml4ZWRNaXJyb3JQYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaXJyb3IucGFyZW50Tm9kZSA9IGNvbW1vbi5lbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBvcHRpb25zLmRyYWdSZXZlcnREdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhY29tbW9uLmVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBpc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNlbGVjdCBhIGRpZmZlcmVudCBldmVudD9cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUlkICE9PSBfdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkOiBldmVudEluc3RhbmNlSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm93IHVzaW5nIG1vdXNlLCBidXQgd2FzIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uLCBjbGVhciBzZWxlY3RlZCBldmVudFxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IF90aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBjb21tb24uRXZlbnRBcGkoaW5pdGlhbENvbnRleHQsIGV2ZW50UmFuZ2UuZGVmLCBldmVudFJhbmdlLmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsQ29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgIHZhciBpbml0aWFsQ29udGV4dCA9IF90aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgLy8gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgIHZhciByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY29tbW9uLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICB2YXIgcmVjZWl2aW5nT3B0aW9ucyA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlY2VpdmluZ09wdGlvbnMuZWRpdGFibGUgJiYgcmVjZWl2aW5nT3B0aW9ucy5kcm9wcGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZUV2ZW50TXV0YXRpb24oaW5pdGlhbEhpdCwgaGl0LCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkucGx1Z2luSG9va3MuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IGNvbW1vbi5hcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tb24uaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY29tbW9uLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbW1vbi5lbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1vbi5kaXNhYmxlQ3Vyc29yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT09IHJlY2VpdmluZ0NvbnRleHQgJiYgLy8gVE9ETzogd3JpdGUgdGVzdCBmb3IgdGhpc1xuICAgICAgICAgICAgICAgICAgICBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIW11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIWNvbW1vbi5nZXRFbFJvb3QoX3RoaXMuc3ViamVjdEVsKS5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJykpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgICAgICAgICAgICAgIF90aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvbjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTsgLy8gYmVjYXVzZSBoYW5kbGVEcmFnRW5kIHdvbid0IGZpcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbENvbnRleHRfMSA9IF90aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsVmlldyA9IGluaXRpYWxDb250ZXh0XzEudmlld0FwaTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgcmVjZWl2aW5nQ29udGV4dF8xID0gX2EucmVjZWl2aW5nQ29udGV4dCwgdmFsaWRNdXRhdGlvbiA9IF9hLnZhbGlkTXV0YXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gX3RoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBfdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEFwaSA9IG5ldyBjb21tb24uRXZlbnRBcGkoaW5pdGlhbENvbnRleHRfMSwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50c18xID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRSZWxldmFudEV2ZW50c18xID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIHZhciBmaW5hbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyRHJhZygpOyAvLyBtdXN0IGhhcHBlbiBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIHdpdGhpbiBzYW1lIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0XzEgPT09IGluaXRpYWxDb250ZXh0XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgY29tbW9uLkV2ZW50QXBpKGluaXRpYWxDb250ZXh0XzEsIG11dGF0ZWRSZWxldmFudEV2ZW50c18xLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50c18xLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogY29tbW9uLmJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50c18xLCBpbml0aWFsQ29udGV4dF8xLCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzXzEsIC8vIHRoZSBwcmUtY2hhbmdlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBpbml0aWFsQ29udGV4dF8xLmdldEN1cnJlbnREYXRhKCkucGx1Z2luSG9va3MuZXZlbnREcm9wVHJhbnNmb3JtZXJzOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IF9iW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbih0cmFuc2Zvcm1lZCwgdHJhbnNmb3JtZXIodmFsaWRNdXRhdGlvbiwgaW5pdGlhbENvbnRleHRfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgaW4gZGlmZmVyZW50IGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWl2aW5nQ29udGV4dF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRSZW1vdmVBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGNvbW1vbi5idWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50c18xLCBpbml0aWFsQ29udGV4dF8xLCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRSZW1vdmVBcmcpLCB7IGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLCB2aWV3OiBpbml0aWFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dF8xLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHNfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywgZXZlbnRSZW1vdmVBcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGVkRXZlbnREZWYgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50QXBpID0gbmV3IGNvbW1vbi5FdmVudEFwaShyZWNlaXZpbmdDb250ZXh0XzEsIGFkZGVkRXZlbnREZWYsIGFkZGVkRXZlbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50c18xLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRBZGRBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGFkZGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogY29tbW9uLmJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50c18xLCByZWNlaXZpbmdDb250ZXh0XzEsIGFkZGVkRXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dF8xLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZHJvcCcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0XzEpKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50RHJvcCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgY29tbW9uLmludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIF90aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kaXNwbGF5RHJhZyA9IGZ1bmN0aW9uIChuZXh0Q29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHN0YXRlLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY29tbW9uLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGU6IHN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhckRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbml0aWFsQ2FsZW5kYXIgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICB2YXIgcmVjZWl2aW5nQ29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcbiAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICB9O1xuICAgIC8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXG4gICAgLy8gUVVFU1RJT046IHdoeSBkbyB3ZSBuZWVkIGl0IG9uIHRoZSByZXNpemFibGU/Pz9cbiAgICBFdmVudERyYWdnaW5nLlNFTEVDVE9SID0gJy5mYy1ldmVudC1kcmFnZ2FibGUsIC5mYy1ldmVudC1yZXNpemFibGUnO1xuICAgIHJldHVybiBFdmVudERyYWdnaW5nO1xufShjb21tb24uSW50ZXJhY3Rpb24pKTtcbmZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIG1hc3NhZ2Vycykge1xuICAgIHZhciBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuO1xuICAgIHZhciBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuO1xuICAgIHZhciBkYXRlMCA9IGRhdGVTcGFuMC5yYW5nZS5zdGFydDtcbiAgICB2YXIgZGF0ZTEgPSBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHN0YW5kYXJkUHJvcHMgPSB7fTtcbiAgICBpZiAoZGF0ZVNwYW4wLmFsbERheSAhPT0gZGF0ZVNwYW4xLmFsbERheSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGRhdGVTcGFuMS5hbGxEYXk7XG4gICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gaGl0MS5jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgaWYgKGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICAgICAgICAgIC8vIG1lYW5zIGRhdGUxIGlzIGFscmVhZHkgc3RhcnQtb2YtZGF5LFxuICAgICAgICAgICAgLy8gYnV0IGRhdGUwIG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuICAgICAgICAgICAgZGF0ZTAgPSBjb21tb24uc3RhcnRPZkRheShkYXRlMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRlbHRhID0gY29tbW9uLmRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGhpdDAuY29udGV4dC5kYXRlRW52LCBoaXQwLmNvbXBvbmVudElkID09PSBoaXQxLmNvbXBvbmVudElkID9cbiAgICAgICAgaGl0MC5sYXJnZVVuaXQgOlxuICAgICAgICBudWxsKTtcbiAgICBpZiAoZGVsdGEubWlsbGlzZWNvbmRzKSB7IC8vIGhhcyBob3Vycy9taW51dGVzL3NlY29uZHNcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG11dGF0aW9uID0ge1xuICAgICAgICBkYXRlc0RlbHRhOiBkZWx0YSxcbiAgICAgICAgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgbWFzc2FnZXJzXzEgPSBtYXNzYWdlcnM7IF9pIDwgbWFzc2FnZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtYXNzYWdlciA9IG1hc3NhZ2Vyc18xW19pXTtcbiAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xuICAgIH1cbiAgICByZXR1cm4gbXV0YXRpb247XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xuICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmV2ZW50TG9uZ1ByZXNzRGVsYXk7XG4gICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgZGVsYXkgPSBvcHRpb25zLmxvbmdQcmVzc0RlbGF5O1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG59XG5cbnZhciBFdmVudFJlc2l6aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudFJlc2l6aW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50UmVzaXppbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgIF90aGlzLmRyYWdnaW5nU2VnRWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7IC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cbiAgICAgICAgX3RoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIF90aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIHNlZ0VsID0gX3RoaXMucXVlcnlTZWdFbChldik7XG4gICAgICAgICAgICB2YXIgc2VnID0gY29tbW9uLmdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gX3RoaXMuZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIG5lZWQgdG8gYmUgd29ya2luZyB3aXRoIGEgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLnNldElnbm9yZU1vdmUoIV90aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgX3RoaXMuY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uICE9PSBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IF90aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBjb21tb24uZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBfdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnID0gY29tbW9uLmdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IGNvbW1vbi5FdmVudEFwaShjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsLCBldikge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50cyA9IF90aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxIaXQgPSBfdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBfdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjb21tb24uY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgX3RoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIV90aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBjb21tb24uYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tb24uaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11dGF0ZWRSZWxldmFudEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX1JFU0laRScsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBpbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfUkVTSVpFJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uLmVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbW9uLmRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgICAgICAgICAgICAgIF90aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBldmVudERlZiA9IF90aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBfdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGV2ZW50QXBpID0gbmV3IGNvbW1vbi5FdmVudEFwaShjb250ZXh0LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIHZhciBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBfdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xuICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5kcmFnZ2luZ1NlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgY29tbW9uLkV2ZW50QXBpKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBjb21tb24uYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBjb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHsgZWw6IF90aGlzLmRyYWdnaW5nU2VnRWwsIHN0YXJ0RGVsdGE6IF90aGlzLnZhbGlkTXV0YXRpb24uc3RhcnREZWx0YSB8fCBjb21tb24uY3JlYXRlRHVyYXRpb24oMCksIGVuZERlbHRhOiBfdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNvbW1vbi5jcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICcuZmMtZXZlbnQtcmVzaXplcic7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgY29tbW9uLmludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCBfdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCBfdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgX3RoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5xdWVyeVNlZ0VsID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHJldHVybiBjb21tb24uZWxlbWVudENsb3Nlc3QoZXYuc3ViamVjdEVsLCAnLmZjLWV2ZW50Jyk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRSZXNpemluZztcbn0oY29tbW9uLkludGVyYWN0aW9uKSk7XG5mdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xuICAgIHZhciBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcbiAgICB2YXIgZGVsdGEgPSBjb21tb24uZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgZGF0ZUVudiwgaGl0MC5sYXJnZVVuaXQpO1xuICAgIGlmIChpc0Zyb21TdGFydCkge1xuICAgICAgICBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5zdGFydCwgZGVsdGEpIDwgaW5zdGFuY2VSYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0RGVsdGE6IGRlbHRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0ZUVudi5hZGQoaW5zdGFuY2VSYW5nZS5lbmQsIGRlbHRhKSA+IGluc3RhbmNlUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kRGVsdGE6IGRlbHRhIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgVW5zZWxlY3RBdXRvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuc2VsZWN0QXV0byhjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlOyAvLyB3aXNoIHdlIGNvdWxkIHVzZSBhIHNlbGVjdG9yIHRvIGRldGVjdCBkYXRlIHNlbGVjdGlvbiwgYnV0IHVzZXMgaGl0IHN5c3RlbVxuICAgICAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RJbmZvKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0SW5mby5qc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICAgICAgdmFyIHVuc2VsZWN0Q2FuY2VsID0gX3RoaXMuY29udGV4dC5vcHRpb25zLnVuc2VsZWN0Q2FuY2VsO1xuICAgICAgICAgICAgdmFyIGRvd25FbCA9IGNvbW1vbi5nZXRFdmVudFRhcmdldFZpYVJvb3QocGV2Lm9yaWdFdmVudCk7XG4gICAgICAgICAgICBfdGhpcy5tYXRjaGVzQ2FuY2VsID0gISFjb21tb24uZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICBfdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWNvbW1vbi5lbGVtZW50Q2xvc2VzdChkb3duRWwsIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IpOyAvLyBpbnRlcmFjdGlvbiBzdGFydGVkIG9uIGFuIGV2ZW50P1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXAgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IF90aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRQb2ludGVyID0gX3RoaXMuZG9jdW1lbnRQb2ludGVyO1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyB0b3VjaC1zY3JvbGxpbmcgc2hvdWxkIG5ldmVyIHVuZm9jdXMgYW55IHR5cGUgb2Ygc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50UG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZGF0ZSBzZWxlY3Rpb24/XG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0IC8vIGEgbmV3IHBvaW50ZXItaW5pdGlhdGVkIGRhdGUgc2VsZWN0aW9uIHNpbmNlIGxhc3Qgb25Eb2N1bWVudFBvaW50ZXJVcD9cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuc2VsZWN0QXV0byA9IGNvbnRleHQub3B0aW9ucy51bnNlbGVjdEF1dG87XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIV90aGlzLm1hdGNoZXNDYW5jZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KHBldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZXZlbnRTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZXZlbnQgc2VsZWN0ZWQ/XG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5tYXRjaGVzRXZlbnQgLy8gaW50ZXJhY3Rpb24gRElETidUIHN0YXJ0IG9uIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRvY3VtZW50UG9pbnRlciA9IHRoaXMuZG9jdW1lbnRQb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhkb2N1bWVudCk7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZFdhdGNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duKTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IGJldHRlciB3YXkgdG8ga25vdyBhYm91dCB3aGV0aGVyIHRoZXJlIHdhcyBhIHNlbGVjdGlvbiB3aXRoIHRoZSBwb2ludGVyXG4gICAgICAgICovXG4gICAgICAgIGNvbnRleHQuZW1pdHRlci5vbignc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XG4gICAgfVxuICAgIFVuc2VsZWN0QXV0by5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIub2ZmKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXIuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuc2VsZWN0QXV0bztcbn0oKSk7XG5cbnZhciBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgZml4ZWRNaXJyb3JQYXJlbnQ6IGNvbW1vbi5pZGVudGl0eSxcbn07XG52YXIgTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gICAgZGF0ZUNsaWNrOiBjb21tb24uaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RhcnQ6IGNvbW1vbi5pZGVudGl0eSxcbiAgICBldmVudERyYWdTdG9wOiBjb21tb24uaWRlbnRpdHksXG4gICAgZXZlbnREcm9wOiBjb21tb24uaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemVTdGFydDogY29tbW9uLmlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplU3RvcDogY29tbW9uLmlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplOiBjb21tb24uaWRlbnRpdHksXG4gICAgZHJvcDogY29tbW9uLmlkZW50aXR5LFxuICAgIGV2ZW50UmVjZWl2ZTogY29tbW9uLmlkZW50aXR5LFxuICAgIGV2ZW50TGVhdmU6IGNvbW1vbi5pZGVudGl0eSxcbn07XG5cbi8qXG5HaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcbkludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXG5vZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cbiovXG52YXIgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHN1cHBsaWVkRHJhZ01ldGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5kcmFnTWV0YSA9IF90aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsLCBldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjb21tb24uY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY29tbW9uLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IF90aGlzLmRyYWdNZXRhLmNyZWF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jYW5Ecm9wRWxPbkNhbGVuZGFyKGV2LnN1YmplY3RFbCwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihoaXQuZGF0ZVNwYW4sIF90aGlzLmRyYWdNZXRhLCByZWNlaXZpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNvbW1vbi5ldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFjb21tb24uaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY29tbW9uLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgLy8gc2hvdyBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3IgZWxlbWVudCBPUiBpZiB3ZSBhcmUgc2h1dHRpbmcgZG93biB0aGUgbWlycm9yICg/KVxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShpc0ZpbmFsIHx8ICFkcm9wcGFibGVFdmVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uLmVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbW9uLmRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJvcHBhYmxlRXZlbnQgPSBkcm9wcGFibGVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHJlY2VpdmluZ0NvbnRleHQgPSBfYS5yZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudCA9IF9hLmRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJEcmFnKCk7XG4gICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCAmJiBkcm9wcGFibGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBmaW5hbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xuICAgICAgICAgICAgICAgIHZhciBmaW5hbFZpZXcgPSBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGk7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdNZXRhID0gX3RoaXMuZHJhZ01ldGE7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dCkpLCB7IGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCwganNFdmVudDogcGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxWaWV3IH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ01ldGEuY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpbmdFdmVudHNfMSA9IGNvbW1vbi5ldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHNfMSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBkcm9wcGFibGVFdmVudC5pbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IGNvbW1vbi5FdmVudEFwaShyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgY29tbW9uLmludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnJlcXVpcmVJbml0aWFsID0gZmFsc2U7IC8vIHdpbGwgc3RhcnQgb3V0c2lkZSBvZiBhIGNvbXBvbmVudFxuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IHN1cHBsaWVkRHJhZ01ldGE7XG4gICAgfVxuICAgIEV4dGVybmFsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5idWlsZERyYWdNZXRhID0gZnVuY3Rpb24gKHN1YmplY3RFbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb24ucGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLnBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKHN1YmplY3RFbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXREcmFnTWV0YUZyb21FbChzdWJqZWN0RWwpO1xuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRpc3BsYXlEcmFnID0gZnVuY3Rpb24gKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4dGVybmFsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhckRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmNhbkRyb3BFbE9uQ2FsZW5kYXIgPSBmdW5jdGlvbiAoZWwsIHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnMuZHJvcEFjY2VwdDtcbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdC5jYWxsKHJlY2VpdmluZ0NvbnRleHQuY2FsZW5kYXJBcGksIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGNvbW1vbi5lbGVtZW50TWF0Y2hlcyhlbCwgZHJvcEFjY2VwdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEV4dGVybmFsRWxlbWVudERyYWdnaW5nO1xufSgpKTtcbi8vIFV0aWxzIGZvciBjb21wdXRpbmcgZXZlbnQgc3RvcmUgZnJvbSB0aGUgRHJhZ01ldGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGRhdGVTcGFuLCBkcmFnTWV0YSwgY29udGV4dCkge1xuICAgIHZhciBkZWZQcm9wcyA9IHRzbGliLl9fYXNzaWduKHt9LCBkcmFnTWV0YS5sZWZ0b3ZlclByb3BzKTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGV4dC5wbHVnaW5Ib29rcy5leHRlcm5hbERlZlRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIHRzbGliLl9fYXNzaWduKGRlZlByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGRyYWdNZXRhKSk7XG4gICAgfVxuICAgIHZhciBfYiA9IGNvbW1vbi5yZWZpbmVFdmVudERlZihkZWZQcm9wcywgY29udGV4dCksIHJlZmluZWQgPSBfYi5yZWZpbmVkLCBleHRyYSA9IF9iLmV4dHJhO1xuICAgIHZhciBkZWYgPSBjb21tb24ucGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZHJhZ01ldGEuc291cmNlSWQsIGRhdGVTcGFuLmFsbERheSwgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgdmFyIHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxuICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgdmFyIGVuZCA9IGRyYWdNZXRhLmR1cmF0aW9uID9cbiAgICAgICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICAgICAgY29tbW9uLmdldERlZmF1bHRFdmVudEVuZChkYXRlU3Bhbi5hbGxEYXksIHN0YXJ0LCBjb250ZXh0KTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjb21tb24uY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICByZXR1cm4geyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH07XG59XG4vLyBVdGlscyBmb3IgZXh0cmFjdGluZyBkYXRhIGZyb20gZWxlbWVudFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0RHJhZ01ldGFGcm9tRWwoZWwpIHtcbiAgICB2YXIgc3RyID0gZ2V0RW1iZWRkZWRFbERhdGEoZWwsICdldmVudCcpO1xuICAgIHZhciBvYmogPSBzdHIgP1xuICAgICAgICBKU09OLnBhcnNlKHN0cikgOlxuICAgICAgICB7IGNyZWF0ZTogZmFsc2UgfTsgLy8gaWYgbm8gZW1iZWRkZWQgZGF0YSwgYXNzdW1lIG5vIGV2ZW50IGNyZWF0aW9uXG4gICAgcmV0dXJuIGNvbW1vbi5wYXJzZURyYWdNZXRhKG9iaik7XG59XG5jb21tb24uY29uZmlnLmRhdGFBdHRyUHJlZml4ID0gJyc7XG5mdW5jdGlvbiBnZXRFbWJlZGRlZEVsRGF0YShlbCwgbmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBjb21tb24uY29uZmlnLmRhdGFBdHRyUHJlZml4O1xuICAgIHZhciBwcmVmaXhlZE5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgbmFtZTtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBwcmVmaXhlZE5hbWUpIHx8ICcnO1xufVxuXG4vKlxuTWFrZXMgYW4gZWxlbWVudCAodGhhdCBpcyAqZXh0ZXJuYWwqIHRvIGFueSBjYWxlbmRhcikgZHJhZ2dhYmxlLlxuQ2FuIHBhc3MgaW4gZGF0YSB0aGF0IGRldGVybWluZXMgaG93IGFuIGV2ZW50IHdpbGwgYmUgY3JlYXRlZCB3aGVuIGRyb3BwZWQgb250byBhIGNhbGVuZGFyLlxuTGV2ZXJhZ2VzIEZ1bGxDYWxlbmRhcidzIGludGVybmFsIGRyYWctbi1kcm9wIGZ1bmN0aW9uYWxpdHkgV0lUSE9VVCBhIHRoaXJkLXBhcnR5IGRyYWcgc3lzdGVtLlxuKi9cbnZhciBFeHRlcm5hbERyYWdnYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHRlcm5hbERyYWdnYWJsZShlbCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSB7fTsgfVxuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZztcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnNldHRpbmdzLCBtaW5EaXN0YW5jZSA9IF9hLm1pbkRpc3RhbmNlLCBsb25nUHJlc3NEZWxheSA9IF9hLmxvbmdQcmVzc0RlbGF5O1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxuICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XG4gICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IGNvbW1vbi5CQVNFX09QVElPTl9ERUZBVUxUUy5ldmVudERyYWdNaW5EaXN0YW5jZSk7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgZXYuaXNUb3VjaCA/IC8vIFRPRE86IGV2ZW50dWFsbHkgcmVhZCBldmVudExvbmdQcmVzc0RlbGF5IGluc3RlYWQgdnZ2XG4gICAgICAgICAgICAgICAgICAgIChsb25nUHJlc3NEZWxheSAhPSBudWxsID8gbG9uZ1ByZXNzRGVsYXkgOiBjb21tb24uQkFTRV9PUFRJT05fREVGQVVMVFMubG9uZ1ByZXNzRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5pc1RvdWNoICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcbiAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ2dpbmcubWlycm9yLmdldE1pcnJvckVsKCkuY2xhc3NMaXN0LmFkZCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoZWwpO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNldHRpbmdzLml0ZW1TZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gc2V0dGluZ3MuaXRlbVNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hcHBlbmRUbyAhPSBudWxsKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5taXJyb3IucGFyZW50Tm9kZSA9IHNldHRpbmdzLmFwcGVuZFRvOyAvLyBUT0RPOiB3cml0ZSB0ZXN0c1xuICAgICAgICB9XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cbiAgICBFeHRlcm5hbERyYWdnYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZXJuYWxEcmFnZ2FibGU7XG59KCkpO1xuXG4vKlxuRGV0ZWN0cyB3aGVuIGEgKlRISVJELVBBUlRZKiBkcmFnLW4tZHJvcCBzeXN0ZW0gaW50ZXJhY3RzIHdpdGggZWxlbWVudHMuXG5UaGUgdGhpcmQtcGFydHkgc3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIHRoZSB2aXN1YWxzIGVmZmVjdHMgb2YgdGhlIGRyYWcuXG5UaGlzIGNsYXNzIHNpbXBseSBtb25pdG9ycyBmb3IgcG9pbnRlciBtb3ZlbWVudHMgYW5kIGZpcmVzIGV2ZW50cy5cbkl0IGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIGhpZGUgdGhlIG1vdmluZyBlbGVtZW50ICh0aGUgXCJtaXJyb3JcIikgZHVyaW5nIHRoZSBkcmFnLlxuKi9cbnZhciBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGFpbmVyRWwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubWlycm9yU2VsZWN0b3IgPSAnJztcbiAgICAgICAgX3RoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldik7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ2VuZCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGEgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSBfdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCBfdGhpcy5oYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIEluZmVycmVkRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRJZ25vcmVNb3ZlID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgdGhpcy5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbDtcbiAgICB9O1xuICAgIEluZmVycmVkRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgLy8gcmVzdG9yZSBhIHByZXZpb3VzbHkgaGlkZGVuIGVsZW1lbnQuXG4gICAgICAgICAgICAvLyB1c2UgdGhlIHJlZmVyZW5jZSBpbiBjYXNlIHRoZSBzZWxlY3RvciBjbGFzcyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1pcnJvckVsID0gdGhpcy5taXJyb3JTZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMubWlycm9yU2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1pcnJvckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwgPSBtaXJyb3JFbDtcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZztcbn0oY29tbW9uLkVsZW1lbnREcmFnZ2luZykpO1xuXG4vKlxuQnJpZGdlcyB0aGlyZC1wYXJ0eSBkcmFnLW4tZHJvcCBzeXN0ZW1zIHdpdGggRnVsbENhbGVuZGFyLlxuTXVzdCBiZSBpbnN0YW50aWF0ZWQgYW5kIGRlc3Ryb3llZCBieSBjYWxsZXIuXG4qL1xudmFyIFRoaXJkUGFydHlEcmFnZ2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhpcmRQYXJ0eURyYWdnYWJsZShjb250YWluZXJPclNldHRpbmdzLCBzZXR0aW5ncykge1xuICAgICAgICB2YXIgY29udGFpbmVyRWwgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyB3aXNoIHdlIGNvdWxkIGp1c3QgdGVzdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0LCBidXQgZG9lc24ndCB3b3JrIGluIElFMTFcbiAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXJFbCA9IGNvbnRhaW5lck9yU2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSAoY29udGFpbmVyT3JTZXR0aW5ncyB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaXRlbVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm1pcnJvclNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yU2VsZWN0b3IgPSBzZXR0aW5ncy5taXJyb3JTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIFRoaXJkUGFydHlEcmFnZ2FibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRoaXJkUGFydHlEcmFnZ2FibGU7XG59KCkpO1xuXG52YXIgbWFpbiA9IGNvbW1vbi5jcmVhdGVQbHVnaW4oe1xuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnRzLkRyYWdnYWJsZSA9IEV4dGVybmFsRHJhZ2dhYmxlO1xuZXhwb3J0cy5GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nID0gRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZztcbmV4cG9ydHMuUG9pbnRlckRyYWdnaW5nID0gUG9pbnRlckRyYWdnaW5nO1xuZXhwb3J0cy5UaGlyZFBhcnR5RHJhZ2dhYmxlID0gVGhpcmRQYXJ0eURyYWdnYWJsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1haW47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb21tb24iLCJyZXF1aXJlIiwidHNsaWIiLCJjb25maWciLCJ0b3VjaE1vdXNlSWdub3JlV2FpdCIsImlnbm9yZU1vdXNlRGVwdGgiLCJsaXN0ZW5lckNudCIsImlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkIiwiUG9pbnRlckRyYWdnaW5nIiwiY29udGFpbmVyRWwiLCJfdGhpcyIsInN1YmplY3RFbCIsInNlbGVjdG9yIiwiaGFuZGxlU2VsZWN0b3IiLCJzaG91bGRJZ25vcmVNb3ZlIiwic2hvdWxkV2F0Y2hTY3JvbGwiLCJpc0RyYWdnaW5nIiwiaXNUb3VjaERyYWdnaW5nIiwid2FzVG91Y2hTY3JvbGwiLCJoYW5kbGVNb3VzZURvd24iLCJldiIsInNob3VsZElnbm9yZU1vdXNlIiwiaXNQcmltYXJ5TW91c2VCdXR0b24iLCJ0cnlTdGFydCIsInBldiIsImNyZWF0ZUV2ZW50RnJvbU1vdXNlIiwiZW1pdHRlciIsInRyaWdnZXIiLCJpbml0U2Nyb2xsV2F0Y2giLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVNb3VzZU1vdmUiLCJoYW5kbGVNb3VzZVVwIiwicmVjb3JkQ29vcmRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFudXAiLCJoYW5kbGVUb3VjaFN0YXJ0IiwiY3JlYXRlRXZlbnRGcm9tVG91Y2giLCJ0YXJnZXRFbCIsInRhcmdldCIsImhhbmRsZVRvdWNoTW92ZSIsImhhbmRsZVRvdWNoRW5kIiwid2luZG93IiwiaGFuZGxlVG91Y2hTY3JvbGwiLCJzdGFydElnbm9yaW5nTW91c2UiLCJoYW5kbGVTY3JvbGwiLCJwYWdlWCIsInBhZ2VYT2Zmc2V0IiwicHJldlNjcm9sbFgiLCJwcmV2UGFnZVgiLCJwYWdlWSIsInBhZ2VZT2Zmc2V0IiwicHJldlNjcm9sbFkiLCJwcmV2UGFnZVkiLCJvcmlnRXZlbnQiLCJpc1RvdWNoIiwiZGVsdGFYIiwib3JpZ1BhZ2VYIiwiZGVsdGFZIiwib3JpZ1BhZ2VZIiwiRW1pdHRlciIsInBhc3NpdmUiLCJsaXN0ZW5lckNyZWF0ZWQiLCJwcm90b3R5cGUiLCJkZXN0cm95IiwibGlzdGVuZXJEZXN0cm95ZWQiLCJxdWVyeVN1YmplY3RFbCIsImRvd25FbCIsImVsZW1lbnRDbG9zZXN0IiwiZGVzdHJveVNjcm9sbFdhdGNoIiwiY2FuY2VsVG91Y2hTY3JvbGwiLCJpc0ZpcnN0IiwidG91Y2hlcyIsImxlbmd0aCIsImJ1dHRvbiIsImN0cmxLZXkiLCJzZXRUaW1lb3V0Iiwib25XaW5kb3dUb3VjaE1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsIkVsZW1lbnRNaXJyb3IiLCJpc1Zpc2libGUiLCJzb3VyY2VFbCIsIm1pcnJvckVsIiwic291cmNlRWxSZWN0IiwicGFyZW50Tm9kZSIsImJvZHkiLCJ6SW5kZXgiLCJyZXZlcnREdXJhdGlvbiIsInN0YXJ0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib3JpZ1NjcmVlblgiLCJvcmlnU2NyZWVuWSIsInVwZGF0ZUVsUG9zaXRpb24iLCJoYW5kbGVNb3ZlIiwic2V0SXNWaXNpYmxlIiwiYm9vbCIsInN0eWxlIiwiZGlzcGxheSIsInN0b3AiLCJuZWVkc1JldmVydEFuaW1hdGlvbiIsImNhbGxiYWNrIiwiZG9uZSIsImRvUmV2ZXJ0QW5pbWF0aW9uIiwiZmluYWxTb3VyY2VFbFJlY3QiLCJ0cmFuc2l0aW9uIiwiYXBwbHlTdHlsZSIsImxlZnQiLCJ0b3AiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJyZW1vdmVFbGVtZW50IiwiZ2V0TWlycm9yRWwiLCJjbG9uZU5vZGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJib3hTaXppbmciLCJ3aWR0aCIsInJpZ2h0IiwiaGVpZ2h0IiwiYm90dG9tIiwibWFyZ2luIiwiYXBwZW5kQ2hpbGQiLCJTY3JvbGxHZW9tQ2FjaGUiLCJfc3VwZXIiLCJfX2V4dGVuZHMiLCJzY3JvbGxDb250cm9sbGVyIiwiZG9lc0xpc3RlbmluZyIsImNhbGwiLCJzY3JvbGxUb3AiLCJnZXRTY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImhhbmRsZVNjcm9sbENoYW5nZSIsIm9yaWdTY3JvbGxUb3AiLCJvcmlnU2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwiZ2V0U2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJnZXRTY3JvbGxIZWlnaHQiLCJjbGllbnRXaWR0aCIsImdldENsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q2xpZW50SGVpZ2h0IiwiY2xpZW50UmVjdCIsImNvbXB1dGVDbGllbnRSZWN0IiwiZ2V0RXZlbnRUYXJnZXQiLCJzZXRTY3JvbGxUb3AiLCJNYXRoIiwibWF4IiwibWluIiwiZ2V0TWF4U2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsImdldE1heFNjcm9sbExlZnQiLCJTY3JvbGxDb250cm9sbGVyIiwiRWxlbWVudFNjcm9sbEdlb21DYWNoZSIsImVsIiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJjb21wdXRlSW5uZXJSZWN0IiwiV2luZG93U2Nyb2xsR2VvbUNhY2hlIiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsImdldFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJBdXRvU2Nyb2xsZXIiLCJpc0VuYWJsZWQiLCJzY3JvbGxRdWVyeSIsImVkZ2VUaHJlc2hvbGQiLCJtYXhWZWxvY2l0eSIsInBvaW50ZXJTY3JlZW5YIiwicG9pbnRlclNjcmVlblkiLCJpc0FuaW1hdGluZyIsInNjcm9sbENhY2hlcyIsImV2ZXJNb3ZlZFVwIiwiZXZlck1vdmVkRG93biIsImV2ZXJNb3ZlZExlZnQiLCJldmVyTW92ZWRSaWdodCIsImFuaW1hdGUiLCJlZGdlIiwiY29tcHV0ZUJlc3RFZGdlIiwiaGFuZGxlU2lkZSIsIm1zU2luY2VSZXF1ZXN0IiwicmVxdWVzdEFuaW1hdGlvbiIsInNjcm9sbFN0YXJ0RWwiLCJidWlsZENhY2hlcyIsInlEZWx0YSIsInhEZWx0YSIsIl9pIiwiX2EiLCJzY3JvbGxDYWNoZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNlY29uZHMiLCJpbnZEaXN0YW5jZSIsImRpc3RhbmNlIiwidmVsb2NpdHkiLCJzaWduIiwibmFtZSIsImJlc3RTaWRlIiwic2Nyb2xsQ2FjaGVzXzEiLCJyZWN0IiwibGVmdERpc3QiLCJyaWdodERpc3QiLCJ0b3BEaXN0IiwiYm90dG9tRGlzdCIsImNhblNjcm9sbFVwIiwiY2FuU2Nyb2xsRG93biIsImNhblNjcm9sbExlZnQiLCJjYW5TY3JvbGxSaWdodCIsInF1ZXJ5U2Nyb2xsRWxzIiwibWFwIiwiZWxzIiwicXVlcnkiLCJwdXNoIiwiYXBwbHkiLCJBcnJheSIsInNsaWNlIiwiZ2V0RWxSb290IiwicXVlcnlTZWxlY3RvckFsbCIsIkZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmciLCJkZWxheSIsIm1pbkRpc3RhbmNlIiwidG91Y2hTY3JvbGxBbGxvd2VkIiwibWlycm9yTmVlZHNSZXZlcnQiLCJpc0ludGVyYWN0aW5nIiwiaXNEZWxheUVuZGVkIiwiaXNEaXN0YW5jZVN1cnBhc3NlZCIsImRlbGF5VGltZW91dElkIiwib25Qb2ludGVyRG93biIsInByZXZlbnRTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJwb2ludGVyIiwibWlycm9yIiwic3RhcnREZWxheSIsImhhbmRsZURpc3RhbmNlU3VycGFzc2VkIiwib25Qb2ludGVyTW92ZSIsImRpc3RhbmNlU3EiLCJ0eXBlIiwiYXV0b1Njcm9sbGVyIiwib25Qb2ludGVyVXAiLCJhbGxvd1NlbGVjdGlvbiIsImFsbG93Q29udGV4dE1lbnUiLCJ0cnlTdG9wRHJhZyIsImNsZWFyVGltZW91dCIsIm9uIiwiaGFuZGxlRGVsYXlFbmQiLCJ0cnlTdGFydERyYWciLCJzdG9wRHJhZyIsImJpbmQiLCJzZXRJZ25vcmVNb3ZlIiwic2V0TWlycm9ySXNWaXNpYmxlIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsIkVsZW1lbnREcmFnZ2luZyIsIk9mZnNldFRyYWNrZXIiLCJvcmlnUmVjdCIsImNvbXB1dGVSZWN0IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwic2Nyb2xsRWwiLCJjb21wdXRlTGVmdCIsImNvbXB1dGVUb3AiLCJpc1dpdGhpbkNsaXBwaW5nIiwicG9pbnQiLCJpc0lnbm9yZWRDbGlwcGluZyIsInBvaW50SW5zaWRlUmVjdCIsIm5vZGUiLCJ0YWdOYW1lIiwiSGl0RHJhZ2dpbmciLCJkcmFnZ2luZyIsImRyb3BwYWJsZVN0b3JlIiwidXNlU3ViamVjdENlbnRlciIsInJlcXVpcmVJbml0aWFsIiwiaW5pdGlhbEhpdCIsIm1vdmluZ0hpdCIsImZpbmFsSGl0IiwiaGFuZGxlUG9pbnRlckRvd24iLCJwcmVwYXJlSGl0cyIsInByb2Nlc3NGaXJzdENvb3JkIiwiaGFuZGxlRHJhZ1N0YXJ0IiwiaGFuZGxlRHJhZ01vdmUiLCJoYW5kbGVQb2ludGVyVXAiLCJyZWxlYXNlSGl0cyIsImhhbmRsZURyYWdFbmQiLCJvcmlnUG9pbnQiLCJhZGp1c3RlZFBvaW50Iiwic3ViamVjdFJlY3QiLCJIVE1MRWxlbWVudCIsImNvbnN0cmFpblBvaW50IiwicXVlcnlIaXRGb3JPZmZzZXQiLCJzbGljZWRTdWJqZWN0UmVjdCIsImludGVyc2VjdFJlY3RzIiwiZ2V0UmVjdENlbnRlciIsImNvb3JkQWRqdXN0IiwiZGlmZlBvaW50cyIsImZvcmNlSGFuZGxlIiwiaGl0IiwiaXNIaXRzRXF1YWwiLCJvZmZzZXRUcmFja2VycyIsIm1hcEhhc2giLCJpbnRlcmFjdGlvblNldHRpbmdzIiwiY29tcG9uZW50IiwiaWQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiYmVzdEhpdCIsIm9mZnNldFRyYWNrZXIiLCJvcmlnaW5MZWZ0Iiwib3JpZ2luVG9wIiwicG9zaXRpb25MZWZ0IiwicG9zaXRpb25Ub3AiLCJxdWVyeUhpdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsImRhdGVQcm9maWxlIiwiYWN0aXZlUmFuZ2UiLCJkYXRlU3BhbiIsInJhbmdlIiwibGF5ZXIiLCJjb21wb25lbnRJZCIsImNvbnRleHQiLCJoaXQwIiwiaGl0MSIsIkJvb2xlYW4iLCJpc0RhdGVTcGFuc0VxdWFsIiwiYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCIsInByb3BzIiwicGx1Z2luSG9va3MiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwidHJhbnNmb3JtIiwiX19hc3NpZ24iLCJidWlsZERhdGVQb2ludEFwaSIsImRhdGVFbnYiLCJzcGFuIiwiZGF0ZSIsInRvRGF0ZSIsImRhdGVTdHIiLCJmb3JtYXRJc28iLCJvbWl0VGltZSIsImFsbERheSIsIkRhdGVDbGlja2luZyIsInNldHRpbmdzIiwiaXNWYWxpZERhdGVEb3duRWwiLCJoaXREcmFnZ2luZyIsImFyZyIsImRheUVsIiwianNFdmVudCIsInZpZXciLCJ2aWV3QXBpIiwiY2FsZW5kYXJBcGkiLCJpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSIsIkludGVyYWN0aW9uIiwiRGF0ZVNlbGVjdGluZyIsImRyYWdTZWxlY3Rpb24iLCJvcHRpb25zIiwiY2FuU2VsZWN0Iiwic2VsZWN0YWJsZSIsImdldENvbXBvbmVudFRvdWNoRGVsYXkkMSIsInVuc2VsZWN0IiwiaGFuZGxlSGl0VXBkYXRlIiwiaXNGaW5hbCIsImlzSW52YWxpZCIsImRpc2FsbG93ZWQiLCJpc0hpdENvbWJvQWxsb3dlZCIsImpvaW5IaXRzSW50b1NlbGVjdGlvbiIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJpc0RhdGVTZWxlY3Rpb25WYWxpZCIsImRpc3BhdGNoIiwic2VsZWN0aW9uIiwiZW5hYmxlQ3Vyc29yIiwiZGlzYWJsZUN1cnNvciIsInRyaWdnZXJEYXRlU2VsZWN0Iiwic2VsZWN0TWluRGlzdGFuY2UiLCJkcmFnU2Nyb2xsIiwic2VsZWN0TG9uZ1ByZXNzRGVsYXkiLCJsb25nUHJlc3NEZWxheSIsImRhdGVTcGFuMCIsImRhdGVTcGFuMSIsIm1zIiwiZW5kIiwic29ydCIsImNvbXBhcmVOdW1iZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyc18xIiwidHJhbnNmb3JtZXIiLCJyZXMiLCJFdmVudERyYWdnaW5nIiwic3ViamVjdFNlZyIsImV2ZW50UmFuZ2UiLCJyZWxldmFudEV2ZW50cyIsInJlY2VpdmluZ0NvbnRleHQiLCJ2YWxpZE11dGF0aW9uIiwibXV0YXRlZFJlbGV2YW50RXZlbnRzIiwib3JpZ1RhcmdldCIsImluaXRpYWxDb250ZXh0IiwiZ2V0RWxTZWciLCJldmVudEluc3RhbmNlSWQiLCJpbnN0YW5jZSIsImluc3RhbmNlSWQiLCJnZXRSZWxldmFudEV2ZW50cyIsImdldEN1cnJlbnREYXRhIiwiZXZlbnRTdG9yZSIsImV2ZW50RHJhZ01pbkRpc3RhbmNlIiwiZXZlbnRTZWxlY3Rpb24iLCJnZXRDb21wb25lbnRUb3VjaERlbGF5IiwiZml4ZWRNaXJyb3JQYXJlbnQiLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJpc1ZhbGlkIiwiaXNWYWxpZFNlZ0Rvd25FbCIsImNvbnRhaW5zIiwiZXZlbnQiLCJFdmVudEFwaSIsImRlZiIsIm11dGF0aW9uIiwiaW50ZXJhY3Rpb24iLCJhZmZlY3RlZEV2ZW50cyIsIm11dGF0ZWRFdmVudHMiLCJjcmVhdGVFbXB0eUV2ZW50U3RvcmUiLCJpc0V2ZW50IiwicmVjZWl2aW5nT3B0aW9ucyIsImVkaXRhYmxlIiwiZHJvcHBhYmxlIiwiY29tcHV0ZUV2ZW50TXV0YXRpb24iLCJldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyIsImFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpc0ludGVyYWN0aW9uVmFsaWQiLCJkaXNwbGF5RHJhZyIsInF1ZXJ5U2VsZWN0b3IiLCJpbml0aWFsQ29udGV4dF8xIiwiaW5pdGlhbFZpZXciLCJyZWNlaXZpbmdDb250ZXh0XzEiLCJldmVudERlZiIsImV2ZW50SW5zdGFuY2UiLCJldmVudEFwaSIsInJlbGV2YW50RXZlbnRzXzEiLCJtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSIsImNsZWFyRHJhZyIsInVwZGF0ZWRFdmVudEFwaSIsImRlZnMiLCJkZWZJZCIsImluc3RhbmNlcyIsImV2ZW50Q2hhbmdlQXJnIiwib2xkRXZlbnQiLCJyZWxhdGVkRXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZXZlcnQiLCJ0cmFuc2Zvcm1lZCIsIl9iIiwiZXZlbnREcm9wVHJhbnNmb3JtZXJzIiwiZGVsdGEiLCJkYXRlc0RlbHRhIiwiZXZlbnRSZW1vdmVBcmciLCJkcmFnZ2VkRWwiLCJhZGRlZEV2ZW50RGVmIiwiYWRkZWRFdmVudEluc3RhbmNlIiwiYWRkZWRFdmVudEFwaSIsImV2ZW50QWRkQXJnIiwiU0VMRUNUT1IiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJ1c2VFdmVudENlbnRlciIsIm5leHRDb250ZXh0Iiwic3RhdGUiLCJwcmV2Q29udGV4dCIsImluaXRpYWxDYWxlbmRhciIsIm1hc3NhZ2VycyIsImRhdGUwIiwiZGF0ZTEiLCJzdGFuZGFyZFByb3BzIiwiaGFzRW5kIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInN0YXJ0T2ZEYXkiLCJkaWZmRGF0ZXMiLCJsYXJnZVVuaXQiLCJtaWxsaXNlY29uZHMiLCJtYXNzYWdlcnNfMSIsIm1hc3NhZ2VyIiwiZXZlbnRMb25nUHJlc3NEZWxheSIsIkV2ZW50UmVzaXppbmciLCJkcmFnZ2luZ1NlZ0VsIiwiZHJhZ2dpbmdTZWciLCJzZWdFbCIsInF1ZXJ5U2VnRWwiLCJzZWciLCJjb21wdXRlTXV0YXRpb24iLCJzdGFydERlbHRhIiwiY3JlYXRlRHVyYXRpb24iLCJlbmREZWx0YSIsImlzRnJvbVN0YXJ0IiwiaW5zdGFuY2VSYW5nZSIsIlVuc2VsZWN0QXV0byIsImlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QiLCJtYXRjaGVzQ2FuY2VsIiwibWF0Y2hlc0V2ZW50Iiwib25TZWxlY3QiLCJzZWxlY3RJbmZvIiwib25Eb2N1bWVudFBvaW50ZXJEb3duIiwidW5zZWxlY3RDYW5jZWwiLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJvbkRvY3VtZW50UG9pbnRlclVwIiwiZG9jdW1lbnRQb2ludGVyIiwiY2FsZW5kYXJTdGF0ZSIsImRhdGVTZWxlY3Rpb24iLCJ1bnNlbGVjdEF1dG8iLCJvZmYiLCJPUFRJT05fUkVGSU5FUlMiLCJpZGVudGl0eSIsIkxJU1RFTkVSX1JFRklORVJTIiwiZGF0ZUNsaWNrIiwiZXZlbnREcmFnU3RhcnQiLCJldmVudERyYWdTdG9wIiwiZXZlbnREcm9wIiwiZXZlbnRSZXNpemVTdGFydCIsImV2ZW50UmVzaXplU3RvcCIsImV2ZW50UmVzaXplIiwiZHJvcCIsImV2ZW50UmVjZWl2ZSIsImV2ZW50TGVhdmUiLCJFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyIsInN1cHBsaWVkRHJhZ01ldGEiLCJkcm9wcGFibGVFdmVudCIsImRyYWdNZXRhIiwiYnVpbGREcmFnTWV0YSIsImNyZWF0ZSIsImNhbkRyb3BFbE9uQ2FsZW5kYXIiLCJjb21wdXRlRXZlbnRGb3JEYXRlU3BhbiIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZmluYWxWaWV3IiwiYWRkaW5nRXZlbnRzXzEiLCJwYXJzZURyYWdNZXRhIiwiZ2V0RHJhZ01ldGFGcm9tRWwiLCJkcm9wQWNjZXB0IiwiZWxlbWVudE1hdGNoZXMiLCJkZWZQcm9wcyIsImxlZnRvdmVyUHJvcHMiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJyZWZpbmVFdmVudERlZiIsInJlZmluZWQiLCJleHRyYSIsInBhcnNlRXZlbnREZWYiLCJzb3VyY2VJZCIsImZvcmNlRXZlbnREdXJhdGlvbiIsImR1cmF0aW9uIiwic3RhcnRUaW1lIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiY3JlYXRlRXZlbnRJbnN0YW5jZSIsInN0ciIsImdldEVtYmVkZGVkRWxEYXRhIiwib2JqIiwiSlNPTiIsInBhcnNlIiwiZGF0YUF0dHJQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhlZE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJFeHRlcm5hbERyYWdnYWJsZSIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiaXRlbVNlbGVjdG9yIiwiYXBwZW5kVG8iLCJldmVudERhdGEiLCJJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyIsIm1pcnJvclNlbGVjdG9yIiwiY3VycmVudE1pcnJvckVsIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJUaGlyZFBhcnR5RHJhZ2dhYmxlIiwiY29udGFpbmVyT3JTZXR0aW5ncyIsIkVsZW1lbnQiLCJtYWluIiwiY3JlYXRlUGx1Z2luIiwiY29tcG9uZW50SW50ZXJhY3Rpb25zIiwiY2FsZW5kYXJJbnRlcmFjdGlvbnMiLCJlbGVtZW50RHJhZ2dpbmdJbXBsIiwib3B0aW9uUmVmaW5lcnMiLCJsaXN0ZW5lclJlZmluZXJzIiwiRHJhZ2dhYmxlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/interaction/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/main.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/main.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n__webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/react/dist/vdom.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar FullCalendar = /** @class */ function(_super) {\n    tslib.__extends(FullCalendar, _super);\n    function FullCalendar() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._calendarApi = new common.CalendarApi();\n        return _this;\n    }\n    FullCalendar.prototype.render = function() {\n        return React.createElement(common.CalendarDataProvider, {\n            optionOverrides: this.props,\n            calendarApi: this._calendarApi\n        }, function(data) {\n            return React.createElement(common.CalendarRoot, {\n                options: data.calendarOptions,\n                theme: data.theme,\n                emitter: data.emitter\n            }, function(classNames, height, isHeightAuto, forPrint) {\n                return React.createElement(\"div\", {\n                    className: classNames.join(\" \"),\n                    style: {\n                        height: height\n                    }\n                }, React.createElement(common.CalendarContent, tslib.__assign({\n                    isHeightAuto: isHeightAuto,\n                    forPrint: forPrint\n                }, data)));\n            });\n        });\n    };\n    FullCalendar.prototype.getApi = function() {\n        return this._calendarApi;\n    };\n    return FullCalendar;\n}(React.Component);\nObject.keys(common).forEach(function(k) {\n    if (k !== \"default\") Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return common[k];\n        }\n    });\n});\nexports[\"default\"] = FullCalendar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFFckIsSUFBSUcsZUFBZSxXQUFXLEdBQUksU0FBVUMsTUFBTSxFQUFFO0lBQ2hETCxNQUFNTSxTQUFTLENBQUNGLGNBQWNDO0lBQzlCLFNBQVNELGVBQWU7UUFDcEIsSUFBSUcsUUFBUUYsV0FBVyxJQUFJLElBQUlBLE9BQU9HLEtBQUssQ0FBQyxJQUFJLEVBQUVDLGNBQWMsSUFBSTtRQUNwRUYsTUFBTUcsWUFBWSxHQUFHLElBQUlQLE9BQU9RLFdBQVc7UUFDM0MsT0FBT0o7SUFDWDtJQUNBSCxhQUFhUSxTQUFTLENBQUNDLE1BQU0sR0FBRyxXQUFZO1FBQ3hDLE9BQVFYLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBT1ksb0JBQW9CLEVBQUU7WUFBRUMsaUJBQWlCLElBQUksQ0FBQ0MsS0FBSztZQUFFQyxhQUFhLElBQUksQ0FBQ1IsWUFBWTtRQUFDLEdBQUcsU0FBVVMsSUFBSSxFQUFFO1lBQUUsT0FBUWpCLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBT2lCLFlBQVksRUFBRTtnQkFBRUMsU0FBU0YsS0FBS0csZUFBZTtnQkFBRUMsT0FBT0osS0FBS0ksS0FBSztnQkFBRUMsU0FBU0wsS0FBS0ssT0FBTztZQUFDLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFO2dCQUFFLE9BQVExQixNQUFNWSxhQUFhLENBQUMsT0FBTztvQkFBRWUsV0FBV0osV0FBV0ssSUFBSSxDQUFDO29CQUFNQyxPQUFPO3dCQUFFTCxRQUFRQTtvQkFBTztnQkFBRSxHQUM5WnhCLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBTzZCLGVBQWUsRUFBRWhDLE1BQU1pQyxRQUFRLENBQUM7b0JBQUVOLGNBQWNBO29CQUFjQyxVQUFVQTtnQkFBUyxHQUFHVDtZQUFVO1FBQUs7SUFDdEk7SUFDQWYsYUFBYVEsU0FBUyxDQUFDc0IsTUFBTSxHQUFHLFdBQVk7UUFDeEMsT0FBTyxJQUFJLENBQUN4QixZQUFZO0lBQzVCO0lBQ0EsT0FBT047QUFDWCxFQUFFRixNQUFNaUMsU0FBUztBQUVqQnZDLE9BQU93QyxJQUFJLENBQUNqQyxRQUFRa0MsT0FBTyxDQUFDLFNBQVVDLENBQUMsRUFBRTtJQUNyQyxJQUFJQSxNQUFNLFdBQVcxQyxPQUFPQyxjQUFjLENBQUNDLFNBQVN3QyxHQUFHO1FBQ25EQyxZQUFZLElBQUk7UUFDaEJDLEtBQUssV0FBWTtZQUNiLE9BQU9yQyxNQUFNLENBQUNtQyxFQUFFO1FBQ3BCO0lBQ0o7QUFDSjtBQUNBeEMsa0JBQWUsR0FBR00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAtZnVsbGNhbGVuZGFyLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC9tYWluLmNqcy5qcz9lYTI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnJlcXVpcmUoJy4vdmRvbS5janMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9jb21tb24nKTtcblxudmFyIEZ1bGxDYWxlbmRhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRnVsbENhbGVuZGFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bGxDYWxlbmRhcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jYWxlbmRhckFwaSA9IG5ldyBjb21tb24uQ2FsZW5kYXJBcGkoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdWxsQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KGNvbW1vbi5DYWxlbmRhckRhdGFQcm92aWRlciwgeyBvcHRpb25PdmVycmlkZXM6IHRoaXMucHJvcHMsIGNhbGVuZGFyQXBpOiB0aGlzLl9jYWxlbmRhckFwaSB9LCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tbW9uLkNhbGVuZGFyUm9vdCwgeyBvcHRpb25zOiBkYXRhLmNhbGVuZGFyT3B0aW9ucywgdGhlbWU6IGRhdGEudGhlbWUsIGVtaXR0ZXI6IGRhdGEuZW1pdHRlciB9LCBmdW5jdGlvbiAoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogaGVpZ2h0IH0gfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tbW9uLkNhbGVuZGFyQ29udGVudCwgdHNsaWIuX19hc3NpZ24oeyBpc0hlaWdodEF1dG86IGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQ6IGZvclByaW50IH0sIGRhdGEpKSkpOyB9KSk7IH0pKTtcbiAgICB9O1xuICAgIEZ1bGxDYWxlbmRhci5wcm90b3R5cGUuZ2V0QXBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXJBcGk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVsbENhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpKTtcblxuT2JqZWN0LmtleXMoY29tbW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uW2tdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZ1bGxDYWxlbmRhcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliIiwicmVxdWlyZSIsIlJlYWN0IiwiY29tbW9uIiwiRnVsbENhbGVuZGFyIiwiX3N1cGVyIiwiX19leHRlbmRzIiwiX3RoaXMiLCJhcHBseSIsImFyZ3VtZW50cyIsIl9jYWxlbmRhckFwaSIsIkNhbGVuZGFyQXBpIiwicHJvdG90eXBlIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsIkNhbGVuZGFyRGF0YVByb3ZpZGVyIiwib3B0aW9uT3ZlcnJpZGVzIiwicHJvcHMiLCJjYWxlbmRhckFwaSIsImRhdGEiLCJDYWxlbmRhclJvb3QiLCJvcHRpb25zIiwiY2FsZW5kYXJPcHRpb25zIiwidGhlbWUiLCJlbWl0dGVyIiwiY2xhc3NOYW1lcyIsImhlaWdodCIsImlzSGVpZ2h0QXV0byIsImZvclByaW50IiwiY2xhc3NOYW1lIiwiam9pbiIsInN0eWxlIiwiQ2FsZW5kYXJDb250ZW50IiwiX19hc3NpZ24iLCJnZXRBcGkiLCJDb21wb25lbnQiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/vdom.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/vdom.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"react\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"react-dom\");\n(typeof globalThis !== \"undefined\" ? globalThis : window).FullCalendarVDom = {\n    Component: React.Component,\n    createElement: React.createElement,\n    render: reactDom.render,\n    createRef: React.createRef,\n    Fragment: React.Fragment,\n    createContext: React.createContext,\n    createPortal: reactDom.createPortal,\n    flushSync: flushSync,\n    unmountComponentAtNode: reactDom.unmountComponentAtNode // never called by FullCalendar's React component\n};\nfunction flushSync(callback) {\n    // always sync from top-level\n    callback();\n}\nexports.flushSync = flushSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFFdEIsUUFBT0UsZUFBZSxjQUFjQSxhQUFhQyxNQUFNLEVBQUVDLGdCQUFnQixHQUFHO0lBQ3pFQyxXQUFXTixNQUFNTSxTQUFTO0lBQzFCQyxlQUFlUCxNQUFNTyxhQUFhO0lBQ2xDQyxRQUFRTixTQUFTTSxNQUFNO0lBQ3ZCQyxXQUFXVCxNQUFNUyxTQUFTO0lBQzFCQyxVQUFVVixNQUFNVSxRQUFRO0lBQ3hCQyxlQUFlWCxNQUFNVyxhQUFhO0lBQ2xDQyxjQUFjVixTQUFTVSxZQUFZO0lBQ25DQyxXQUFXQTtJQUNYQyx3QkFBd0JaLFNBQVNZLHNCQUFzQixDQUFDLGlEQUFpRDtBQUM3RztBQUNBLFNBQVNELFVBQVVFLFFBQVEsRUFBRTtJQUN6Qiw2QkFBNkI7SUFDN0JBO0FBQ0o7QUFFQWpCLGlCQUFpQixHQUFHZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcC1mdWxsY2FsZW5kYXIvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uY2pzLmpzPzU5NzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHJlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbih0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogd2luZG93KS5GdWxsQ2FsZW5kYXJWRG9tID0ge1xuICAgIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50LFxuICAgIGNyZWF0ZUVsZW1lbnQ6IFJlYWN0LmNyZWF0ZUVsZW1lbnQsXG4gICAgcmVuZGVyOiByZWFjdERvbS5yZW5kZXIsXG4gICAgY3JlYXRlUmVmOiBSZWFjdC5jcmVhdGVSZWYsXG4gICAgRnJhZ21lbnQ6IFJlYWN0LkZyYWdtZW50LFxuICAgIGNyZWF0ZUNvbnRleHQ6IFJlYWN0LmNyZWF0ZUNvbnRleHQsXG4gICAgY3JlYXRlUG9ydGFsOiByZWFjdERvbS5jcmVhdGVQb3J0YWwsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogcmVhY3REb20udW5tb3VudENvbXBvbmVudEF0Tm9kZSAvLyBuZXZlciBjYWxsZWQgYnkgRnVsbENhbGVuZGFyJ3MgUmVhY3QgY29tcG9uZW50XG59O1xuZnVuY3Rpb24gZmx1c2hTeW5jKGNhbGxiYWNrKSB7XG4gICAgLy8gYWx3YXlzIHN5bmMgZnJvbSB0b3AtbGV2ZWxcbiAgICBjYWxsYmFjaygpO1xufVxuXG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlYWN0IiwicmVxdWlyZSIsInJlYWN0RG9tIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsIkZ1bGxDYWxlbmRhclZEb20iLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hTeW5jIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/vdom.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/timegrid/main.cjs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.cjs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar daygrid = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.cjs.js\");\n;\nvar AllDaySplitter = /** @class */ function(_super) {\n    tslib.__extends(AllDaySplitter, _super);\n    function AllDaySplitter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AllDaySplitter.prototype.getKeyInfo = function() {\n        return {\n            allDay: {},\n            timed: {}\n        };\n    };\n    AllDaySplitter.prototype.getKeysForDateSpan = function(dateSpan) {\n        if (dateSpan.allDay) {\n            return [\n                \"allDay\"\n            ];\n        }\n        return [\n            \"timed\"\n        ];\n    };\n    AllDaySplitter.prototype.getKeysForEventDef = function(eventDef) {\n        if (!eventDef.allDay) {\n            return [\n                \"timed\"\n            ];\n        }\n        if (common.hasBgRendering(eventDef)) {\n            return [\n                \"timed\",\n                \"allDay\"\n            ];\n        }\n        return [\n            \"allDay\"\n        ];\n    };\n    return AllDaySplitter;\n}(common.Splitter);\nvar DEFAULT_SLAT_LABEL_FORMAT = common.createFormatter({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"short\"\n});\nfunction TimeColsAxisCell(props) {\n    var classNames = [\n        \"fc-timegrid-slot\",\n        \"fc-timegrid-slot-label\",\n        props.isLabeled ? \"fc-scrollgrid-shrink\" : \"fc-timegrid-slot-minor\"\n    ];\n    return common.createElement(common.ViewContextType.Consumer, null, function(context) {\n        if (!props.isLabeled) {\n            return common.createElement(\"td\", {\n                className: classNames.join(\" \"),\n                \"data-time\": props.isoTimeStr\n            });\n        }\n        var dateEnv = context.dateEnv, options = context.options, viewApi = context.viewApi;\n        var labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? common.createFormatter(options.slotLabelFormat[0]) : common.createFormatter(options.slotLabelFormat);\n        var hookProps = {\n            level: 0,\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat)\n        };\n        return common.createElement(common.RenderHook, {\n            hookProps: hookProps,\n            classNames: options.slotLabelClassNames,\n            content: options.slotLabelContent,\n            defaultContent: renderInnerContent,\n            didMount: options.slotLabelDidMount,\n            willUnmount: options.slotLabelWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return common.createElement(\"td\", {\n                ref: rootElRef,\n                className: classNames.concat(customClassNames).join(\" \"),\n                \"data-time\": props.isoTimeStr\n            }, common.createElement(\"div\", {\n                className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n            }, common.createElement(\"div\", {\n                className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n                ref: innerElRef\n            }, innerContent)));\n        });\n    });\n}\nfunction renderInnerContent(props) {\n    return props.text;\n}\nvar TimeBodyAxis = /** @class */ function(_super) {\n    tslib.__extends(TimeBodyAxis, _super);\n    function TimeBodyAxis() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeBodyAxis.prototype.render = function() {\n        return this.props.slatMetas.map(function(slatMeta) {\n            return common.createElement(\"tr\", {\n                key: slatMeta.key\n            }, common.createElement(TimeColsAxisCell, tslib.__assign({}, slatMeta)));\n        });\n    };\n    return TimeBodyAxis;\n}(common.BaseComponent);\nvar DEFAULT_WEEK_NUM_FORMAT = common.createFormatter({\n    week: \"short\"\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nvar TimeColsView = /** @class */ function(_super) {\n    tslib.__extends(TimeColsView, _super);\n    function TimeColsView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n        _this.headerElRef = common.createRef();\n        _this.rootElRef = common.createRef();\n        _this.scrollerElRef = common.createRef();\n        _this.state = {\n            slatCoords: null\n        };\n        _this.handleScrollTopRequest = function(scrollTop) {\n            var scrollerEl = _this.scrollerElRef.current;\n            if (scrollerEl) {\n                scrollerEl.scrollTop = scrollTop;\n            }\n        };\n        /* Header Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ _this.renderHeadAxis = function(rowKey, frameHeight) {\n            if (frameHeight === void 0) {\n                frameHeight = \"\";\n            }\n            var options = _this.context.options;\n            var dateProfile = _this.props.dateProfile;\n            var range = dateProfile.renderRange;\n            var dayCnt = common.diffDays(range.start, range.end);\n            var navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n             ? common.buildNavLinkAttrs(_this.context, range.start, \"week\") : {};\n            if (options.weekNumbers && rowKey === \"day\") {\n                return common.createElement(common.WeekNumberRoot, {\n                    date: range.start,\n                    defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n                }, function(rootElRef, classNames, innerElRef, innerContent) {\n                    return common.createElement(\"th\", {\n                        ref: rootElRef,\n                        \"aria-hidden\": true,\n                        className: [\n                            \"fc-timegrid-axis\",\n                            \"fc-scrollgrid-shrink\"\n                        ].concat(classNames).join(\" \")\n                    }, common.createElement(\"div\", {\n                        className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n                        style: {\n                            height: frameHeight\n                        }\n                    }, common.createElement(\"a\", tslib.__assign({\n                        ref: innerElRef,\n                        className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n                    }, navLinkAttrs), innerContent)));\n                });\n            }\n            return common.createElement(\"th\", {\n                \"aria-hidden\": true,\n                className: \"fc-timegrid-axis\"\n            }, common.createElement(\"div\", {\n                className: \"fc-timegrid-axis-frame\",\n                style: {\n                    height: frameHeight\n                }\n            }));\n        };\n        /* Table Component Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n        // but DayGrid still needs to have classNames on inner elements in order to measure.\n        _this.renderTableRowAxis = function(rowHeight) {\n            var _a = _this.context, options = _a.options, viewApi = _a.viewApi;\n            var hookProps = {\n                text: options.allDayText,\n                view: viewApi\n            };\n            return(// TODO: make reusable hook. used in list view too\n            common.createElement(common.RenderHook, {\n                hookProps: hookProps,\n                classNames: options.allDayClassNames,\n                content: options.allDayContent,\n                defaultContent: renderAllDayInner,\n                didMount: options.allDayDidMount,\n                willUnmount: options.allDayWillUnmount\n            }, function(rootElRef, classNames, innerElRef, innerContent) {\n                return common.createElement(\"td\", {\n                    ref: rootElRef,\n                    \"aria-hidden\": true,\n                    className: [\n                        \"fc-timegrid-axis\",\n                        \"fc-scrollgrid-shrink\"\n                    ].concat(classNames).join(\" \")\n                }, common.createElement(\"div\", {\n                    className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame\" + (rowHeight == null ? \" fc-timegrid-axis-frame-liquid\" : \"\"),\n                    style: {\n                        height: rowHeight\n                    }\n                }, common.createElement(\"span\", {\n                    className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n                    ref: innerElRef\n                }, innerContent)));\n            }));\n        };\n        _this.handleSlatCoords = function(slatCoords) {\n            _this.setState({\n                slatCoords: slatCoords\n            });\n        };\n        return _this;\n    }\n    // rendering\n    // ----------------------------------------------------------------------------------------------------\n    TimeColsView.prototype.renderSimpleLayout = function(headerRowContent, allDayContent, timeContent) {\n        var _a = this, context = _a.context, props = _a.props;\n        var sections = [];\n        var stickyHeaderDates = common.getStickyHeaderDates(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                chunk: {\n                    content: allDayContent\n                }\n            });\n            sections.push({\n                type: \"body\",\n                key: \"all-day-divider\",\n                outerContent: common.createElement(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, common.createElement(\"td\", {\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunk: {\n                scrollerElRef: this.scrollerElRef,\n                content: timeContent\n            }\n        });\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec,\n            elRef: this.rootElRef\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                className: [\n                    \"fc-timegrid\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, common.createElement(common.SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [\n                    {\n                        width: \"shrink\"\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    TimeColsView.prototype.renderHScrollLayout = function(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n        var _this = this;\n        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        var _a = this, context = _a.context, props = _a.props;\n        var stickyHeaderDates = !props.forPrint && common.getStickyHeaderDates(context.options);\n        var stickyFooterScrollbar = !props.forPrint && common.getStickyFooterScrollbar(context.options);\n        var sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: function(arg) {\n                            return common.createElement(\"tr\", {\n                                role: \"presentation\"\n                            }, _this.renderHeadAxis(\"day\", arg.rowSyncHeights[0]));\n                        }\n                    },\n                    {\n                        key: \"cols\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: function(contentArg) {\n                            return common.createElement(\"tr\", {\n                                role: \"presentation\"\n                            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n                        }\n                    },\n                    {\n                        key: \"cols\",\n                        content: allDayContent\n                    }\n                ]\n            });\n            sections.push({\n                key: \"all-day-divider\",\n                type: \"body\",\n                outerContent: common.createElement(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, common.createElement(\"td\", {\n                    colSpan: 2,\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        var isNowIndicator = context.options.nowIndicator;\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunks: [\n                {\n                    key: \"axis\",\n                    content: function(arg) {\n                        return(// TODO: make this now-indicator arrow more DRY with TimeColsContent\n                        common.createElement(\"div\", {\n                            className: \"fc-timegrid-axis-chunk\"\n                        }, common.createElement(\"table\", {\n                            \"aria-hidden\": true,\n                            style: {\n                                height: arg.expandRows ? arg.clientHeight : \"\"\n                            }\n                        }, arg.tableColGroupNode, common.createElement(\"tbody\", null, common.createElement(TimeBodyAxis, {\n                            slatMetas: slatMetas\n                        }))), common.createElement(\"div\", {\n                            className: \"fc-timegrid-now-indicator-container\"\n                        }, common.createElement(common.NowTimer, {\n                            unit: isNowIndicator ? \"minute\" : \"day\" /* hacky */ \n                        }, function(nowDate) {\n                            var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                            if (typeof nowIndicatorTop === \"number\") {\n                                return common.createElement(common.NowIndicatorRoot, {\n                                    isAxis: true,\n                                    date: nowDate\n                                }, function(rootElRef, classNames, innerElRef, innerContent) {\n                                    return common.createElement(\"div\", {\n                                        ref: rootElRef,\n                                        className: [\n                                            \"fc-timegrid-now-indicator-arrow\"\n                                        ].concat(classNames).join(\" \"),\n                                        style: {\n                                            top: nowIndicatorTop\n                                        }\n                                    }, innerContent);\n                                });\n                            }\n                            return null;\n                        }))));\n                    }\n                },\n                {\n                    key: \"cols\",\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                key: \"footer\",\n                type: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        content: common.renderScrollShim\n                    },\n                    {\n                        key: \"cols\",\n                        content: common.renderScrollShim\n                    }\n                ]\n            });\n        }\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec,\n            elRef: this.rootElRef\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                className: [\n                    \"fc-timegrid\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, common.createElement(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: false,\n                colGroups: [\n                    {\n                        width: \"shrink\",\n                        cols: [\n                            {\n                                width: \"shrink\"\n                            }\n                        ]\n                    },\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/ TimeColsView.prototype.getAllDayMaxEventProps = function() {\n        var _a = this.context.options, dayMaxEvents = _a.dayMaxEvents, dayMaxEventRows = _a.dayMaxEventRows;\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            dayMaxEvents = undefined;\n            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n        }\n        return {\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows\n        };\n    };\n    return TimeColsView;\n}(common.DateComponent);\nfunction renderAllDayInner(hookProps) {\n    return hookProps.text;\n}\nvar TimeColsSlatsCoords = /** @class */ function() {\n    function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n        this.positions = positions;\n        this.dateProfile = dateProfile;\n        this.slotDuration = slotDuration;\n    }\n    TimeColsSlatsCoords.prototype.safeComputeTop = function(date) {\n        var dateProfile = this.dateProfile;\n        if (common.rangeContainsMarker(dateProfile.currentRange, date)) {\n            var startOfDayDate = common.startOfDay(date);\n            var timeMs = date.valueOf() - startOfDayDate.valueOf();\n            if (timeMs >= common.asRoughMs(dateProfile.slotMinTime) && timeMs < common.asRoughMs(dateProfile.slotMaxTime)) {\n                return this.computeTimeTop(common.createDuration(timeMs));\n            }\n        }\n        return null;\n    };\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    TimeColsSlatsCoords.prototype.computeDateTop = function(when, startOfDayDate) {\n        if (!startOfDayDate) {\n            startOfDayDate = common.startOfDay(when);\n        }\n        return this.computeTimeTop(common.createDuration(when.valueOf() - startOfDayDate.valueOf()));\n    };\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n    TimeColsSlatsCoords.prototype.computeTimeTop = function(duration) {\n        var _a = this, positions = _a.positions, dateProfile = _a.dateProfile;\n        var len = positions.els.length;\n        // floating-point value of # of slots covered\n        var slatCoverage = (duration.milliseconds - common.asRoughMs(dateProfile.slotMinTime)) / common.asRoughMs(this.slotDuration);\n        var slatIndex;\n        var slatRemainder;\n        // compute a floating-point number for how many slats should be progressed through.\n        // from 0 to number of slats (inclusive)\n        // constrained because slotMinTime/slotMaxTime might be customized.\n        slatCoverage = Math.max(0, slatCoverage);\n        slatCoverage = Math.min(len, slatCoverage);\n        // an integer index of the furthest whole slat\n        // from 0 to number slats (*exclusive*, so len-1)\n        slatIndex = Math.floor(slatCoverage);\n        slatIndex = Math.min(slatIndex, len - 1);\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n        // could be 1.0 if slatCoverage is covering *all* the slots\n        slatRemainder = slatCoverage - slatIndex;\n        return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n    };\n    return TimeColsSlatsCoords;\n}();\nvar TimeColsSlatsBody = /** @class */ function(_super) {\n    tslib.__extends(TimeColsSlatsBody, _super);\n    function TimeColsSlatsBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColsSlatsBody.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var slatElRefs = props.slatElRefs;\n        return common.createElement(\"tbody\", null, props.slatMetas.map(function(slatMeta, i) {\n            var hookProps = {\n                time: slatMeta.time,\n                date: context.dateEnv.toDate(slatMeta.date),\n                view: context.viewApi\n            };\n            var classNames = [\n                \"fc-timegrid-slot\",\n                \"fc-timegrid-slot-lane\",\n                slatMeta.isLabeled ? \"\" : \"fc-timegrid-slot-minor\"\n            ];\n            return common.createElement(\"tr\", {\n                key: slatMeta.key,\n                ref: slatElRefs.createRef(slatMeta.key)\n            }, props.axis && common.createElement(TimeColsAxisCell, tslib.__assign({}, slatMeta)), common.createElement(common.RenderHook, {\n                hookProps: hookProps,\n                classNames: options.slotLaneClassNames,\n                content: options.slotLaneContent,\n                didMount: options.slotLaneDidMount,\n                willUnmount: options.slotLaneWillUnmount\n            }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                return common.createElement(\"td\", {\n                    ref: rootElRef,\n                    className: classNames.concat(customClassNames).join(\" \"),\n                    \"data-time\": slatMeta.isoTimeStr\n                }, innerContent);\n            }));\n        }));\n    };\n    return TimeColsSlatsBody;\n}(common.BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/ var TimeColsSlats = /** @class */ function(_super) {\n    tslib.__extends(TimeColsSlats, _super);\n    function TimeColsSlats() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = common.createRef();\n        _this.slatElRefs = new common.RefMap();\n        return _this;\n    }\n    TimeColsSlats.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        return common.createElement(\"div\", {\n            ref: this.rootElRef,\n            className: \"fc-timegrid-slots\"\n        }, common.createElement(\"table\", {\n            \"aria-hidden\": true,\n            className: context.theme.getClass(\"table\"),\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth,\n                height: props.minHeight\n            }\n        }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , common.createElement(TimeColsSlatsBody, {\n            slatElRefs: this.slatElRefs,\n            axis: props.axis,\n            slatMetas: props.slatMetas\n        })));\n    };\n    TimeColsSlats.prototype.componentDidMount = function() {\n        this.updateSizing();\n    };\n    TimeColsSlats.prototype.componentDidUpdate = function() {\n        this.updateSizing();\n    };\n    TimeColsSlats.prototype.componentWillUnmount = function() {\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    };\n    TimeColsSlats.prototype.updateSizing = function() {\n        var _a = this, context = _a.context, props = _a.props;\n        if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            var rootEl = this.rootElRef.current;\n            if (rootEl.offsetHeight) {\n                props.onCoords(new TimeColsSlatsCoords(new common.PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n            }\n        }\n    };\n    return TimeColsSlats;\n}(common.BaseComponent);\nfunction collectSlatEls(elMap, slatMetas) {\n    return slatMetas.map(function(slatMeta) {\n        return elMap[slatMeta.key];\n    });\n}\nfunction splitSegsByCol(segs, colCnt) {\n    var segsByCol = [];\n    var i;\n    for(i = 0; i < colCnt; i += 1){\n        segsByCol.push([]);\n    }\n    if (segs) {\n        for(i = 0; i < segs.length; i += 1){\n            segsByCol[segs[i].col].push(segs[i]);\n        }\n    }\n    return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n    var byRow = [];\n    if (!ui) {\n        for(var i = 0; i < colCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(var i = 0; i < colCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){\n            var seg = _a[_i];\n            byRow[seg.col].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nvar TimeColMoreLink = /** @class */ function(_super) {\n    tslib.__extends(TimeColMoreLink, _super);\n    function TimeColMoreLink() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = common.createRef();\n        return _this;\n    }\n    TimeColMoreLink.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        return common.createElement(common.MoreLinkRoot, {\n            allDayDate: null,\n            moreCnt: props.hiddenSegs.length,\n            allSegs: props.hiddenSegs,\n            hiddenSegs: props.hiddenSegs,\n            alignmentElRef: this.rootElRef,\n            defaultContent: renderMoreLinkInner,\n            extraDateSpan: props.extraDateSpan,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            popoverContent: function() {\n                return renderPlainFgSegs(props.hiddenSegs, props);\n            }\n        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n            return common.createElement(\"a\", {\n                ref: function(el) {\n                    common.setRef(rootElRef, el);\n                    common.setRef(_this.rootElRef, el);\n                },\n                className: [\n                    \"fc-timegrid-more-link\"\n                ].concat(classNames).join(\" \"),\n                style: {\n                    top: props.top,\n                    bottom: props.bottom\n                },\n                onClick: handleClick,\n                title: title,\n                \"aria-expanded\": isExpanded,\n                \"aria-controls\": popoverId\n            }, common.createElement(\"div\", {\n                ref: innerElRef,\n                className: \"fc-timegrid-more-link-inner fc-sticky\"\n            }, innerContent));\n        });\n    };\n    return TimeColMoreLink;\n}(common.BaseComponent);\nfunction renderMoreLinkInner(props) {\n    return props.shortText;\n}\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n    var hierarchy = new common.SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    var hiddenEntries = hierarchy.addSegs(segInputs);\n    var hiddenGroups = common.groupIntersectingEntries(hiddenEntries);\n    var web = buildWeb(hierarchy);\n    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n    var segRects = webToRects(web);\n    return {\n        segRects: segRects,\n        hiddenGroups: hiddenGroups\n    };\n}\nfunction buildWeb(hierarchy) {\n    var entriesByLevel = hierarchy.entriesByLevel;\n    var buildNode = cacheable(function(level, lateral) {\n        return level + \":\" + lateral;\n    }, function(level, lateral) {\n        var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n        var nextLevelRes = buildNodes(siblingRange, buildNode);\n        var entry = entriesByLevel[level][lateral];\n        return [\n            tslib.__assign(tslib.__assign({}, entry), {\n                nextLevelNodes: nextLevelRes[0]\n            }),\n            entry.thickness + nextLevelRes[1]\n        ];\n    });\n    return buildNodes(entriesByLevel.length ? {\n        level: 0,\n        lateralStart: 0,\n        lateralEnd: entriesByLevel[0].length\n    } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n    if (!siblingRange) {\n        return [\n            [],\n            0\n        ];\n    }\n    var level = siblingRange.level, lateralStart = siblingRange.lateralStart, lateralEnd = siblingRange.lateralEnd;\n    var lateral = lateralStart;\n    var pairs = [];\n    while(lateral < lateralEnd){\n        pairs.push(buildNode(level, lateral));\n        lateral += 1;\n    }\n    pairs.sort(cmpDescPressures);\n    return [\n        pairs.map(extractNode),\n        pairs[0][1]\n    ];\n}\nfunction cmpDescPressures(a, b) {\n    return b[1] - a[1];\n}\nfunction extractNode(a) {\n    return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n    var levelCoords = hierarchy.levelCoords, entriesByLevel = hierarchy.entriesByLevel;\n    var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n    var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n    var levelCnt = levelCoords.length;\n    var level = subjectLevel;\n    // skip past levels that are too high up\n    for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n    for(; level < levelCnt; level += 1){\n        var entries = entriesByLevel[level];\n        var entry = void 0;\n        var searchIndex = common.binarySearch(entries, subjectEntry.span.start, common.getEntrySpanEnd);\n        var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n        var lateralEnd = lateralStart;\n        while((entry = entries[lateralEnd]) && // but not past the whole seg list\n        entry.span.start < subjectEntry.span.end){\n            lateralEnd += 1;\n        }\n        if (lateralStart < lateralEnd) {\n            return {\n                level: level,\n                lateralStart: lateralStart,\n                lateralEnd: lateralEnd\n            };\n        }\n    }\n    return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n    var stretchNode = cacheable(function(node, startCoord, prevThickness) {\n        return common.buildEntryKey(node);\n    }, function(node, startCoord, prevThickness) {\n        var nextLevelNodes = node.nextLevelNodes, thickness = node.thickness;\n        var allThickness = thickness + prevThickness;\n        var thicknessFraction = thickness / allThickness;\n        var endCoord;\n        var newChildren = [];\n        if (!nextLevelNodes.length) {\n            endCoord = totalThickness;\n        } else {\n            for(var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++){\n                var childNode = nextLevelNodes_1[_i];\n                if (endCoord === undefined) {\n                    var res = stretchNode(childNode, startCoord, allThickness);\n                    endCoord = res[0];\n                    newChildren.push(res[1]);\n                } else {\n                    var res = stretchNode(childNode, endCoord, 0);\n                    newChildren.push(res[1]);\n                }\n            }\n        }\n        var newThickness = (endCoord - startCoord) * thicknessFraction;\n        return [\n            endCoord - newThickness,\n            tslib.__assign(tslib.__assign({}, node), {\n                thickness: newThickness,\n                nextLevelNodes: newChildren\n            })\n        ];\n    });\n    return topLevelNodes.map(function(node) {\n        return stretchNode(node, 0, 0)[1];\n    });\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n    var rects = [];\n    var processNode = cacheable(function(node, levelCoord, stackDepth) {\n        return common.buildEntryKey(node);\n    }, function(node, levelCoord, stackDepth) {\n        var rect = tslib.__assign(tslib.__assign({}, node), {\n            levelCoord: levelCoord,\n            stackDepth: stackDepth,\n            stackForward: 0\n        });\n        rects.push(rect);\n        return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n    });\n    function processNodes(nodes, levelCoord, stackDepth) {\n        var stackForward = 0;\n        for(var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++){\n            var node = nodes_1[_i];\n            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n        }\n        return stackForward;\n    }\n    processNodes(topLevelNodes, 0, 0);\n    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n    var cache = {};\n    return function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var key = keyFunc.apply(void 0, args);\n        return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);\n    };\n}\nfunction computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {\n    if (slatCoords === void 0) {\n        slatCoords = null;\n    }\n    if (eventMinHeight === void 0) {\n        eventMinHeight = 0;\n    }\n    var vcoords = [];\n    if (slatCoords) {\n        for(var i = 0; i < segs.length; i += 1){\n            var seg = segs[i];\n            var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n            var spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));\n            vcoords.push({\n                start: Math.round(spanStart),\n                end: Math.round(spanEnd)\n            });\n        }\n    }\n    return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {\n    var segInputs = [];\n    var dumbSegs = []; // segs without coords\n    for(var i = 0; i < segs.length; i += 1){\n        var vcoords = segVCoords[i];\n        if (vcoords) {\n            segInputs.push({\n                index: i,\n                thickness: 1,\n                span: vcoords\n            });\n        } else {\n            dumbSegs.push(segs[i]);\n        }\n    }\n    var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack), segRects = _a.segRects, hiddenGroups = _a.hiddenGroups;\n    var segPlacements = [];\n    for(var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++){\n        var segRect = segRects_1[_i];\n        segPlacements.push({\n            seg: segs[segRect.index],\n            rect: segRect\n        });\n    }\n    for(var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++){\n        var dumbSeg = dumbSegs_1[_b];\n        segPlacements.push({\n            seg: dumbSeg,\n            rect: null\n        });\n    }\n    return {\n        segPlacements: segPlacements,\n        hiddenGroups: hiddenGroups\n    };\n}\nvar DEFAULT_TIME_FORMAT = common.createFormatter({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    meridiem: false\n});\nvar TimeColEvent = /** @class */ function(_super) {\n    tslib.__extends(TimeColEvent, _super);\n    function TimeColEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColEvent.prototype.render = function() {\n        var classNames = [\n            \"fc-timegrid-event\",\n            \"fc-v-event\"\n        ];\n        if (this.props.isShort) {\n            classNames.push(\"fc-timegrid-event-short\");\n        }\n        return common.createElement(common.StandardEvent, tslib.__assign({}, this.props, {\n            defaultTimeFormat: DEFAULT_TIME_FORMAT,\n            extraClassNames: classNames\n        }));\n    };\n    return TimeColEvent;\n}(common.BaseComponent);\nvar TimeColMisc = /** @class */ function(_super) {\n    tslib.__extends(TimeColMisc, _super);\n    function TimeColMisc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColMisc.prototype.render = function() {\n        var props = this.props;\n        return common.createElement(common.DayCellContent, {\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            extraHookProps: props.extraHookProps\n        }, function(innerElRef, innerContent) {\n            return innerContent && common.createElement(\"div\", {\n                className: \"fc-timegrid-col-misc\",\n                ref: innerElRef\n            }, innerContent);\n        });\n    };\n    return TimeColMisc;\n}(common.BaseComponent);\nvar TimeCol = /** @class */ function(_super) {\n    tslib.__extends(TimeCol, _super);\n    function TimeCol() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sortEventSegs = common.memoize(common.sortEventSegs);\n        return _this;\n    }\n    // TODO: memoize event-placement?\n    TimeCol.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var isSelectMirror = context.options.selectMirror;\n        var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n        var interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n        return common.createElement(common.DayCellRoot, {\n            elRef: props.elRef,\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            extraHookProps: props.extraHookProps\n        }, function(rootElRef, classNames, dataAttrs) {\n            return common.createElement(\"td\", tslib.__assign({\n                ref: rootElRef,\n                role: \"gridcell\",\n                className: [\n                    \"fc-timegrid-col\"\n                ].concat(classNames, props.extraClassNames || []).join(\" \")\n            }, dataAttrs, props.extraDataAttrs), common.createElement(\"div\", {\n                className: \"fc-timegrid-col-frame\"\n            }, common.createElement(\"div\", {\n                className: \"fc-timegrid-col-bg\"\n            }, _this.renderFillSegs(props.businessHourSegs, \"non-business\"), _this.renderFillSegs(props.bgEventSegs, \"bg-event\"), _this.renderFillSegs(props.dateSelectionSegs, \"highlight\")), common.createElement(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), common.createElement(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), common.createElement(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n            }, _this.renderNowIndicator(props.nowIndicatorSegs)), common.createElement(TimeColMisc, {\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraHookProps: props.extraHookProps\n            })));\n        });\n    };\n    TimeCol.prototype.renderFgSegs = function(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        var props = this.props;\n        if (props.forPrint) {\n            return renderPlainFgSegs(sortedFgSegs, props);\n        }\n        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n    };\n    TimeCol.prototype.renderPositionedFgSegs = function(segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        var _this = this;\n        var _a = this.context.options, eventMaxStack = _a.eventMaxStack, eventShortHeight = _a.eventShortHeight, eventOrderStrict = _a.eventOrderStrict, eventMinHeight = _a.eventMinHeight;\n        var _b = this.props, date = _b.date, slatCoords = _b.slatCoords, eventSelection = _b.eventSelection, todayRange = _b.todayRange, nowDate = _b.nowDate;\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n        var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack), segPlacements = _c.segPlacements, hiddenGroups = _c.hiddenGroups;\n        return common.createElement(common.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function(segPlacement) {\n            var seg = segPlacement.seg, rect = segPlacement.rect;\n            var instanceId = seg.eventRange.instance.instanceId;\n            var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n            var vStyle = computeSegVStyle(rect && rect.span);\n            var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {\n                left: 0,\n                right: 0\n            };\n            var isInset = Boolean(rect) && rect.stackForward > 0;\n            var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n            return common.createElement(\"div\", {\n                className: \"fc-timegrid-event-harness\" + (isInset ? \" fc-timegrid-event-harness-inset\" : \"\"),\n                key: instanceId,\n                style: tslib.__assign(tslib.__assign({\n                    visibility: isVisible ? \"\" : \"hidden\"\n                }, vStyle), hStyle)\n            }, common.createElement(TimeColEvent, tslib.__assign({\n                seg: seg,\n                isDragging: isDragging,\n                isResizing: isResizing,\n                isDateSelecting: isDateSelecting,\n                isSelected: instanceId === eventSelection,\n                isShort: isShort\n            }, common.getSegMeta(seg, todayRange, nowDate))));\n        }));\n    };\n    // will already have eventMinHeight applied because segInputs already had it\n    TimeCol.prototype.renderHiddenGroups = function(hiddenGroups, segs) {\n        var _a = this.props, extraDateSpan = _a.extraDateSpan, dateProfile = _a.dateProfile, todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;\n        return common.createElement(common.Fragment, null, hiddenGroups.map(function(hiddenGroup) {\n            var positionCss = computeSegVStyle(hiddenGroup.span);\n            var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n            return common.createElement(TimeColMoreLink, {\n                key: common.buildIsoString(common.computeEarliestSegStart(hiddenSegs)),\n                hiddenSegs: hiddenSegs,\n                top: positionCss.top,\n                bottom: positionCss.bottom,\n                extraDateSpan: extraDateSpan,\n                dateProfile: dateProfile,\n                todayRange: todayRange,\n                nowDate: nowDate,\n                eventSelection: eventSelection,\n                eventDrag: eventDrag,\n                eventResize: eventResize\n            });\n        }));\n    };\n    TimeCol.prototype.renderFillSegs = function(segs, fillType) {\n        var _a = this, props = _a.props, context = _a.context;\n        var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n        var children = segVCoords.map(function(vcoords, i) {\n            var seg = segs[i];\n            return common.createElement(\"div\", {\n                key: common.buildEventRangeKey(seg.eventRange),\n                className: \"fc-timegrid-bg-harness\",\n                style: computeSegVStyle(vcoords)\n            }, fillType === \"bg-event\" ? common.createElement(common.BgEvent, tslib.__assign({\n                seg: seg\n            }, common.getSegMeta(seg, props.todayRange, props.nowDate))) : common.renderFill(fillType));\n        });\n        return common.createElement(common.Fragment, null, children);\n    };\n    TimeCol.prototype.renderNowIndicator = function(segs) {\n        var _a = this.props, slatCoords = _a.slatCoords, date = _a.date;\n        if (!slatCoords) {\n            return null;\n        }\n        return segs.map(function(seg, i) {\n            return common.createElement(common.NowIndicatorRoot, {\n                isAxis: false,\n                date: date,\n                // key doesn't matter. will only ever be one\n                key: i\n            }, function(rootElRef, classNames, innerElRef, innerContent) {\n                return common.createElement(\"div\", {\n                    ref: rootElRef,\n                    className: [\n                        \"fc-timegrid-now-indicator-line\"\n                    ].concat(classNames).join(\" \"),\n                    style: {\n                        top: slatCoords.computeDateTop(seg.start, date)\n                    }\n                }, innerContent);\n            });\n        });\n    };\n    TimeCol.prototype.computeSegHStyle = function(segHCoords) {\n        var _a = this.context, isRtl = _a.isRtl, options = _a.options;\n        var shouldOverlap = options.slotEventOverlap;\n        var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n        var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n        var left; // amount of space from left edge, a fraction of the total width\n        var right; // amount of space from right edge, a fraction of the total width\n        if (shouldOverlap) {\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\n            farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n        }\n        if (isRtl) {\n            left = 1 - farCoord;\n            right = nearCoord;\n        } else {\n            left = nearCoord;\n            right = 1 - farCoord;\n        }\n        var props = {\n            zIndex: segHCoords.stackDepth + 1,\n            left: left * 100 + \"%\",\n            right: right * 100 + \"%\"\n        };\n        if (shouldOverlap && !segHCoords.stackForward) {\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\n            props[isRtl ? \"marginLeft\" : \"marginRight\"] = 10 * 2; // 10 is a guesstimate of the icon's width\n        }\n        return props;\n    };\n    return TimeCol;\n}(common.BaseComponent);\nfunction renderPlainFgSegs(sortedFgSegs, _a) {\n    var todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;\n    var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n    return common.createElement(common.Fragment, null, sortedFgSegs.map(function(seg) {\n        var instanceId = seg.eventRange.instance.instanceId;\n        return common.createElement(\"div\", {\n            key: instanceId,\n            style: {\n                visibility: hiddenInstances[instanceId] ? \"hidden\" : \"\"\n            }\n        }, common.createElement(TimeColEvent, tslib.__assign({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === eventSelection,\n            isShort: false\n        }, common.getSegMeta(seg, todayRange, nowDate))));\n    }));\n}\nfunction computeSegVStyle(segVCoords) {\n    if (!segVCoords) {\n        return {\n            top: \"\",\n            bottom: \"\"\n        };\n    }\n    return {\n        top: segVCoords.start,\n        bottom: -segVCoords.end\n    };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n    return segEntries.map(function(segEntry) {\n        return allSegs[segEntry.index];\n    });\n}\nvar TimeColsContent = /** @class */ function(_super) {\n    tslib.__extends(TimeColsContent, _super);\n    function TimeColsContent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.splitFgEventSegs = common.memoize(splitSegsByCol);\n        _this.splitBgEventSegs = common.memoize(splitSegsByCol);\n        _this.splitBusinessHourSegs = common.memoize(splitSegsByCol);\n        _this.splitNowIndicatorSegs = common.memoize(splitSegsByCol);\n        _this.splitDateSelectionSegs = common.memoize(splitSegsByCol);\n        _this.splitEventDrag = common.memoize(splitInteractionByCol);\n        _this.splitEventResize = common.memoize(splitInteractionByCol);\n        _this.rootElRef = common.createRef();\n        _this.cellElRefs = new common.RefMap();\n        return _this;\n    }\n    TimeColsContent.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n        var colCnt = props.cells.length;\n        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n        var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n        var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n        var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n        return common.createElement(\"div\", {\n            className: \"fc-timegrid-cols\",\n            ref: this.rootElRef\n        }, common.createElement(\"table\", {\n            role: \"presentation\",\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth\n            }\n        }, props.tableColGroupNode, common.createElement(\"tbody\", {\n            role: \"presentation\"\n        }, common.createElement(\"tr\", {\n            role: \"row\"\n        }, props.axis && common.createElement(\"td\", {\n            \"aria-hidden\": true,\n            className: \"fc-timegrid-col fc-timegrid-axis\"\n        }, common.createElement(\"div\", {\n            className: \"fc-timegrid-col-frame\"\n        }, common.createElement(\"div\", {\n            className: \"fc-timegrid-now-indicator-container\"\n        }, typeof nowIndicatorTop === \"number\" && common.createElement(common.NowIndicatorRoot, {\n            isAxis: true,\n            date: props.nowDate\n        }, function(rootElRef, classNames, innerElRef, innerContent) {\n            return common.createElement(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-timegrid-now-indicator-arrow\"\n                ].concat(classNames).join(\" \"),\n                style: {\n                    top: nowIndicatorTop\n                }\n            }, innerContent);\n        })))), props.cells.map(function(cell, i) {\n            return common.createElement(TimeCol, {\n                key: cell.key,\n                elRef: _this.cellElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                nowDate: props.nowDate,\n                todayRange: props.todayRange,\n                extraHookProps: cell.extraHookProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                fgEventSegs: fgEventSegsByRow[i],\n                bgEventSegs: bgEventSegsByRow[i],\n                businessHourSegs: businessHourSegsByRow[i],\n                nowIndicatorSegs: nowIndicatorSegsByRow[i],\n                dateSelectionSegs: dateSelectionSegsByRow[i],\n                eventDrag: eventDragByRow[i],\n                eventResize: eventResizeByRow[i],\n                slatCoords: props.slatCoords,\n                eventSelection: props.eventSelection,\n                forPrint: props.forPrint\n            });\n        })))));\n    };\n    TimeColsContent.prototype.componentDidMount = function() {\n        this.updateCoords();\n    };\n    TimeColsContent.prototype.componentDidUpdate = function() {\n        this.updateCoords();\n    };\n    TimeColsContent.prototype.updateCoords = function() {\n        var props = this.props;\n        if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            props.onColCoords(new common.PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));\n        }\n    };\n    return TimeColsContent;\n}(common.BaseComponent);\nfunction collectCellEls(elMap, cells) {\n    return cells.map(function(cell) {\n        return elMap[cell.key];\n    });\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/ var TimeCols = /** @class */ function(_super) {\n    tslib.__extends(TimeCols, _super);\n    function TimeCols() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.processSlotOptions = common.memoize(processSlotOptions);\n        _this.state = {\n            slatCoords: null\n        };\n        _this.handleRootEl = function(el) {\n            if (el) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: el,\n                    isHitComboAllowed: _this.props.isHitComboAllowed\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        _this.handleScrollRequest = function(request) {\n            var onScrollTopRequest = _this.props.onScrollTopRequest;\n            var slatCoords = _this.state.slatCoords;\n            if (onScrollTopRequest && slatCoords) {\n                if (request.time) {\n                    var top_1 = slatCoords.computeTimeTop(request.time);\n                    top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n                    if (top_1) {\n                        top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    onScrollTopRequest(top_1);\n                }\n                return true;\n            }\n            return false;\n        };\n        _this.handleColCoords = function(colCoords) {\n            _this.colCoords = colCoords;\n        };\n        _this.handleSlatCoords = function(slatCoords) {\n            _this.setState({\n                slatCoords: slatCoords\n            });\n            if (_this.props.onSlatCoords) {\n                _this.props.onSlatCoords(slatCoords);\n            }\n        };\n        return _this;\n    }\n    TimeCols.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        return common.createElement(\"div\", {\n            className: \"fc-timegrid-body\",\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, common.createElement(TimeColsSlats, {\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            slatMetas: props.slatMetas,\n            clientWidth: props.clientWidth,\n            minHeight: props.expandRows ? props.clientHeight : \"\",\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.axis ? props.tableColGroupNode : null,\n            onCoords: this.handleSlatCoords\n        }), common.createElement(TimeColsContent, {\n            cells: props.cells,\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            todayRange: props.todayRange,\n            nowDate: props.nowDate,\n            nowIndicatorSegs: props.nowIndicatorSegs,\n            clientWidth: props.clientWidth,\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.tableColGroupNode,\n            slatCoords: state.slatCoords,\n            onColCoords: this.handleColCoords,\n            forPrint: props.forPrint\n        }));\n    };\n    TimeCols.prototype.componentDidMount = function() {\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    };\n    TimeCols.prototype.componentDidUpdate = function(prevProps) {\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    };\n    TimeCols.prototype.componentWillUnmount = function() {\n        this.scrollResponder.detach();\n    };\n    TimeCols.prototype.queryHit = function(positionLeft, positionTop) {\n        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options;\n        var colCoords = this.colCoords;\n        var dateProfile = this.props.dateProfile;\n        var slatCoords = this.state.slatCoords;\n        var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration), snapDuration = _b.snapDuration, snapsPerSlot = _b.snapsPerSlot;\n        var colIndex = colCoords.leftToIndex(positionLeft);\n        var slatIndex = slatCoords.positions.topToIndex(positionTop);\n        if (colIndex != null && slatIndex != null) {\n            var cell = this.props.cells[colIndex];\n            var slatTop = slatCoords.positions.tops[slatIndex];\n            var slatHeight = slatCoords.positions.getHeight(slatIndex);\n            var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n            var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n            var dayDate = this.props.cells[colIndex].date;\n            var time = common.addDurations(dateProfile.slotMinTime, common.multiplyDuration(snapDuration, snapIndex));\n            var start = dateEnv.add(dayDate, time);\n            var end = dateEnv.add(start, snapDuration);\n            return {\n                dateProfile: dateProfile,\n                dateSpan: tslib.__assign({\n                    range: {\n                        start: start,\n                        end: end\n                    },\n                    allDay: false\n                }, cell.extraDateSpan),\n                dayEl: colCoords.els[colIndex],\n                rect: {\n                    left: colCoords.lefts[colIndex],\n                    right: colCoords.rights[colIndex],\n                    top: slatTop,\n                    bottom: slatTop + slatHeight\n                },\n                layer: 0\n            };\n        }\n        return null;\n    };\n    return TimeCols;\n}(common.DateComponent);\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n    var snapDuration = snapDurationOverride || slotDuration;\n    var snapsPerSlot = common.wholeDivideDurations(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n        snapDuration = slotDuration;\n        snapsPerSlot = 1;\n    // TODO: say warning?\n    }\n    return {\n        snapDuration: snapDuration,\n        snapsPerSlot: snapsPerSlot\n    };\n}\nvar DayTimeColsSlicer = /** @class */ function(_super) {\n    tslib.__extends(DayTimeColsSlicer, _super);\n    function DayTimeColsSlicer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DayTimeColsSlicer.prototype.sliceRange = function(range, dayRanges) {\n        var segs = [];\n        for(var col = 0; col < dayRanges.length; col += 1){\n            var segRange = common.intersectRanges(range, dayRanges[col]);\n            if (segRange) {\n                segs.push({\n                    start: segRange.start,\n                    end: segRange.end,\n                    isStart: segRange.start.valueOf() === range.start.valueOf(),\n                    isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                    col: col\n                });\n            }\n        }\n        return segs;\n    };\n    return DayTimeColsSlicer;\n}(common.Slicer);\nvar DayTimeCols = /** @class */ function(_super) {\n    tslib.__extends(DayTimeCols, _super);\n    function DayTimeCols() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildDayRanges = common.memoize(buildDayRanges);\n        _this.slicer = new DayTimeColsSlicer();\n        _this.timeColsRef = common.createRef();\n        return _this;\n    }\n    DayTimeCols.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var dateProfile = props.dateProfile, dayTableModel = props.dayTableModel;\n        var isNowIndicator = context.options.nowIndicator;\n        var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n        // give it the first row of cells\n        // TODO: would move this further down hierarchy, but sliceNowDate needs it\n        return common.createElement(common.NowTimer, {\n            unit: isNowIndicator ? \"minute\" : \"day\"\n        }, function(nowDate, todayRange) {\n            return common.createElement(TimeCols, tslib.__assign({\n                ref: _this.timeColsRef\n            }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n                forPrint: props.forPrint,\n                axis: props.axis,\n                dateProfile: dateProfile,\n                slatMetas: props.slatMetas,\n                slotDuration: props.slotDuration,\n                cells: dayTableModel.cells[0],\n                tableColGroupNode: props.tableColGroupNode,\n                tableMinWidth: props.tableMinWidth,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                expandRows: props.expandRows,\n                nowDate: nowDate,\n                nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n                todayRange: todayRange,\n                onScrollTopRequest: props.onScrollTopRequest,\n                onSlatCoords: props.onSlatCoords\n            }));\n        });\n    };\n    return DayTimeCols;\n}(common.DateComponent);\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n    var ranges = [];\n    for(var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++){\n        var date = _a[_i];\n        ranges.push({\n            start: dateEnv.add(date, dateProfile.slotMinTime),\n            end: dateEnv.add(date, dateProfile.slotMaxTime)\n        });\n    }\n    return ranges;\n}\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar STOCK_SUB_DURATIONS = [\n    {\n        hours: 1\n    },\n    {\n        minutes: 30\n    },\n    {\n        minutes: 15\n    },\n    {\n        seconds: 30\n    },\n    {\n        seconds: 15\n    }\n];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n    var dayStart = new Date(0);\n    var slatTime = slotMinTime;\n    var slatIterator = common.createDuration(0);\n    var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n    var metas = [];\n    while(common.asRoughMs(slatTime) < common.asRoughMs(slotMaxTime)){\n        var date = dateEnv.add(dayStart, slatTime);\n        var isLabeled = common.wholeDivideDurations(slatIterator, labelInterval) !== null;\n        metas.push({\n            date: date,\n            time: slatTime,\n            key: date.toISOString(),\n            isoTimeStr: common.formatIsoTimeString(date),\n            isLabeled: isLabeled\n        });\n        slatTime = common.addDurations(slatTime, slotDuration);\n        slatIterator = common.addDurations(slatIterator, slotDuration);\n    }\n    return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n    var i;\n    var labelInterval;\n    var slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){\n        labelInterval = common.createDuration(STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = common.wholeDivideDurations(labelInterval, slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1) {\n            return labelInterval;\n        }\n    }\n    return slotDuration; // fall back\n}\nvar DayTimeColsView = /** @class */ function(_super) {\n    tslib.__extends(DayTimeColsView, _super);\n    function DayTimeColsView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildTimeColsModel = common.memoize(buildTimeColsModel);\n        _this.buildSlatMetas = common.memoize(buildSlatMetas);\n        return _this;\n    }\n    DayTimeColsView.prototype.render = function() {\n        var _this = this;\n        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv, dateProfileGenerator = _a.dateProfileGenerator;\n        var props = this.props;\n        var dateProfile = props.dateProfile;\n        var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n        var splitProps = this.allDaySplitter.splitProps(props);\n        var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n        var dayMinWidth = options.dayMinWidth;\n        var hasAttachedAxis = !dayMinWidth;\n        var hasDetachedAxis = dayMinWidth;\n        var headerContent = options.dayHeaders && common.createElement(common.DayHeader, {\n            dates: dayTableModel.headerDates,\n            dateProfile: dateProfile,\n            datesRepDistinctDays: true,\n            renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n        });\n        var allDayContent = options.allDaySlot !== false && function(contentArg) {\n            return common.createElement(daygrid.DayTable, tslib.__assign({}, splitProps.allDay, {\n                dateProfile: dateProfile,\n                dayTableModel: dayTableModel,\n                nextDayThreshold: options.nextDayThreshold,\n                tableMinWidth: contentArg.tableMinWidth,\n                colGroupNode: contentArg.tableColGroupNode,\n                renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n                showWeekNumbers: false,\n                expandRows: false,\n                headerAlignElRef: _this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            }, _this.getAllDayMaxEventProps()));\n        };\n        var timeGridContent = function(contentArg) {\n            return common.createElement(DayTimeCols, tslib.__assign({}, splitProps.timed, {\n                dayTableModel: dayTableModel,\n                dateProfile: dateProfile,\n                axis: hasAttachedAxis,\n                slotDuration: options.slotDuration,\n                slatMetas: slatMetas,\n                forPrint: props.forPrint,\n                tableColGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                onSlatCoords: _this.handleSlatCoords,\n                expandRows: contentArg.expandRows,\n                onScrollTopRequest: _this.handleScrollTopRequest\n            }));\n        };\n        return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    };\n    return DayTimeColsView;\n}(TimeColsView);\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n    var daySeries = new common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new common.DayTableModel(daySeries, false);\n}\nvar OPTION_REFINERS = {\n    allDaySlot: Boolean\n};\nvar main = common.createPlugin({\n    initialView: \"timeGridWeek\",\n    optionRefiners: OPTION_REFINERS,\n    views: {\n        timeGrid: {\n            component: DayTimeColsView,\n            usesMinMaxTime: true,\n            allDaySlot: true,\n            slotDuration: \"00:30:00\",\n            slotEventOverlap: true\n        },\n        timeGridDay: {\n            type: \"timeGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        timeGridWeek: {\n            type: \"timeGrid\",\n            duration: {\n                weeks: 1\n            }\n        }\n    }\n});\nexports.DayTimeCols = DayTimeCols;\nexports.DayTimeColsSlicer = DayTimeColsSlicer;\nexports.DayTimeColsView = DayTimeColsView;\nexports.TimeCols = TimeCols;\nexports.TimeColsSlatsCoords = TimeColsSlatsCoords;\nexports.TimeColsView = TimeColsView;\nexports.buildDayRanges = buildDayRanges;\nexports.buildSlatMetas = buildSlatMetas;\nexports.buildTimeColsModel = buildTimeColsModel;\nexports[\"default\"] = main;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmNqcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBQ0E7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU8sSUFBSTtBQUFDLENBQUMsRUFBQztBQUU3RCxJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQzs7QUFHdEIsSUFBSUcsaUJBQWlCLFdBQVcsR0FBSSxTQUFVQyxNQUFNLEVBQUU7SUFDbERILE1BQU1JLFNBQVMsQ0FBQ0YsZ0JBQWdCQztJQUNoQyxTQUFTRCxpQkFBaUI7UUFDdEIsT0FBT0MsV0FBVyxJQUFJLElBQUlBLE9BQU9FLEtBQUssQ0FBQyxJQUFJLEVBQUVDLGNBQWMsSUFBSTtJQUNuRTtJQUNBSixlQUFlSyxTQUFTLENBQUNDLFVBQVUsR0FBRyxXQUFZO1FBQzlDLE9BQU87WUFDSEMsUUFBUSxDQUFDO1lBQ1RDLE9BQU8sQ0FBQztRQUNaO0lBQ0o7SUFDQVIsZUFBZUssU0FBUyxDQUFDSSxrQkFBa0IsR0FBRyxTQUFVQyxRQUFRLEVBQUU7UUFDOUQsSUFBSUEsU0FBU0gsTUFBTSxFQUFFO1lBQ2pCLE9BQU87Z0JBQUM7YUFBUztRQUNyQixDQUFDO1FBQ0QsT0FBTztZQUFDO1NBQVE7SUFDcEI7SUFDQVAsZUFBZUssU0FBUyxDQUFDTSxrQkFBa0IsR0FBRyxTQUFVQyxRQUFRLEVBQUU7UUFDOUQsSUFBSSxDQUFDQSxTQUFTTCxNQUFNLEVBQUU7WUFDbEIsT0FBTztnQkFBQzthQUFRO1FBQ3BCLENBQUM7UUFDRCxJQUFJWCxPQUFPaUIsY0FBYyxDQUFDRCxXQUFXO1lBQ2pDLE9BQU87Z0JBQUM7Z0JBQVM7YUFBUztRQUM5QixDQUFDO1FBQ0QsT0FBTztZQUFDO1NBQVM7SUFDckI7SUFDQSxPQUFPWjtBQUNYLEVBQUVKLE9BQU9rQixRQUFRO0FBRWpCLElBQUlDLDRC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RWdYLE1BQU07WUFBRTtRQUN4QjtRQUNBQyxjQUFjO1lBQ1YxYixNQUFNO1lBQ055RSxVQUFVO2dCQUFFa1gsT0FBTztZQUFFO1FBQ3pCO0lBQ0o7QUFDSjtBQUVBMWpCLG1CQUFtQixHQUFHNmY7QUFDdEI3Zix5QkFBeUIsR0FBR3FmO0FBQzVCcmYsdUJBQXVCLEdBQUdzaEI7QUFDMUJ0aEIsZ0JBQWdCLEdBQUcyYztBQUNuQjNjLDJCQUEyQixHQUFHd0w7QUFDOUJ4TCxvQkFBb0IsR0FBR2dGO0FBQ3ZCaEYsc0JBQXNCLEdBQUc4ZjtBQUN6QjlmLHNCQUFzQixHQUFHMGdCO0FBQ3pCMWdCLDBCQUEwQixHQUFHdWhCO0FBQzdCdmhCLGtCQUFlLEdBQUcraUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAtZnVsbGNhbGVuZGFyLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvdGltZWdyaWQvbWFpbi5janMuanM/ODVjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMS4zXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMiBBZGFtIFNoYXdcbiovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCdAZnVsbGNhbGVuZGFyL2NvbW1vbicpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBkYXlncmlkID0gcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9kYXlncmlkJyk7XG47XG5cbnZhciBBbGxEYXlTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoQWxsRGF5U3BsaXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWxsRGF5U3BsaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxEYXk6IHt9LFxuICAgICAgICAgICAgdGltZWQ6IHt9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbW9uLmhhc0JnUmVuZGVyaW5nKGV2ZW50RGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnLCAnYWxsRGF5J107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XG4gICAgfTtcbiAgICByZXR1cm4gQWxsRGF5U3BsaXR0ZXI7XG59KGNvbW1vbi5TcGxpdHRlcikpO1xuXG52YXIgREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFwcm9wcy5pc0xhYmVsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCB2aWV3QXBpID0gY29udGV4dC52aWV3QXBpO1xuICAgICAgICB2YXIgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY29tbW9uLmNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdFswXSkgOlxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5SZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLnNsb3RMYWJlbENsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuc2xvdExhYmVsQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYWJlbFdpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbiBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5cbnZhciBUaW1lQm9keUF4aXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVCb2R5QXhpcywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQm9keUF4aXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGltZUJvZHlBeGlzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCB0c2xpYi5fX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSkpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQm9keUF4aXM7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5cbnZhciBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNvbW1vbi5jcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xudmFyIEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUyA9IDU7XG52YXIgVGltZUNvbHNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc1ZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIF90aGlzLmhlYWRlckVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbGVyRWxSZWYgPSBjb21tb24uY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlckVsID0gX3RoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgX3RoaXMucmVuZGVySGVhZEF4aXMgPSBmdW5jdGlvbiAocm93S2V5LCBmcmFtZUhlaWdodCkge1xuICAgICAgICAgICAgaWYgKGZyYW1lSGVpZ2h0ID09PSB2b2lkIDApIHsgZnJhbWVIZWlnaHQgPSAnJzsgfVxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBfdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgdmFyIGRheUNudCA9IGNvbW1vbi5kaWZmRGF5cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKSAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgICAgICA/IGNvbW1vbi5idWlsZE5hdkxpbmtBdHRycyhfdGhpcy5jb250ZXh0LCByYW5nZS5zdGFydCwgJ3dlZWsnKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53ZWVrTnVtYmVycyAmJiByb3dLZXkgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uV2Vla051bWJlclJvb3QsIHsgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGhcIiwgeyByZWY6IHJvb3RFbFJlZiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluaycsXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgbmF2TGlua0F0dHJzKSwgaW5uZXJDb250ZW50KSkpKTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRoXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgX3RoaXMucmVuZGVyVGFibGVSb3dBeGlzID0gZnVuY3Rpb24gKHJvd0hlaWdodCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHZpZXdBcGkgPSBfYS52aWV3QXBpO1xuICAgICAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5SZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmFsbERheUNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlckFsbERheUlubmVyLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHJlZjogcm9vdEVsUmVmLCBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluaycsXG4gICAgICAgICAgICAgICAgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyArIChyb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2xhdENvb3JkcyA9IGZ1bmN0aW9uIChzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHM6IHNsYXRDb29yZHMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gcmVuZGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVyU2ltcGxlTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gY29tbW9uLmdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMsIGVsUmVmOiB0aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCByZWY6IHJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVySFNjcm9sbExheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCBzbGF0Q29vcmRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgY29tbW9uLmdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIHZhciBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgY29tbW9uLmdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBfdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpOyB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBfdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMoY29udGVudEFyZy5yb3dTeW5jSGVpZ2h0c1swXSkpKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhbGxEYXlDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1kYXktZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWNodW5rXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVCb2R5QXhpcywgeyBzbGF0TWV0YXM6IHNsYXRNZXRhcyB9KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Ob3dUaW1lciwgeyB1bml0OiBpc05vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgLyogaGFja3kgKi8gfSwgZnVuY3Rpb24gKG5vd0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vd0luZGljYXRvclRvcCA9IGlzTm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGF0Q29vcmRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKG5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkpOyB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tbW9uLnJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29tbW9uLnJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjLCBlbFJlZjogdGhpcy5yb290RWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogZmFsc2UsIGNvbEdyb3VwczogW1xuICAgICAgICAgICAgICAgICAgICB7IHdpZHRoOiAnc2hyaW5rJywgY29sczogW3sgd2lkdGg6ICdzaHJpbmsnIH1dIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfSxcbiAgICAgICAgICAgICAgICBdLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgLyogRGltZW5zaW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgVGltZUNvbHNWaWV3LnByb3RvdHlwZS5nZXRBbGxEYXlNYXhFdmVudFByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQub3B0aW9ucywgZGF5TWF4RXZlbnRzID0gX2EuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MgPSBfYS5kYXlNYXhFdmVudFJvd3M7XG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7IC8vIGlzIGF1dG8/XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1M7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1ZpZXc7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihob29rUHJvcHMpIHtcbiAgICByZXR1cm4gaG9va1Byb3BzLnRleHQ7XG59XG5cbnZhciBUaW1lQ29sc1NsYXRzQ29vcmRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzU2xhdHNDb29yZHMocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5zYWZlQ29tcHV0ZVRvcCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIGlmIChjb21tb24ucmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZkRheURhdGUgPSBjb21tb24uc3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgIHZhciB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gY29tbW9uLmFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSkgJiZcbiAgICAgICAgICAgICAgICB0aW1lTXMgPCBjb21tb24uYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNvbW1vbi5jcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5jb21wdXRlRGF0ZVRvcCA9IGZ1bmN0aW9uICh3aGVuLCBzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICBpZiAoIXN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgICAgICBzdGFydE9mRGF5RGF0ZSA9IGNvbW1vbi5zdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNvbW1vbi5jcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH07XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXG4gICAgLy8gVGhpcyBpcyBhIG1ha2VzaGlmeSB3YXkgdG8gY29tcHV0ZSB0aGUgdGltZS10b3AuIEFzc3VtZXMgYWxsIHNsYXRNZXRhcyBkYXRlcyBhcmUgdW5pZm9ybS5cbiAgICAvLyBFdmVudHVhbGx5IGFsbG93IGNvbXB1dGF0aW9uIHdpdGggYXJiaXJhcnkgc2xhdCBkYXRlcy5cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5jb21wdXRlVGltZVRvcCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwb3NpdGlvbnMgPSBfYS5wb3NpdGlvbnMsIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gY29tbW9uLmFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSkpIC8gY29tbW9uLmFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIHZhciBzbGF0SW5kZXg7XG4gICAgICAgIHZhciBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzQ29vcmRzO1xufSgpKTtcblxudmFyIFRpbWVDb2xzU2xhdHNCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc1NsYXRzQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBzbGF0RWxSZWZzID0gcHJvcHMuc2xhdEVsUmVmcztcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgIHNsYXRNZXRhLmlzTGFiZWxlZCA/ICcnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCB0c2xpYi5fX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuc2xvdExhbmVDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLnNsb3RMYW5lQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMuc2xvdExhbmVEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhbmVXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBzbGF0TWV0YS5pc29UaW1lU3RyIH0sIGlubmVyQ29udGVudCkpOyB9KSkpO1xuICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzU2xhdHNCb2R5O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG52YXIgVGltZUNvbHNTbGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGltZUNvbHNTbGF0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zbGF0RWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5taW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlIC8qIHJlbGllcyBvbiB0aGVyZSBvbmx5IGJlaW5nIGEgc2luZ2xlIDxjb2w+IGZvciB0aGUgYXhpcyAqLyxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH07XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRpbWVDb2xzU2xhdHMucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0U2xhdEVscyh0aGlzLnNsYXRFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuc2xhdE1ldGFzKSwgZmFsc2UsIHRydWUpLCB0aGlzLnByb3BzLmRhdGVQcm9maWxlLCBjb250ZXh0Lm9wdGlvbnMuc2xvdER1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xuICAgIHJldHVybiBzbGF0TWV0YXMubWFwKGZ1bmN0aW9uIChzbGF0TWV0YSkgeyByZXR1cm4gZWxNYXBbc2xhdE1ldGEua2V5XTsgfSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIHZhciBzZWdzQnlDb2wgPSBbXTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xuICAgIH1cbiAgICBpZiAoc2Vncykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzQnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlDb2wodWksIGNvbENudCkge1xuICAgIHZhciBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHVpLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gX2FbX2ldO1xuICAgICAgICAgICAgYnlSb3dbc2VnLmNvbF0uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG52YXIgVGltZUNvbE1vcmVMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sTW9yZUxpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbE1vcmVMaW5rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xNb3JlTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Nb3JlTGlua1Jvb3QsIHsgYWxsRGF5RGF0ZTogbnVsbCwgbW9yZUNudDogcHJvcHMuaGlkZGVuU2Vncy5sZW5ndGgsIGFsbFNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGFsaWdubWVudEVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgcG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHByb3BzLmhpZGRlblNlZ3MsIHByb3BzKTsgfSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhhbmRsZUNsaWNrLCB0aXRsZSwgaXNFeHBhbmRlZCwgcG9wb3ZlcklkKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgcmVmOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBjb21tb24uc2V0UmVmKHJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgICAgIGNvbW1vbi5zZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9LCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBwcm9wcy50b3AsIGJvdHRvbTogcHJvcHMuYm90dG9tIH0sIG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCB0aXRsZTogdGl0bGUsIFwiYXJpYS1leHBhbmRlZFwiOiBpc0V4cGFuZGVkLCBcImFyaWEtY29udHJvbHNcIjogcG9wb3ZlcklkIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lciBmYy1zdGlja3lcIiB9LCBpbm5lckNvbnRlbnQpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sTW9yZUxpbms7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnNob3J0VGV4dDtcbn1cblxuLy8gc2VnSW5wdXRzIGFzc3VtZWQgc29ydGVkXG5mdW5jdGlvbiBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgc3RyaWN0T3JkZXIsIG1heFN0YWNrQ250KSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IG5ldyBjb21tb24uU2VnSGllcmFyY2h5KCk7XG4gICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgfVxuICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xuICAgIH1cbiAgICB2YXIgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgdmFyIGhpZGRlbkdyb3VwcyA9IGNvbW1vbi5ncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgdmFyIHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgdmFyIHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzOiBzZWdSZWN0cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIHZhciBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgYnVpbGROb2RlID0gY2FjaGVhYmxlKGZ1bmN0aW9uIChsZXZlbCwgbGF0ZXJhbCkgeyByZXR1cm4gbGV2ZWwgKyAnOicgKyBsYXRlcmFsOyB9LCBmdW5jdGlvbiAobGV2ZWwsIGxhdGVyYWwpIHtcbiAgICAgICAgdmFyIHNpYmxpbmdSYW5nZSA9IGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgbGV2ZWwsIGxhdGVyYWwpO1xuICAgICAgICB2YXIgbmV4dExldmVsUmVzID0gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNCeUxldmVsW2xldmVsXVtsYXRlcmFsXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICB2YXIgbGV2ZWwgPSBzaWJsaW5nUmFuZ2UubGV2ZWwsIGxhdGVyYWxTdGFydCA9IHNpYmxpbmdSYW5nZS5sYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgPSBzaWJsaW5nUmFuZ2UubGF0ZXJhbEVuZDtcbiAgICB2YXIgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgdmFyIGxldmVsQ29vcmRzID0gaGllcmFyY2h5LmxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCA9IGhpZXJhcmNoeS5lbnRyaWVzQnlMZXZlbDtcbiAgICB2YXIgc3ViamVjdEVudHJ5ID0gZW50cmllc0J5TGV2ZWxbc3ViamVjdExldmVsXVtzdWJqZWN0TGF0ZXJhbF07XG4gICAgdmFyIGFmdGVyU3ViamVjdCA9IGxldmVsQ29vcmRzW3N1YmplY3RMZXZlbF0gKyBzdWJqZWN0RW50cnkudGhpY2tuZXNzO1xuICAgIHZhciBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcbiAgICB2YXIgbGV2ZWwgPSBzdWJqZWN0TGV2ZWw7XG4gICAgLy8gc2tpcCBwYXN0IGxldmVscyB0aGF0IGFyZSB0b28gaGlnaCB1cFxuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2xldmVsXSA8IGFmdGVyU3ViamVjdDsgbGV2ZWwgKz0gMSlcbiAgICAgICAgOyAvLyBkbyBub3RoaW5nXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XG4gICAgICAgIHZhciBlbnRyeSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIHNlYXJjaEluZGV4ID0gY29tbW9uLmJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgY29tbW9uLmdldEVudHJ5U3BhbkVuZCk7XG4gICAgICAgIHZhciBsYXRlcmFsU3RhcnQgPSBzZWFyY2hJbmRleFswXSArIHNlYXJjaEluZGV4WzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgdmFyIGxhdGVyYWxFbmQgPSBsYXRlcmFsU3RhcnQ7XG4gICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgIChlbnRyeSA9IGVudHJpZXNbbGF0ZXJhbEVuZF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgc2VnIGxpc3RcbiAgICAgICAgICAgIGVudHJ5LnNwYW4uc3RhcnQgPCBzdWJqZWN0RW50cnkuc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgIGxhdGVyYWxFbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXJhbFN0YXJ0IDwgbGF0ZXJhbEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGV2ZWw6IGxldmVsLCBsYXRlcmFsU3RhcnQ6IGxhdGVyYWxTdGFydCwgbGF0ZXJhbEVuZDogbGF0ZXJhbEVuZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyZXRjaFdlYih0b3BMZXZlbE5vZGVzLCB0b3RhbFRoaWNrbmVzcykge1xuICAgIHZhciBzdHJldGNoTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykgeyByZXR1cm4gY29tbW9uLmJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSB7XG4gICAgICAgIHZhciBuZXh0TGV2ZWxOb2RlcyA9IG5vZGUubmV4dExldmVsTm9kZXMsIHRoaWNrbmVzcyA9IG5vZGUudGhpY2tuZXNzO1xuICAgICAgICB2YXIgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgdmFyIHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICB2YXIgZW5kQ29vcmQ7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbmV4dExldmVsTm9kZXNfMSA9IG5leHRMZXZlbE5vZGVzOyBfaSA8IG5leHRMZXZlbE5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IG5leHRMZXZlbE5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdOyB9KTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIHZhciByZWN0cyA9IFtdO1xuICAgIHZhciBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgeyByZXR1cm4gY29tbW9uLmJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSB7XG4gICAgICAgIHZhciByZWN0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQ6IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoOiBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgdmFyIHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGtleUZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCkge1xuICAgIGlmIChzbGF0Q29vcmRzID09PSB2b2lkIDApIHsgc2xhdENvb3JkcyA9IG51bGw7IH1cbiAgICBpZiAoZXZlbnRNaW5IZWlnaHQgPT09IHZvaWQgMCkgeyBldmVudE1pbkhlaWdodCA9IDA7IH1cbiAgICB2YXIgdmNvb3JkcyA9IFtdO1xuICAgIGlmIChzbGF0Q29vcmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICB2YXIgc3BhblN0YXJ0ID0gc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGNvbERhdGUpO1xuICAgICAgICAgICAgdmFyIHNwYW5FbmQgPSBNYXRoLm1heChzcGFuU3RhcnQgKyAoZXZlbnRNaW5IZWlnaHQgfHwgMCksIC8vIDooXG4gICAgICAgICAgICBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGNvbERhdGUpKTtcbiAgICAgICAgICAgIHZjb29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoc3BhblN0YXJ0KSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoc3BhbkVuZCksIC8vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmNvb3Jkcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgLy8gbWlnaHQgbm90IGhhdmUgZm9yIGV2ZXJ5IHNlZ1xuZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjaykge1xuICAgIHZhciBzZWdJbnB1dHMgPSBbXTtcbiAgICB2YXIgZHVtYlNlZ3MgPSBbXTsgLy8gc2VncyB3aXRob3V0IGNvb3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmNvb3JkcyA9IHNlZ1ZDb29yZHNbaV07XG4gICAgICAgIGlmICh2Y29vcmRzKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgICAgIHNwYW46IHZjb29yZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1bWJTZWdzLnB1c2goc2Vnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spLCBzZWdSZWN0cyA9IF9hLnNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgPSBfYS5oaWRkZW5Hcm91cHM7XG4gICAgdmFyIHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ1JlY3RzXzEgPSBzZWdSZWN0czsgX2kgPCBzZWdSZWN0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnUmVjdCA9IHNlZ1JlY3RzXzFbX2ldO1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgc2VnOiBzZWdzW3NlZ1JlY3QuaW5kZXhdLFxuICAgICAgICAgICAgcmVjdDogc2VnUmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgZHVtYlNlZ3NfMSA9IGR1bWJTZWdzOyBfYiA8IGR1bWJTZWdzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBkdW1iU2VnID0gZHVtYlNlZ3NfMVtfYl07XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50czogc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cblxudmFyIERFRkFVTFRfVElNRV9GT1JNQVQgPSBjb21tb24uY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgbWVyaWRpZW06IGZhbHNlLFxufSk7XG52YXIgVGltZUNvbEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy10aW1lZ3JpZC1ldmVudCcsXG4gICAgICAgICAgICAnZmMtdi1ldmVudCcsXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlzU2hvcnQpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5TdGFuZGFyZEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCwgZXh0cmFDbGFzc05hbWVzOiBjbGFzc05hbWVzIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbEV2ZW50O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGltZUNvbE1pc2MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVDb2xNaXNjLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xNaXNjKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRpbWVDb2xNaXNjLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUNlbGxDb250ZW50LCB7IGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1taXNjXCIsIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xNaXNjO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGltZUNvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGltZUNvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc29ydEV2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKGNvbW1vbi5zb3J0RXZlbnRTZWdzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtZW1vaXplIGV2ZW50LXBsYWNlbWVudD9cbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgaXNTZWxlY3RNaXJyb3IgPSBjb250ZXh0Lm9wdGlvbnMuc2VsZWN0TWlycm9yO1xuICAgICAgICB2YXIgbWlycm9yU2VncyA9IChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2VncykgfHxcbiAgICAgICAgICAgIChpc1NlbGVjdE1pcnJvciAmJiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncykgfHxcbiAgICAgICAgICAgIFtdO1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcyA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHZhciBzb3J0ZWRGZ1NlZ3MgPSB0aGlzLnNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIGNvbnRleHQub3B0aW9ucy5ldmVudE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRGF5Q2VsbFJvb3QsIHsgZWxSZWY6IHByb3BzLmVsUmVmLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcInRkXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiByb290RWxSZWYsIHJvbGU6IFwiZ3JpZGNlbGxcIiwgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkLWNvbCddLmNvbmNhdChjbGFzc05hbWVzLCBwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLmpvaW4oJyAnKSB9LCBkYXRhQXR0cnMsIHByb3BzLmV4dHJhRGF0YUF0dHJzKSxcbiAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCBfdGhpcy5yZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIF90aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvcikpKSxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIF90aGlzLnJlbmRlck5vd0luZGljYXRvcihwcm9wcy5ub3dJbmRpY2F0b3JTZWdzKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbE1pc2MsIHsgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYUhvb2tQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMgfSkpKSk7IH0pKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzb3J0ZWRGZ1NlZ3MsIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUG9zaXRpb25lZEZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpO1xuICAgIH07XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVyUG9zaXRpb25lZEZnU2VncyA9IGZ1bmN0aW9uIChzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcbiAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dC5vcHRpb25zLCBldmVudE1heFN0YWNrID0gX2EuZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCA9IF9hLmV2ZW50U2hvcnRIZWlnaHQsIGV2ZW50T3JkZXJTdHJpY3QgPSBfYS5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1pbkhlaWdodCA9IF9hLmV2ZW50TWluSGVpZ2h0O1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCBkYXRlID0gX2IuZGF0ZSwgc2xhdENvb3JkcyA9IF9iLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uID0gX2IuZXZlbnRTZWxlY3Rpb24sIHRvZGF5UmFuZ2UgPSBfYi50b2RheVJhbmdlLCBub3dEYXRlID0gX2Iubm93RGF0ZTtcbiAgICAgICAgdmFyIGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgdmFyIHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XG4gICAgICAgIHZhciBfYyA9IGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayksIHNlZ1BsYWNlbWVudHMgPSBfYy5zZWdQbGFjZW1lbnRzLCBoaWRkZW5Hcm91cHMgPSBfYy5oaWRkZW5Hcm91cHM7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKGZ1bmN0aW9uIChzZWdQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2VnUGxhY2VtZW50LnNlZywgcmVjdCA9IHNlZ1BsYWNlbWVudC5yZWN0O1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIHZhciBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gX3RoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIHZhciBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0luc2V0ID8gJyBmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzLWluc2V0JyA6ICcnKSwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGlzU2hvcnQ6IGlzU2hvcnQgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckhpZGRlbkdyb3VwcyA9IGZ1bmN0aW9uIChoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZXh0cmFEYXRlU3BhbiA9IF9hLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UgPSBfYS50b2RheVJhbmdlLCBub3dEYXRlID0gX2Eubm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24gPSBfYS5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnID0gX2EuZXZlbnREcmFnLCBldmVudFJlc2l6ZSA9IF9hLmV2ZW50UmVzaXplO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcChmdW5jdGlvbiAoaGlkZGVuR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICB2YXIgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGNvbW1vbi5idWlsZElzb1N0cmluZyhjb21tb24uY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckZpbGxTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKGZ1bmN0aW9uICh2Y29vcmRzLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGNvbW1vbi5idWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogY29tcHV0ZVNlZ1ZTdHlsZSh2Y29vcmRzKSB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkJnRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlLCBwcm9wcy5ub3dEYXRlKSkpIDpcbiAgICAgICAgICAgICAgICBjb21tb24ucmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uIChzZWdzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNsYXRDb29yZHMgPSBfYS5zbGF0Q29vcmRzLCBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5tYXAoZnVuY3Rpb24gKHNlZywgaSkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5Ob3dJbmRpY2F0b3JSb290LCB7IGlzQXhpczogZmFsc2UsIGRhdGU6IGRhdGUsIFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5lJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF0ZSkgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpOyB9KTtcbiAgICB9O1xuICAgIFRpbWVDb2wucHJvdG90eXBlLmNvbXB1dGVTZWdIU3R5bGUgPSBmdW5jdGlvbiAoc2VnSENvb3Jkcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGlzUnRsID0gX2EuaXNSdGwsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgc2hvdWxkT3ZlcmxhcCA9IG9wdGlvbnMuc2xvdEV2ZW50T3ZlcmxhcDtcbiAgICAgICAgdmFyIG5lYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgdmFyIGZhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkICsgc2VnSENvb3Jkcy50aGlja25lc3M7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIHZhciBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG4gICAgICAgICAgICBmYXJDb29yZCA9IE1hdGgubWluKDEsIG5lYXJDb29yZCArIChmYXJDb29yZCAtIG5lYXJDb29yZCkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IG5lYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBuZWFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IHNlZ0hDb29yZHMuc3RhY2tEZXB0aCArIDEsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICogMTAwICsgJyUnLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICogMTAwICsgJyUnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiAhc2VnSENvb3Jkcy5zdGFja0ZvcndhcmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cbiAgICAgICAgICAgIHByb3BzW2lzUnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCBfYSkge1xuICAgIHZhciB0b2RheVJhbmdlID0gX2EudG9kYXlSYW5nZSwgbm93RGF0ZSA9IF9hLm5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uID0gX2EuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZyA9IF9hLmV2ZW50RHJhZywgZXZlbnRSZXNpemUgPSBfYS5ldmVudFJlc2l6ZTtcbiAgICB2YXIgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICB9KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZTdHlsZShzZWdWQ29vcmRzKSB7XG4gICAgaWYgKCFzZWdWQ29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogJycsIGJvdHRvbTogJycgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBzZWdWQ29vcmRzLnN0YXJ0LFxuICAgICAgICBib3R0b206IC1zZWdWQ29vcmRzLmVuZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhzZWdFbnRyaWVzLCBhbGxTZWdzKSB7XG4gICAgcmV0dXJuIHNlZ0VudHJpZXMubWFwKGZ1bmN0aW9uIChzZWdFbnRyeSkgeyByZXR1cm4gYWxsU2Vnc1tzZWdFbnRyeS5pbmRleF07IH0pO1xufVxuXG52YXIgVGltZUNvbHNDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUaW1lQ29sc0NvbnRlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNDb250ZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IGNvbW1vbi5tZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gY29tbW9uLm1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICBfdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnREcmFnID0gY29tbW9uLm1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IGNvbW1vbi5tZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBjb21tb24uUmVmTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHNDb250ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgbm93SW5kaWNhdG9yVG9wID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgcHJvcHMuc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChwcm9wcy5ub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgdmFyIGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBiZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJnRXZlbnRTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIG5vd0luZGljYXRvclNlZ3NCeVJvdyA9IHRoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzKHByb3BzLm5vd0luZGljYXRvclNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgY29sQ250KTtcbiAgICAgICAgdmFyIGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGNvbENudCk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWZyYW1lXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiB0cnVlLCBkYXRlOiBwcm9wcy5ub3dEYXRlIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IF90aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBjZWxsLmV4dHJhSG9va1Byb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfSkpKSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc0NvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUudXBkYXRlQ29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0Q2VsbEVscyh0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuY2VsbHMpLCB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHNDb250ZW50O1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gZWxNYXBbY2VsbC5rZXldOyB9KTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgVGltZUNvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRpbWVDb2xzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gY29tbW9uLm1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBfdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgb25TY3JvbGxUb3BSZXF1ZXN0ID0gX3RoaXMucHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0O1xuICAgICAgICAgICAgdmFyIHNsYXRDb29yZHMgPSBfdGhpcy5zdGF0ZS5zbGF0Q29vcmRzO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcF8xID0gTWF0aC5jZWlsKHRvcF8xKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BfMSArPSAxOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFRvcFJlcXVlc3QodG9wXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ29sQ29vcmRzID0gZnVuY3Rpb24gKGNvbENvb3Jkcykge1xuICAgICAgICAgICAgX3RoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gZnVuY3Rpb24gKHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2xhdENvb3Jkczogc2xhdENvb3JkcyB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ib2R5XCIsIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChUaW1lQ29sc0NvbnRlbnQsIHsgY2VsbHM6IHByb3BzLmNlbGxzLCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogcHJvcHMubm93SW5kaWNhdG9yU2VncywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHNsYXRDb29yZHM6IHN0YXRlLnNsYXRDb29yZHMsIG9uQ29sQ29vcmRzOiB0aGlzLmhhbmRsZUNvbENvb3JkcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLmRldGFjaCgpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb2xDb29yZHMgPSB0aGlzLmNvbENvb3JkcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIHNsYXRDb29yZHMgPSB0aGlzLnN0YXRlLnNsYXRDb29yZHM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zKHRoaXMucHJvcHMuc2xvdER1cmF0aW9uLCBvcHRpb25zLnNuYXBEdXJhdGlvbiksIHNuYXBEdXJhdGlvbiA9IF9iLnNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90ID0gX2Iuc25hcHNQZXJTbG90O1xuICAgICAgICB2YXIgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgdmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICB2YXIgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gY29tbW9uLmFkZER1cmF0aW9ucyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgY29tbW9uLm11bHRpcGx5RHVyYXRpb24oc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbmFwRHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IHRzbGliLl9fYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHM7XG59KGNvbW1vbi5EYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIHZhciBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgdmFyIHNuYXBzUGVyU2xvdCA9IGNvbW1vbi53aG9sZURpdmlkZUR1cmF0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbik7XG4gICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbG90RHVyYXRpb247XG4gICAgICAgIHNuYXBzUGVyU2xvdCA9IDE7XG4gICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xuICAgIH1cbiAgICByZXR1cm4geyBzbmFwRHVyYXRpb246IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90OiBzbmFwc1BlclNsb3QgfTtcbn1cblxudmFyIERheVRpbWVDb2xzU2xpY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlUaW1lQ29sc1NsaWNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUaW1lQ29sc1NsaWNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEYXlUaW1lQ29sc1NsaWNlci5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIHZhciBzZWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgc2VnUmFuZ2UgPSBjb21tb24uaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbY29sXSk7XG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzU2xpY2VyO1xufShjb21tb24uU2xpY2VyKSk7XG5cbnZhciBEYXlUaW1lQ29scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGltZUNvbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGltZUNvbHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWlsZERheVJhbmdlcyA9IGNvbW1vbi5tZW1vaXplKGJ1aWxkRGF5UmFuZ2VzKTtcbiAgICAgICAgX3RoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XG4gICAgICAgIF90aGlzLnRpbWVDb2xzUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbCA9IHByb3BzLmRheVRhYmxlTW9kZWw7XG4gICAgICAgIHZhciBpc05vd0luZGljYXRvciA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3I7XG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIH0sIGZ1bmN0aW9uIChub3dEYXRlLCB0b2RheVJhbmdlKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIHRzbGliLl9fYXNzaWduKHsgcmVmOiBfdGhpcy50aW1lQ29sc1JlZiB9LCBfdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogaXNOb3dJbmRpY2F0b3IgJiYgX3RoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBvblNjcm9sbFRvcFJlcXVlc3Q6IHByb3BzLm9uU2Nyb2xsVG9wUmVxdWVzdCwgb25TbGF0Q29vcmRzOiBwcm9wcy5vblNsYXRDb29yZHMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRpbWVDb2xzO1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkYXRlID0gX2FbX2ldO1xuICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxuLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XG52YXIgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICB2YXIgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICB2YXIgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICB2YXIgc2xhdEl0ZXJhdG9yID0gY29tbW9uLmNyZWF0ZUR1cmF0aW9uKDApO1xuICAgIHZhciBsYWJlbEludGVydmFsID0gZXhwbGljaXRMYWJlbEludGVydmFsIHx8IGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG4gICAgdmFyIG1ldGFzID0gW107XG4gICAgd2hpbGUgKGNvbW1vbi5hc1JvdWdoTXMoc2xhdFRpbWUpIDwgY29tbW9uLmFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICB2YXIgaXNMYWJlbGVkID0gY29tbW9uLndob2xlRGl2aWRlRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgbGFiZWxJbnRlcnZhbCkgIT09IG51bGw7XG4gICAgICAgIG1ldGFzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHNsYXRUaW1lLFxuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc29UaW1lU3RyOiBjb21tb24uZm9ybWF0SXNvVGltZVN0cmluZyhkYXRlKSxcbiAgICAgICAgICAgIGlzTGFiZWxlZDogaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBjb21tb24uYWRkRHVyYXRpb25zKHNsYXRUaW1lLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBzbGF0SXRlcmF0b3IgPSBjb21tb24uYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFzO1xufVxuLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxhYmVsSW50ZXJ2YWw7XG4gICAgdmFyIHNsb3RzUGVyTGFiZWw7XG4gICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG4gICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsYWJlbEludGVydmFsID0gY29tbW9uLmNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gY29tbW9uLndob2xlRGl2aWRlRHVyYXRpb25zKGxhYmVsSW50ZXJ2YWwsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIGlmIChzbG90c1BlckxhYmVsICE9PSBudWxsICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xvdER1cmF0aW9uOyAvLyBmYWxsIGJhY2tcbn1cblxudmFyIERheVRpbWVDb2xzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGltZUNvbHNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRpbWVDb2xzVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IGNvbW1vbi5tZW1vaXplKGJ1aWxkVGltZUNvbHNNb2RlbCk7XG4gICAgICAgIF90aGlzLmJ1aWxkU2xhdE1ldGFzID0gY29tbW9uLm1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBfYS5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICB2YXIgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgdmFyIGRheU1pbldpZHRoID0gb3B0aW9ucy5kYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUhlYWRlciwgeyBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5czogdHJ1ZSwgcmVuZGVySW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVySGVhZEF4aXMgOiBudWxsIH0pKTtcbiAgICAgICAgdmFyIGFsbERheUNvbnRlbnQgPSAob3B0aW9ucy5hbGxEYXlTbG90ICE9PSBmYWxzZSkgJiYgKGZ1bmN0aW9uIChjb250ZW50QXJnKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoZGF5Z3JpZC5EYXlUYWJsZSwgdHNsaWIuX19hc3NpZ24oe30sIHNwbGl0UHJvcHMuYWxsRGF5LCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgcmVuZGVyUm93SW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IF90aGlzLnJlbmRlclRhYmxlUm93QXhpcyA6IG51bGwsIHNob3dXZWVrTnVtYmVyczogZmFsc2UsIGV4cGFuZFJvd3M6IGZhbHNlLCBoZWFkZXJBbGlnbkVsUmVmOiBfdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9LCBfdGhpcy5nZXRBbGxEYXlNYXhFdmVudFByb3BzKCkpKSk7IH0pO1xuICAgICAgICB2YXIgdGltZUdyaWRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgdHNsaWIuX19hc3NpZ24oe30sIHNwbGl0UHJvcHMudGltZWQsIHsgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBheGlzOiBoYXNBdHRhY2hlZEF4aXMsIHNsb3REdXJhdGlvbjogb3B0aW9ucy5zbG90RHVyYXRpb24sIHNsYXRNZXRhczogc2xhdE1ldGFzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIHRhYmxlQ29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBvblNsYXRDb29yZHM6IF90aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiBfdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7IH07XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUaW1lQ29sc1ZpZXc7XG59KFRpbWVDb2xzVmlldykpO1xuZnVuY3Rpb24gYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgY29tbW9uLkRheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBjb21tb24uRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGZhbHNlKTtcbn1cblxudmFyIE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBhbGxEYXlTbG90OiBCb29sZWFuLFxufTtcblxudmFyIG1haW4gPSBjb21tb24uY3JlYXRlUGx1Z2luKHtcbiAgICBpbml0aWFsVmlldzogJ3RpbWVHcmlkV2VlaycsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICB2aWV3czoge1xuICAgICAgICB0aW1lR3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUaW1lQ29sc1ZpZXcsXG4gICAgICAgICAgICB1c2VzTWluTWF4VGltZTogdHJ1ZSxcbiAgICAgICAgICAgIGFsbERheVNsb3Q6IHRydWUsXG4gICAgICAgICAgICBzbG90RHVyYXRpb246ICcwMDozMDowMCcsXG4gICAgICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlLCAvLyBhIGJhZCBuYW1lLiBjb25mdXNlZCB3aXRoIG92ZXJsYXAvY29uc3RyYWludCBzeXN0ZW1cbiAgICAgICAgfSxcbiAgICAgICAgdGltZUdyaWREYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkV2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnRzLkRheVRpbWVDb2xzID0gRGF5VGltZUNvbHM7XG5leHBvcnRzLkRheVRpbWVDb2xzU2xpY2VyID0gRGF5VGltZUNvbHNTbGljZXI7XG5leHBvcnRzLkRheVRpbWVDb2xzVmlldyA9IERheVRpbWVDb2xzVmlldztcbmV4cG9ydHMuVGltZUNvbHMgPSBUaW1lQ29scztcbmV4cG9ydHMuVGltZUNvbHNTbGF0c0Nvb3JkcyA9IFRpbWVDb2xzU2xhdHNDb29yZHM7XG5leHBvcnRzLlRpbWVDb2xzVmlldyA9IFRpbWVDb2xzVmlldztcbmV4cG9ydHMuYnVpbGREYXlSYW5nZXMgPSBidWlsZERheVJhbmdlcztcbmV4cG9ydHMuYnVpbGRTbGF0TWV0YXMgPSBidWlsZFNsYXRNZXRhcztcbmV4cG9ydHMuYnVpbGRUaW1lQ29sc01vZGVsID0gYnVpbGRUaW1lQ29sc01vZGVsO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWFpbjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbW1vbiIsInJlcXVpcmUiLCJ0c2xpYiIsImRheWdyaWQiLCJBbGxEYXlTcGxpdHRlciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJvdG90eXBlIiwiZ2V0S2V5SW5mbyIsImFsbERheSIsInRpbWVkIiwiZ2V0S2V5c0ZvckRhdGVTcGFuIiwiZGF0ZVNwYW4iLCJnZXRLZXlzRm9yRXZlbnREZWYiLCJldmVudERlZiIsImhhc0JnUmVuZGVyaW5nIiwiU3BsaXR0ZXIiLCJERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIiwiY3JlYXRlRm9ybWF0dGVyIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJUaW1lQ29sc0F4aXNDZWxsIiwicHJvcHMiLCJjbGFzc05hbWVzIiwiaXNMYWJlbGVkIiwiY3JlYXRlRWxlbWVudCIsIlZpZXdDb250ZXh0VHlwZSIsIkNvbnN1bWVyIiwiY29udGV4dCIsImNsYXNzTmFtZSIsImpvaW4iLCJpc29UaW1lU3RyIiwiZGF0ZUVudiIsIm9wdGlvbnMiLCJ2aWV3QXBpIiwibGFiZWxGb3JtYXQiLCJzbG90TGFiZWxGb3JtYXQiLCJBcnJheSIsImlzQXJyYXkiLCJob29rUHJvcHMiLCJsZXZlbCIsInRpbWUiLCJkYXRlIiwidG9EYXRlIiwidmlldyIsInRleHQiLCJmb3JtYXQiLCJSZW5kZXJIb29rIiwic2xvdExhYmVsQ2xhc3NOYW1lcyIsImNvbnRlbnQiLCJzbG90TGFiZWxDb250ZW50IiwiZGVmYXVsdENvbnRlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJkaWRNb3VudCIsInNsb3RMYWJlbERpZE1vdW50Iiwid2lsbFVubW91bnQiLCJzbG90TGFiZWxXaWxsVW5tb3VudCIsInJvb3RFbFJlZiIsImN1c3RvbUNsYXNzTmFtZXMiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50IiwicmVmIiwiY29uY2F0IiwiVGltZUJvZHlBeGlzIiwicmVuZGVyIiwic2xhdE1ldGFzIiwibWFwIiwic2xhdE1ldGEiLCJrZXkiLCJfX2Fzc2lnbiIsIkJhc2VDb21wb25lbnQiLCJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsIndlZWsiLCJBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MiLCJUaW1lQ29sc1ZpZXciLCJfdGhpcyIsImFsbERheVNwbGl0dGVyIiwiaGVhZGVyRWxSZWYiLCJjcmVhdGVSZWYiLCJzY3JvbGxlckVsUmVmIiwic3RhdGUiLCJzbGF0Q29vcmRzIiwiaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCIsInNjcm9sbFRvcCIsInNjcm9sbGVyRWwiLCJjdXJyZW50IiwicmVuZGVySGVhZEF4aXMiLCJyb3dLZXkiLCJmcmFtZUhlaWdodCIsImRhdGVQcm9maWxlIiwicmFuZ2UiLCJyZW5kZXJSYW5nZSIsImRheUNudCIsImRpZmZEYXlzIiwic3RhcnQiLCJlbmQiLCJuYXZMaW5rQXR0cnMiLCJidWlsZE5hdkxpbmtBdHRycyIsIndlZWtOdW1iZXJzIiwiV2Vla051bWJlclJvb3QiLCJkZWZhdWx0Rm9ybWF0Iiwic3R5bGUiLCJoZWlnaHQiLCJyZW5kZXJUYWJsZVJvd0F4aXMiLCJyb3dIZWlnaHQiLCJfYSIsImFsbERheVRleHQiLCJhbGxEYXlDbGFzc05hbWVzIiwiYWxsRGF5Q29udGVudCIsInJlbmRlckFsbERheUlubmVyIiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsImhhbmRsZVNsYXRDb29yZHMiLCJzZXRTdGF0ZSIsInJlbmRlclNpbXBsZUxheW91dCIsImhlYWRlclJvd0NvbnRlbnQiLCJ0aW1lQ29udGVudCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsInB1c2giLCJ0eXBlIiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50Iiwib3V0ZXJDb250ZW50Iiwicm9sZSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJsaXF1aWQiLCJleHBhbmRSb3dzIiwiQm9vbGVhbiIsIlZpZXdSb290Iiwidmlld1NwZWMiLCJTaW1wbGVTY3JvbGxHcmlkIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsIndpZHRoIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImdldFN0aWNreUZvb3RlclNjcm9sbGJhciIsInN5bmNSb3dIZWlnaHRzIiwiY2h1bmtzIiwiYXJnIiwicm93U3luY0hlaWdodHMiLCJjb250ZW50QXJnIiwiY29sU3BhbiIsImlzTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yIiwiY2xpZW50SGVpZ2h0IiwidGFibGVDb2xHcm91cE5vZGUiLCJOb3dUaW1lciIsInVuaXQiLCJub3dEYXRlIiwibm93SW5kaWNhdG9yVG9wIiwic2FmZUNvbXB1dGVUb3AiLCJOb3dJbmRpY2F0b3JSb290IiwiaXNBeGlzIiwidG9wIiwicmVuZGVyU2Nyb2xsU2hpbSIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsImdldEFsbERheU1heEV2ZW50UHJvcHMiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJ1bmRlZmluZWQiLCJEYXRlQ29tcG9uZW50IiwiVGltZUNvbHNTbGF0c0Nvb3JkcyIsInBvc2l0aW9ucyIsInNsb3REdXJhdGlvbiIsInJhbmdlQ29udGFpbnNNYXJrZXIiLCJjdXJyZW50UmFuZ2UiLCJzdGFydE9mRGF5RGF0ZSIsInN0YXJ0T2ZEYXkiLCJ0aW1lTXMiLCJ2YWx1ZU9mIiwiYXNSb3VnaE1zIiwic2xvdE1pblRpbWUiLCJzbG90TWF4VGltZSIsImNvbXB1dGVUaW1lVG9wIiwiY3JlYXRlRHVyYXRpb24iLCJjb21wdXRlRGF0ZVRvcCIsIndoZW4iLCJkdXJhdGlvbiIsImxlbiIsImVscyIsImxlbmd0aCIsInNsYXRDb3ZlcmFnZSIsIm1pbGxpc2Vjb25kcyIsInNsYXRJbmRleCIsInNsYXRSZW1haW5kZXIiLCJNYXRoIiwibWF4IiwibWluIiwiZmxvb3IiLCJ0b3BzIiwiZ2V0SGVpZ2h0IiwiVGltZUNvbHNTbGF0c0JvZHkiLCJzbGF0RWxSZWZzIiwiaSIsImF4aXMiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsIlRpbWVDb2xzU2xhdHMiLCJSZWZNYXAiLCJ0YWJsZU1pbldpZHRoIiwiY2xpZW50V2lkdGgiLCJtaW5IZWlnaHQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZVNpemluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwib25Db29yZHMiLCJyb290RWwiLCJvZmZzZXRIZWlnaHQiLCJQb3NpdGlvbkNhY2hlIiwiY29sbGVjdFNsYXRFbHMiLCJjdXJyZW50TWFwIiwiZWxNYXAiLCJzcGxpdFNlZ3NCeUNvbCIsInNlZ3MiLCJzZWdzQnlDb2wiLCJjb2wiLCJzcGxpdEludGVyYWN0aW9uQnlDb2wiLCJ1aSIsImJ5Um93IiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJpc0V2ZW50IiwiX2kiLCJzZWciLCJUaW1lQ29sTW9yZUxpbmsiLCJNb3JlTGlua1Jvb3QiLCJhbGxEYXlEYXRlIiwibW9yZUNudCIsImhpZGRlblNlZ3MiLCJhbGxTZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiZXh0cmFEYXRlU3BhbiIsInRvZGF5UmFuZ2UiLCJwb3BvdmVyQ29udGVudCIsInJlbmRlclBsYWluRmdTZWdzIiwiaGFuZGxlQ2xpY2siLCJ0aXRsZSIsImlzRXhwYW5kZWQiLCJwb3BvdmVySWQiLCJlbCIsInNldFJlZiIsImJvdHRvbSIsIm9uQ2xpY2siLCJzaG9ydFRleHQiLCJidWlsZFBvc2l0aW9uaW5nIiwic2VnSW5wdXRzIiwic3RyaWN0T3JkZXIiLCJtYXhTdGFja0NudCIsImhpZXJhcmNoeSIsIlNlZ0hpZXJhcmNoeSIsImhpZGRlbkVudHJpZXMiLCJhZGRTZWdzIiwiaGlkZGVuR3JvdXBzIiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwid2ViIiwiYnVpbGRXZWIiLCJzdHJldGNoV2ViIiwic2VnUmVjdHMiLCJ3ZWJUb1JlY3RzIiwiZW50cmllc0J5TGV2ZWwiLCJidWlsZE5vZGUiLCJjYWNoZWFibGUiLCJsYXRlcmFsIiwic2libGluZ1JhbmdlIiwiZmluZE5leHRMZXZlbFNlZ3MiLCJuZXh0TGV2ZWxSZXMiLCJidWlsZE5vZGVzIiwiZW50cnkiLCJuZXh0TGV2ZWxOb2RlcyIsInRoaWNrbmVzcyIsImxhdGVyYWxTdGFydCIsImxhdGVyYWxFbmQiLCJwYWlycyIsInNvcnQiLCJjbXBEZXNjUHJlc3N1cmVzIiwiZXh0cmFjdE5vZGUiLCJhIiwiYiIsInN1YmplY3RMZXZlbCIsInN1YmplY3RMYXRlcmFsIiwibGV2ZWxDb29yZHMiLCJzdWJqZWN0RW50cnkiLCJhZnRlclN1YmplY3QiLCJsZXZlbENudCIsImVudHJpZXMiLCJzZWFyY2hJbmRleCIsImJpbmFyeVNlYXJjaCIsImdldEVudHJ5U3BhbkVuZCIsInRvcExldmVsTm9kZXMiLCJ0b3RhbFRoaWNrbmVzcyIsInN0cmV0Y2hOb2RlIiwibm9kZSIsInN0YXJ0Q29vcmQiLCJwcmV2VGhpY2tuZXNzIiwiYnVpbGRFbnRyeUtleSIsImFsbFRoaWNrbmVzcyIsInRoaWNrbmVzc0ZyYWN0aW9uIiwiZW5kQ29vcmQiLCJuZXdDaGlsZHJlbiIsIm5leHRMZXZlbE5vZGVzXzEiLCJjaGlsZE5vZGUiLCJyZXMiLCJuZXdUaGlja25lc3MiLCJyZWN0cyIsInByb2Nlc3NOb2RlIiwibGV2ZWxDb29yZCIsInN0YWNrRGVwdGgiLCJyZWN0Iiwic3RhY2tGb3J3YXJkIiwicHJvY2Vzc05vZGVzIiwibm9kZXMiLCJub2Rlc18xIiwia2V5RnVuYyIsIndvcmtGdW5jIiwiY2FjaGUiLCJhcmdzIiwiY29tcHV0ZVNlZ1ZDb29yZHMiLCJjb2xEYXRlIiwiZXZlbnRNaW5IZWlnaHQiLCJ2Y29vcmRzIiwic3BhblN0YXJ0Iiwic3BhbkVuZCIsInJvdW5kIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50cyIsInNlZ1ZDb29yZHMiLCJldmVudE9yZGVyU3RyaWN0IiwiZXZlbnRNYXhTdGFjayIsImR1bWJTZWdzIiwiaW5kZXgiLCJzZWdQbGFjZW1lbnRzIiwic2VnUmVjdHNfMSIsInNlZ1JlY3QiLCJfYiIsImR1bWJTZWdzXzEiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCIsIlRpbWVDb2xFdmVudCIsImlzU2hvcnQiLCJTdGFuZGFyZEV2ZW50IiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJleHRyYUNsYXNzTmFtZXMiLCJUaW1lQ29sTWlzYyIsIkRheUNlbGxDb250ZW50IiwiZXh0cmFIb29rUHJvcHMiLCJUaW1lQ29sIiwic29ydEV2ZW50U2VncyIsIm1lbW9pemUiLCJpc1NlbGVjdE1pcnJvciIsInNlbGVjdE1pcnJvciIsIm1pcnJvclNlZ3MiLCJldmVudERyYWciLCJldmVudFJlc2l6ZSIsImRhdGVTZWxlY3Rpb25TZWdzIiwiaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcyIsInNvcnRlZEZnU2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsIkRheUNlbGxSb290IiwiZGF0YUF0dHJzIiwiZXh0cmFEYXRhQXR0cnMiLCJyZW5kZXJGaWxsU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2VncyIsInJlbmRlckZnU2VncyIsInJlbmRlck5vd0luZGljYXRvciIsIm5vd0luZGljYXRvclNlZ3MiLCJzZWdJc0ludmlzaWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwicmVuZGVyUG9zaXRpb25lZEZnU2VncyIsImV2ZW50U2hvcnRIZWlnaHQiLCJldmVudFNlbGVjdGlvbiIsImlzTWlycm9yIiwiX2MiLCJGcmFnbWVudCIsInJlbmRlckhpZGRlbkdyb3VwcyIsInNlZ1BsYWNlbWVudCIsImluc3RhbmNlSWQiLCJldmVudFJhbmdlIiwiaW5zdGFuY2UiLCJpc1Zpc2libGUiLCJ2U3R5bGUiLCJjb21wdXRlU2VnVlN0eWxlIiwiaFN0eWxlIiwiY29tcHV0ZVNlZ0hTdHlsZSIsImxlZnQiLCJyaWdodCIsImlzSW5zZXQiLCJ2aXNpYmlsaXR5IiwiaXNTZWxlY3RlZCIsImdldFNlZ01ldGEiLCJoaWRkZW5Hcm91cCIsInBvc2l0aW9uQ3NzIiwiY29tcGlsZVNlZ3NGcm9tRW50cmllcyIsImJ1aWxkSXNvU3RyaW5nIiwiY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQiLCJmaWxsVHlwZSIsImNoaWxkcmVuIiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJzZWdIQ29vcmRzIiwiaXNSdGwiLCJzaG91bGRPdmVybGFwIiwic2xvdEV2ZW50T3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiekluZGV4IiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdE5vd0luZGljYXRvclNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwiY2VsbEVsUmVmcyIsImNlbGxzIiwiZmdFdmVudFNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJub3dJbmRpY2F0b3JTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwiY2VsbCIsInVwZGF0ZUNvb3JkcyIsIm9uQ29sQ29vcmRzIiwiY29sbGVjdENlbGxFbHMiLCJUaW1lQ29scyIsInByb2Nlc3NTbG90T3B0aW9ucyIsImhhbmRsZVJvb3RFbCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJyZXF1ZXN0Iiwib25TY3JvbGxUb3BSZXF1ZXN0IiwidG9wXzEiLCJjZWlsIiwiaGFuZGxlQ29sQ29vcmRzIiwiY29sQ29vcmRzIiwib25TbGF0Q29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwicHJldlByb3BzIiwidXBkYXRlIiwiZGV0YWNoIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsInNuYXBEdXJhdGlvbiIsInNuYXBzUGVyU2xvdCIsImNvbEluZGV4IiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4Iiwic2xhdFRvcCIsInNsYXRIZWlnaHQiLCJwYXJ0aWFsIiwibG9jYWxTbmFwSW5kZXgiLCJzbmFwSW5kZXgiLCJkYXlEYXRlIiwiYWRkRHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFkZCIsImRheUVsIiwibGVmdHMiLCJyaWdodHMiLCJsYXllciIsInNuYXBEdXJhdGlvbk92ZXJyaWRlIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJEYXlUaW1lQ29sc1NsaWNlciIsInNsaWNlUmFuZ2UiLCJkYXlSYW5nZXMiLCJzZWdSYW5nZSIsImludGVyc2VjdFJhbmdlcyIsImlzU3RhcnQiLCJpc0VuZCIsIlNsaWNlciIsIkRheVRpbWVDb2xzIiwiYnVpbGREYXlSYW5nZXMiLCJzbGljZXIiLCJ0aW1lQ29sc1JlZiIsImRheVRhYmxlTW9kZWwiLCJzbGljZVByb3BzIiwic2xpY2VOb3dEYXRlIiwicmFuZ2VzIiwiaGVhZGVyRGF0ZXMiLCJTVE9DS19TVUJfRFVSQVRJT05TIiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsImJ1aWxkU2xhdE1ldGFzIiwiZXhwbGljaXRMYWJlbEludGVydmFsIiwiZGF5U3RhcnQiLCJEYXRlIiwic2xhdFRpbWUiLCJzbGF0SXRlcmF0b3IiLCJsYWJlbEludGVydmFsIiwiY29tcHV0ZUxhYmVsSW50ZXJ2YWwiLCJtZXRhcyIsInRvSVNPU3RyaW5nIiwiZm9ybWF0SXNvVGltZVN0cmluZyIsInNsb3RzUGVyTGFiZWwiLCJEYXlUaW1lQ29sc1ZpZXciLCJidWlsZFRpbWVDb2xzTW9kZWwiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInNwbGl0UHJvcHMiLCJzbG90TGFiZWxJbnRlcnZhbCIsImhhc0F0dGFjaGVkQXhpcyIsImhhc0RldGFjaGVkQXhpcyIsImhlYWRlckNvbnRlbnQiLCJkYXlIZWFkZXJzIiwiRGF5SGVhZGVyIiwiZGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsInJlbmRlckludHJvIiwiYWxsRGF5U2xvdCIsIkRheVRhYmxlIiwibmV4dERheVRocmVzaG9sZCIsImNvbEdyb3VwTm9kZSIsInJlbmRlclJvd0ludHJvIiwic2hvd1dlZWtOdW1iZXJzIiwiaGVhZGVyQWxpZ25FbFJlZiIsInRpbWVHcmlkQ29udGVudCIsImRheVNlcmllcyIsIkRheVNlcmllc01vZGVsIiwiRGF5VGFibGVNb2RlbCIsIk9QVElPTl9SRUZJTkVSUyIsIm1haW4iLCJjcmVhdGVQbHVnaW4iLCJpbml0aWFsVmlldyIsIm9wdGlvblJlZmluZXJzIiwidmlld3MiLCJ0aW1lR3JpZCIsImNvbXBvbmVudCIsInVzZXNNaW5NYXhUaW1lIiwidGltZUdyaWREYXkiLCJkYXlzIiwidGltZUdyaWRXZWVrIiwid2Vla3MiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/timegrid/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.css":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.css ***!
  \****************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.css":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.css ***!
  \*****************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@fullcalendar/timegrid/main.css":
/*!******************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.css ***!
  \******************************************************/
/***/ (() => {



/***/ }),

/***/ "@ant-design/icons":
/*!************************************!*\
  !*** external "@ant-design/icons" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@ant-design/icons");

/***/ }),

/***/ "antd":
/*!***********************!*\
  !*** external "antd" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("antd");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/router");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react-infinite-scroll-component":
/*!**************************************************!*\
  !*** external "react-infinite-scroll-component" ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-infinite-scroll-component");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("tslib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./pages/_app.tsx"));
module.exports = __webpack_exports__;

})();