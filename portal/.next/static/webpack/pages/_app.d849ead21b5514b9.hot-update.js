"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./components/Calendar/index.tsx":
/*!***************************************!*\
  !*** ./components/Calendar/index.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Calendar; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/react */ \"./node_modules/@fullcalendar/react/dist/main.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.js\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/interaction */ \"./node_modules/@fullcalendar/interaction/main.js\");\n/* harmony import */ var _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fullcalendar/timegrid */ \"./node_modules/@fullcalendar/timegrid/main.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction Calendar() {\n    _s();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const start = new Date();\n    const end = new Date(new Date().setMinutes(start.getMinutes() + 30));\n    const data = [\n        {\n            title: \"sala 1\",\n            start,\n            end,\n            backgroundColor: \"green\",\n            extendedProps: {\n                id: 1\n            }\n        },\n        {\n            title: \"sala 2\",\n            start: new Date(new Date().setHours(start.getHours() + 1)),\n            end: new Date(new Date().setHours(start.getHours() + 2)),\n            backgroundColor: \"purple\",\n            extendedProps: {\n                id: 2\n            }\n        },\n        {\n            title: \"sala 3\",\n            start: new Date(new Date().setHours(start.getHours() + 2)),\n            end: new Date(new Date().setHours(start.getHours() + 3)),\n            backgroundColor: \"#000\",\n            extendedProps: {\n                id: 3\n            }\n        }\n    ];\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(data);\n    const calendarRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            padding: 20\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            nowIndicator: true,\n            eventClick: (info)=>console.log(info.event.extendedProps, info.event.title),\n            editable: true,\n            views: {\n                dayGrid: {\n                    selectable: true\n                },\n                timeGrid: {\n                    selectable: true\n                },\n                dayGridMonth: {\n                    selectable: false\n                }\n            },\n            ref: calendarRef,\n            plugins: [\n                _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n                _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n            ],\n            initialView: \"timeGridWeek\",\n            eventDrop: (info)=>{\n                const eventFiltered = events.filter((event)=>event.extendedProps.id !== info.event.extendedProps.id);\n                setEvents([\n                    ...eventFiltered,\n                    {\n                        title: info.event.title,\n                        start: info.event.startStr,\n                        end: info.event.endStr,\n                        backgroundColor: info.event.backgroundColor,\n                        extendedProps: {\n                            id: info.event.extendedProps.id\n                        }\n                    }\n                ]);\n                alert(\"Dropped \" + info.event.title);\n            },\n            eventResize: (info)=>{\n                const eventFiltered = events.filter((event)=>event.extendedProps.id !== info.event.extendedProps.id);\n                setEvents([\n                    ...eventFiltered,\n                    {\n                        title: info.event.title,\n                        start: info.event.startStr,\n                        end: info.event.endStr,\n                        backgroundColor: info.event.backgroundColor,\n                        extendedProps: {\n                            id: info.event.extendedProps.id\n                        }\n                    }\n                ]);\n                alert(\"Resized \" + info.event.title);\n            },\n            select: (info)=>{\n                // @ts-ignore\n                setEvents((event)=>{\n                    const newId = events[events.length - 1].extendedProps.id + 1;\n                    return [\n                        ...event,\n                        {\n                            title: \"sala \".concat(newId),\n                            start: info.startStr,\n                            end: info.endStr,\n                            backgroundColor: \"gray\",\n                            extendedProps: {\n                                id: newId\n                            }\n                        }\n                    ];\n                });\n                alert(\"selected \" + info.startStr + \" to \" + info.endStr);\n            },\n            events: events,\n            locale: \"pt-br\",\n            timeZone: \"UTF\",\n            titleFormat: {\n                year: \"numeric\",\n                month: \"long\"\n            },\n            // allDayText={\"24h\"}\n            allDaySlot: false,\n            buttonText: {\n                today: \"Hoje\",\n                month: \"M\\xeas\",\n                week: \"Semana\",\n                day: \"Dia\",\n                list: \"Lista\"\n            },\n            customButtons: {\n                custom1: {\n                    text: \"custom 1\",\n                    click: function() {\n                        alert(\"clicked custom button 1!\");\n                    }\n                },\n                custom2: {\n                    text: \"About page\",\n                    click: function() {\n                        router.push(\"/about\");\n                    }\n                }\n            },\n            headerToolbar: {\n                left: \"dayGridMonth,timeGridWeek,timeGridDay custom1\",\n                center: \"title\",\n                right: \"custom2 today prevYear,prev,next,nextYear\"\n            }\n        }, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Calendar/index.tsx\",\n            lineNumber: 33,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Calendar/index.tsx\",\n        lineNumber: 32,\n        columnNumber: 5\n    }, this);\n}\n_s(Calendar, \"+xgfEd1YqAuwZo1r4dbQPUz7FKU=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter\n    ];\n});\n_c = Calendar;\nvar _c;\n$RefreshReg$(_c, \"Calendar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0NhbGVuZGFyL2luZGV4LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOztBQUE4QztBQUNHO0FBQ1M7QUFDTjtBQUNYO0FBQ0Y7QUFFeEIsU0FBU08sV0FBVzs7SUFDakMsTUFBTUMsU0FBU0Ysc0RBQVNBO0lBRXhCLE1BQU1HLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsTUFBTSxJQUFJRCxLQUFLLElBQUlBLE9BQU9FLFVBQVUsQ0FBQ0gsTUFBTUksVUFBVSxLQUFLO0lBRWhFLE1BQU1DLE9BQU87UUFDWDtZQUNFQyxPQUFPO1lBQVVOO1lBQU9FO1lBQUtLLGlCQUFpQjtZQUFTQyxlQUFlO2dCQUFFQyxJQUFJO1lBQUU7UUFDaEY7UUFDQTtZQUNFSCxPQUFPO1lBQVVOLE9BQU8sSUFBSUMsS0FBSyxJQUFJQSxPQUFPUyxRQUFRLENBQUNWLE1BQU1XLFFBQVEsS0FBSztZQUFLVCxLQUFLLElBQUlELEtBQUssSUFBSUEsT0FBT1MsUUFBUSxDQUFDVixNQUFNVyxRQUFRLEtBQUs7WUFBS0osaUJBQWlCO1lBQVVDLGVBQWU7Z0JBQUVDLElBQUk7WUFBRTtRQUMzTDtRQUNBO1lBQ0VILE9BQU87WUFBVU4sT0FBTyxJQUFJQyxLQUFLLElBQUlBLE9BQU9TLFFBQVEsQ0FBQ1YsTUFBTVcsUUFBUSxLQUFLO1lBQUtULEtBQUssSUFBSUQsS0FBSyxJQUFJQSxPQUFPUyxRQUFRLENBQUNWLE1BQU1XLFFBQVEsS0FBSztZQUFLSixpQkFBaUI7WUFBUUMsZUFBZTtnQkFBRUMsSUFBSTtZQUFFO1FBQ3pMO0tBQ0Q7SUFFRCxNQUFNLENBQUNHLFFBQVFDLFVBQVUsR0FBR2pCLCtDQUFRQSxDQUFDUztJQUdyQyxNQUFNUyxjQUFjbkIsNkNBQU1BLENBQUMsSUFBSTtJQUUvQixxQkFDRSw4REFBQ29CO1FBQUlDLE9BQU87WUFBRUMsU0FBUztRQUFHO2tCQUN4Qiw0RUFBQzFCLDJEQUFZQTtZQUNYMkIsY0FBYyxJQUFJO1lBQ2xCQyxZQUFZLENBQUNDLE9BQVNDLFFBQVFDLEdBQUcsQ0FBQ0YsS0FBS0csS0FBSyxDQUFDZixhQUFhLEVBQUVZLEtBQUtHLEtBQUssQ0FBQ2pCLEtBQUs7WUFDNUVrQixVQUFVLElBQUk7WUFDZEMsT0FBTztnQkFDTEMsU0FBUztvQkFDUEMsWUFBWSxJQUFJO2dCQUNsQjtnQkFDQUMsVUFBVTtvQkFDUkQsWUFBWSxJQUFJO2dCQUNsQjtnQkFDQUUsY0FBYztvQkFDWkYsWUFBWSxLQUFLO2dCQUNuQjtZQUVGO1lBQ0FHLEtBQUtoQjtZQUNMaUIsU0FBUztnQkFBQ3ZDLDZEQUFhQTtnQkFBRUMsaUVBQWlCQTtnQkFBRUMsOERBQWNBO2FBQUM7WUFDM0RzQyxhQUFZO1lBQ1pDLFdBQVcsQ0FBQ2IsT0FBUztnQkFDbkIsTUFBTWMsZ0JBQWdCdEIsT0FBT3VCLE1BQU0sQ0FBQ1osQ0FBQUEsUUFBU0EsTUFBTWYsYUFBYSxDQUFDQyxFQUFFLEtBQUtXLEtBQUtHLEtBQUssQ0FBQ2YsYUFBYSxDQUFDQyxFQUFFO2dCQUNuR0ksVUFBVTt1QkFDTHFCO29CQUNIO3dCQUFFNUIsT0FBT2MsS0FBS0csS0FBSyxDQUFDakIsS0FBSzt3QkFBRU4sT0FBT29CLEtBQUtHLEtBQUssQ0FBQ2EsUUFBUTt3QkFBRWxDLEtBQUtrQixLQUFLRyxLQUFLLENBQUNjLE1BQU07d0JBQUU5QixpQkFBaUJhLEtBQUtHLEtBQUssQ0FBQ2hCLGVBQWU7d0JBQUVDLGVBQWU7NEJBQUVDLElBQUlXLEtBQUtHLEtBQUssQ0FBQ2YsYUFBYSxDQUFDQyxFQUFFO3dCQUFDO29CQUFFO2lCQUNoTDtnQkFFRDZCLE1BQU0sYUFBYWxCLEtBQUtHLEtBQUssQ0FBQ2pCLEtBQUs7WUFDckM7WUFDQWlDLGFBQWEsQ0FBQ25CLE9BQVM7Z0JBQ3JCLE1BQU1jLGdCQUFnQnRCLE9BQU91QixNQUFNLENBQUNaLENBQUFBLFFBQVNBLE1BQU1mLGFBQWEsQ0FBQ0MsRUFBRSxLQUFLVyxLQUFLRyxLQUFLLENBQUNmLGFBQWEsQ0FBQ0MsRUFBRTtnQkFDbkdJLFVBQVU7dUJBQ0xxQjtvQkFDSDt3QkFBRTVCLE9BQU9jLEtBQUtHLEtBQUssQ0FBQ2pCLEtBQUs7d0JBQUVOLE9BQU9vQixLQUFLRyxLQUFLLENBQUNhLFFBQVE7d0JBQUVsQyxLQUFLa0IsS0FBS0csS0FBSyxDQUFDYyxNQUFNO3dCQUFFOUIsaUJBQWlCYSxLQUFLRyxLQUFLLENBQUNoQixlQUFlO3dCQUFFQyxlQUFlOzRCQUFFQyxJQUFJVyxLQUFLRyxLQUFLLENBQUNmLGFBQWEsQ0FBQ0MsRUFBRTt3QkFBQztvQkFBRTtpQkFDaEw7Z0JBQ0Q2QixNQUFNLGFBQWFsQixLQUFLRyxLQUFLLENBQUNqQixLQUFLO1lBQ3JDO1lBRUFrQyxRQUFRLENBQUNwQixPQUFTO2dCQUNoQixhQUFhO2dCQUNiUCxVQUFVVSxDQUFBQSxRQUFTO29CQUNqQixNQUFNa0IsUUFBUTdCLE1BQU0sQ0FBQ0EsT0FBTzhCLE1BQU0sR0FBRyxFQUFFLENBQUNsQyxhQUFhLENBQUNDLEVBQUUsR0FBRztvQkFDM0QsT0FBTzsyQkFDRmM7d0JBQ0g7NEJBQUVqQixPQUFPLFFBQWMsT0FBTm1DOzRCQUFTekMsT0FBT29CLEtBQUtnQixRQUFROzRCQUFFbEMsS0FBS2tCLEtBQUtpQixNQUFNOzRCQUFFOUIsaUJBQWlCOzRCQUFRQyxlQUFlO2dDQUFFQyxJQUFJZ0M7NEJBQU07d0JBQUU7cUJBQUU7Z0JBQzlIO2dCQUNBSCxNQUFNLGNBQWNsQixLQUFLZ0IsUUFBUSxHQUFHLFNBQVNoQixLQUFLaUIsTUFBTTtZQUMxRDtZQUNBekIsUUFBUUE7WUFDUitCLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxhQUFhO2dCQUFFQyxNQUFNO2dCQUFXQyxPQUFPO1lBQU87WUFDOUMscUJBQXFCO1lBQ3JCQyxZQUFZLEtBQUs7WUFDakJDLFlBQVk7Z0JBQ1ZDLE9BQU87Z0JBQ1BILE9BQU87Z0JBQ1BJLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0xDLE1BQU07WUFDUjtZQUNBQyxlQUFlO2dCQUNiQyxTQUFTO29CQUNQQyxNQUFNO29CQUNOQyxPQUFPLFdBQVk7d0JBQ2pCbkIsTUFBTTtvQkFDUjtnQkFDRjtnQkFDQW9CLFNBQVM7b0JBQ1BGLE1BQU07b0JBQ05DLE9BQU8sV0FBWTt3QkFDakIxRCxPQUFPNEQsSUFBSSxDQUFDO29CQUNkO2dCQUNGO1lBQ0Y7WUFDQUMsZUFBZTtnQkFDYkMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsT0FBTztZQUNUOzs7Ozs7Ozs7OztBQUlSLENBQUM7R0EzR3VCakU7O1FBQ1BELGtEQUFTQTs7O0tBREZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQ2FsZW5kYXIvaW5kZXgudHN4Pzk2NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZ1bGxDYWxlbmRhciBmcm9tICdAZnVsbGNhbGVuZGFyL3JlYWN0J1xuaW1wb3J0IGRheUdyaWRQbHVnaW4gZnJvbSAnQGZ1bGxjYWxlbmRhci9kYXlncmlkJ1xuaW1wb3J0IGludGVyYWN0aW9uUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uXCI7XG5pbXBvcnQgdGltZUdyaWRQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvdGltZWdyaWRcIjtcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2FsZW5kYXIoKSB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG5cbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBlbmQgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldE1pbnV0ZXMoc3RhcnQuZ2V0TWludXRlcygpICsgMzApKTtcblxuICBjb25zdCBkYXRhID0gW1xuICAgIHtcbiAgICAgIHRpdGxlOiAnc2FsYSAxJywgc3RhcnQsIGVuZCwgYmFja2dyb3VuZENvbG9yOiBcImdyZWVuXCIsIGV4dGVuZGVkUHJvcHM6IHsgaWQ6IDEgfVxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICdzYWxhIDInLCBzdGFydDogbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycyhzdGFydC5nZXRIb3VycygpICsgMSkpLCBlbmQ6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoc3RhcnQuZ2V0SG91cnMoKSArIDIpKSwgYmFja2dyb3VuZENvbG9yOiBcInB1cnBsZVwiLCBleHRlbmRlZFByb3BzOiB7IGlkOiAyIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnc2FsYSAzJywgc3RhcnQ6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoc3RhcnQuZ2V0SG91cnMoKSArIDIpKSwgZW5kOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKHN0YXJ0LmdldEhvdXJzKCkgKyAzKSksIGJhY2tncm91bmRDb2xvcjogXCIjMDAwXCIsIGV4dGVuZGVkUHJvcHM6IHsgaWQ6IDMgfVxuICAgIH1cbiAgXVxuXG4gIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZShkYXRhKVxuXG5cbiAgY29uc3QgY2FsZW5kYXJSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6IDIwIH19PlxuICAgICAgPEZ1bGxDYWxlbmRhclxuICAgICAgICBub3dJbmRpY2F0b3I9e3RydWV9XG4gICAgICAgIGV2ZW50Q2xpY2s9eyhpbmZvKSA9PiBjb25zb2xlLmxvZyhpbmZvLmV2ZW50LmV4dGVuZGVkUHJvcHMsIGluZm8uZXZlbnQudGl0bGUpfVxuICAgICAgICBlZGl0YWJsZT17dHJ1ZX1cbiAgICAgICAgdmlld3M9e3tcbiAgICAgICAgICBkYXlHcmlkOiB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lR3JpZDoge1xuICAgICAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF5R3JpZE1vbnRoOiB7XG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICB9fVxuICAgICAgICByZWY9e2NhbGVuZGFyUmVmfVxuICAgICAgICBwbHVnaW5zPXtbZGF5R3JpZFBsdWdpbiwgaW50ZXJhY3Rpb25QbHVnaW4sIHRpbWVHcmlkUGx1Z2luXX1cbiAgICAgICAgaW5pdGlhbFZpZXc9XCJ0aW1lR3JpZFdlZWtcIlxuICAgICAgICBldmVudERyb3A9eyhpbmZvKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXZlbnRGaWx0ZXJlZCA9IGV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gZXZlbnQuZXh0ZW5kZWRQcm9wcy5pZCAhPT0gaW5mby5ldmVudC5leHRlbmRlZFByb3BzLmlkKSBhcyBhbnlcbiAgICAgICAgICBzZXRFdmVudHMoW1xuICAgICAgICAgICAgLi4uZXZlbnRGaWx0ZXJlZCxcbiAgICAgICAgICAgIHsgdGl0bGU6IGluZm8uZXZlbnQudGl0bGUsIHN0YXJ0OiBpbmZvLmV2ZW50LnN0YXJ0U3RyLCBlbmQ6IGluZm8uZXZlbnQuZW5kU3RyLCBiYWNrZ3JvdW5kQ29sb3I6IGluZm8uZXZlbnQuYmFja2dyb3VuZENvbG9yLCBleHRlbmRlZFByb3BzOiB7IGlkOiBpbmZvLmV2ZW50LmV4dGVuZGVkUHJvcHMuaWQgfSB9XG4gICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgICBhbGVydCgnRHJvcHBlZCAnICsgaW5mby5ldmVudC50aXRsZSlcbiAgICAgICAgfX1cbiAgICAgICAgZXZlbnRSZXNpemU9eyhpbmZvKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXZlbnRGaWx0ZXJlZCA9IGV2ZW50cy5maWx0ZXIoZXZlbnQgPT4gZXZlbnQuZXh0ZW5kZWRQcm9wcy5pZCAhPT0gaW5mby5ldmVudC5leHRlbmRlZFByb3BzLmlkKSBhcyBhbnlcbiAgICAgICAgICBzZXRFdmVudHMoW1xuICAgICAgICAgICAgLi4uZXZlbnRGaWx0ZXJlZCxcbiAgICAgICAgICAgIHsgdGl0bGU6IGluZm8uZXZlbnQudGl0bGUsIHN0YXJ0OiBpbmZvLmV2ZW50LnN0YXJ0U3RyLCBlbmQ6IGluZm8uZXZlbnQuZW5kU3RyLCBiYWNrZ3JvdW5kQ29sb3I6IGluZm8uZXZlbnQuYmFja2dyb3VuZENvbG9yLCBleHRlbmRlZFByb3BzOiB7IGlkOiBpbmZvLmV2ZW50LmV4dGVuZGVkUHJvcHMuaWQgfSB9XG4gICAgICAgICAgXSlcbiAgICAgICAgICBhbGVydCgnUmVzaXplZCAnICsgaW5mby5ldmVudC50aXRsZSlcbiAgICAgICAgfX1cblxuICAgICAgICBzZWxlY3Q9eyhpbmZvKSA9PiB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHNldEV2ZW50cyhldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV0uZXh0ZW5kZWRQcm9wcy5pZCArIDFcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICB7IHRpdGxlOiBgc2FsYSAke25ld0lkfWAsIHN0YXJ0OiBpbmZvLnN0YXJ0U3RyLCBlbmQ6IGluZm8uZW5kU3RyLCBiYWNrZ3JvdW5kQ29sb3I6IFwiZ3JheVwiLCBleHRlbmRlZFByb3BzOiB7IGlkOiBuZXdJZCB9IH1dXG4gICAgICAgICAgfSlcbiAgICAgICAgICBhbGVydCgnc2VsZWN0ZWQgJyArIGluZm8uc3RhcnRTdHIgKyAnIHRvICcgKyBpbmZvLmVuZFN0cik7XG4gICAgICAgIH19XG4gICAgICAgIGV2ZW50cz17ZXZlbnRzfVxuICAgICAgICBsb2NhbGU9e1wicHQtYnJcIn1cbiAgICAgICAgdGltZVpvbmU9e1wiVVRGXCJ9XG4gICAgICAgIHRpdGxlRm9ybWF0PXt7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9fVxuICAgICAgICAvLyBhbGxEYXlUZXh0PXtcIjI0aFwifVxuICAgICAgICBhbGxEYXlTbG90PXtmYWxzZX1cbiAgICAgICAgYnV0dG9uVGV4dD17e1xuICAgICAgICAgIHRvZGF5OiAnSG9qZScsXG4gICAgICAgICAgbW9udGg6ICdNw6pzJyxcbiAgICAgICAgICB3ZWVrOiAnU2VtYW5hJyxcbiAgICAgICAgICBkYXk6ICdEaWEnLFxuICAgICAgICAgIGxpc3Q6ICdMaXN0YSdcbiAgICAgICAgfX1cbiAgICAgICAgY3VzdG9tQnV0dG9ucz17e1xuICAgICAgICAgIGN1c3RvbTE6IHtcbiAgICAgICAgICAgIHRleHQ6ICdjdXN0b20gMScsXG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhbGVydCgnY2xpY2tlZCBjdXN0b20gYnV0dG9uIDEhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXN0b20yOiB7XG4gICAgICAgICAgICB0ZXh0OiAnQWJvdXQgcGFnZScsXG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByb3V0ZXIucHVzaCgnL2Fib3V0JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAgIGhlYWRlclRvb2xiYXI9e3tcbiAgICAgICAgICBsZWZ0OiAnZGF5R3JpZE1vbnRoLHRpbWVHcmlkV2Vlayx0aW1lR3JpZERheSBjdXN0b20xJyxcbiAgICAgICAgICBjZW50ZXI6ICd0aXRsZScsXG4gICAgICAgICAgcmlnaHQ6ICdjdXN0b20yIHRvZGF5IHByZXZZZWFyLHByZXYsbmV4dCxuZXh0WWVhcidcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJGdWxsQ2FsZW5kYXIiLCJkYXlHcmlkUGx1Z2luIiwiaW50ZXJhY3Rpb25QbHVnaW4iLCJ0aW1lR3JpZFBsdWdpbiIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlUm91dGVyIiwiQ2FsZW5kYXIiLCJyb3V0ZXIiLCJzdGFydCIsIkRhdGUiLCJlbmQiLCJzZXRNaW51dGVzIiwiZ2V0TWludXRlcyIsImRhdGEiLCJ0aXRsZSIsImJhY2tncm91bmRDb2xvciIsImV4dGVuZGVkUHJvcHMiLCJpZCIsInNldEhvdXJzIiwiZ2V0SG91cnMiLCJldmVudHMiLCJzZXRFdmVudHMiLCJjYWxlbmRhclJlZiIsImRpdiIsInN0eWxlIiwicGFkZGluZyIsIm5vd0luZGljYXRvciIsImV2ZW50Q2xpY2siLCJpbmZvIiwiY29uc29sZSIsImxvZyIsImV2ZW50IiwiZWRpdGFibGUiLCJ2aWV3cyIsImRheUdyaWQiLCJzZWxlY3RhYmxlIiwidGltZUdyaWQiLCJkYXlHcmlkTW9udGgiLCJyZWYiLCJwbHVnaW5zIiwiaW5pdGlhbFZpZXciLCJldmVudERyb3AiLCJldmVudEZpbHRlcmVkIiwiZmlsdGVyIiwic3RhcnRTdHIiLCJlbmRTdHIiLCJhbGVydCIsImV2ZW50UmVzaXplIiwic2VsZWN0IiwibmV3SWQiLCJsZW5ndGgiLCJsb2NhbGUiLCJ0aW1lWm9uZSIsInRpdGxlRm9ybWF0IiwieWVhciIsIm1vbnRoIiwiYWxsRGF5U2xvdCIsImJ1dHRvblRleHQiLCJ0b2RheSIsIndlZWsiLCJkYXkiLCJsaXN0IiwiY3VzdG9tQnV0dG9ucyIsImN1c3RvbTEiLCJ0ZXh0IiwiY2xpY2siLCJjdXN0b20yIiwicHVzaCIsImhlYWRlclRvb2xiYXIiLCJsZWZ0IiwiY2VudGVyIiwicmlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Calendar/index.tsx\n"));

/***/ }),

/***/ "./components/Layout/index.tsx":
/*!*************************************!*\
  !*** ./components/Layout/index.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ant-design/icons */ \"./node_modules/@ant-design/icons/es/index.js\");\n/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd */ \"./node_modules/antd/es/index.js\");\n/* harmony import */ var _Calendar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Calendar */ \"./components/Calendar/index.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst { Header , Content  } = antd__WEBPACK_IMPORTED_MODULE_3__.Layout;\nconst items = [\n    {\n        label: \"Calendar\",\n        key: \"1\",\n        icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.AppstoreOutlined, {}, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n            lineNumber: 13,\n            columnNumber: 11\n        }, undefined)\n    },\n    {\n        label: \"Users\",\n        key: \"2\",\n        icon: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__.MailOutlined, {}, void 0, false, {\n            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n            lineNumber: 18,\n            columnNumber: 11\n        }, undefined)\n    }\n];\nconst AppLayout = (param)=>{\n    let { children  } = param;\n    _s();\n    const { token: { colorBgContainer  }  } = antd__WEBPACK_IMPORTED_MODULE_3__.theme.useToken();\n    const [current, setCurrent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"1\");\n    const onClick = (e)=>{\n        setCurrent(e.key);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Layout, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Header, {\n                className: \"header\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Menu, {\n                    theme: \"dark\",\n                    onClick: onClick,\n                    selectedKeys: [\n                        current\n                    ],\n                    mode: \"horizontal\",\n                    items: items\n                }, void 0, false, {\n                    fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                    lineNumber: 36,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Menu, {}, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                lineNumber: 44,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Content, {\n                style: {\n                    padding: \"0 50px\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(antd__WEBPACK_IMPORTED_MODULE_3__.Layout, {\n                    style: {\n                        padding: \"24px 0\",\n                        background: colorBgContainer\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Content, {\n                        style: {\n                            padding: \"0 24px\",\n                            minHeight: 280\n                        },\n                        children: current === \"1\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Calendar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                            fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                            lineNumber: 48,\n                            columnNumber: 33\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                        lineNumber: 47,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                    lineNumber: 46,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n                lineNumber: 45,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/serhiivoloshyn/Desktop/cubex/portal/components/Layout/index.tsx\",\n        lineNumber: 34,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AppLayout, \"MR8OjKByIBPhNzn/AEe1A0NXS0I=\", false, function() {\n    return [\n        antd__WEBPACK_IMPORTED_MODULE_3__.theme.useToken\n    ];\n});\n_c = AppLayout;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AppLayout);\nvar _c;\n$RefreshReg$(_c, \"AppLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0xheW91dC9pbmRleC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFBaUM7QUFDa0M7QUFFeEI7QUFDUjtBQUVuQyxNQUFNLEVBQUVPLE9BQU0sRUFBRUMsUUFBTyxFQUFFLEdBQUdMLHdDQUFNQTtBQUVsQyxNQUFNTSxRQUE0QjtJQUNoQztRQUNFQyxPQUFPO1FBQ1BDLEtBQUs7UUFDTEMsb0JBQU0sOERBQUNYLCtEQUFnQkE7Ozs7O0lBQ3pCO0lBQ0E7UUFDRVMsT0FBTztRQUNQQyxLQUFLO1FBQ0xDLG9CQUFNLDhEQUFDViwyREFBWUE7Ozs7O0lBQ3JCO0NBQ0Q7QUFFRCxNQUFNVyxZQUFtRCxTQUErQztRQUE5QyxFQUFFQyxTQUFRLEVBQStCOztJQUNqRyxNQUFNLEVBQ0pDLE9BQU8sRUFBRUMsaUJBQWdCLEVBQUUsR0FDNUIsR0FBR1gsZ0RBQWM7SUFFbEIsTUFBTSxDQUFDYSxTQUFTQyxXQUFXLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUV2QyxNQUFNb0IsVUFBZ0MsQ0FBQ0MsSUFBTTtRQUMzQ0YsV0FBV0UsRUFBRVYsR0FBRztJQUNsQjtJQUVBLHFCQUNFLDhEQUFDUix3Q0FBTUE7OzBCQUNMLDhEQUFDSTtnQkFBT2UsV0FBVTswQkFDaEIsNEVBQUNsQixzQ0FBSUE7b0JBQ0hDLE9BQU07b0JBQ05lLFNBQVNBO29CQUNURyxjQUFjO3dCQUFDTDtxQkFBUTtvQkFDdkJNLE1BQUs7b0JBQ0xmLE9BQU9BOzs7Ozs7Ozs7OzswQkFHWCw4REFBQ0wsc0NBQUlBOzs7OzswQkFDTCw4REFBQ0k7Z0JBQVFpQixPQUFPO29CQUFFQyxTQUFTO2dCQUFTOzBCQUNsQyw0RUFBQ3ZCLHdDQUFNQTtvQkFBQ3NCLE9BQU87d0JBQUVDLFNBQVM7d0JBQVVDLFlBQVlYO29CQUFpQjs4QkFDL0QsNEVBQUNSO3dCQUFRaUIsT0FBTzs0QkFBRUMsU0FBUzs0QkFBVUUsV0FBVzt3QkFBSTtrQ0FDakRWLFlBQVkscUJBQU8sOERBQUNaLGlEQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNekM7R0FoQ01POztRQUdBUixnREFBY1k7OztLQUhkSjtBQWtDTiwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0xheW91dC9pbmRleC50c3g/NjQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQXBwc3RvcmVPdXRsaW5lZCwgTWFpbE91dGxpbmVkIH0gZnJvbSBcIkBhbnQtZGVzaWduL2ljb25zXCI7XG5pbXBvcnQgdHlwZSB7IE1lbnVQcm9wcyB9IGZyb20gXCJhbnRkXCI7XG5pbXBvcnQgeyBMYXlvdXQsIE1lbnUsIHRoZW1lIH0gZnJvbSBcImFudGRcIjtcbmltcG9ydCBDYWxlbmRhciBmcm9tIFwiLi4vQ2FsZW5kYXJcIjtcblxuY29uc3QgeyBIZWFkZXIsIENvbnRlbnQgfSA9IExheW91dDtcblxuY29uc3QgaXRlbXM6IE1lbnVQcm9wc1tcIml0ZW1zXCJdID0gW1xuICB7XG4gICAgbGFiZWw6IFwiQ2FsZW5kYXJcIixcbiAgICBrZXk6IFwiMVwiLFxuICAgIGljb246IDxBcHBzdG9yZU91dGxpbmVkIC8+LFxuICB9LFxuICB7XG4gICAgbGFiZWw6IFwiVXNlcnNcIixcbiAgICBrZXk6IFwiMlwiLFxuICAgIGljb246IDxNYWlsT3V0bGluZWQgLz4sXG4gIH0sXG5dO1xuXG5jb25zdCBBcHBMYXlvdXQ6IFJlYWN0LkZDPHtjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlfT4gPSAoeyBjaGlsZHJlbiB9OiB7Y2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZX0pID0+IHtcbiAgY29uc3Qge1xuICAgIHRva2VuOiB7IGNvbG9yQmdDb250YWluZXIgfSxcbiAgfSA9IHRoZW1lLnVzZVRva2VuKCk7XG5cbiAgY29uc3QgW2N1cnJlbnQsIHNldEN1cnJlbnRdID0gdXNlU3RhdGUoXCIxXCIpO1xuXG4gIGNvbnN0IG9uQ2xpY2s6IE1lbnVQcm9wc1tcIm9uQ2xpY2tcIl0gPSAoZSkgPT4ge1xuICAgIHNldEN1cnJlbnQoZS5rZXkpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPExheW91dD5cbiAgICAgIDxIZWFkZXIgY2xhc3NOYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgIDxNZW51XG4gICAgICAgICAgdGhlbWU9XCJkYXJrXCJcbiAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgIHNlbGVjdGVkS2V5cz17W2N1cnJlbnRdfVxuICAgICAgICAgIG1vZGU9XCJob3Jpem9udGFsXCJcbiAgICAgICAgICBpdGVtcz17aXRlbXN9XG4gICAgICAgIC8+XG4gICAgICA8L0hlYWRlcj5cbiAgICAgIDxNZW51IC8+XG4gICAgICA8Q29udGVudCBzdHlsZT17eyBwYWRkaW5nOiBcIjAgNTBweFwiIH19PlxuICAgICAgICA8TGF5b3V0IHN0eWxlPXt7IHBhZGRpbmc6IFwiMjRweCAwXCIsIGJhY2tncm91bmQ6IGNvbG9yQmdDb250YWluZXIgfX0+XG4gICAgICAgICAgPENvbnRlbnQgc3R5bGU9e3sgcGFkZGluZzogXCIwIDI0cHhcIiwgbWluSGVpZ2h0OiAyODAgfX0+XG4gICAgICAgICAgICB7Y3VycmVudCA9PT0gXCIxXCIgJiYgPENhbGVuZGFyIC8+fVxuICAgICAgICAgIDwvQ29udGVudD5cbiAgICAgICAgPC9MYXlvdXQ+XG4gICAgICA8L0NvbnRlbnQ+XG4gICAgPC9MYXlvdXQ+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBcHBMYXlvdXQ7XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJBcHBzdG9yZU91dGxpbmVkIiwiTWFpbE91dGxpbmVkIiwiTGF5b3V0IiwiTWVudSIsInRoZW1lIiwiQ2FsZW5kYXIiLCJIZWFkZXIiLCJDb250ZW50IiwiaXRlbXMiLCJsYWJlbCIsImtleSIsImljb24iLCJBcHBMYXlvdXQiLCJjaGlsZHJlbiIsInRva2VuIiwiY29sb3JCZ0NvbnRhaW5lciIsInVzZVRva2VuIiwiY3VycmVudCIsInNldEN1cnJlbnQiLCJvbkNsaWNrIiwiZSIsImNsYXNzTmFtZSIsInNlbGVjdGVkS2V5cyIsIm1vZGUiLCJzdHlsZSIsInBhZGRpbmciLCJiYWNrZ3JvdW5kIiwibWluSGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Layout/index.tsx\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": function() { return /* binding */ BASE_OPTION_DEFAULTS; },\n/* harmony export */   \"BASE_OPTION_REFINERS\": function() { return /* binding */ BASE_OPTION_REFINERS; },\n/* harmony export */   \"BaseComponent\": function() { return /* binding */ BaseComponent; },\n/* harmony export */   \"BgEvent\": function() { return /* binding */ BgEvent; },\n/* harmony export */   \"CalendarApi\": function() { return /* binding */ CalendarApi; },\n/* harmony export */   \"CalendarContent\": function() { return /* binding */ CalendarContent; },\n/* harmony export */   \"CalendarDataManager\": function() { return /* binding */ CalendarDataManager; },\n/* harmony export */   \"CalendarDataProvider\": function() { return /* binding */ CalendarDataProvider; },\n/* harmony export */   \"CalendarRoot\": function() { return /* binding */ CalendarRoot; },\n/* harmony export */   \"ContentHook\": function() { return /* binding */ ContentHook; },\n/* harmony export */   \"CustomContentRenderContext\": function() { return /* binding */ CustomContentRenderContext; },\n/* harmony export */   \"DateComponent\": function() { return /* binding */ DateComponent; },\n/* harmony export */   \"DateEnv\": function() { return /* binding */ DateEnv; },\n/* harmony export */   \"DateProfileGenerator\": function() { return /* binding */ DateProfileGenerator; },\n/* harmony export */   \"DayCellContent\": function() { return /* binding */ DayCellContent; },\n/* harmony export */   \"DayCellRoot\": function() { return /* binding */ DayCellRoot; },\n/* harmony export */   \"DayHeader\": function() { return /* binding */ DayHeader; },\n/* harmony export */   \"DaySeriesModel\": function() { return /* binding */ DaySeriesModel; },\n/* harmony export */   \"DayTableModel\": function() { return /* binding */ DayTableModel; },\n/* harmony export */   \"DelayedRunner\": function() { return /* binding */ DelayedRunner; },\n/* harmony export */   \"ElementDragging\": function() { return /* binding */ ElementDragging; },\n/* harmony export */   \"ElementScrollController\": function() { return /* binding */ ElementScrollController; },\n/* harmony export */   \"Emitter\": function() { return /* binding */ Emitter; },\n/* harmony export */   \"EventApi\": function() { return /* binding */ EventApi; },\n/* harmony export */   \"EventRoot\": function() { return /* binding */ EventRoot; },\n/* harmony export */   \"EventSourceApi\": function() { return /* binding */ EventSourceApi; },\n/* harmony export */   \"Interaction\": function() { return /* binding */ Interaction; },\n/* harmony export */   \"MoreLinkRoot\": function() { return /* binding */ MoreLinkRoot; },\n/* harmony export */   \"MountHook\": function() { return /* binding */ MountHook; },\n/* harmony export */   \"NamedTimeZoneImpl\": function() { return /* binding */ NamedTimeZoneImpl; },\n/* harmony export */   \"NowIndicatorRoot\": function() { return /* binding */ NowIndicatorRoot; },\n/* harmony export */   \"NowTimer\": function() { return /* binding */ NowTimer; },\n/* harmony export */   \"PositionCache\": function() { return /* binding */ PositionCache; },\n/* harmony export */   \"RefMap\": function() { return /* binding */ RefMap; },\n/* harmony export */   \"RenderHook\": function() { return /* binding */ RenderHook; },\n/* harmony export */   \"ScrollController\": function() { return /* binding */ ScrollController; },\n/* harmony export */   \"ScrollResponder\": function() { return /* binding */ ScrollResponder; },\n/* harmony export */   \"Scroller\": function() { return /* binding */ Scroller; },\n/* harmony export */   \"SegHierarchy\": function() { return /* binding */ SegHierarchy; },\n/* harmony export */   \"SimpleScrollGrid\": function() { return /* binding */ SimpleScrollGrid; },\n/* harmony export */   \"Slicer\": function() { return /* binding */ Slicer; },\n/* harmony export */   \"Splitter\": function() { return /* binding */ Splitter; },\n/* harmony export */   \"StandardEvent\": function() { return /* binding */ StandardEvent; },\n/* harmony export */   \"TableDateCell\": function() { return /* binding */ TableDateCell; },\n/* harmony export */   \"TableDowCell\": function() { return /* binding */ TableDowCell; },\n/* harmony export */   \"Theme\": function() { return /* binding */ Theme; },\n/* harmony export */   \"ViewApi\": function() { return /* binding */ ViewApi; },\n/* harmony export */   \"ViewContextType\": function() { return /* binding */ ViewContextType; },\n/* harmony export */   \"ViewRoot\": function() { return /* binding */ ViewRoot; },\n/* harmony export */   \"WeekNumberRoot\": function() { return /* binding */ WeekNumberRoot; },\n/* harmony export */   \"WindowScrollController\": function() { return /* binding */ WindowScrollController; },\n/* harmony export */   \"addDays\": function() { return /* binding */ addDays; },\n/* harmony export */   \"addDurations\": function() { return /* binding */ addDurations; },\n/* harmony export */   \"addMs\": function() { return /* binding */ addMs; },\n/* harmony export */   \"addWeeks\": function() { return /* binding */ addWeeks; },\n/* harmony export */   \"allowContextMenu\": function() { return /* binding */ allowContextMenu; },\n/* harmony export */   \"allowSelection\": function() { return /* binding */ allowSelection; },\n/* harmony export */   \"applyMutationToEventStore\": function() { return /* binding */ applyMutationToEventStore; },\n/* harmony export */   \"applyStyle\": function() { return /* binding */ applyStyle; },\n/* harmony export */   \"applyStyleProp\": function() { return /* binding */ applyStyleProp; },\n/* harmony export */   \"asCleanDays\": function() { return /* binding */ asCleanDays; },\n/* harmony export */   \"asRoughMinutes\": function() { return /* binding */ asRoughMinutes; },\n/* harmony export */   \"asRoughMs\": function() { return /* binding */ asRoughMs; },\n/* harmony export */   \"asRoughSeconds\": function() { return /* binding */ asRoughSeconds; },\n/* harmony export */   \"binarySearch\": function() { return /* binding */ binarySearch; },\n/* harmony export */   \"buildClassNameNormalizer\": function() { return /* binding */ buildClassNameNormalizer; },\n/* harmony export */   \"buildEntryKey\": function() { return /* binding */ buildEntryKey; },\n/* harmony export */   \"buildEventApis\": function() { return /* binding */ buildEventApis; },\n/* harmony export */   \"buildEventRangeKey\": function() { return /* binding */ buildEventRangeKey; },\n/* harmony export */   \"buildHashFromArray\": function() { return /* binding */ buildHashFromArray; },\n/* harmony export */   \"buildIsoString\": function() { return /* binding */ buildIsoString; },\n/* harmony export */   \"buildNavLinkAttrs\": function() { return /* binding */ buildNavLinkAttrs; },\n/* harmony export */   \"buildSegCompareObj\": function() { return /* binding */ buildSegCompareObj; },\n/* harmony export */   \"buildSegTimeText\": function() { return /* binding */ buildSegTimeText; },\n/* harmony export */   \"collectFromHash\": function() { return /* binding */ collectFromHash; },\n/* harmony export */   \"combineEventUis\": function() { return /* binding */ combineEventUis; },\n/* harmony export */   \"compareByFieldSpec\": function() { return /* binding */ compareByFieldSpec; },\n/* harmony export */   \"compareByFieldSpecs\": function() { return /* binding */ compareByFieldSpecs; },\n/* harmony export */   \"compareNumbers\": function() { return /* binding */ compareNumbers; },\n/* harmony export */   \"compareObjs\": function() { return /* binding */ compareObjs; },\n/* harmony export */   \"computeEarliestSegStart\": function() { return /* binding */ computeEarliestSegStart; },\n/* harmony export */   \"computeEdges\": function() { return /* binding */ computeEdges; },\n/* harmony export */   \"computeFallbackHeaderFormat\": function() { return /* binding */ computeFallbackHeaderFormat; },\n/* harmony export */   \"computeHeightAndMargins\": function() { return /* binding */ computeHeightAndMargins; },\n/* harmony export */   \"computeInnerRect\": function() { return /* binding */ computeInnerRect; },\n/* harmony export */   \"computeRect\": function() { return /* binding */ computeRect; },\n/* harmony export */   \"computeSegDraggable\": function() { return /* binding */ computeSegDraggable; },\n/* harmony export */   \"computeSegEndResizable\": function() { return /* binding */ computeSegEndResizable; },\n/* harmony export */   \"computeSegStartResizable\": function() { return /* binding */ computeSegStartResizable; },\n/* harmony export */   \"computeShrinkWidth\": function() { return /* binding */ computeShrinkWidth; },\n/* harmony export */   \"computeSmallestCellWidth\": function() { return /* binding */ computeSmallestCellWidth; },\n/* harmony export */   \"computeVisibleDayRange\": function() { return /* binding */ computeVisibleDayRange; },\n/* harmony export */   \"config\": function() { return /* binding */ config; },\n/* harmony export */   \"constrainPoint\": function() { return /* binding */ constrainPoint; },\n/* harmony export */   \"createAriaClickAttrs\": function() { return /* binding */ createAriaClickAttrs; },\n/* harmony export */   \"createDuration\": function() { return /* binding */ createDuration; },\n/* harmony export */   \"createEmptyEventStore\": function() { return /* binding */ createEmptyEventStore; },\n/* harmony export */   \"createEventInstance\": function() { return /* binding */ createEventInstance; },\n/* harmony export */   \"createEventUi\": function() { return /* binding */ createEventUi; },\n/* harmony export */   \"createFormatter\": function() { return /* binding */ createFormatter; },\n/* harmony export */   \"createPlugin\": function() { return /* binding */ createPlugin; },\n/* harmony export */   \"diffDates\": function() { return /* binding */ diffDates; },\n/* harmony export */   \"diffDayAndTime\": function() { return /* binding */ diffDayAndTime; },\n/* harmony export */   \"diffDays\": function() { return /* binding */ diffDays; },\n/* harmony export */   \"diffPoints\": function() { return /* binding */ diffPoints; },\n/* harmony export */   \"diffWeeks\": function() { return /* binding */ diffWeeks; },\n/* harmony export */   \"diffWholeDays\": function() { return /* binding */ diffWholeDays; },\n/* harmony export */   \"diffWholeWeeks\": function() { return /* binding */ diffWholeWeeks; },\n/* harmony export */   \"disableCursor\": function() { return /* binding */ disableCursor; },\n/* harmony export */   \"elementClosest\": function() { return /* binding */ elementClosest; },\n/* harmony export */   \"elementMatches\": function() { return /* binding */ elementMatches; },\n/* harmony export */   \"enableCursor\": function() { return /* binding */ enableCursor; },\n/* harmony export */   \"eventTupleToStore\": function() { return /* binding */ eventTupleToStore; },\n/* harmony export */   \"filterEventStoreDefs\": function() { return /* binding */ filterEventStoreDefs; },\n/* harmony export */   \"filterHash\": function() { return /* binding */ filterHash; },\n/* harmony export */   \"findDirectChildren\": function() { return /* binding */ findDirectChildren; },\n/* harmony export */   \"findElements\": function() { return /* binding */ findElements; },\n/* harmony export */   \"flexibleCompare\": function() { return /* binding */ flexibleCompare; },\n/* harmony export */   \"formatDate\": function() { return /* binding */ formatDate; },\n/* harmony export */   \"formatDayString\": function() { return /* binding */ formatDayString; },\n/* harmony export */   \"formatIsoTimeString\": function() { return /* binding */ formatIsoTimeString; },\n/* harmony export */   \"formatRange\": function() { return /* binding */ formatRange; },\n/* harmony export */   \"getAllowYScrolling\": function() { return /* binding */ getAllowYScrolling; },\n/* harmony export */   \"getCanVGrowWithinCell\": function() { return /* binding */ getCanVGrowWithinCell; },\n/* harmony export */   \"getClippingParents\": function() { return /* binding */ getClippingParents; },\n/* harmony export */   \"getDateMeta\": function() { return /* binding */ getDateMeta; },\n/* harmony export */   \"getDayClassNames\": function() { return /* binding */ getDayClassNames; },\n/* harmony export */   \"getDefaultEventEnd\": function() { return /* binding */ getDefaultEventEnd; },\n/* harmony export */   \"getElRoot\": function() { return /* binding */ getElRoot; },\n/* harmony export */   \"getElSeg\": function() { return /* binding */ getElSeg; },\n/* harmony export */   \"getEntrySpanEnd\": function() { return /* binding */ getEntrySpanEnd; },\n/* harmony export */   \"getEventClassNames\": function() { return /* binding */ getEventClassNames; },\n/* harmony export */   \"getEventTargetViaRoot\": function() { return /* binding */ getEventTargetViaRoot; },\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": function() { return /* binding */ getIsRtlScrollbarOnLeft; },\n/* harmony export */   \"getRectCenter\": function() { return /* binding */ getRectCenter; },\n/* harmony export */   \"getRelevantEvents\": function() { return /* binding */ getRelevantEvents; },\n/* harmony export */   \"getScrollGridClassNames\": function() { return /* binding */ getScrollGridClassNames; },\n/* harmony export */   \"getScrollbarWidths\": function() { return /* binding */ getScrollbarWidths; },\n/* harmony export */   \"getSectionClassNames\": function() { return /* binding */ getSectionClassNames; },\n/* harmony export */   \"getSectionHasLiquidHeight\": function() { return /* binding */ getSectionHasLiquidHeight; },\n/* harmony export */   \"getSegAnchorAttrs\": function() { return /* binding */ getSegAnchorAttrs; },\n/* harmony export */   \"getSegMeta\": function() { return /* binding */ getSegMeta; },\n/* harmony export */   \"getSlotClassNames\": function() { return /* binding */ getSlotClassNames; },\n/* harmony export */   \"getStickyFooterScrollbar\": function() { return /* binding */ getStickyFooterScrollbar; },\n/* harmony export */   \"getStickyHeaderDates\": function() { return /* binding */ getStickyHeaderDates; },\n/* harmony export */   \"getUnequalProps\": function() { return /* binding */ getUnequalProps; },\n/* harmony export */   \"getUniqueDomId\": function() { return /* binding */ getUniqueDomId; },\n/* harmony export */   \"globalLocales\": function() { return /* binding */ globalLocales; },\n/* harmony export */   \"globalPlugins\": function() { return /* binding */ globalPlugins; },\n/* harmony export */   \"greatestDurationDenominator\": function() { return /* binding */ greatestDurationDenominator; },\n/* harmony export */   \"groupIntersectingEntries\": function() { return /* binding */ groupIntersectingEntries; },\n/* harmony export */   \"guid\": function() { return /* binding */ guid; },\n/* harmony export */   \"hasBgRendering\": function() { return /* binding */ hasBgRendering; },\n/* harmony export */   \"hasShrinkWidth\": function() { return /* binding */ hasShrinkWidth; },\n/* harmony export */   \"identity\": function() { return /* binding */ identity; },\n/* harmony export */   \"interactionSettingsStore\": function() { return /* binding */ interactionSettingsStore; },\n/* harmony export */   \"interactionSettingsToStore\": function() { return /* binding */ interactionSettingsToStore; },\n/* harmony export */   \"intersectRanges\": function() { return /* binding */ intersectRanges; },\n/* harmony export */   \"intersectRects\": function() { return /* binding */ intersectRects; },\n/* harmony export */   \"intersectSpans\": function() { return /* binding */ intersectSpans; },\n/* harmony export */   \"isArraysEqual\": function() { return /* binding */ isArraysEqual; },\n/* harmony export */   \"isColPropsEqual\": function() { return /* binding */ isColPropsEqual; },\n/* harmony export */   \"isDateSelectionValid\": function() { return /* binding */ isDateSelectionValid; },\n/* harmony export */   \"isDateSpansEqual\": function() { return /* binding */ isDateSpansEqual; },\n/* harmony export */   \"isInt\": function() { return /* binding */ isInt; },\n/* harmony export */   \"isInteractionValid\": function() { return /* binding */ isInteractionValid; },\n/* harmony export */   \"isMultiDayRange\": function() { return /* binding */ isMultiDayRange; },\n/* harmony export */   \"isPropsEqual\": function() { return /* binding */ isPropsEqual; },\n/* harmony export */   \"isPropsValid\": function() { return /* binding */ isPropsValid; },\n/* harmony export */   \"isValidDate\": function() { return /* binding */ isValidDate; },\n/* harmony export */   \"joinSpans\": function() { return /* binding */ joinSpans; },\n/* harmony export */   \"listenBySelector\": function() { return /* binding */ listenBySelector; },\n/* harmony export */   \"mapHash\": function() { return /* binding */ mapHash; },\n/* harmony export */   \"memoize\": function() { return /* binding */ memoize; },\n/* harmony export */   \"memoizeArraylike\": function() { return /* binding */ memoizeArraylike; },\n/* harmony export */   \"memoizeHashlike\": function() { return /* binding */ memoizeHashlike; },\n/* harmony export */   \"memoizeObjArg\": function() { return /* binding */ memoizeObjArg; },\n/* harmony export */   \"mergeEventStores\": function() { return /* binding */ mergeEventStores; },\n/* harmony export */   \"multiplyDuration\": function() { return /* binding */ multiplyDuration; },\n/* harmony export */   \"padStart\": function() { return /* binding */ padStart; },\n/* harmony export */   \"parseBusinessHours\": function() { return /* binding */ parseBusinessHours; },\n/* harmony export */   \"parseClassNames\": function() { return /* binding */ parseClassNames; },\n/* harmony export */   \"parseDragMeta\": function() { return /* binding */ parseDragMeta; },\n/* harmony export */   \"parseEventDef\": function() { return /* binding */ parseEventDef; },\n/* harmony export */   \"parseFieldSpecs\": function() { return /* binding */ parseFieldSpecs; },\n/* harmony export */   \"parseMarker\": function() { return /* binding */ parse; },\n/* harmony export */   \"pointInsideRect\": function() { return /* binding */ pointInsideRect; },\n/* harmony export */   \"preventContextMenu\": function() { return /* binding */ preventContextMenu; },\n/* harmony export */   \"preventDefault\": function() { return /* binding */ preventDefault; },\n/* harmony export */   \"preventSelection\": function() { return /* binding */ preventSelection; },\n/* harmony export */   \"rangeContainsMarker\": function() { return /* binding */ rangeContainsMarker; },\n/* harmony export */   \"rangeContainsRange\": function() { return /* binding */ rangeContainsRange; },\n/* harmony export */   \"rangesEqual\": function() { return /* binding */ rangesEqual; },\n/* harmony export */   \"rangesIntersect\": function() { return /* binding */ rangesIntersect; },\n/* harmony export */   \"refineEventDef\": function() { return /* binding */ refineEventDef; },\n/* harmony export */   \"refineProps\": function() { return /* binding */ refineProps; },\n/* harmony export */   \"removeElement\": function() { return /* binding */ removeElement; },\n/* harmony export */   \"removeExact\": function() { return /* binding */ removeExact; },\n/* harmony export */   \"renderChunkContent\": function() { return /* binding */ renderChunkContent; },\n/* harmony export */   \"renderFill\": function() { return /* binding */ renderFill; },\n/* harmony export */   \"renderMicroColGroup\": function() { return /* binding */ renderMicroColGroup; },\n/* harmony export */   \"renderScrollShim\": function() { return /* binding */ renderScrollShim; },\n/* harmony export */   \"requestJson\": function() { return /* binding */ requestJson; },\n/* harmony export */   \"sanitizeShrinkWidth\": function() { return /* binding */ sanitizeShrinkWidth; },\n/* harmony export */   \"setElSeg\": function() { return /* binding */ setElSeg; },\n/* harmony export */   \"setRef\": function() { return /* binding */ setRef; },\n/* harmony export */   \"sliceEventStore\": function() { return /* binding */ sliceEventStore; },\n/* harmony export */   \"sliceEvents\": function() { return /* binding */ sliceEvents; },\n/* harmony export */   \"sortEventSegs\": function() { return /* binding */ sortEventSegs; },\n/* harmony export */   \"startOfDay\": function() { return /* binding */ startOfDay; },\n/* harmony export */   \"translateRect\": function() { return /* binding */ translateRect; },\n/* harmony export */   \"triggerDateSelect\": function() { return /* binding */ triggerDateSelect; },\n/* harmony export */   \"unpromisify\": function() { return /* binding */ unpromisify; },\n/* harmony export */   \"version\": function() { return /* binding */ version; },\n/* harmony export */   \"whenTransitionDone\": function() { return /* binding */ whenTransitionDone; },\n/* harmony export */   \"wholeDivideDurations\": function() { return /* binding */ wholeDivideDurations; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/common/main.css\");\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_main_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/common/vdom.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _vdom_js__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"BASE_OPTION_DEFAULTS\",\"BASE_OPTION_REFINERS\",\"BaseComponent\",\"BgEvent\",\"CalendarApi\",\"CalendarContent\",\"CalendarDataManager\",\"CalendarDataProvider\",\"CalendarRoot\",\"ContentHook\",\"CustomContentRenderContext\",\"DateComponent\",\"DateEnv\",\"DateProfileGenerator\",\"DayCellContent\",\"DayCellRoot\",\"DayHeader\",\"DaySeriesModel\",\"DayTableModel\",\"DelayedRunner\",\"ElementDragging\",\"ElementScrollController\",\"Emitter\",\"EventApi\",\"EventRoot\",\"EventSourceApi\",\"Interaction\",\"MoreLinkRoot\",\"MountHook\",\"NamedTimeZoneImpl\",\"NowIndicatorRoot\",\"NowTimer\",\"PositionCache\",\"RefMap\",\"RenderHook\",\"ScrollController\",\"ScrollResponder\",\"Scroller\",\"SegHierarchy\",\"SimpleScrollGrid\",\"Slicer\",\"Splitter\",\"StandardEvent\",\"TableDateCell\",\"TableDowCell\",\"Theme\",\"ViewApi\",\"ViewContextType\",\"ViewRoot\",\"WeekNumberRoot\",\"WindowScrollController\",\"addDays\",\"addDurations\",\"addMs\",\"addWeeks\",\"allowContextMenu\",\"allowSelection\",\"applyMutationToEventStore\",\"applyStyle\",\"applyStyleProp\",\"asCleanDays\",\"asRoughMinutes\",\"asRoughMs\",\"asRoughSeconds\",\"binarySearch\",\"buildClassNameNormalizer\",\"buildEntryKey\",\"buildEventApis\",\"buildEventRangeKey\",\"buildHashFromArray\",\"buildIsoString\",\"buildNavLinkAttrs\",\"buildSegCompareObj\",\"buildSegTimeText\",\"collectFromHash\",\"combineEventUis\",\"compareByFieldSpec\",\"compareByFieldSpecs\",\"compareNumbers\",\"compareObjs\",\"computeEarliestSegStart\",\"computeEdges\",\"computeFallbackHeaderFormat\",\"computeHeightAndMargins\",\"computeInnerRect\",\"computeRect\",\"computeSegDraggable\",\"computeSegEndResizable\",\"computeSegStartResizable\",\"computeShrinkWidth\",\"computeSmallestCellWidth\",\"computeVisibleDayRange\",\"config\",\"constrainPoint\",\"createAriaClickAttrs\",\"createDuration\",\"createEmptyEventStore\",\"createEventInstance\",\"createEventUi\",\"createFormatter\",\"createPlugin\",\"diffDates\",\"diffDayAndTime\",\"diffDays\",\"diffPoints\",\"diffWeeks\",\"diffWholeDays\",\"diffWholeWeeks\",\"disableCursor\",\"elementClosest\",\"elementMatches\",\"enableCursor\",\"eventTupleToStore\",\"filterEventStoreDefs\",\"filterHash\",\"findDirectChildren\",\"findElements\",\"flexibleCompare\",\"formatDate\",\"formatDayString\",\"formatIsoTimeString\",\"formatRange\",\"getAllowYScrolling\",\"getCanVGrowWithinCell\",\"getClippingParents\",\"getDateMeta\",\"getDayClassNames\",\"getDefaultEventEnd\",\"getElRoot\",\"getElSeg\",\"getEntrySpanEnd\",\"getEventClassNames\",\"getEventTargetViaRoot\",\"getIsRtlScrollbarOnLeft\",\"getRectCenter\",\"getRelevantEvents\",\"getScrollGridClassNames\",\"getScrollbarWidths\",\"getSectionClassNames\",\"getSectionHasLiquidHeight\",\"getSegAnchorAttrs\",\"getSegMeta\",\"getSlotClassNames\",\"getStickyFooterScrollbar\",\"getStickyHeaderDates\",\"getUnequalProps\",\"getUniqueDomId\",\"globalLocales\",\"globalPlugins\",\"greatestDurationDenominator\",\"groupIntersectingEntries\",\"guid\",\"hasBgRendering\",\"hasShrinkWidth\",\"identity\",\"interactionSettingsStore\",\"interactionSettingsToStore\",\"intersectRanges\",\"intersectRects\",\"intersectSpans\",\"isArraysEqual\",\"isColPropsEqual\",\"isDateSelectionValid\",\"isDateSpansEqual\",\"isInt\",\"isInteractionValid\",\"isMultiDayRange\",\"isPropsEqual\",\"isPropsValid\",\"isValidDate\",\"joinSpans\",\"listenBySelector\",\"mapHash\",\"memoize\",\"memoizeArraylike\",\"memoizeHashlike\",\"memoizeObjArg\",\"mergeEventStores\",\"multiplyDuration\",\"padStart\",\"parseBusinessHours\",\"parseClassNames\",\"parseDragMeta\",\"parseEventDef\",\"parseFieldSpecs\",\"parseMarker\",\"pointInsideRect\",\"preventContextMenu\",\"preventDefault\",\"preventSelection\",\"rangeContainsMarker\",\"rangeContainsRange\",\"rangesEqual\",\"rangesIntersect\",\"refineEventDef\",\"refineProps\",\"removeElement\",\"removeExact\",\"renderChunkContent\",\"renderFill\",\"renderMicroColGroup\",\"renderScrollShim\",\"requestJson\",\"sanitizeShrinkWidth\",\"setElSeg\",\"setRef\",\"sliceEventStore\",\"sliceEvents\",\"sortEventSegs\",\"startOfDay\",\"translateRect\",\"triggerDateSelect\",\"unpromisify\",\"version\",\"whenTransitionDone\",\"wholeDivideDurations\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _vdom_js__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \n\n\n\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar EventSourceApi = /** @class */ function() {\n    function EventSourceApi(context, internalEventSource) {\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    EventSourceApi.prototype.remove = function() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    };\n    EventSourceApi.prototype.refetch = function() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    };\n    Object.defineProperty(EventSourceApi.prototype, \"id\", {\n        get: function() {\n            return this.internalEventSource.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"url\", {\n        get: function() {\n            return this.internalEventSource.meta.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"format\", {\n        get: function() {\n            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return EventSourceApi;\n}();\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    var containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    var allMatches = [];\n    for(var i = 0; i < containers.length; i += 1){\n        var matches = containers[i].querySelectorAll(selector);\n        for(var j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    var parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    var allMatches = [];\n    for(var i = 0; i < parents.length; i += 1){\n        var childNodes = parents[i].children; // only ever elements\n        for(var j = 0; j < childNodes.length; j += 1){\n            var childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(var propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = val + \"px\";\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\nfunction getElRoot(el) {\n    return el.getRootNode ? el.getRootNode() : document;\n}\n// Unique ID for DOM attribute\nvar guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return function(ev) {\n        var matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    var attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return function() {\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    var currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, function(mouseOverEv, matchedChild) {\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            var realOnMouseLeave_1 = function(mouseLeaveEv) {\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave_1);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave_1);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nvar transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    var realCallback = function(ev) {\n        callback(ev);\n        transitionEventNames.forEach(function(eventName) {\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach(function(eventName) {\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown: function(ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nvar guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.classList.add(\"fc-unselectable\");\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.classList.remove(\"fc-unselectable\");\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    var specs = [];\n    var tokens = [];\n    var i;\n    var token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    var i;\n    var cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    var s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter.apply(void 0, args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce(function(str, arg, index) {\n            return str.replace(\"$\" + index, arg || \"\");\n        }, formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    var allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    var contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nvar DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    var a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    var m0day = startOfDay(m0);\n    var m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    var d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    var y = marker.getUTCFullYear();\n    var w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    var firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    var dayStart = startOfDay(marker);\n    var days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    var fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    var fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC.apply(Date, a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId: defId,\n        range: range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    var dest = {};\n    if (complexPropsMap) {\n        for(var name_1 in complexPropsMap){\n            var complexObjs = [];\n            // collect the trailing object values, stopping when a non-object is discovered\n            for(var i = propObjs.length - 1; i >= 0; i -= 1){\n                var val = propObjs[i][name_1];\n                if (typeof val === \"object\" && val) {\n                    complexObjs.unshift(val);\n                } else if (val !== undefined) {\n                    dest[name_1] = val; // if there were no objects, this value will be used\n                    break;\n                }\n            }\n            // if the trailing values were objects, use the merged value\n            if (complexObjs.length) {\n                dest[name_1] = mergeProps(complexObjs);\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(var i = propObjs.length - 1; i >= 0; i -= 1){\n        var props = propObjs[i];\n        for(var name_2 in props){\n            if (!(name_2 in dest)) {\n                dest[name_2] = props[name_2];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    var filtered = {};\n    for(var key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    var newHash = {};\n    for(var key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    var hash = {};\n    for(var _i = 0, a_1 = a; _i < a_1.length; _i++){\n        var item = a_1[_i];\n        hash[item] = true;\n    }\n    return hash;\n}\nfunction buildHashFromArray(a, func) {\n    var hash = {};\n    for(var i = 0; i < a.length; i += 1){\n        var tuple = func(a[i], i);\n        hash[tuple[0]] = tuple[1];\n    }\n    return hash;\n}\nfunction hashValuesToArray(obj) {\n    var a = [];\n    for(var key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    var keys = [];\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n    if (equalityFuncs === void 0) {\n        equalityFuncs = {};\n    }\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(var key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(var key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n    if (startIndex === void 0) {\n        startIndex = 0;\n    }\n    if (step === void 0) {\n        step = 1;\n    }\n    var res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(var i = startIndex; i < endIndex; i += step){\n        var val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(var i = 0; i < recurringTypes.length; i += 1){\n        var parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            var allDay = refined.allDay;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay: allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;\n    var defs = eventStore.defs, instances = eventStore.instances;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, function(instance) {\n        return !defs[instance.defId].recurringDef;\n    });\n    for(var defId in defs){\n        var def = defs[defId];\n        if (def.recurringDef) {\n            var duration = def.recurringDef.duration;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for(var _i = 0, starts_1 = starts; _i < starts_1.length; _i++){\n                var start = starts_1[_i];\n                var instance = createEventInstance(defId, {\n                    start: start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nvar INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    var _a;\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject((_a = {}, _a[unit || \"milliseconds\"] = input, _a));\n    }\n    return null;\n}\nfunction parseString(s) {\n    var m = PARSE_RE.exec(s);\n    if (m) {\n        var sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    var duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    var weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    var res = null;\n    for(var i = 0; i < INTERNAL_UNITS.length; i += 1){\n        var unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            var localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    var ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n    if (stripZeroTime === void 0) {\n        stripZeroTime = false;\n    }\n    var s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso) {\n    if (doIso === void 0) {\n        doIso = false;\n    }\n    var sign = minutes < 0 ? \"-\" : \"+\";\n    var abs = Math.abs(minutes);\n    var hours = Math.floor(abs / 60);\n    var mins = Math.round(abs % 60);\n    if (doIso) {\n        return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n    }\n    return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : \"\");\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    var removeCnt = 0;\n    var i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    var len = a0.length;\n    var i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    var currentArgs;\n    var currentRes;\n    return function() {\n        var newArgs = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            newArgs[_i] = arguments[_i];\n        }\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArg;\n    var currentRes;\n    return function(newArg) {\n        if (!currentArg) {\n            currentRes = workerFunc.call(_this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.call(_this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgSets = [];\n    var currentResults = [];\n    return function(newArgSets) {\n        var currentLen = currentArgSets.length;\n        var newLen = newArgSets.length;\n        var i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                var res = workerFunc.apply(_this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgHash = {};\n    var currentResHash = {};\n    return function(newArgHash) {\n        var newResHash = {};\n        for(var key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                var res = workerFunc.apply(_this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nvar COMMA_RE = /,/g; // we need re for globalness\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\nvar UTC_RE = /UTC|GMT/;\nvar NativeFormatter = /** @class */ function() {\n    function NativeFormatter(formatSettings) {\n        var standardDateProps = {};\n        var extendedSettings = {};\n        var severity = 0;\n        for(var name_1 in formatSettings){\n            if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name_1] = formatSettings[name_1];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n            } else {\n                standardDateProps[name_1] = formatSettings[name_1];\n                if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    NativeFormatter.prototype.format = function(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    };\n    NativeFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;\n        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        var biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        var full0 = this.format(start, context);\n        var full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        var partial0 = partialFormattingFunc(start);\n        var partial1 = partialFormattingFunc(end);\n        var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    };\n    NativeFormatter.prototype.getLargestUnit = function() {\n        switch(this.severity){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    };\n    return NativeFormatter;\n}();\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    var standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return function(date) {\n            return formatTimeZoneOffset(date.timeZoneOffset);\n        };\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return function(date) {\n            return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n        };\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps); // copy\n    extendedSettings = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    var zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        var zeroProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return function(date) {\n        var marker = date.marker;\n        var format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        var s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase();\n        });\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase() + \"m\";\n        });\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, function(m0) {\n            return m0.toLocaleLowerCase();\n        });\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    var replaced = false;\n    s = s.replace(UTC_RE, function() {\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += \" \" + tzoStr;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    var parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    var partialOptions = {};\n    for(var name_2 in options){\n        if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n            partialOptions[name_2] = options[name_2];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    var i0 = 0;\n    while(i0 < full0.length){\n        var found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        var before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        var after0 = full0.substr(i0);\n        var i1 = 0;\n        while(i1 < full1.length){\n            var found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            var before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            var after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    var a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    var startInfo = expandZonedMarker(start, context.calendarSystem);\n    var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ var CmdFormatter = /** @class */ function() {\n    function CmdFormatter(cmdStr) {\n        this.cmdStr = cmdStr;\n    }\n    CmdFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    CmdFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return CmdFormatter;\n}();\nvar FuncFormatter = /** @class */ function() {\n    function FuncFormatter(func) {\n        this.func = func;\n    }\n    FuncFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    FuncFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return FuncFormatter;\n}();\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nvar BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    monthMode: Boolean,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nvar BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \" – \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30\n};\n// calendar listeners\n// ------------------\nvar CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nvar CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nvar VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    var refined = {};\n    var extra = {};\n    for(var propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(var propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined: refined,\n        extra: extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n    var eventStore = createEmptyEventStore();\n    var eventRefiners = buildEventRefiners(context);\n    for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n        var rawEvent = rawEvents_1[_i];\n        var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore) {\n    if (eventStore === void 0) {\n        eventStore = createEmptyEventStore();\n    }\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    var instance = eventStore.instances[instanceId];\n    if (instance) {\n        var def_1 = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        var newStore = filterEventStoreDefs(eventStore, function(lookDef) {\n            return isEventDefsGrouped(def_1, lookDef);\n        });\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def_1.defId] = def_1;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.defs), store1.defs),\n        instances: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    var defs = filterHash(eventStore.defs, filterFunc);\n    var instances = filterHash(eventStore.instances, function(instance) {\n        return defs[instance.defId] // still exists?\n        ;\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    var defs = master.defs, instances = master.instances;\n    var filteredDefs = {};\n    var filteredInstances = {};\n    for(var defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(var instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nvar EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nvar EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    var constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nvar EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nvar EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nvar EVENT_REFINERS = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;\n    var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def: def,\n            instance: null\n        };\n    }\n    var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context);\n        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        return {\n            def: def,\n            instance: instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n    var def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: guid(),\n        sourceId: sourceId,\n        allDay: allDay,\n        hasEnd: hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, refined.extendedProps || {}), extra)\n    };\n    for(var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++){\n        var memberAdder = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(def, memberAdder(refined));\n    }\n    // help out EventApi from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    var allDay = refined.allDay;\n    var startMeta;\n    var startMarker = null;\n    var hasEnd = false;\n    var endMeta;\n    var endMarker = null;\n    var startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay: allDay,\n        hasEnd: hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    var res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    var start = startOfDay(timedRange.start);\n    var end = addDays(start, dayCnt);\n    return {\n        start: start,\n        end: end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n    if (nextDayThreshold === void 0) {\n        nextDayThreshold = createDuration(0);\n    }\n    var startDay = null;\n    var endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    var visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nfunction parseRange(input, dateEnv) {\n    var start = null;\n    var end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start: start,\n        end: end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    var invertedRanges = [];\n    var start = constraintRange.start; // the end of the previous range. the start of the new range\n    var i;\n    var dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start: start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start: start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    var start = range0.start, end = range0.end;\n    var newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start: start,\n            end: end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    var inverseBgByGroupId = {};\n    var inverseBgByDefId = {};\n    var defByGroupId = {};\n    var bgRanges = [];\n    var fgRanges = [];\n    var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        var ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = eventStore.defs[instance.defId];\n        var ui = eventUis[def.defId];\n        var origRange = instance.range;\n        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        var slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def: def,\n                    ui: ui,\n                    instance: instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(var groupId in inverseBgByGroupId){\n        var ranges = inverseBgByGroupId[groupId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++){\n            var invertedRange = invertedRanges_1[_i];\n            var def = defByGroupId[groupId];\n            var ui = eventUis[def.defId];\n            bgRanges.push({\n                def: def,\n                ui: ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(var defId in inverseBgByDefId){\n        var ranges = inverseBgByDefId[defId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++){\n            var invertedRange = invertedRanges_2[_a];\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, function(eventDef) {\n        return compileEventUi(eventDef, eventUiBases);\n    });\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    var uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    var objs = segs.map(buildSegCompareObj);\n    objs.sort(function(obj0, obj1) {\n        return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n    });\n    return objs.map(function(c) {\n        return c._seg;\n    });\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    var end = range.end ? range.end.valueOf() : 0; // \"\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start: start,\n        end: end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    var pluginHooks = context.pluginHooks;\n    var transformers = pluginHooks.isDraggableTransformers;\n    var _a = seg.eventRange, def = _a.def, ui = _a.ui;\n    var val = ui.startEditable;\n    for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n        var transformer = transformers_1[_i];\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;\n    var eventDef = seg.eventRange.def;\n    var eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    var wholeEventStart = eventInstance.range.start;\n    var wholeEventEnd = eventInstance.range.end;\n    var segStart = startOverride || seg.start || seg.eventRange.range.start;\n    var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    var segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end < (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    var classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString();\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    var _a = seg.eventRange, def = _a.def, instance = _a.instance;\n    var url = def.url;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    var emitter = context.emitter, options = context.options;\n    var eventInteractive = options.eventInteractive;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs(function(ev) {\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventApi(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nvar STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    var span = parseOpenDateSpan(raw, dateEnv);\n    var range = span.range;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;\n    var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    var allDay = standardProps.allDay;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay: allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(var propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(var propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime: omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime: omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    var res = refineEventDef({\n        editable: false\n    }, context);\n    var def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def: def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    var props = {};\n    for(var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, transform(dateSpan, context));\n    }\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    var dest = createEmptyEventStore();\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    var standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef), standardProps), {\n        ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for(var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++){\n        var applier = _a[_i];\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    var dateEnv = context.dateEnv;\n    var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar ViewApi = /** @class */ function() {\n    function ViewApi(type, getCurrentData, dateEnv) {\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    Object.defineProperty(ViewApi.prototype, \"calendar\", {\n        get: function() {\n            return this.getCurrentData().calendarApi;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"title\", {\n        get: function() {\n            return this.getCurrentData().viewTitle;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewApi.prototype.getOption = function(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    };\n    return ViewApi;\n}();\nvar EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventSourceRefiners(context);\n    }\n    var rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;\n        var metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    for(var i = defs.length - 1; i >= 0; i -= 1){\n        var def = defs[i];\n        var meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta: meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    var initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === \"function\") {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\nvar CalendarApi = /** @class */ function() {\n    function CalendarApi() {}\n    CalendarApi.prototype.getCurrentData = function() {\n        return this.currentDataManager.getCurrentData();\n    };\n    CalendarApi.prototype.dispatch = function(action) {\n        return this.currentDataManager.dispatch(action);\n    };\n    Object.defineProperty(CalendarApi.prototype, \"view\", {\n        get: function() {\n            return this.getCurrentData().viewApi;\n        } // for public API\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    CalendarApi.prototype.batchRendering = function(callback) {\n        callback();\n    };\n    CalendarApi.prototype.updateSize = function() {\n        this.trigger(\"_resize\", true);\n    };\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.setOption = function(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    };\n    CalendarApi.prototype.getOption = function(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    };\n    CalendarApi.prototype.getAvailableLocaleCodes = function() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    };\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.on = function(handlerName, handler) {\n        var currentDataManager = this.currentDataManager;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n        }\n    };\n    CalendarApi.prototype.off = function(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    };\n    // not meant for public use\n    CalendarApi.prototype.trigger = function(handlerName) {\n        var _a;\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this.currentDataManager.emitter).trigger.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            handlerName\n        ], args));\n    };\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.changeView = function(viewType, dateOrRange) {\n        var _this = this;\n        this.batchRendering(function() {\n            _this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType\n                    });\n                    _this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    var dateEnv = _this.getCurrentData().dateEnv;\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                _this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType: viewType\n                });\n            }\n        });\n    };\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    CalendarApi.prototype.zoomTo = function(dateMarker, viewType) {\n        var state = this.getCurrentData();\n        var spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker: dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: dateMarker\n            });\n        }\n    };\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    CalendarApi.prototype.getUnitViewSpec = function(unit) {\n        var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;\n        var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        var i;\n        var spec;\n        for(var viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    };\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.prev = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    };\n    CalendarApi.prototype.next = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    };\n    CalendarApi.prototype.prevYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    };\n    CalendarApi.prototype.nextYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    };\n    CalendarApi.prototype.today = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n        });\n    };\n    CalendarApi.prototype.gotoDate = function(zonedDateInput) {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    };\n    CalendarApi.prototype.incrementDate = function(deltaInput) {\n        var state = this.getCurrentData();\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    };\n    // for external API\n    CalendarApi.prototype.getDate = function() {\n        var state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    };\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.formatDate = function(d, formatter) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    };\n    // `settings` is for formatter AND isEndExclusive\n    CalendarApi.prototype.formatRange = function(d0, d1, settings) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    };\n    CalendarApi.prototype.formatIso = function(d, omitTime) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime: omitTime\n        });\n    };\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    // this public method receives start/end dates in any format, with any timezone\n    // NOTE: args were changed from v3\n    CalendarApi.prototype.select = function(dateOrObj, endDate) {\n        var selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        var state = this.getCurrentData();\n        var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection: selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    };\n    // public method\n    CalendarApi.prototype.unselect = function(pev) {\n        var state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    };\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.addEvent = function(eventInput, sourceInput) {\n        if (eventInput instanceof EventApi) {\n            var def = eventInput._def;\n            var instance = eventInput._instance;\n            var currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def: def,\n                        instance: instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        var state = this.getCurrentData();\n        var eventSource;\n        if (sourceInput instanceof EventSourceApi) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                eventSource = hashValuesToArray(state.eventSources)[0];\n            }\n        } else if (sourceInput != null) {\n            var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn('Could not find an event source with ID \"' + sourceInput + '\"'); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        var tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    };\n    CalendarApi.prototype.triggerEventAdd = function(eventApi) {\n        var _this = this;\n        var emitter = this.getCurrentData().emitter;\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: function() {\n                _this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    };\n    // TODO: optimize\n    CalendarApi.prototype.getEventById = function(id) {\n        var state = this.getCurrentData();\n        var _a = state.eventStore, defs = _a.defs, instances = _a.instances;\n        id = String(id);\n        for(var defId in defs){\n            var def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventApi(state, def, null);\n                }\n                for(var instanceId in instances){\n                    var instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventApi(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.getEvents = function() {\n        var currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    };\n    CalendarApi.prototype.removeAllEvents = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    };\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.getEventSources = function() {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        var sourceApis = [];\n        for(var internalId in sourceHash){\n            sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    };\n    CalendarApi.prototype.getEventSourceById = function(id) {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        id = String(id);\n        for(var sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceApi(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.addEventSource = function(sourceInput) {\n        var state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceApi) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        var eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceApi(state, eventSource);\n        }\n        return null;\n    };\n    CalendarApi.prototype.removeAllEventSources = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    };\n    CalendarApi.prototype.refetchEvents = function() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    };\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.scrollToTime = function(timeInput) {\n        var time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time: time\n            });\n        }\n    };\n    return CalendarApi;\n}();\nvar EventApi = /** @class */ function() {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    function EventApi(context, def, instance) {\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ EventApi.prototype.setProp = function(name, val) {\n        var _a, _b;\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: (_a = {}, _a[name] = val, _a)\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            var ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = (_b = {}, _b[name] = val, _b);\n            }\n            this.mutate({\n                standardProps: {\n                    ui: ui\n                }\n            });\n        } else {\n            console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n        }\n    };\n    EventApi.prototype.setExtendedProp = function(name, val) {\n        var _a;\n        this.mutate({\n            extendedProps: (_a = {}, _a[name] = val, _a)\n        });\n    };\n    EventApi.prototype.setStart = function(startInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            var instanceRange = this._instance.range;\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta: startDelta\n                });\n            }\n        }\n    };\n    EventApi.prototype.setEnd = function(endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta: endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    };\n    EventApi.prototype.setDates = function(startInput, endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var standardProps = {\n            allDay: options.allDay\n        };\n        var start = dateEnv.createMarker(startInput);\n        var end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            var instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps: standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta: startDelta,\n                        endDelta: endDelta,\n                        standardProps: standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps: standardProps\n                });\n            }\n        }\n    };\n    EventApi.prototype.moveStart = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveEnd = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveDates = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.setAllDay = function(allDay, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var standardProps = {\n            allDay: allDay\n        };\n        var maintainDuration = options.maintainDuration;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps: standardProps\n        });\n    };\n    EventApi.prototype.formatRange = function(formatInput) {\n        var dateEnv = this._context.dateEnv;\n        var instance = this._instance;\n        var formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    };\n    EventApi.prototype.mutate = function(mutation) {\n        var instance = this._instance;\n        if (instance) {\n            var def = this._def;\n            var context_1 = this._context;\n            var eventStore_1 = context_1.getCurrentData().eventStore;\n            var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n            var eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n            var oldEvent = new EventApi(context_1, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context_1.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context_1.emitter.trigger(\"eventChange\", {\n                oldEvent: oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n                revert: function() {\n                    context_1.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore: eventStore_1\n                    });\n                }\n            });\n        }\n    };\n    EventApi.prototype.remove = function() {\n        var context = this._context;\n        var asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert: function() {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    };\n    Object.defineProperty(EventApi.prototype, \"source\", {\n        get: function() {\n            var sourceId = this._def.sourceId;\n            if (sourceId) {\n                return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n            }\n            return null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"start\", {\n        get: function() {\n            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"end\", {\n        get: function() {\n            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance) {\n                return this._context.dateEnv.formatIso(instance.range.start, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"endStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance && this._def.hasEnd) {\n                return this._context.dateEnv.formatIso(instance.range.end, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedEndTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"id\", {\n        // computable props that all access the def\n        // TODO: find a TypeScript-compatible way to do this at scale\n        get: function() {\n            return this._def.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"groupId\", {\n        get: function() {\n            return this._def.groupId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allDay\", {\n        get: function() {\n            return this._def.allDay;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"title\", {\n        get: function() {\n            return this._def.title;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"url\", {\n        get: function() {\n            return this._def.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"display\", {\n        get: function() {\n            return this._def.ui.display || \"auto\";\n        } // bad. just normalize the type earlier\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startEditable\", {\n        get: function() {\n            return this._def.ui.startEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n        get: function() {\n            return this._def.ui.durationEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"constraint\", {\n        get: function() {\n            return this._def.ui.constraints[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"overlap\", {\n        get: function() {\n            return this._def.ui.overlap;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allow\", {\n        get: function() {\n            return this._def.ui.allows[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n        get: function() {\n            return this._def.ui.backgroundColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"borderColor\", {\n        get: function() {\n            return this._def.ui.borderColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"textColor\", {\n        get: function() {\n            return this._def.ui.textColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"classNames\", {\n        // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n        get: function() {\n            return this._def.ui.classNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n        get: function() {\n            return this._def.extendedProps;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EventApi.prototype.toPlainObject = function(settings) {\n        if (settings === void 0) {\n            settings = {};\n        }\n        var def = this._def;\n        var ui = def.ui;\n        var _a = this, startStr = _a.startStr, endStr = _a.endStr;\n        var res = {};\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    };\n    EventApi.prototype.toJSON = function() {\n        return this.toPlainObject();\n    };\n    return EventApi;\n}();\nfunction eventApiToStore(eventApi) {\n    var _a, _b;\n    var def = eventApi._def;\n    var instance = eventApi._instance;\n    return {\n        defs: (_a = {}, _a[def.defId] = def, _a),\n        instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    var defs = eventStore.defs, instances = eventStore.instances;\n    var eventApis = [];\n    var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(var id in instances){\n        var instance = instances[id];\n        var def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventApi(context, def, instance));\n        }\n    }\n    return eventApis;\n}\nvar calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nvar GregorianCalendarSystem = /** @class */ function() {\n    function GregorianCalendarSystem() {}\n    GregorianCalendarSystem.prototype.getMarkerYear = function(d) {\n        return d.getUTCFullYear();\n    };\n    GregorianCalendarSystem.prototype.getMarkerMonth = function(d) {\n        return d.getUTCMonth();\n    };\n    GregorianCalendarSystem.prototype.getMarkerDay = function(d) {\n        return d.getUTCDate();\n    };\n    GregorianCalendarSystem.prototype.arrayToMarker = function(arr) {\n        return arrayToUtcDate(arr);\n    };\n    GregorianCalendarSystem.prototype.markerToArray = function(marker) {\n        return dateToUtcArray(marker);\n    };\n    return GregorianCalendarSystem;\n}();\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    var m = ISO_RE.exec(str);\n    if (m) {\n        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n        if (isValidDate(marker)) {\n            var timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker: marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset: timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nvar DateEnv = /** @class */ function() {\n    function DateEnv(settings) {\n        var timeZone = this.timeZone = settings.timeZone;\n        var isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    DateEnv.prototype.createMarker = function(input) {\n        var meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    };\n    DateEnv.prototype.createNowMarker = function() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    };\n    DateEnv.prototype.createMarkerMeta = function(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        var marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    };\n    DateEnv.prototype.parse = function(s) {\n        var parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        var marker = parts.marker;\n        var forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo: forcedTzo\n        };\n    };\n    // Accessors\n    DateEnv.prototype.getYear = function(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    };\n    DateEnv.prototype.getMonth = function(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    };\n    // Adding / Subtracting\n    DateEnv.prototype.add = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.subtract = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addYears = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addMonths = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    // Diffing Whole Units\n    DateEnv.prototype.diffWholeYears = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    };\n    DateEnv.prototype.diffWholeMonths = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    };\n    // Range / Duration\n    DateEnv.prototype.greatestWholeUnit = function(m0, m1) {\n        var n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    };\n    DateEnv.prototype.countDurationsBetween = function(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        var diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    };\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    DateEnv.prototype.startOf = function(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    };\n    DateEnv.prototype.startOfYear = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    };\n    DateEnv.prototype.startOfMonth = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    };\n    DateEnv.prototype.startOfWeek = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    };\n    // Week Number\n    DateEnv.prototype.computeWeekNumber = function(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    };\n    // TODO: choke on timeZoneName: long\n    DateEnv.prototype.format = function(marker, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        return formatter.format({\n            marker: marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    };\n    DateEnv.prototype.formatRange = function(start, end, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    };\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ DateEnv.prototype.formatIso = function(marker, extraOptions) {\n        if (extraOptions === void 0) {\n            extraOptions = {};\n        }\n        var timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    };\n    // TimeZone\n    DateEnv.prototype.timestampToMarker = function(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    };\n    DateEnv.prototype.offsetForMarker = function(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    };\n    // Conversion\n    DateEnv.prototype.toDate = function(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    };\n    return DateEnv;\n}();\nvar globalLocales = [];\nvar MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nvar RAW_EN_LOCALE = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today: function(buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : \"This \" + buttonText;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint: function(eventCnt) {\n        return \"Show \" + eventCnt + \" more event\" + (eventCnt === 1 ? \"\" : \"s\");\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    var allRawLocales = globalLocales.concat(explicitRawLocales);\n    var rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for(var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++){\n        var rawLocale = allRawLocales_1[_i];\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode: defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    var codes = [].concat(codeArg || []); // will convert to array\n    var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(var i = 0; i < codes.length; i += 1){\n        var parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(var j = parts.length; j > 0; j -= 1){\n            var simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    var merged = mergeProps([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    var week = merged.week;\n    delete merged.week;\n    return {\n        codeArg: codeArg,\n        codes: codes,\n        week: week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\nfunction formatDate(dateInput, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var dateEnv = buildDateEnv$1(options);\n    var formatter = createFormatter(options);\n    var dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    var dateEnv = buildDateEnv$1(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    var formatter = createFormatter(options);\n    var startMeta = dateEnv.createMarkerMeta(startInput);\n    var endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv$1(settings) {\n    var locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new DateEnv((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        timeZone: BASE_OPTION_DEFAULTS.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale: locale\n    }));\n}\nvar DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    var rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter(function(rawDef) {\n            return rawDef.daysOfWeek;\n        });\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map(function(rawDef) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, DEF_DEFAULTS), rawDef);\n    });\n    return rawDefs;\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    var res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nvar canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    var el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    var div = el.querySelector(\"div\");\n    var possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nvar Splitter = /** @class */ function() {\n    function Splitter() {\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    Splitter.prototype.splitProps = function(props) {\n        var _this = this;\n        var keyInfos = this.getKeyInfo(props);\n        var defKeys = this.getKeysForEventDefs(props.eventStore);\n        var dateSelections = this.splitDateSelection(props.dateSelection);\n        var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        var eventStores = this.splitEventStore(props.eventStore, defKeys);\n        var eventDrags = this.splitEventDrag(props.eventDrag);\n        var eventResizes = this.splitEventResize(props.eventResize);\n        var splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, function(info, key) {\n            return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n        });\n        for(var key in keyInfos){\n            var keyInfo = keyInfos[key];\n            var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            var buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore: eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    };\n    Splitter.prototype._splitDateSpan = function(dateSpan) {\n        var dateSpans = {};\n        if (dateSpan) {\n            var keys = this.getKeysForDateSpan(dateSpan);\n            for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){\n                var key = keys_1[_i];\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    };\n    Splitter.prototype._getKeysForEventDefs = function(eventStore) {\n        var _this = this;\n        return mapHash(eventStore.defs, function(eventDef) {\n            return _this.getKeysForEventDef(eventDef);\n        });\n    };\n    Splitter.prototype._splitEventStore = function(eventStore, defKeys) {\n        var defs = eventStore.defs, instances = eventStore.instances;\n        var splitStores = {};\n        for(var defId in defs){\n            for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                var key = _a[_i];\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(var instanceId in instances){\n            var instance = instances[instanceId];\n            for(var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++){\n                var key = _c[_b];\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    };\n    Splitter.prototype._splitIndividualUi = function(eventUiBases, defKeys) {\n        var splitHashes = {};\n        for(var defId in eventUiBases){\n            if (defId) {\n                for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                    var key = _a[_i];\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    };\n    Splitter.prototype._splitInteraction = function(interaction) {\n        var splitStates = {};\n        if (interaction) {\n            var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            var populate = function(key) {\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(var key in affectedStores_1){\n                populate(key);\n            }\n            for(var key in mutatedStores_1){\n                populate(key);\n            }\n        }\n        return splitStates;\n    };\n    return Splitter;\n}();\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    var baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    var stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    var classNames = [\n        \"fc-day\",\n        \"fc-day-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    var classNames = [\n        \"fc-slot\",\n        \"fc-slot-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nvar DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nvar WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {\n    if (viewType === void 0) {\n        viewType = \"day\";\n    }\n    if (isTabbable === void 0) {\n        isTabbable = true;\n    }\n    var dateEnv = context.dateEnv, options = context.options, calendarApi = context.calendarApi;\n    var dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        var zonedDate = dateEnv.toDate(dateMarker);\n        var handleInteraction = function(ev) {\n            var customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nvar _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    var outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    var innerEl = outerEl.firstChild;\n    var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nvar _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    var el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    var res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding) {\n    if (getPadding === void 0) {\n        getPadding = false;\n    }\n    var computedStyle = window.getComputedStyle(el);\n    var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    var res = {\n        borderLeft: borderLeft,\n        borderRight: borderRight,\n        borderTop: borderTop,\n        borderBottom: borderBottom,\n        scrollbarBottom: scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n    if (goWithinPadding === void 0) {\n        goWithinPadding = false;\n    }\n    var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    var edges = computeEdges(el, goWithinPadding);\n    var res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    var rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.pageXOffset,\n        top: rect.top + window.pageYOffset,\n        right: rect.right + window.pageXOffset,\n        bottom: rect.bottom + window.pageYOffset\n    };\n}\nfunction computeClippedClientRect(el) {\n    var clippingParents = getClippingParents(el);\n    var rect = el.getBoundingClientRect();\n    for(var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++){\n        var clippingParent = clippingParents_1[_i];\n        var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\nfunction computeHeightAndMargins(el) {\n    return el.getBoundingClientRect().height + computeVMargins(el);\n}\nfunction computeVMargins(el) {\n    var computed = window.getComputedStyle(el);\n    return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n}\n// does not return window\nfunction getClippingParents(el) {\n    var parents = [];\n    while(el instanceof HTMLElement){\n        var computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n// given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\nfunction unpromisify(func, success, failure) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    var isResolved = false;\n    var wrappedSuccess = function() {\n        if (!isResolved) {\n            isResolved = true;\n            success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n    };\n    var wrappedFailure = function() {\n        if (!isResolved) {\n            isResolved = true;\n            if (failure) {\n                failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            }\n        }\n    };\n    var res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nvar Emitter = /** @class */ function() {\n    function Emitter() {\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    Emitter.prototype.setThisContext = function(thisContext) {\n        this.thisContext = thisContext;\n    };\n    Emitter.prototype.setOptions = function(options) {\n        this.options = options;\n    };\n    Emitter.prototype.on = function(type, handler) {\n        addToHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.off = function(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.trigger = function(type) {\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        var attachedHandlers = this.handlers[type] || [];\n        var optionHandler = this.options && this.options[type];\n        var handlers = [].concat(optionHandler || [], attachedHandlers);\n        for(var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++){\n            var handler = handlers_1[_a];\n            handler.apply(this.thisContext, args);\n        }\n    };\n    Emitter.prototype.hasHandlers = function(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    };\n    return Emitter;\n}();\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter(function(func) {\n                return func !== handler;\n            });\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ var PositionCache = /** @class */ function() {\n    function PositionCache(originEl, els, isHorizontal, isVertical) {\n        this.els = els;\n        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    PositionCache.prototype.buildElHorizontals = function(originClientLeft) {\n        var lefts = [];\n        var rights = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    };\n    // Populates the top/bottom internal coordinate arrays\n    PositionCache.prototype.buildElVerticals = function(originClientTop) {\n        var tops = [];\n        var bottoms = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    };\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.leftToIndex = function(leftPosition) {\n        var _a = this, lefts = _a.lefts, rights = _a.rights;\n        var len = lefts.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.topToIndex = function(topPosition) {\n        var _a = this, tops = _a.tops, bottoms = _a.bottoms;\n        var len = tops.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Gets the width of the element at the given index\n    PositionCache.prototype.getWidth = function(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    };\n    // Gets the height of the element at the given index\n    PositionCache.prototype.getHeight = function(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    };\n    return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ var ScrollController = /** @class */ function() {\n    function ScrollController() {}\n    ScrollController.prototype.getMaxScrollTop = function() {\n        return this.getScrollHeight() - this.getClientHeight();\n    };\n    ScrollController.prototype.getMaxScrollLeft = function() {\n        return this.getScrollWidth() - this.getClientWidth();\n    };\n    ScrollController.prototype.canScrollVertically = function() {\n        return this.getMaxScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollHorizontally = function() {\n        return this.getMaxScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollUp = function() {\n        return this.getScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollDown = function() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    };\n    ScrollController.prototype.canScrollLeft = function() {\n        return this.getScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollRight = function() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    };\n    return ScrollController;\n}();\nvar ElementScrollController = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ElementScrollController, _super);\n    function ElementScrollController(el) {\n        var _this = _super.call(this) || this;\n        _this.el = el;\n        return _this;\n    }\n    ElementScrollController.prototype.getScrollTop = function() {\n        return this.el.scrollTop;\n    };\n    ElementScrollController.prototype.getScrollLeft = function() {\n        return this.el.scrollLeft;\n    };\n    ElementScrollController.prototype.setScrollTop = function(top) {\n        this.el.scrollTop = top;\n    };\n    ElementScrollController.prototype.setScrollLeft = function(left) {\n        this.el.scrollLeft = left;\n    };\n    ElementScrollController.prototype.getScrollWidth = function() {\n        return this.el.scrollWidth;\n    };\n    ElementScrollController.prototype.getScrollHeight = function() {\n        return this.el.scrollHeight;\n    };\n    ElementScrollController.prototype.getClientHeight = function() {\n        return this.el.clientHeight;\n    };\n    ElementScrollController.prototype.getClientWidth = function() {\n        return this.el.clientWidth;\n    };\n    return ElementScrollController;\n}(ScrollController);\nvar WindowScrollController = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(WindowScrollController, _super);\n    function WindowScrollController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WindowScrollController.prototype.getScrollTop = function() {\n        return window.pageYOffset;\n    };\n    WindowScrollController.prototype.getScrollLeft = function() {\n        return window.pageXOffset;\n    };\n    WindowScrollController.prototype.setScrollTop = function(n) {\n        window.scroll(window.pageXOffset, n);\n    };\n    WindowScrollController.prototype.setScrollLeft = function(n) {\n        window.scroll(n, window.pageYOffset);\n    };\n    WindowScrollController.prototype.getScrollWidth = function() {\n        return document.documentElement.scrollWidth;\n    };\n    WindowScrollController.prototype.getScrollHeight = function() {\n        return document.documentElement.scrollHeight;\n    };\n    WindowScrollController.prototype.getClientHeight = function() {\n        return document.documentElement.clientHeight;\n    };\n    WindowScrollController.prototype.getClientWidth = function() {\n        return document.documentElement.clientWidth;\n    };\n    return WindowScrollController;\n}(ScrollController);\nvar Theme = /** @class */ function() {\n    function Theme(calendarOptions) {\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    Theme.prototype.setIconOverride = function(iconOverrideHash) {\n        var iconClassesCopy;\n        var buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    };\n    Theme.prototype.applyIconOverridePrefix = function(className) {\n        var prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    };\n    Theme.prototype.getClass = function(key) {\n        return this.classes[key] || \"\";\n    };\n    Theme.prototype.getIconClass = function(buttonName, isRtl) {\n        var className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return this.baseIconClass + \" \" + className;\n        }\n        return \"\";\n    };\n    Theme.prototype.getCustomButtonIconClass = function(customButtonProps) {\n        var className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n            }\n        }\n        return \"\";\n    };\n    return Theme;\n}();\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\nvar ScrollResponder = /** @class */ function() {\n    function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n        var _this = this;\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = function(request) {\n            _this.queuedRequest = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.queuedRequest || {}, request);\n            _this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    ScrollResponder.prototype.detach = function() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    };\n    ScrollResponder.prototype.update = function(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    };\n    ScrollResponder.prototype.fireInitialScroll = function() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    };\n    ScrollResponder.prototype.drain = function() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    };\n    return ScrollResponder;\n}();\nvar ViewContextType = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv: dateEnv,\n        options: viewOptions,\n        pluginHooks: pluginHooks,\n        emitter: emitter,\n        dispatch: dispatch,\n        getCurrentData: getCurrentData,\n        calendarApi: calendarApi,\n        viewSpec: viewSpec,\n        viewApi: viewApi,\n        dateProfileGenerator: dateProfileGenerator,\n        theme: theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler: function(handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler: function(handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder: function(execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent: registerInteractiveComponent,\n        unregisterInteractiveComponent: unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ var PureComponent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(PureComponent, _super);\n    function PureComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PureComponent.prototype.shouldComponentUpdate = function(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    };\n    // HACK for freakin' React StrictMode\n    PureComponent.prototype.safeSetState = function(newState) {\n        if (!compareObjs(this.state, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    };\n    PureComponent.addPropsEquality = addPropsEquality;\n    PureComponent.addStateEquality = addStateEquality;\n    PureComponent.contextType = ViewContextType;\n    return PureComponent;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nvar BaseComponent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(BaseComponent, _super);\n    function BaseComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BaseComponent.contextType = ViewContextType;\n    return BaseComponent;\n}(PureComponent);\nfunction addPropsEquality(propEquality) {\n    var hash = Object.create(this.prototype.propEquality);\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    var hash = Object.create(this.prototype.stateEquality);\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ var DateComponent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DateComponent, _super);\n    function DateComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.uid = guid();\n        return _this;\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.prepareHits = function() {};\n    DateComponent.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    };\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.isValidSegDownEl = function(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    };\n    DateComponent.prototype.isValidDateDownEl = function(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    };\n    return DateComponent;\n}(BaseComponent);\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: guid(),\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        contentTypeHandlers: input.contentTypeHandlers || {},\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    var isAdded = {};\n    var hooks = {\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        contentTypeHandlers: {},\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for(var _i = 0, defs_1 = defs; _i < defs_1.length; _i++){\n            var def = defs_1[_i];\n            if (!isAdded[def.id]) {\n                isAdded[def.id] = true;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    var currentOverrideDefs = [];\n    var currentGlobalDefs = [];\n    var currentHooks;\n    return function(overrideDefs, globalDefs) {\n        if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        contentTypeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n        listenerRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nvar StandardTheme = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardTheme, _super);\n    function StandardTheme() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StandardTheme;\n}(Theme);\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    var hash = {};\n    var viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    var defaultConfig = defaultConfigs[viewType];\n    var overrideConfig = overrideConfigs[viewType];\n    var queryProp = function(name) {\n        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    };\n    var theComponent = queryProp(\"component\");\n    var superType = queryProp(\"superType\");\n    var superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\n/* eslint max-classes-per-file: off */ // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\nvar RenderHook = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(RenderHook, _super);\n    function RenderHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.handleRootEl = function(el) {\n            setRef(_this.rootElRef, el);\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        return _this;\n    }\n    RenderHook.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var hookProps = props.hookProps;\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n            hookProps: hookProps,\n            didMount: props.didMount,\n            willUnmount: props.willUnmount,\n            elRef: this.handleRootEl\n        }, function(rootElRef) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n                hookProps: hookProps,\n                content: props.content,\n                defaultContent: props.defaultContent,\n                backupElRef: _this.rootElRef\n            }, function(innerElRef, innerContent) {\n                return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n            });\n        });\n    };\n    return RenderHook;\n}(BaseComponent);\n// TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\nvar CustomContentRenderContext = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)(0);\nfunction ContentHook(props) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(CustomContentRenderContext.Consumer, null, function(renderId) {\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHookInner, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            renderId: renderId\n        }, props));\n    });\n}\n_c = ContentHook;\nvar ContentHookInner = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ContentHookInner, _super);\n    function ContentHookInner() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.innerElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    ContentHookInner.prototype.render = function() {\n        return this.props.children(this.innerElRef, this.renderInnerContent());\n    };\n    ContentHookInner.prototype.componentDidMount = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentDidUpdate = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentWillUnmount = function() {\n        if (this.customContentInfo && this.customContentInfo.destroy) {\n            this.customContentInfo.destroy();\n        }\n    };\n    ContentHookInner.prototype.renderInnerContent = function() {\n        var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n        var innerContent = this.getInnerContent();\n        var meta = this.getContentMeta(innerContent);\n        // initial run, or content-type changing? (from vue -> react for example)\n        if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n            // clearing old value\n            if (customContentInfo) {\n                if (customContentInfo.destroy) {\n                    customContentInfo.destroy();\n                }\n                customContentInfo = this.customContentInfo = null;\n            }\n            // assigning new value\n            if (meta.contentKey) {\n                customContentInfo = this.customContentInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    contentKey: meta.contentKey,\n                    contentVal: innerContent[meta.contentKey]\n                }, meta.buildLifecycleFuncs());\n            }\n        // updating\n        } else if (customContentInfo) {\n            customContentInfo.contentVal = innerContent[meta.contentKey];\n        }\n        return customContentInfo ? [] // signal that something was specified\n         : innerContent; // assume a [p]react vdom node. use it\n    };\n    ContentHookInner.prototype.getInnerContent = function() {\n        var props = this.props;\n        var innerContent = normalizeContent(props.content, props.hookProps);\n        if (innerContent === undefined) {\n            innerContent = normalizeContent(props.defaultContent, props.hookProps);\n        }\n        return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n    };\n    ContentHookInner.prototype.getContentMeta = function(innerContent) {\n        var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n        var contentKey = \"\";\n        var buildLifecycleFuncs = null;\n        if (innerContent) {\n            for(var searchKey in contentTypeHandlers){\n                if (innerContent[searchKey] !== undefined) {\n                    contentKey = searchKey;\n                    buildLifecycleFuncs = contentTypeHandlers[searchKey];\n                    break;\n                }\n            }\n        }\n        return {\n            contentKey: contentKey,\n            buildLifecycleFuncs: buildLifecycleFuncs\n        };\n    };\n    ContentHookInner.prototype.updateCustomContent = function() {\n        if (this.customContentInfo) {\n            this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal);\n        }\n    };\n    return ContentHookInner;\n}(BaseComponent);\nvar MountHook = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MountHook, _super);\n    function MountHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, rootEl);\n            }\n        };\n        return _this;\n    }\n    MountHook.prototype.render = function() {\n        return this.props.children(this.handleRootEl);\n    };\n    MountHook.prototype.componentDidMount = function() {\n        var callback = this.props.didMount;\n        if (callback) {\n            callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    MountHook.prototype.componentWillUnmount = function() {\n        var callback = this.props.willUnmount;\n        if (callback) {\n            callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    return MountHook;\n}(BaseComponent);\nfunction buildClassNameNormalizer() {\n    var currentGenerator;\n    var currentHookProps;\n    var currentClassNames = [];\n    return function(generator, hookProps) {\n        if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n            currentGenerator = generator;\n            currentHookProps = hookProps;\n            currentClassNames = normalizeClassNames(generator, hookProps);\n        }\n        return currentClassNames;\n    };\n}\nfunction normalizeClassNames(classNames, hookProps) {\n    if (typeof classNames === \"function\") {\n        classNames = classNames(hookProps);\n    }\n    return parseClassNames(classNames);\n}\nfunction normalizeContent(input, hookProps) {\n    if (typeof input === \"function\") {\n        return input(hookProps, _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement); // give the function the vdom-creation func\n    }\n    return input;\n}\nvar ViewRoot = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewRoot, _super);\n    function ViewRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    ViewRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = {\n            view: context.viewApi\n        };\n        var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n            hookProps: hookProps,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, [\n                \"fc-\" + props.viewSpec.type + \"-view\",\n                \"fc-view\"\n            ].concat(customClassNames));\n        });\n    };\n    return ViewRoot;\n}(BaseComponent);\nfunction parseViewConfigs(inputs) {\n    return mapHash(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    var rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    var component = rawOptions.component;\n    if (rawOptions.content) {\n        component = createViewHookComponent(rawOptions);\n    // TODO: remove content/classNames/didMount/etc from options?\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions: rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return function(viewProps) {\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function(context) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewRoot, {\n                viewSpec: context.viewSpec\n            }, function(viewElRef, viewClassNames) {\n                var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                });\n                return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n                    hookProps: hookProps,\n                    classNames: options.classNames,\n                    content: options.content,\n                    didMount: options.didMount,\n                    willUnmount: options.willUnmount,\n                    elRef: viewElRef\n                }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: viewClassNames.concat(customClassNames).join(\" \"),\n                        ref: rootElRef\n                    }, innerContent);\n                });\n            });\n        });\n    };\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var defaultConfigs = parseViewConfigs(defaultInputs);\n    var overrideConfigs = parseViewConfigs(optionOverrides.views);\n    var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return mapHash(viewDefs, function(viewDef) {\n        return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    });\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    var duration = null;\n    var durationUnit = \"\";\n    var singleUnit = \"\";\n    var singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            var denom = greatestDurationDenominator(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    var queryButtonText = function(optionsSubset) {\n        var buttonTextMap = optionsSubset.buttonText || {};\n        var buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    var queryButtonTitle = function(optionsSubset) {\n        var buttonHints = optionsSubset.buttonHints || {};\n        var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration: duration,\n        durationUnit: durationUnit,\n        singleUnit: singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)\n    };\n}\n// hack to get memoization working\nvar durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    var json = JSON.stringify(durationInput);\n    var res = durationInputMap[json];\n    if (res === undefined) {\n        res = createDuration(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nvar DateProfileGenerator = /** @class */ function() {\n    function DateProfileGenerator(props) {\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    DateProfileGenerator.prototype.buildPrev = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    };\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    DateProfileGenerator.prototype.buildNext = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    };\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    DateProfileGenerator.prototype.build = function(currentDate, direction, forceToValid) {\n        if (forceToValid === void 0) {\n            forceToValid = true;\n        }\n        var props = this.props;\n        var validRange;\n        var currentInfo;\n        var isRangeAllDay;\n        var renderRange;\n        var activeRange;\n        var isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        return {\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange: validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay: isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange: activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange: renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid: isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    };\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildValidRange = function() {\n        var input = this.props.validRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.nowDate) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    };\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    DateProfileGenerator.prototype.buildCurrentRangeInfo = function(date, direction) {\n        var props = this.props;\n        var duration = null;\n        var unit = null;\n        var range = null;\n        var dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration: duration,\n            unit: unit,\n            range: range\n        };\n    };\n    DateProfileGenerator.prototype.getFallbackDuration = function() {\n        return createDuration({\n            day: 1\n        });\n    };\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    DateProfileGenerator.prototype.adjustActiveRange = function(range) {\n        var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;\n        var start = range.start, end = range.end;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    DateProfileGenerator.prototype.buildRangeFromDuration = function(date, direction, duration, unit) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var start;\n        var end;\n        var res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            var dateIncrement = this.props.dateIncrement;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start: start,\n                end: end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    };\n    // Builds the \"current\" range when a dayCount is specified.\n    DateProfileGenerator.prototype.buildRangeFromDayCount = function(date, direction, dayCount) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var runningCount = 0;\n        var start = date;\n        var end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    DateProfileGenerator.prototype.buildCustomVisibleRange = function(date) {\n        var props = this.props;\n        var input = props.visibleRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        var range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    };\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    };\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    DateProfileGenerator.prototype.buildDateIncrement = function(fallback) {\n        var dateIncrement = this.props.dateIncrement;\n        var customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    };\n    DateProfileGenerator.prototype.refineRange = function(rangeInput) {\n        if (rangeInput) {\n            var range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    };\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    DateProfileGenerator.prototype.initHiddenDays = function() {\n        var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        var dayCnt = 0;\n        var i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    };\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    DateProfileGenerator.prototype.trimHiddenDays = function(range) {\n        var start = range.start, end = range.end;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        return null;\n    };\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    DateProfileGenerator.prototype.isHiddenDay = function(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    };\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    DateProfileGenerator.prototype.skipHiddenDays = function(date, inc, isExclusive) {\n        if (inc === void 0) {\n            inc = 1;\n        }\n        if (isExclusive === void 0) {\n            isExclusive = false;\n        }\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    };\n    return DateProfileGenerator;\n}();\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    var _a;\n    switch(action.type){\n        case \"SET_OPTION\":\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    var dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(var sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    var hash = {};\n    for(var _i = 0, sources_1 = sources; _i < sources_1.length; _i++){\n        var source = sources_1[_i];\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return filterHash(eventSourceHash, function(eventSource) {\n        return eventSource.sourceId !== sourceId;\n    });\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function(eventSource) {\n        return isSourceDirty(eventSource, fetchRange, context);\n    }), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    var nextSources = {};\n    for(var sourceId in prevSources){\n        var source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    var options = context.options, calendarApi = context.calendarApi;\n    var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    var fetchId = guid();\n    sourceDef.fetch({\n        eventSource: eventSource,\n        range: fetchRange,\n        isRefetch: isRefetch,\n        context: context\n    }, function(res) {\n        var rawEvents = res.rawEvents;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            rawEvents: rawEvents\n        });\n    }, function(error) {\n        console.warn(error.message, error);\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            error: error\n        });\n    });\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    var _a;\n    var eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, sourceHash), (_a = {}, _a[sourceId] = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n            isFetching: false,\n            fetchRange: fetchRange\n        }), _a));\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return filterHash(eventSources, function(eventSource) {\n        return doesSourceNeedRange(eventSource, context);\n    });\n}\nfunction parseInitialSources(rawOptions, context) {\n    var refiners = buildEventSourceRefiners(context);\n    var rawSources = [].concat(rawOptions.eventSources || []);\n    var sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for(var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++){\n        var rawSource = rawSources_1[_i];\n        var source = parseEventSource(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, function(eventDef) {\n                return !eventDef.sourceId // only keep events with no source id\n                ;\n            });\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    var calEachTransform = context.options.eventDataTransform;\n    var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    var refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n            var rawEvent = rawEvents_1[_i];\n            var refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    var defs = eventStore.defs;\n    var instances = mapHash(eventStore.instances, function(instance) {\n        var def = defs[instance.defId];\n        if (def.allDay || def.recurringDef) {\n            return instance; // isn't dependent on timezone\n        }\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, function(eventDef) {\n        return eventDef.sourceId !== sourceId;\n    });\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, function(instance) {\n            return !removals[instance.instanceId];\n        })\n    };\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    var newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    var newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header: header,\n        footer: footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var sectionWidgets = {};\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    for(var sectionName in sectionStrHash){\n        var sectionStr = sectionStrHash[sectionName];\n        var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets: sectionWidgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var isRtl = calendarOptions.direction === \"rtl\";\n    var calendarCustomButtons = calendarOptions.customButtons || {};\n    var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    var calendarButtonText = calendarOptions.buttonText || {};\n    var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    var calendarButtonHints = calendarOptions.buttonHints || {};\n    var sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    var widgets = sectionSubstrs.map(function(buttonGroupStr) {\n        return buttonGroupStr.split(\",\").map(function(buttonName) {\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName: buttonName\n                };\n            }\n            var customButtonProps;\n            var viewSpec;\n            var buttonClick;\n            var buttonIcon; // only one of these will be set\n            var buttonText; // \"\n            var buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = function(ev) {\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = function() {\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = function() {\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    var prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = function(navUnit) {\n                        return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                    };\n                }\n            }\n            return {\n                buttonName: buttonName,\n                buttonClick: buttonClick,\n                buttonIcon: buttonIcon,\n                buttonText: buttonText,\n                buttonHint: buttonHint\n            };\n        });\n    });\n    return {\n        widgets: widgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\nvar eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta: function(refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success) {\n        success({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nvar arrayEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nvar eventSourceDef$1 = {\n    parseMeta: function(refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var dateEnv = arg.context.dateEnv;\n        var func = arg.eventSource.meta;\n        unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function(rawEvents) {\n            success({\n                rawEvents: rawEvents\n            }); // needs an object response\n        }, failure);\n    }\n};\nvar funcEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n    method = method.toUpperCase();\n    var body = null;\n    if (method === \"GET\") {\n        url = injectQueryStringParams(url, params);\n    } else {\n        body = encodeParams(params);\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    if (method !== \"GET\") {\n        xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    }\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 400) {\n            var parsed = false;\n            var res = void 0;\n            try {\n                res = JSON.parse(xhr.responseText);\n                parsed = true;\n            } catch (err) {\n            // will handle parsed=false\n            }\n            if (parsed) {\n                successCallback(res, xhr);\n            } else {\n                failureCallback(\"Failure parsing JSON\", xhr);\n            }\n        } else {\n            failureCallback(\"Request failed\", xhr);\n        }\n    };\n    xhr.onerror = function() {\n        failureCallback(\"Request failed\", xhr);\n    };\n    xhr.send(body);\n}\nfunction injectQueryStringParams(url, params) {\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + encodeParams(params);\n}\nfunction encodeParams(params) {\n    var parts = [];\n    for(var key in params){\n        parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return parts.join(\"&\");\n}\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: identity,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nvar eventSourceDef = {\n    parseMeta: function(refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var meta = arg.eventSource.meta;\n        var requestParams = buildRequestParams(meta, arg.range, arg.context);\n        requestJson(meta.method, meta.url, requestParams, function(rawEvents, xhr) {\n            success({\n                rawEvents: rawEvents,\n                xhr: xhr\n            });\n        }, function(errorMessage, xhr) {\n            failure({\n                message: errorMessage,\n                xhr: xhr\n            });\n        });\n    }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var startParam;\n    var endParam;\n    var timeZoneParam;\n    var customRequestParams;\n    var params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nvar SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: identity,\n    startTime: createDuration,\n    endTime: createDuration,\n    duration: createDuration,\n    startRecur: identity,\n    endRecur: identity\n};\nvar recurring = {\n    parse: function(refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            var recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n            };\n            var duration = void 0;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = subtractDurations(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration: duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand: function(typeData, framingRange, dateEnv) {\n        var clippedFramingRange = intersectRanges(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n    var dayMarker = startOfDay(framingRange.start);\n    var endMarker = framingRange.end;\n    var instanceStarts = [];\n    while(dayMarker < endMarker){\n        var instanceStart = void 0;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = addDays(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nvar changeHandlerPlugin = createPlugin({\n    optionChangeHandlers: {\n        events: function(events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n    var newInputs = [];\n    for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n        var input = inputs_1[_i];\n        var inputFound = false;\n        for(var i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for(var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++){\n        var unfoundSource = unfoundSources_1[_a];\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for(var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++){\n        var newInput = newInputs_1[_b];\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    var emitter = context.emitter;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", buildEventApis(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ var globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        isLoadingFuncs: [\n            function(state) {\n                return computeEventSourcesLoading(state.eventSources);\n            }\n        ],\n        contentTypeHandlers: {\n            html: buildHtmlRenderer,\n            domNodes: buildDomNodeRenderer\n        },\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nfunction buildHtmlRenderer() {\n    var currentEl = null;\n    var currentHtml = \"\";\n    function render(el, html) {\n        if (el !== currentEl || html !== currentHtml) {\n            el.innerHTML = html;\n        }\n        currentEl = el;\n        currentHtml = html;\n    }\n    function destroy() {\n        currentEl.innerHTML = \"\";\n        currentEl = null;\n        currentHtml = \"\";\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nfunction buildDomNodeRenderer() {\n    var currentEl = null;\n    var currentDomNodes = [];\n    function render(el, domNodes) {\n        var newDomNodes = Array.prototype.slice.call(domNodes);\n        if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {\n            // append first, remove second (for scroll resetting)\n            for(var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++){\n                var newNode = newDomNodes_1[_i];\n                el.appendChild(newNode);\n            }\n            destroy();\n        }\n        currentEl = el;\n        currentDomNodes = newDomNodes;\n    }\n    function destroy() {\n        currentDomNodes.forEach(removeElement);\n        currentDomNodes = [];\n        currentEl = null;\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nvar DelayedRunner = /** @class */ function() {\n    function DelayedRunner(drainedOption) {\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    DelayedRunner.prototype.request = function(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    };\n    DelayedRunner.prototype.pause = function(scope) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    };\n    DelayedRunner.prototype.resume = function(scope, force) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                var depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    };\n    DelayedRunner.prototype.isPaused = function() {\n        return Object.keys(this.pauseDepths).length;\n    };\n    DelayedRunner.prototype.tryDrain = function() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    };\n    DelayedRunner.prototype.clear = function() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    };\n    DelayedRunner.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    };\n    DelayedRunner.prototype.drained = function() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    };\n    return DelayedRunner;\n}();\nvar TaskRunner = /** @class */ function() {\n    function TaskRunner(runTaskOption, drainedOption) {\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n    }\n    TaskRunner.prototype.request = function(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    };\n    TaskRunner.prototype.pause = function(scope) {\n        this.delayedRunner.pause(scope);\n    };\n    TaskRunner.prototype.resume = function(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    };\n    TaskRunner.prototype.drain = function() {\n        var queue = this.queue;\n        while(queue.length){\n            var completedTasks = [];\n            var task = void 0;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    };\n    TaskRunner.prototype.runTask = function(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    };\n    TaskRunner.prototype.drained = function(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    };\n    return TaskRunner;\n}();\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    var range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    var currentRangeUnit = dateProfile.currentRangeUnit;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nvar CalendarDataManager = /** @class */ function() {\n    function CalendarDataManager(props) {\n        var _this = this;\n        this.computeOptionsData = memoize(this._computeOptionsData);\n        this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n        this.organizeRawLocales = memoize(organizeRawLocales);\n        this.buildLocale = memoize(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = memoize(buildDateEnv);\n        this.buildTheme = memoize(buildTheme);\n        this.parseToolbars = memoize(parseToolbars);\n        this.buildViewSpecs = memoize(buildViewSpecs);\n        this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n        this.buildViewApi = memoize(buildViewApi);\n        this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n        this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n        this.buildEventUiBases = memoize(buildEventUiBases);\n        this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n        this.buildTitle = memoize(buildTitle);\n        this.emitter = new Emitter();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.getCurrentData = function() {\n            return _this.data;\n        };\n        this.dispatch = function(action) {\n            _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        var dynamicOptionOverrides = {};\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n        var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        // needs to be after setThisContext\n        for(var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++){\n            var callback = _a[_i];\n            callback(calendarContext);\n        }\n        // NOT DRY\n        var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        var initialState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources: eventSources,\n            eventUiBases: {},\n            eventStore: createEmptyEventStore(),\n            renderableEventStore: createEmptyEventStore(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), initialState);\n        for(var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++){\n            var reducer = _c[_b];\n            (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    CalendarDataManager.prototype.resetOptions = function(optionOverrides, append) {\n        var props = this.props;\n        props.optionOverrides = append ? (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props.optionOverrides), optionOverrides) : optionOverrides;\n        this.actionRunner.request({\n            type: \"NOTHING\"\n        });\n    };\n    CalendarDataManager.prototype._handleAction = function(action) {\n        var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;\n        var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = reduceViewType(state.currentViewType, action);\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: emitter,\n            getCurrentData: this.getCurrentData\n        };\n        var currentDate = state.currentDate, dateProfile = state.dateProfile;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = reduceCurrentDate(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj\n        var eventUiBySource = this.buildEventUiBySource(eventSources);\n        var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        var newState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            eventSources: eventSources,\n            eventStore: eventStore,\n            renderableEventStore: renderableEventStore,\n            selectionConfig: selectionConfig,\n            eventUiBases: eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), newState);\n        for(var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++){\n            var reducer = _c[_i];\n            (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        var wasLoading = computeIsLoading(state, calendarContext);\n        var isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    };\n    CalendarDataManager.prototype.updateData = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var oldData = this.data;\n        var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        var data = this.data = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        var oldCalendarOptions = oldData && oldData.calendarOptions;\n        var newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(var optionName in changeHandlers){\n                if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        if (props.onData) {\n            props.onData(data);\n        }\n    };\n    CalendarDataManager.prototype._computeOptionsData = function(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n        var theme = this.buildTheme(refinedOptions, pluginHooks);\n        var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n        return {\n            calendarOptions: refinedOptions,\n            pluginHooks: pluginHooks,\n            dateEnv: dateEnv,\n            viewSpecs: viewSpecs,\n            theme: theme,\n            toolbarConfig: toolbarConfig,\n            localeDefaults: localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    };\n    // always called from behind a memoizer\n    CalendarDataManager.prototype.processRawCalendarOptions = function(optionOverrides, dynamicOptionOverrides) {\n        var _a = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]), locales = _a.locales, locale = _a.locale;\n        var availableLocaleData = this.organizeRawLocales(locales);\n        var availableRawLocales = availableLocaleData.map;\n        var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        var refiners = this.currentCalendarOptionsRefiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var extra = {};\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refined = {};\n        var currentRaw = this.currentCalendarOptionsInput;\n        var currentRefined = this.currentCalendarOptionsRefined;\n        var anyChanges = false;\n        for(var optionName in raw){\n            if (optionName !== \"plugins\") {\n                if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n                    refined[optionName] = currentRefined[optionName];\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                    anyChanges = true;\n                } else {\n                    extra[optionName] = currentRaw[optionName];\n                }\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks: pluginHooks,\n            availableLocaleData: availableLocaleData,\n            localeDefaults: localeDefaults,\n            extra: extra\n        };\n    };\n    CalendarDataManager.prototype._computeCurrentViewData = function(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        var viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error('viewType \"' + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n        }\n        var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            monthMode: refinedOptions.monthMode,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec: viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator: dateProfileGenerator,\n            viewApi: viewApi\n        };\n    };\n    CalendarDataManager.prototype.processRawViewOptions = function(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var refined = {};\n        var currentRaw = this.currentViewOptionsInput;\n        var currentRefined = this.currentViewOptionsRefined;\n        var anyChanges = false;\n        var extra = {};\n        for(var optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra: extra\n        };\n    };\n    return CalendarDataManager;\n}();\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new DateEnv({\n        calendarSystem: \"gregory\",\n        timeZone: timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale: locale,\n        weekNumberCalculation: weekNumberCalculation,\n        firstDay: firstDay,\n        weekText: weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator: defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewApi(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return mapHash(eventSources, function(eventSource) {\n        return eventSource.ui;\n    });\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    var eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(var defId in eventDefs){\n        var def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    var options = calendarContext.options;\n    return {\n        eventUiSingleBase: createEventUi({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: createEventUi({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for(var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++){\n        var isLoadingFunc = _a[_i];\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(var optionName in options){\n        console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : \"\"));\n    }\n}\n// TODO: move this to react plugin?\nvar CalendarDataProvider = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarDataProvider, _super);\n    function CalendarDataProvider(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleData = function(data) {\n            if (!_this.dataManager) {\n                // eslint-disable-next-line react/no-direct-mutation-state\n                _this.state = data; // can't use setState yet\n            } else {\n                _this.setState(data);\n            }\n        };\n        _this.dataManager = new CalendarDataManager({\n            optionOverrides: props.optionOverrides,\n            calendarApi: props.calendarApi,\n            onData: _this.handleData\n        });\n        return _this;\n    }\n    CalendarDataProvider.prototype.render = function() {\n        return this.props.children(this.state);\n    };\n    CalendarDataProvider.prototype.componentDidUpdate = function(prevProps) {\n        var newOptionOverrides = this.props.optionOverrides;\n        if (newOptionOverrides !== prevProps.optionOverrides) {\n            this.dataManager.resetOptions(newOptionOverrides);\n        }\n    };\n    return CalendarDataProvider;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nvar NamedTimeZoneImpl = /** @class */ function() {\n    function NamedTimeZoneImpl(timeZoneName) {\n        this.timeZoneName = timeZoneName;\n    }\n    return NamedTimeZoneImpl;\n}();\nvar SegHierarchy = /** @class */ function() {\n    function SegHierarchy() {\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    SegHierarchy.prototype.addSegs = function(inputs) {\n        var hiddenEntries = [];\n        for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n            var input = inputs_1[_i];\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    };\n    SegHierarchy.prototype.insertEntry = function(entry, hiddenEntries) {\n        var insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n            return 1;\n        }\n        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    };\n    SegHierarchy.prototype.isInsertionValid = function(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    };\n    // returns number of new entries inserted\n    SegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.splitEntry = function(entry, barrier, hiddenEntries) {\n        var partCnt = 0;\n        var splitHiddenEntries = [];\n        var entrySpan = entry.span;\n        var barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, splitHiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, splitHiddenEntries);\n        }\n        if (partCnt) {\n            hiddenEntries.push.apply(hiddenEntries, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                {\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: intersectSpans(barrierSpan, entrySpan)\n                }\n            ], splitHiddenEntries));\n            return partCnt;\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.insertEntryAt = function(entry, insertion) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    };\n    SegHierarchy.prototype.findInsertion = function(newEntry) {\n        var _a = this, levelCoords = _a.levelCoords, entriesByLevel = _a.entriesByLevel, strictOrder = _a.strictOrder, stackCnts = _a.stackCnts;\n        var levelCnt = levelCoords.length;\n        var candidateCoord = 0;\n        var touchingLevel = -1;\n        var touchingLateral = -1;\n        var touchingEntry = null;\n        var stackCnt = 0;\n        for(var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            var trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n                break;\n            }\n            var trackingEntries = entriesByLevel[trackingLevel];\n            var trackingEntry = void 0;\n            var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                var trackingEntryBottom = trackingCoord + trackingEntry.thickness;\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        var destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        var destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel: touchingLevel,\n            touchingLateral: touchingLateral,\n            touchingEntry: touchingEntry,\n            stackCnt: stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    };\n    // sorted by levelCoord (lowest to highest)\n    SegHierarchy.prototype.toRects = function() {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        var levelCnt = entriesByLevel.length;\n        var rects = [];\n        for(var level = 0; level < levelCnt; level += 1){\n            var entries = entriesByLevel[level];\n            var levelCoord = levelCoords[level];\n            for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n                var entry = entries_1[_i];\n                rects.push((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, entry), {\n                    levelCoord: levelCoord\n                }));\n            }\n        }\n        return rects;\n    };\n    return SegHierarchy;\n}();\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    var merges = [];\n    for(var _i = 0, entries_2 = entries; _i < entries_2.length; _i++){\n        var entry = entries_2[_i];\n        var filteredMerges = [];\n        var hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for(var _a = 0, merges_1 = merges; _a < merges_1.length; _a++){\n            var merge = merges_1[_a];\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    var start = Math.max(span0.start, span1.start);\n    var end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start: start,\n            end: end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    var startIndex = 0;\n    var endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        var middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\nvar Interaction = /** @class */ function() {\n    function Interaction(settings) {\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    Interaction.prototype.destroy = function() {};\n    return Interaction;\n}();\nfunction parseInteractionSettings(component, input) {\n    return {\n        component: component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    var _a;\n    return _a = {}, _a[settings.component.uid] = settings, _a;\n}\n// global state\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ var ElementDragging = /** @class */ function() {\n    function ElementDragging(el, selector) {\n        this.emitter = new Emitter();\n    }\n    ElementDragging.prototype.destroy = function() {};\n    ElementDragging.prototype.setMirrorIsVisible = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setMirrorNeedsRevert = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setAutoScrollEnabled = function(bool) {\n    // optional\n    };\n    return ElementDragging;\n}();\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ var DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    var _a = refineProps(raw, DRAG_META_REFINERS), refined = _a.refined, extra = _a.extra;\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\nvar ToolbarSection = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ToolbarSection, _super);\n    function ToolbarSection() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarSection.prototype.render = function() {\n        var _this = this;\n        var children = this.props.widgetGroups.map(function(widgetGroup) {\n            return _this.renderWidgetGroup(widgetGroup);\n        });\n        return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            \"div\",\n            {\n                className: \"fc-toolbar-chunk\"\n            }\n        ], children));\n    };\n    ToolbarSection.prototype.renderWidgetGroup = function(widgetGroup) {\n        var props = this.props;\n        var theme = this.context.theme;\n        var children = [];\n        var isOnlyButtons = true;\n        for(var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++){\n            var widget = widgetGroup_1[_i];\n            var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon, buttonHint = widget.buttonHint;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                var isPressed = buttonName === props.activeButton;\n                var isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                var buttonClasses = [\n                    \"fc-\" + buttonName + \"-button\",\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n                    className: buttonIcon\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            var groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                \"div\",\n                {\n                    className: groupClassName\n                }\n            ], children));\n        }\n        return children[0];\n    };\n    return ToolbarSection;\n}(BaseComponent);\nvar Toolbar = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Toolbar, _super);\n    function Toolbar() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Toolbar.prototype.render = function() {\n        var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;\n        var forceLtr = false;\n        var startContent;\n        var endContent;\n        var sectionWidgets = model.sectionWidgets;\n        var centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        var classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    };\n    Toolbar.prototype.renderSection = function(key, widgetGroups) {\n        var props = this.props;\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    };\n    return Toolbar;\n}(BaseComponent);\n// TODO: do function component?\nvar ViewContainer = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewContainer, _super);\n    function ViewContainer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            availableWidth: null\n        };\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n            _this.updateAvailableWidth();\n        };\n        _this.handleResize = function() {\n            _this.updateAvailableWidth();\n        };\n        return _this;\n    }\n    ViewContainer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var aspectRatio = props.aspectRatio;\n        var classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        var height = \"\";\n        var paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = 1 / aspectRatio * 100 + \"%\";\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height: height,\n                paddingBottom: paddingBottom\n            }\n        }, props.children);\n    };\n    ViewContainer.prototype.componentDidMount = function() {\n        this.context.addResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.updateAvailableWidth = function() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    };\n    return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ var EventClicking = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventClicking, _super);\n    function EventClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handleSegClick = function(ev, segEl) {\n            var component = _this.component;\n            var context = component.context;\n            var seg = getElSeg(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                var hasUrlContainer = elementClosest(ev.target, \".fc-event-forced-url\");\n                var url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        _this.destroy = listenBySelector(settings.el, \"click\", \".fc-event\", _this.handleSegClick);\n        return _this;\n    }\n    return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ var EventHovering = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventHovering, _super);\n    function EventHovering(settings) {\n        var _this = _super.call(this, settings) || this;\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        _this.handleEventElRemove = function(el) {\n            if (el === _this.currentSegEl) {\n                _this.handleSegLeave(null, _this.currentSegEl);\n            }\n        };\n        _this.handleSegEnter = function(ev, segEl) {\n            if (getElSeg(segEl)) {\n                _this.currentSegEl = segEl;\n                _this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        _this.handleSegLeave = function(ev, segEl) {\n            if (_this.currentSegEl) {\n                _this.currentSegEl = null;\n                _this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        _this.removeHoverListeners = listenToHoverBySelector(settings.el, \".fc-event\", _this.handleSegEnter, _this.handleSegLeave);\n        return _this;\n    }\n    EventHovering.prototype.destroy = function() {\n        this.removeHoverListeners();\n    };\n    EventHovering.prototype.triggerEvent = function(publicEvName, ev, segEl) {\n        var component = this.component;\n        var context = component.context;\n        var seg = getElSeg(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    };\n    return EventHovering;\n}(Interaction);\nvar CalendarContent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarContent, _super);\n    function CalendarContent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildViewContext = memoize(buildViewContext);\n        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n        _this.buildToolbarProps = memoize(buildToolbarProps);\n        _this.headerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.footerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.interactionsStore = {};\n        // eslint-disable-next-line\n        _this.state = {\n            viewLabelId: getUniqueDomId()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.registerInteractiveComponent = function(component, settingsInput) {\n            var settings = parseInteractionSettings(component, settingsInput);\n            var DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n            var interactions = interactionClasses.map(function(TheInteractionClass) {\n                return new TheInteractionClass(settings);\n            });\n            _this.interactionsStore[component.uid] = interactions;\n            interactionSettingsStore[component.uid] = settings;\n        };\n        _this.unregisterInteractiveComponent = function(component) {\n            var listeners = _this.interactionsStore[component.uid];\n            if (listeners) {\n                for(var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++){\n                    var listener = listeners_1[_i];\n                    listener.destroy();\n                }\n                delete _this.interactionsStore[component.uid];\n            }\n            delete interactionSettingsStore[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.resizeRunner = new DelayedRunner(function() {\n            _this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            _this.props.emitter.trigger(\"windowResize\", {\n                view: _this.props.viewApi\n            });\n        });\n        _this.handleWindowResize = function(ev) {\n            var options = _this.props.options;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                _this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n        return _this;\n    }\n    /*\n    renders INSIDE of an outer div\n    */ CalendarContent.prototype.render = function() {\n        var props = this.props;\n        var toolbarConfig = props.toolbarConfig, options = props.options;\n        var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);\n        var viewVGrow = false;\n        var viewHeight = \"\";\n        var viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : \"\";\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Provider, {\n            value: viewContext\n        }, toolbarConfig.header && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            ref: this.headerRef,\n            extraClassName: \"fc-header-toolbar\",\n            model: toolbarConfig.header,\n            titleId: viewLabelId\n        }, toolbarProps)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContainer, {\n            liquid: viewVGrow,\n            height: viewHeight,\n            aspectRatio: viewAspectRatio,\n            labeledById: viewLabelId\n        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            ref: this.footerRef,\n            extraClassName: \"fc-footer-toolbar\",\n            model: toolbarConfig.footer,\n            titleId: \"\"\n        }, toolbarProps)));\n    };\n    CalendarContent.prototype.componentDidMount = function() {\n        var props = this.props;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function(CalendarInteractionClass) {\n            return new CalendarInteractionClass(props);\n        });\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    };\n    CalendarContent.prototype.componentDidUpdate = function(prevProps) {\n        var props = this.props;\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    };\n    CalendarContent.prototype.componentWillUnmount = function() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for(var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++){\n            var interaction = _a[_i];\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    };\n    CalendarContent.prototype.buildAppendContent = function() {\n        var props = this.props;\n        var children = props.pluginHooks.viewContainerAppends.map(function(buildAppendContent) {\n            return buildAppendContent(props);\n        });\n        return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            _vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment,\n            {}\n        ], children));\n    };\n    CalendarContent.prototype.renderView = function(props) {\n        var pluginHooks = props.pluginHooks;\n        var viewSpec = props.viewSpec;\n        var viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n            var transformer = transformers_1[_i];\n            (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(viewProps, transformer.transform(viewProps, props));\n        }\n        var ViewComponent = viewSpec.component;\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps));\n    };\n    return CalendarContent;\n}(PureComponent);\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title: title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map(function(TheClass) {\n        return new TheClass();\n    });\n}\nvar CalendarRoot = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarRoot, _super);\n    function CalendarRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            forPrint: false\n        };\n        _this.handleBeforePrint = function() {\n            _this.setState({\n                forPrint: true\n            });\n        };\n        _this.handleAfterPrint = function() {\n            _this.setState({\n                forPrint: false\n            });\n        };\n        return _this;\n    }\n    CalendarRoot.prototype.render = function() {\n        var props = this.props;\n        var options = props.options;\n        var forPrint = this.state.forPrint;\n        var isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        var height = !isHeightAuto && options.height != null ? options.height : \"\";\n        var classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            \"fc-direction-\" + options.direction,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    };\n    CalendarRoot.prototype.componentDidMount = function() {\n        var emitter = this.props.emitter;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    };\n    CalendarRoot.prototype.componentWillUnmount = function() {\n        var emitter = this.props.emitter;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    };\n    return CalendarRoot;\n}(BaseComponent);\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nvar CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(hookProps) {\n    return hookProps.text;\n}\nvar TableDateCell = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateCell, _super);\n    function TableDateCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDateCell.prototype.render = function() {\n        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;\n        var props = this.props;\n        var date = props.date, dateProfile = props.dateProfile;\n        var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            date: dateEnv.toDate(date),\n            view: viewApi\n        }, props.extraHookProps), {\n            text: text\n        }), dayMeta);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                ref: innerElRef,\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \")\n            }, navLinkAttrs), innerContent)));\n        });\n    };\n    return TableDateCell;\n}(BaseComponent);\nvar WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nvar TableDowCell = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDowCell, _super);\n    function TableDowCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDowCell.prototype.render = function() {\n        var props = this.props;\n        var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;\n        var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        var dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            date: date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraHookProps), {\n            text: text\n        });\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n                \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT),\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \"),\n                ref: innerElRef\n            }, innerContent)));\n        });\n    };\n    return TableDowCell;\n}(BaseComponent);\nvar NowTimer = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(NowTimer, _super);\n    function NowTimer(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        _this.initialNowQueriedMs = new Date().valueOf();\n        _this.state = _this.computeTiming().currentState;\n        return _this;\n    }\n    NowTimer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        return props.children(state.nowDate, state.todayRange);\n    };\n    NowTimer.prototype.componentDidMount = function() {\n        this.setTimeout();\n    };\n    NowTimer.prototype.componentDidUpdate = function(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    };\n    NowTimer.prototype.componentWillUnmount = function() {\n        this.clearTimeout();\n    };\n    NowTimer.prototype.computeTiming = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            nextState: {\n                nowDate: nextUnitStart,\n                todayRange: buildDayRange(nextUnitStart)\n            },\n            waitMs: waitMs\n        };\n    };\n    NowTimer.prototype.setTimeout = function() {\n        var _this = this;\n        var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;\n        this.timeoutId = setTimeout(function() {\n            _this.setState(nextState, function() {\n                _this.setTimeout();\n            });\n        }, waitMs);\n    };\n    NowTimer.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    };\n    NowTimer.contextType = ViewContextType;\n    return NowTimer;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\nfunction buildDayRange(date) {\n    var start = startOfDay(date);\n    var end = addDays(start, 1);\n    return {\n        start: start,\n        end: end\n    };\n}\nvar DayHeader = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayHeader, _super);\n    function DayHeader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n        return _this;\n    }\n    DayHeader.prototype.render = function() {\n        var context = this.context;\n        var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;\n        var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map(function(date) {\n                return datesRepDistinctDays ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                });\n            }));\n        });\n    };\n    return DayHeader;\n}(BaseComponent);\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nvar DaySeriesModel = /** @class */ function() {\n    function DaySeriesModel(range, dateProfileGenerator) {\n        var date = range.start;\n        var end = range.end;\n        var indices = [];\n        var dates = [];\n        var dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    DaySeriesModel.prototype.sliceRange = function(range) {\n        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        var clippedFirstIndex = Math.max(0, firstIndex);\n        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    };\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    DaySeriesModel.prototype.getDateDayIndex = function(date) {\n        var indices = this.indices;\n        var dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    };\n    return DaySeriesModel;\n}();\nvar DayTableModel = /** @class */ function() {\n    function DayTableModel(daySeries, breakOnWeeks) {\n        var dates = daySeries.dates;\n        var daysPerRow;\n        var firstDay;\n        var rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    DayTableModel.prototype.buildCells = function() {\n        var rows = [];\n        for(var row = 0; row < this.rowCnt; row += 1){\n            var cells = [];\n            for(var col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    };\n    DayTableModel.prototype.buildCell = function(row, col) {\n        var date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date: date\n        };\n    };\n    DayTableModel.prototype.buildHeaderDates = function() {\n        var dates = [];\n        for(var col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    };\n    DayTableModel.prototype.sliceRange = function(range) {\n        var colCnt = this.colCnt;\n        var seriesSeg = this.daySeries.sliceRange(range);\n        var segs = [];\n        if (seriesSeg) {\n            var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;\n            var index = firstIndex;\n            while(index <= lastIndex){\n                var row = Math.floor(index / colCnt);\n                var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row: row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    };\n    return DayTableModel;\n}();\nvar Slicer = /** @class */ function() {\n    function Slicer() {\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    Slicer.prototype.sliceProps = function(props, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        var eventUiBases = props.eventUiBases;\n        var eventSegs = this.sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            props.eventStore,\n            eventUiBases,\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs));\n        return {\n            dateSelectionSegs: this.sliceDateSelection.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                props.dateSelection,\n                eventUiBases,\n                context\n            ], extraArgs)),\n            businessHourSegs: this.sliceBusinessHours.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                props.businessHours,\n                dateProfile,\n                nextDayThreshold,\n                context\n            ], extraArgs)),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                props.eventDrag,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventResize: this.sliceEventResize.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n                props.eventResize,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    };\n    Slicer.prototype.sliceNowDate = function(date, context) {\n        var extraArgs = [];\n        for(var _i = 2; _i < arguments.length; _i++){\n            extraArgs[_i - 2] = arguments[_i];\n        }\n        return this._sliceDateSpan.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            {\n                range: {\n                    start: date,\n                    end: addMs(date, 1)\n                },\n                allDay: false\n            },\n            {},\n            context\n        ], extraArgs));\n    };\n    Slicer.prototype._sliceBusinessHours = function(businessHours, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),\n            {},\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs)).bg;\n    };\n    Slicer.prototype._sliceEventStore = function(eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (eventStore) {\n            var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    };\n    Slicer.prototype._sliceInteraction = function(interaction, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!interaction) {\n            return null;\n        }\n        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    };\n    Slicer.prototype._sliceDateSpan = function(dateSpan, eventUiBases, context) {\n        var extraArgs = [];\n        for(var _i = 3; _i < arguments.length; _i++){\n            extraArgs[_i - 3] = arguments[_i];\n        }\n        if (!dateSpan) {\n            return [];\n        }\n        var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n        var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            dateSpan.range\n        ], extraArgs));\n        for(var _a = 0, segs_1 = segs; _a < segs_1.length; _a++){\n            var seg = segs_1[_a];\n            seg.eventRange = eventRange;\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRanges = function(eventRanges, extraArgs) {\n        var segs = [];\n        for(var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++){\n            var eventRange = eventRanges_1[_i];\n            segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRange = function(eventRange, extraArgs) {\n        var dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            dateRange\n        ], extraArgs));\n        for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n            var seg = segs_2[_i];\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    };\n    return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    var range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    var instances = interaction.mutatedEvents.instances;\n    for(var instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection: dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    var calendarState = context.getCurrentData();\n    var props = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n    if (dateSpanMeta === void 0) {\n        dateSpanMeta = {};\n    }\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var currentState = context.getCurrentData();\n    var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    var subjectEventStore = interaction.mutatedEvents;\n    var subjectDefs = subjectEventStore.defs;\n    var subjectInstances = subjectEventStore.instances;\n    var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    var otherDefs = otherEventStore.defs;\n    var otherInstances = otherEventStore.instances;\n    var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(var subjectInstanceId in subjectInstances){\n        var subjectInstance = subjectInstances[subjectInstanceId];\n        var subjectRange = subjectInstance.range;\n        var subjectConfig = subjectConfigs[subjectInstance.defId];\n        var subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        var eventOverlap = context.options.eventOverlap;\n        var eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(var otherInstanceId in otherInstances){\n            var otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                var otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), new EventApi(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for(var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++){\n            var subjectAllow = _a[_i];\n            var subjectDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            var origDef = calendarEventStore.defs[subjectDef.defId];\n            var origInstance = calendarEventStore.instances[subjectInstanceId];\n            var eventApi = void 0;\n            if (origDef) {\n                eventApi = new EventApi(context, origDef, origInstance);\n            } else {\n                eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var relevantEventStore = state.eventStore;\n    var relevantDefs = relevantEventStore.defs;\n    var relevantInstances = relevantEventStore.instances;\n    var selection = state.dateSelection;\n    var selectionRange = selection.range;\n    var selectionConfig = context.getCurrentData().selectionConfig;\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    var selectOverlap = context.options.selectOverlap;\n    var selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(var relevantInstanceId in relevantInstances){\n        var relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for(var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++){\n        var selectionAllow = _a[_i];\n        var fullDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for(var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++){\n        var constraint = constraints_1[_i];\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function(eventDef) {\n            return eventDef.groupId === constraint;\n        }));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    var instances = eventStore.instances;\n    var ranges = [];\n    for(var instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for(var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++){\n        var outerRange = outerRanges_1[_i];\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nvar Scroller = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Scroller, _super);\n    function Scroller() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    Scroller.prototype.render = function() {\n        var props = this.props;\n        var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;\n        var isAbsolute = liquid && liquidIsAbsolute;\n        var className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    };\n    Scroller.prototype.needsXScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.needsYScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.getXScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    Scroller.prototype.getYScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ var RefMap = /** @class */ function() {\n    function RefMap(masterCallback) {\n        var _this = this;\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = function(val, key) {\n            var _a = _this, depths = _a.depths, currentMap = _a.currentMap;\n            var removed = false;\n            var added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete _this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (_this.masterCallback) {\n                if (removed) {\n                    _this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    _this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    RefMap.prototype.createRef = function(key) {\n        var _this = this;\n        var refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = function(val) {\n                _this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    };\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    RefMap.prototype.collect = function(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    };\n    RefMap.prototype.getAll = function() {\n        return hashValuesToArray(this.currentMap);\n    };\n    return RefMap;\n}();\nfunction computeShrinkWidth(chunkEls) {\n    var shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    var largestWidth = 0;\n    for(var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++){\n        var shrinkCell = shrinkCells_1[_i];\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    var expandRows = arg.expandRows;\n    var content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    var colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for(var _i = 0, cols_1 = cols; _i < cols_1.length; _i++){\n        var colProps = cols_1[_i];\n        var span = colProps.span || 1;\n        for(var i = 0; i < span; i += 1){\n            colNodes.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n        \"colgroup\",\n        {}\n    ], colNodes));\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for(var _i = 0, cols_2 = cols; _i < cols_2.length; _i++){\n        var col = cols_2[_i];\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    var classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    var classNames = [\n        \"fc-scrollgrid-section\",\n        \"fc-scrollgrid-section-\" + sectionConfig.type,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    var stickyHeaderDates = options.stickyHeaderDates;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    var stickyFooterScrollbar = options.stickyFooterScrollbar;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nvar SimpleScrollGrid = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(SimpleScrollGrid, _super);\n    function SimpleScrollGrid() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.processCols = memoize(function(a) {\n            return a;\n        }, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        _this.renderMicroColGroup = memoize(renderMicroColGroup);\n        _this.scrollerRefs = new RefMap();\n        _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n        _this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        _this.handleSizing = function() {\n            _this.safeSetState((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                shrinkWidth: _this.computeShrinkWidth()\n            }, _this.computeScrollerDims()));\n        };\n        return _this;\n    }\n    SimpleScrollGrid.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var sectionConfigs = props.sections || [];\n        var cols = this.processCols(props.cols);\n        var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        var classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        var configCnt = sectionConfigs.length;\n        var configI = 0;\n        var currentConfig;\n        var headSectionNodes = [];\n        var bodySectionNodes = [];\n        var footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        var isBuggy = !getCanVGrowWithinCell();\n        var roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            \"thead\",\n            roleAttrs\n        ], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            \"tbody\",\n            roleAttrs\n        ], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            \"tfoot\",\n            roleAttrs\n        ], footSectionNodes)), isBuggy && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            \"tbody\",\n            roleAttrs\n        ], headSectionNodes), bodySectionNodes), footSectionNodes)));\n    };\n    SimpleScrollGrid.prototype.renderSection = function(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    };\n    SimpleScrollGrid.prototype.renderChunkTd = function(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        var props = this.props;\n        var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;\n        var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        var overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        var sectionKey = sectionConfig.key;\n        var content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: function() {}\n        }, isHeader);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-scroller-harness\" + (isLiquid ? \" fc-scroller-harness-liquid\" : \"\")\n        }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    };\n    SimpleScrollGrid.prototype._handleScrollerEl = function(scrollerEl, key) {\n        var section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    };\n    SimpleScrollGrid.prototype.componentDidMount = function() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.componentDidUpdate = function() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    };\n    SimpleScrollGrid.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.computeShrinkWidth = function() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    };\n    SimpleScrollGrid.prototype.computeScrollerDims = function() {\n        var scrollbarWidth = getScrollbarWidths();\n        var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;\n        var forceYScrollbars = false;\n        var scrollerClientWidths = {};\n        var scrollerClientHeights = {};\n        for(var sectionKey in scrollerRefs.currentMap){\n            var scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for(var _i = 0, _b = this.props.sections; _i < _b.length; _i++){\n            var section = _b[_i];\n            var sectionKey = section.key;\n            var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars: forceYScrollbars,\n            scrollerClientWidths: scrollerClientWidths,\n            scrollerClientHeights: scrollerClientHeights\n        };\n    };\n    return SimpleScrollGrid;\n}(BaseComponent);\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for(var _i = 0, sections_1 = sections; _i < sections_1.length; _i++){\n        var section = sections_1[_i];\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nvar EventRoot = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventRoot, _super);\n    function EventRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.elRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    EventRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var seg = props.seg;\n        var eventRange = seg.eventRange;\n        var ui = eventRange.ui;\n        var hookProps = {\n            event: new EventApi(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.eventClassNames,\n            content: options.eventContent,\n            defaultContent: props.defaultContent,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount,\n            elRef: this.elRef\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n        });\n    };\n    EventRoot.prototype.componentDidMount = function() {\n        setElSeg(this.elRef.current, this.props.seg);\n    };\n    /*\n    need to re-assign seg to the element if seg changes, even if the element is the same\n    */ EventRoot.prototype.componentDidUpdate = function(prevProps) {\n        var seg = this.props.seg;\n        if (seg !== prevProps.seg) {\n            setElSeg(this.elRef.current, seg);\n        }\n    };\n    return EventRoot;\n}(BaseComponent);\n// should not be a purecomponent\nvar StandardEvent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardEvent, _super);\n    function StandardEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StandardEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var seg = props.seg;\n        var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n        var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n            seg: seg,\n            timeText: timeText,\n            disableDragging: props.disableDragging,\n            disableResizing: props.disableResizing,\n            defaultContent: props.defaultContent || renderInnerContent$1,\n            isDragging: props.isDragging,\n            isResizing: props.isResizing,\n            isDateSelecting: props.isDateSelecting,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                className: props.extraClassNames.concat(classNames).join(\" \"),\n                style: {\n                    borderColor: hookProps.borderColor,\n                    backgroundColor: hookProps.backgroundColor\n                },\n                ref: rootElRef\n            }, getSegAnchorAttrs(seg, context)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-event-main\",\n                ref: innerElRef,\n                style: {\n                    color: hookProps.textColor\n                }\n            }, innerContent), hookProps.isStartResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), hookProps.isEndResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            }));\n        });\n    };\n    return StandardEvent;\n}(BaseComponent);\nfunction renderInnerContent$1(innerProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title-container\"\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\"))));\n}\nvar NowIndicatorRoot = function(props) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function(context) {\n        var options = context.options;\n        var hookProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.nowIndicatorClassNames,\n            content: options.nowIndicatorContent,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }, props.children);\n    });\n};\n_c1 = NowIndicatorRoot;\nvar DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nvar DayCellContent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellContent, _super);\n    function DayCellContent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DayCellContent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = refineDayCellHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n            hookProps: hookProps,\n            content: options.dayCellContent,\n            defaultContent: props.defaultContent\n        }, props.children);\n    };\n    return DayCellContent;\n}(BaseComponent);\nfunction refineDayCellHookProps(raw) {\n    var date = raw.date, dateEnv = raw.dateEnv;\n    var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : \"\"\n    }), raw.extraProps);\n}\nvar DayCellRoot = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellRoot, _super);\n    function DayCellRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    DayCellRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = this.refineHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n         : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n        var dataAttrs = hookProps.isDisabled ? {} : {\n            \"data-date\": formatDayString(props.date)\n        };\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n            hookProps: hookProps,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n        });\n    };\n    return DayCellRoot;\n}(BaseComponent);\nfunction renderFill(fillType) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-\" + fillType\n    });\n}\nvar BgEvent = function(props) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n        defaultContent: renderInnerContent,\n        seg: props.seg /* uselesss i think */ ,\n        timeText: \"\",\n        disableDragging: true,\n        disableResizing: true,\n        isDragging: false,\n        isResizing: false,\n        isDateSelecting: false,\n        isSelected: false,\n        isPast: props.isPast,\n        isFuture: props.isFuture,\n        isToday: props.isToday\n    }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: rootElRef,\n            className: [\n                \"fc-bg-event\"\n            ].concat(classNames).join(\" \"),\n            style: {\n                backgroundColor: hookProps.backgroundColor\n            }\n        }, innerContent);\n    });\n};\n_c2 = BgEvent;\nfunction renderInnerContent(props) {\n    var title = props.event.title;\n    return title && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nvar WeekNumberRoot = function(props) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function(context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var date = props.date;\n        var format = options.weekNumberFormat || props.defaultFormat;\n        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        var text = dateEnv.format(date, format);\n        var hookProps = {\n            num: num,\n            text: text,\n            date: date\n        };\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.weekNumberClassNames,\n            content: options.weekNumberContent,\n            defaultContent: renderInner,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }, props.children);\n    });\n};\n_c3 = WeekNumberRoot;\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nvar PADDING_FROM_VIEWPORT = 10;\nvar Popover = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Popover, _super);\n    function Popover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            titleId: getUniqueDomId()\n        };\n        _this.handleRootEl = function(el) {\n            _this.rootEl = el;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        _this.handleDocumentMouseDown = function(ev) {\n            // only hide the popover if the click happened outside the popover\n            var target = getEventTargetViaRoot(ev);\n            if (!_this.rootEl.contains(target)) {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleDocumentKeyDown = function(ev) {\n            if (ev.key === \"Escape\") {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleCloseClick = function() {\n            var onClose = _this.props.onClose;\n            if (onClose) {\n                onClose();\n            }\n        };\n        return _this;\n    }\n    Popover.prototype.render = function() {\n        var _a = this.context, theme = _a.theme, options = _a.options;\n        var _b = this, props = _b.props, state = _b.state;\n        var classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId\n        }, props.extraAttrs, {\n            ref: this.handleRootEl\n        }), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    };\n    Popover.prototype.componentDidMount = function() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    };\n    Popover.prototype.componentWillUnmount = function() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    };\n    Popover.prototype.updateSize = function() {\n        var isRtl = this.context.isRtl;\n        var _a = this.props, alignmentEl = _a.alignmentEl, alignGridTop = _a.alignGridTop;\n        var rootEl = this.rootEl;\n        var alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            var popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            var popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin_1.top,\n                left: popoverLeft - origin_1.left\n            });\n        }\n    };\n    return Popover;\n}(BaseComponent);\nvar MorePopover = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MorePopover, _super);\n    function MorePopover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    MorePopover.prototype.render = function() {\n        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;\n        var props = this.props;\n        var startDate = props.startDate, todayRange = props.todayRange, dateProfile = props.dateProfile;\n        var title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellRoot, {\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange,\n            elRef: this.handleRootEl\n        }, function(rootElRef, dayClassNames, dataAttrs) {\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Popover, {\n                elRef: rootElRef,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(dayClassNames),\n                extraAttrs: dataAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellContent, {\n                date: startDate,\n                dateProfile: dateProfile,\n                todayRange: todayRange\n            }, function(innerElRef, innerContent) {\n                return innerContent && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-more-popover-misc\",\n                    ref: innerElRef\n                }, innerContent);\n            }), props.children);\n        });\n    };\n    MorePopover.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        var _a = this, rootEl = _a.rootEl, props = _a.props;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    allDay: true,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    };\n    return MorePopover;\n}(DateComponent);\nvar MoreLinkRoot = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MoreLinkRoot, _super);\n    function MoreLinkRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.linkElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        _this.handleClick = function(ev) {\n            var _a = _this, props = _a.props, context = _a.context;\n            var moreLinkClick = context.options.moreLinkClick;\n            var date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;\n                return {\n                    event: new EventApi(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date: date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                _this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        _this.handlePopoverClose = function() {\n            _this.setState({\n                isPopoverOpen: false\n            });\n        };\n        return _this;\n    }\n    MoreLinkRoot.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state;\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function(context) {\n            var viewApi = context.viewApi, options = context.options, calendarApi = context.calendarApi;\n            var moreLinkText = options.moreLinkText;\n            var moreCnt = props.moreCnt;\n            var range = computeRange(props);\n            var text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText;\n            var title = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            var hookProps = {\n                num: moreCnt,\n                shortText: \"+\" + moreCnt,\n                text: text,\n                view: viewApi\n            };\n            return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, Boolean(props.moreCnt) && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n                elRef: _this.linkElRef,\n                hookProps: hookProps,\n                classNames: options.moreLinkClassNames,\n                content: options.moreLinkContent,\n                defaultContent: props.defaultContent || renderMoreLinkInner,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                return props.children(rootElRef, [\n                    \"fc-more-link\"\n                ].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : \"\");\n            }), state.isPopoverOpen && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: _this.parentEl,\n                alignmentEl: props.alignmentElRef.current,\n                alignGridTop: props.alignGridTop,\n                onClose: _this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    };\n    MoreLinkRoot.prototype.componentDidMount = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.componentDidUpdate = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.updateParentEl = function() {\n        if (this.linkElRef.current) {\n            this.parentEl = elementClosest(this.linkElRef.current, \".fc-view-harness\");\n        }\n    };\n    return MoreLinkRoot;\n}(BaseComponent);\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    var hiddenSegs = props.hiddenSegs;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\n// exports\n// --------------------------------------------------------------------------------------------------\nvar version = \"5.11.3\"; // important to type it, so .d.ts has generic string\n //# sourceMappingURL=main.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ContentHook\");\n$RefreshReg$(_c1, \"NowIndicatorRoot\");\n$RefreshReg$(_c2, \"BgEvent\");\n$RefreshReg$(_c3, \"WeekNumberRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQSxHQUNvQjtBQUV1QztBQUM0QztBQUM3RTtBQUUxQixvREFBb0Q7QUFDcEQsbUNBQW1DO0FBQ25DLElBQUlTLGlCQUFpQixXQUFXLEdBQUksV0FBWTtJQUM1QyxTQUFTQSxlQUFlQyxPQUFPLEVBQUVDLG1CQUFtQixFQUFFO1FBQ2xELElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdBO0lBQy9CO0lBQ0FGLGVBQWVHLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFdBQVk7UUFDMUMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFFBQVEsQ0FBQztZQUNsQkMsTUFBTTtZQUNOQyxVQUFVLElBQUksQ0FBQ0wsbUJBQW1CLENBQUNLLFFBQVE7UUFDL0M7SUFDSjtJQUNBUCxlQUFlRyxTQUFTLENBQUNLLE9BQU8sR0FBRyxXQUFZO1FBQzNDLElBQUksQ0FBQ1AsT0FBTyxDQUFDSSxRQUFRLENBQUM7WUFDbEJDLE1BQU07WUFDTkcsV0FBVztnQkFBQyxJQUFJLENBQUNQLG1CQUFtQixDQUFDSyxRQUFRO2FBQUM7WUFDOUNHLFdBQVcsSUFBSTtRQUNuQjtJQUNKO0lBQ0FDLE9BQU9DLGNBQWMsQ0FBQ1osZUFBZUcsU0FBUyxFQUFFLE1BQU07UUFDbERVLEtBQUssV0FBWTtZQUNiLE9BQU8sSUFBSSxDQUFDWCxtQkFBbUIsQ0FBQ1ksUUFBUTtRQUM1QztRQUNBQyxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUNaLGVBQWVHLFNBQVMsRUFBRSxPQUFPO1FBQ25EVSxLQUFLLFdBQVk7WUFDYixPQUFPLElBQUksQ0FBQ1gsbUJBQW1CLENBQUNlLElBQUksQ0FBQ0MsR0FBRztRQUM1QztRQUNBSCxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUNaLGVBQWVHLFNBQVMsRUFBRSxVQUFVO1FBQ3REVSxLQUFLLFdBQVk7WUFDYixPQUFPLElBQUksQ0FBQ1gsbUJBQW1CLENBQUNlLElBQUksQ0FBQ0UsTUFBTSxFQUFFLDRCQUE0QjtRQUM3RTtRQUNBSixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBLE9BQU9oQjtBQUNYO0FBRUEsU0FBU29CLGNBQWNDLEVBQUUsRUFBRTtJQUN2QixJQUFJQSxHQUFHQyxVQUFVLEVBQUU7UUFDZkQsR0FBR0MsVUFBVSxDQUFDQyxXQUFXLENBQUNGO0lBQzlCLENBQUM7QUFDTDtBQUNBLFdBQVc7QUFDWCxtSEFBbUg7QUFDbkgsU0FBU0csZUFBZUgsRUFBRSxFQUFFSSxRQUFRLEVBQUU7SUFDbEMsSUFBSUosR0FBR0ssT0FBTyxFQUFFO1FBQ1osT0FBT0wsR0FBR0ssT0FBTyxDQUFDRDtJQUNsQiw2QkFBNkI7SUFDN0Isd0VBQXdFO0lBQzVFLENBQUM7SUFDRCxJQUFJLENBQUNFLFNBQVNDLGVBQWUsQ0FBQ0MsUUFBUSxDQUFDUixLQUFLO1FBQ3hDLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxHQUFHO1FBQ0MsSUFBSVMsZUFBZVQsSUFBSUksV0FBVztZQUM5QixPQUFPSjtRQUNYLENBQUM7UUFDREEsS0FBTUEsR0FBR1UsYUFBYSxJQUFJVixHQUFHQyxVQUFVO0lBQzNDLFFBQVNELE9BQU8sSUFBSSxJQUFJQSxHQUFHVyxRQUFRLEtBQUssR0FBRztJQUMzQyxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVNGLGVBQWVULEVBQUUsRUFBRUksUUFBUSxFQUFFO0lBQ2xDLElBQUlRLFNBQVNaLEdBQUdhLE9BQU8sSUFBSWIsR0FBR2MsZUFBZSxJQUFJZCxHQUFHZSxpQkFBaUI7SUFDckUsT0FBT0gsT0FBT0ksSUFBSSxDQUFDaEIsSUFBSUk7QUFDM0I7QUFDQSwrQkFBK0I7QUFDL0Isc0RBQXNEO0FBQ3RELDRCQUE0QjtBQUM1QixTQUFTYSxhQUFhQyxTQUFTLEVBQUVkLFFBQVEsRUFBRTtJQUN2QyxJQUFJZSxhQUFhRCxxQkFBcUJFLGNBQWM7UUFBQ0Y7S0FBVSxHQUFHQSxTQUFTO0lBQzNFLElBQUlHLGFBQWEsRUFBRTtJQUNuQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsV0FBV0ksTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDM0MsSUFBSVQsVUFBVU0sVUFBVSxDQUFDRyxFQUFFLENBQUNFLGdCQUFnQixDQUFDcEI7UUFDN0MsSUFBSyxJQUFJcUIsSUFBSSxHQUFHQSxJQUFJWixRQUFRVSxNQUFNLEVBQUVFLEtBQUssRUFBRztZQUN4Q0osV0FBV0ssSUFBSSxDQUFDYixPQUFPLENBQUNZLEVBQUU7UUFDOUI7SUFDSjtJQUNBLE9BQU9KO0FBQ1g7QUFDQSwrQkFBK0I7QUFDL0IsNEVBQTRFO0FBQzVFLFNBQVNNLG1CQUFtQkMsTUFBTSxFQUFFeEIsUUFBUSxFQUFFO0lBQzFDLElBQUl5QixVQUFVRCxrQkFBa0JSLGNBQWM7UUFBQ1E7S0FBTyxHQUFHQSxNQUFNO0lBQy9ELElBQUlQLGFBQWEsRUFBRTtJQUNuQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU8sUUFBUU4sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeEMsSUFBSVEsYUFBYUQsT0FBTyxDQUFDUCxFQUFFLENBQUNTLFFBQVEsRUFBRSxxQkFBcUI7UUFDM0QsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUlLLFdBQVdQLE1BQU0sRUFBRUUsS0FBSyxFQUFHO1lBQzNDLElBQUlPLFlBQVlGLFVBQVUsQ0FBQ0wsRUFBRTtZQUM3QixJQUFJLENBQUNyQixZQUFZSyxlQUFldUIsV0FBVzVCLFdBQVc7Z0JBQ2xEaUIsV0FBV0ssSUFBSSxDQUFDTTtZQUNwQixDQUFDO1FBQ0w7SUFDSjtJQUNBLE9BQU9YO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsbUhBQW1IO0FBQ25ILElBQUlZLGdCQUFnQjtBQUNwQixTQUFTQyxXQUFXbEMsRUFBRSxFQUFFbUMsS0FBSyxFQUFFO0lBQzNCLElBQUssSUFBSUMsWUFBWUQsTUFBTztRQUN4QkUsZUFBZXJDLElBQUlvQyxVQUFVRCxLQUFLLENBQUNDLFNBQVM7SUFDaEQ7QUFDSjtBQUNBLFNBQVNDLGVBQWVyQyxFQUFFLEVBQUVzQyxJQUFJLEVBQUVDLEdBQUcsRUFBRTtJQUNuQyxJQUFJQSxPQUFPLElBQUksRUFBRTtRQUNidkMsR0FBR3dDLEtBQUssQ0FBQ0YsS0FBSyxHQUFHO0lBQ3JCLE9BQ0ssSUFBSSxPQUFPQyxRQUFRLFlBQVlOLGNBQWNRLElBQUksQ0FBQ0gsT0FBTztRQUMxRHRDLEdBQUd3QyxLQUFLLENBQUNGLEtBQUssR0FBR0MsTUFBTTtJQUMzQixPQUNLO1FBQ0R2QyxHQUFHd0MsS0FBSyxDQUFDRixLQUFLLEdBQUdDO0lBQ3JCLENBQUM7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixtSEFBbUg7QUFDbkgsb0VBQW9FO0FBQ3BFLDRFQUE0RTtBQUM1RSxrRUFBa0U7QUFDbEUsU0FBU0csc0JBQXNCQyxFQUFFLEVBQUU7SUFDL0IsSUFBSUMsSUFBSUM7SUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQ0QsS0FBS0QsR0FBR0csWUFBWSxNQUFNLElBQUksSUFBSUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNUIsSUFBSSxDQUFDMkIsR0FBRyxDQUFDLEVBQUUsTUFBTSxJQUFJLElBQUlFLE9BQU8sS0FBSyxJQUFJQSxLQUFLRixHQUFHSSxNQUFNO0FBQ3ZJO0FBQ0EsNEJBQTRCO0FBQzVCLG1IQUFtSDtBQUNuSCxTQUFTQyxVQUFVaEQsRUFBRSxFQUFFO0lBQ25CLE9BQU9BLEdBQUdpRCxXQUFXLEdBQUdqRCxHQUFHaUQsV0FBVyxLQUFLM0MsUUFBUTtBQUN2RDtBQUNBLDhCQUE4QjtBQUM5QixJQUFJNEMsU0FBUztBQUNiLFNBQVNDLGlCQUFpQjtJQUN0QkQsVUFBVTtJQUNWLE9BQU8sWUFBWUE7QUFDdkI7QUFFQSxrRUFBa0U7QUFDbEUsU0FBU0UsZUFBZVQsRUFBRSxFQUFFO0lBQ3hCQSxHQUFHUyxjQUFjO0FBQ3JCO0FBQ0EsbUJBQW1CO0FBQ25CLG1IQUFtSDtBQUNuSCxTQUFTQyx1QkFBdUJqRCxRQUFRLEVBQUVrRCxPQUFPLEVBQUU7SUFDL0MsT0FBTyxTQUFVWCxFQUFFLEVBQUU7UUFDakIsSUFBSVksZUFBZXBELGVBQWV3QyxHQUFHSSxNQUFNLEVBQUUzQztRQUM3QyxJQUFJbUQsY0FBYztZQUNkRCxRQUFRdEMsSUFBSSxDQUFDdUMsY0FBY1osSUFBSVk7UUFDbkMsQ0FBQztJQUNMO0FBQ0o7QUFDQSxTQUFTQyxpQkFBaUJ0QyxTQUFTLEVBQUV1QyxTQUFTLEVBQUVyRCxRQUFRLEVBQUVrRCxPQUFPLEVBQUU7SUFDL0QsSUFBSUksa0JBQWtCTCx1QkFBdUJqRCxVQUFVa0Q7SUFDdkRwQyxVQUFVeUMsZ0JBQWdCLENBQUNGLFdBQVdDO0lBQ3RDLE9BQU8sV0FBWTtRQUNmeEMsVUFBVTBDLG1CQUFtQixDQUFDSCxXQUFXQztJQUM3QztBQUNKO0FBQ0EsU0FBU0csd0JBQXdCM0MsU0FBUyxFQUFFZCxRQUFRLEVBQUUwRCxZQUFZLEVBQUVDLFlBQVksRUFBRTtJQUM5RSxJQUFJQztJQUNKLE9BQU9SLGlCQUFpQnRDLFdBQVcsYUFBYWQsVUFBVSxTQUFVNkQsV0FBVyxFQUFFVixZQUFZLEVBQUU7UUFDM0YsSUFBSUEsaUJBQWlCUyxxQkFBcUI7WUFDdENBLHNCQUFzQlQ7WUFDdEJPLGFBQWFHLGFBQWFWO1lBQzFCLElBQUlXLHFCQUFxQixTQUFVQyxZQUFZLEVBQUU7Z0JBQzdDSCxzQkFBc0IsSUFBSTtnQkFDMUJELGFBQWFJLGNBQWNaO2dCQUMzQkEsYUFBYUssbUJBQW1CLENBQUMsY0FBY007WUFDbkQ7WUFDQSxtREFBbUQ7WUFDbkRYLGFBQWFJLGdCQUFnQixDQUFDLGNBQWNPO1FBQ2hELENBQUM7SUFDTDtBQUNKO0FBQ0EsWUFBWTtBQUNaLG1IQUFtSDtBQUNuSCxJQUFJRSx1QkFBdUI7SUFDdkI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QscUVBQXFFO0FBQ3JFLFNBQVNDLG1CQUFtQnJFLEVBQUUsRUFBRXNFLFFBQVEsRUFBRTtJQUN0QyxJQUFJQyxlQUFlLFNBQVU1QixFQUFFLEVBQUU7UUFDN0IyQixTQUFTM0I7UUFDVHlCLHFCQUFxQkksT0FBTyxDQUFDLFNBQVVDLFNBQVMsRUFBRTtZQUM5Q3pFLEdBQUc0RCxtQkFBbUIsQ0FBQ2EsV0FBV0Y7UUFDdEM7SUFDSjtJQUNBSCxxQkFBcUJJLE9BQU8sQ0FBQyxTQUFVQyxTQUFTLEVBQUU7UUFDOUN6RSxHQUFHMkQsZ0JBQWdCLENBQUNjLFdBQVdGLGVBQWUsOERBQThEO0lBQ2hIO0FBQ0o7QUFDQSxtQkFBbUI7QUFDbkIsbUhBQW1IO0FBQ25ILFNBQVNHLHFCQUFxQnBCLE9BQU8sRUFBRTtJQUNuQyxPQUFPcEYsK0NBQVFBLENBQUM7UUFBRXlHLFNBQVNyQjtJQUFRLEdBQUdzQix3QkFBd0J0QjtBQUNsRTtBQUNBLFNBQVNzQix3QkFBd0J0QixPQUFPLEVBQUU7SUFDdEMsT0FBTztRQUNIdUIsVUFBVTtRQUNWQyxXQUFXLFNBQVVuQyxFQUFFLEVBQUU7WUFDckIsSUFBSUEsR0FBR29DLEdBQUcsS0FBSyxXQUFXcEMsR0FBR29DLEdBQUcsS0FBSyxLQUFLO2dCQUN0Q3pCLFFBQVFYO2dCQUNSQSxHQUFHUyxjQUFjLElBQUksbUNBQW1DO1lBQzVELENBQUM7UUFDTDtJQUNKO0FBQ0o7QUFFQSxJQUFJNEIsYUFBYTtBQUNqQixTQUFTQyxPQUFPO0lBQ1pELGNBQWM7SUFDZCxPQUFPRSxPQUFPRjtBQUNsQjtBQUNBO3NIQUNzSCxHQUN0SCxpRkFBaUY7QUFDakYsU0FBU0csZ0JBQWdCO0lBQ3JCN0UsU0FBUzhFLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUM7QUFDaEM7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0MsZUFBZTtJQUNwQmpGLFNBQVM4RSxJQUFJLENBQUNDLFNBQVMsQ0FBQ3RHLE1BQU0sQ0FBQztBQUNuQztBQUNBO3NIQUNzSCxHQUN0SCxTQUFTeUcsaUJBQWlCeEYsRUFBRSxFQUFFO0lBQzFCQSxHQUFHcUYsU0FBUyxDQUFDQyxHQUFHLENBQUM7SUFDakJ0RixHQUFHMkQsZ0JBQWdCLENBQUMsZUFBZVA7QUFDdkM7QUFDQSxTQUFTcUMsZUFBZXpGLEVBQUUsRUFBRTtJQUN4QkEsR0FBR3FGLFNBQVMsQ0FBQ3RHLE1BQU0sQ0FBQztJQUNwQmlCLEdBQUc0RCxtQkFBbUIsQ0FBQyxlQUFlUjtBQUMxQztBQUNBO3NIQUNzSCxHQUN0SCxTQUFTc0MsbUJBQW1CMUYsRUFBRSxFQUFFO0lBQzVCQSxHQUFHMkQsZ0JBQWdCLENBQUMsZUFBZVA7QUFDdkM7QUFDQSxTQUFTdUMsaUJBQWlCM0YsRUFBRSxFQUFFO0lBQzFCQSxHQUFHNEQsbUJBQW1CLENBQUMsZUFBZVI7QUFDMUM7QUFDQSxTQUFTd0MsZ0JBQWdCQyxLQUFLLEVBQUU7SUFDNUIsSUFBSUMsUUFBUSxFQUFFO0lBQ2QsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSXpFO0lBQ0osSUFBSTBFO0lBQ0osSUFBSSxPQUFPSCxVQUFVLFVBQVU7UUFDM0JFLFNBQVNGLE1BQU1JLEtBQUssQ0FBQztJQUN6QixPQUNLLElBQUksT0FBT0osVUFBVSxZQUFZO1FBQ2xDRSxTQUFTO1lBQUNGO1NBQU07SUFDcEIsT0FDSyxJQUFJSyxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDM0JFLFNBQVNGO0lBQ2IsQ0FBQztJQUNELElBQUt2RSxJQUFJLEdBQUdBLElBQUl5RSxPQUFPeEUsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDbkMwRSxRQUFRRCxNQUFNLENBQUN6RSxFQUFFO1FBQ2pCLElBQUksT0FBTzBFLFVBQVUsVUFBVTtZQUMzQkYsTUFBTXBFLElBQUksQ0FBQ3NFLE1BQU1JLE1BQU0sQ0FBQyxPQUFPLE1BQzNCO2dCQUFFQyxPQUFPTCxNQUFNTSxTQUFTLENBQUM7Z0JBQUlDLE9BQU8sQ0FBQztZQUFFLElBQ3ZDO2dCQUFFRixPQUFPTDtnQkFBT08sT0FBTztZQUFFLENBQUM7UUFDbEMsT0FDSyxJQUFJLE9BQU9QLFVBQVUsWUFBWTtZQUNsQ0YsTUFBTXBFLElBQUksQ0FBQztnQkFBRThFLE1BQU1SO1lBQU07UUFDN0IsQ0FBQztJQUNMO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBLFNBQVNXLG9CQUFvQkMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRTtJQUNqRCxJQUFJdEY7SUFDSixJQUFJdUY7SUFDSixJQUFLdkYsSUFBSSxHQUFHQSxJQUFJc0YsV0FBV3JGLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3ZDdUYsTUFBTUMsbUJBQW1CSixNQUFNQyxNQUFNQyxVQUFVLENBQUN0RixFQUFFO1FBQ2xELElBQUl1RixLQUFLO1lBQ0wsT0FBT0E7UUFDWCxDQUFDO0lBQ0w7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTQyxtQkFBbUJKLElBQUksRUFBRUMsSUFBSSxFQUFFSSxTQUFTLEVBQUU7SUFDL0MsSUFBSUEsVUFBVVAsSUFBSSxFQUFFO1FBQ2hCLE9BQU9PLFVBQVVQLElBQUksQ0FBQ0UsTUFBTUM7SUFDaEMsQ0FBQztJQUNELE9BQU9LLGdCQUFnQk4sSUFBSSxDQUFDSyxVQUFVVixLQUFLLENBQUMsRUFBRU0sSUFBSSxDQUFDSSxVQUFVVixLQUFLLENBQUMsSUFDNURVLENBQUFBLFVBQVVSLEtBQUssSUFBSTtBQUM5QjtBQUNBLFNBQVNTLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7SUFDM0IsSUFBSSxDQUFDRCxLQUFLLENBQUNDLEdBQUc7UUFDVixPQUFPO0lBQ1gsQ0FBQztJQUNELElBQUlBLEtBQUssSUFBSSxFQUFFO1FBQ1gsT0FBTyxDQUFDO0lBQ1osQ0FBQztJQUNELElBQUlELEtBQUssSUFBSSxFQUFFO1FBQ1gsT0FBTztJQUNYLENBQUM7SUFDRCxJQUFJLE9BQU9BLE1BQU0sWUFBWSxPQUFPQyxNQUFNLFVBQVU7UUFDaEQsT0FBT2hDLE9BQU8rQixHQUFHRSxhQUFhLENBQUNqQyxPQUFPZ0M7SUFDMUMsQ0FBQztJQUNELE9BQU9ELElBQUlDO0FBQ2Y7QUFDQTtzSEFDc0gsR0FDdEgsU0FBU0UsU0FBUzdFLEdBQUcsRUFBRThFLEdBQUcsRUFBRTtJQUN4QixJQUFJQyxJQUFJcEMsT0FBTzNDO0lBQ2YsT0FBTyxNQUFNZ0YsTUFBTSxDQUFDLEdBQUdGLE1BQU1DLEVBQUUvRixNQUFNLElBQUkrRjtBQUM3QztBQUNBLFNBQVNFLG1CQUFtQkMsU0FBUyxFQUFFQyxJQUFJLEVBQUVDLFlBQVksRUFBRTtJQUN2RCxJQUFJLE9BQU9GLGNBQWMsWUFBWTtRQUNqQyxPQUFPQSxVQUFVRyxLQUFLLENBQUMsS0FBSyxHQUFHRjtJQUNuQyxDQUFDO0lBQ0QsSUFBSSxPQUFPRCxjQUFjLFVBQVU7UUFDL0IsT0FBT0MsS0FBS0csTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUU7WUFBRSxPQUFRRixJQUFJRyxPQUFPLENBQUMsTUFBTUQsT0FBT0QsT0FBTztRQUFNLEdBQUdOO0lBQ3JHLENBQUM7SUFDRCxPQUFPRTtBQUNYO0FBQ0E7c0hBQ3NILEdBQ3RILFNBQVNPLGVBQWVqQixDQUFDLEVBQUVDLENBQUMsRUFBRTtJQUMxQixPQUFPRCxJQUFJQztBQUNmO0FBQ0EsU0FBU2lCLE1BQU1DLENBQUMsRUFBRTtJQUNkLE9BQU9BLElBQUksTUFBTTtBQUNyQjtBQUNBO3NIQUNzSCxHQUN0SCxTQUFTQyx5QkFBeUJDLE1BQU0sRUFBRTtJQUN0QyxJQUFJQyxhQUFhRCxPQUFPRSxhQUFhLENBQUM7SUFDdEMsSUFBSUMsaUJBQWlCSCxPQUFPRSxhQUFhLENBQUM7SUFDMUMsSUFBSSxDQUFDRCxZQUFZO1FBQ2IsTUFBTSxJQUFJRyxNQUFNLDhDQUE4QyxDQUFDLGtCQUFrQjtJQUNyRixDQUFDO0lBQ0QsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDakIsTUFBTSxJQUFJQyxNQUFNLGdEQUFnRDtJQUNwRSxDQUFDO0lBQ0QsT0FBT0osT0FBT0sscUJBQXFCLEdBQUdDLEtBQUssR0FBR0wsV0FBV0kscUJBQXFCLEdBQUdDLEtBQUssR0FBRywwQkFBMEI7SUFDL0dILGVBQWVFLHFCQUFxQixHQUFHQyxLQUFLO0FBQ3BEO0FBRUEsSUFBSUMsVUFBVTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztJQUFPO0NBQU07QUFDL0QsU0FBUztBQUNULFNBQVNDLFNBQVNDLENBQUMsRUFBRVgsQ0FBQyxFQUFFO0lBQ3BCLElBQUluQixJQUFJK0IsZUFBZUQ7SUFDdkI5QixDQUFDLENBQUMsRUFBRSxJQUFJbUIsSUFBSTtJQUNaLE9BQU9hLGVBQWVoQztBQUMxQjtBQUNBLFNBQVNpQyxRQUFRSCxDQUFDLEVBQUVYLENBQUMsRUFBRTtJQUNuQixJQUFJbkIsSUFBSStCLGVBQWVEO0lBQ3ZCOUIsQ0FBQyxDQUFDLEVBQUUsSUFBSW1CO0lBQ1IsT0FBT2EsZUFBZWhDO0FBQzFCO0FBQ0EsU0FBU2tDLE1BQU1KLENBQUMsRUFBRVgsQ0FBQyxFQUFFO0lBQ2pCLElBQUluQixJQUFJK0IsZUFBZUQ7SUFDdkI5QixDQUFDLENBQUMsRUFBRSxJQUFJbUI7SUFDUixPQUFPYSxlQUFlaEM7QUFDMUI7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLFNBQVNtQyxVQUFVQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUN2QixPQUFPQyxTQUFTRixJQUFJQyxNQUFNO0FBQzlCO0FBQ0EsU0FBU0MsU0FBU0YsRUFBRSxFQUFFQyxFQUFFLEVBQUU7SUFDdEIsT0FBTyxDQUFDQSxHQUFHRSxPQUFPLEtBQUtILEdBQUdHLE9BQU8sRUFBQyxJQUFNLFFBQU8sS0FBSyxLQUFLLEVBQUM7QUFDOUQ7QUFDQSxTQUFTQyxVQUFVSixFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUN2QixPQUFPLENBQUNBLEdBQUdFLE9BQU8sS0FBS0gsR0FBR0csT0FBTyxFQUFDLElBQU0sUUFBTyxLQUFLLEVBQUM7QUFDekQ7QUFDQSxTQUFTRSxZQUFZTCxFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUN6QixPQUFPLENBQUNBLEdBQUdFLE9BQU8sS0FBS0gsR0FBR0csT0FBTyxFQUFDLElBQU0sUUFBTyxFQUFDO0FBQ3BEO0FBQ0EsU0FBU0csWUFBWU4sRUFBRSxFQUFFQyxFQUFFLEVBQUU7SUFDekIsT0FBTyxDQUFDQSxHQUFHRSxPQUFPLEtBQUtILEdBQUdHLE9BQU8sRUFBQyxJQUFLO0FBQzNDO0FBQ0EsU0FBU0ksZUFBZVAsRUFBRSxFQUFFQyxFQUFFLEVBQUU7SUFDNUIsSUFBSU8sUUFBUUMsV0FBV1Q7SUFDdkIsSUFBSVUsUUFBUUQsV0FBV1I7SUFDdkIsT0FBTztRQUNIVSxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsTUFBTUMsS0FBS0MsS0FBSyxDQUFDYixTQUFTTSxPQUFPRTtRQUNqQ00sY0FBYyxHQUFJYixPQUFPLEtBQUtPLE1BQU1QLE9BQU8sS0FBT0gsQ0FBQUEsR0FBR0csT0FBTyxLQUFLSyxNQUFNTCxPQUFPLEVBQUM7SUFDbkY7QUFDSjtBQUNBLHNCQUFzQjtBQUN0QixTQUFTYyxlQUFlakIsRUFBRSxFQUFFQyxFQUFFLEVBQUU7SUFDNUIsSUFBSWlCLElBQUlDLGNBQWNuQixJQUFJQztJQUMxQixJQUFJaUIsTUFBTSxJQUFJLElBQUlBLElBQUksTUFBTSxHQUFHO1FBQzNCLE9BQU9BLElBQUk7SUFDZixDQUFDO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7QUFDQSxTQUFTQyxjQUFjbkIsRUFBRSxFQUFFQyxFQUFFLEVBQUU7SUFDM0IsSUFBSW1CLFNBQVNwQixRQUFRb0IsU0FBU25CLEtBQUs7UUFDL0IsT0FBT2EsS0FBS0MsS0FBSyxDQUFDYixTQUFTRixJQUFJQztJQUNuQyxDQUFDO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBU1EsV0FBV2YsQ0FBQyxFQUFFO0lBQ25CLE9BQU9FLGVBQWU7UUFDbEJGLEVBQUUyQixjQUFjO1FBQ2hCM0IsRUFBRTRCLFdBQVc7UUFDYjVCLEVBQUU2QixVQUFVO0tBQ2Y7QUFDTDtBQUNBLFNBQVNDLFlBQVk5QixDQUFDLEVBQUU7SUFDcEIsT0FBT0UsZUFBZTtRQUNsQkYsRUFBRTJCLGNBQWM7UUFDaEIzQixFQUFFNEIsV0FBVztRQUNiNUIsRUFBRTZCLFVBQVU7UUFDWjdCLEVBQUUrQixXQUFXO0tBQ2hCO0FBQ0w7QUFDQSxTQUFTQyxjQUFjaEMsQ0FBQyxFQUFFO0lBQ3RCLE9BQU9FLGVBQWU7UUFDbEJGLEVBQUUyQixjQUFjO1FBQ2hCM0IsRUFBRTRCLFdBQVc7UUFDYjVCLEVBQUU2QixVQUFVO1FBQ1o3QixFQUFFK0IsV0FBVztRQUNiL0IsRUFBRWlDLGFBQWE7S0FDbEI7QUFDTDtBQUNBLFNBQVNDLGNBQWNsQyxDQUFDLEVBQUU7SUFDdEIsT0FBT0UsZUFBZTtRQUNsQkYsRUFBRTJCLGNBQWM7UUFDaEIzQixFQUFFNEIsV0FBVztRQUNiNUIsRUFBRTZCLFVBQVU7UUFDWjdCLEVBQUUrQixXQUFXO1FBQ2IvQixFQUFFaUMsYUFBYTtRQUNmakMsRUFBRW1DLGFBQWE7S0FDbEI7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQixTQUFTQyxXQUFXQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQ2xDLElBQUlDLElBQUlILE9BQU9WLGNBQWM7SUFDN0IsSUFBSWMsSUFBSUMsZ0JBQWdCTCxRQUFRRyxHQUFHRixLQUFLQztJQUN4QyxJQUFJRSxJQUFJLEdBQUc7UUFDUCxPQUFPQyxnQkFBZ0JMLFFBQVFHLElBQUksR0FBR0YsS0FBS0M7SUFDL0MsQ0FBQztJQUNELElBQUlJLFFBQVFELGdCQUFnQkwsUUFBUUcsSUFBSSxHQUFHRixLQUFLQztJQUNoRCxJQUFJSSxTQUFTLEdBQUc7UUFDWixPQUFPdkIsS0FBS3dCLEdBQUcsQ0FBQ0gsR0FBR0U7SUFDdkIsQ0FBQztJQUNELE9BQU9GO0FBQ1g7QUFDQSxTQUFTQyxnQkFBZ0JMLE1BQU0sRUFBRVEsSUFBSSxFQUFFUCxHQUFHLEVBQUVDLEdBQUcsRUFBRTtJQUM3QyxJQUFJTyxpQkFBaUI1QyxlQUFlO1FBQUMyQztRQUFNO1FBQUcsSUFBSUUsZ0JBQWdCRixNQUFNUCxLQUFLQztLQUFLO0lBQ2xGLElBQUlTLFdBQVdqQyxXQUFXc0I7SUFDMUIsSUFBSWxCLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ2IsU0FBU3NDLGdCQUFnQkU7SUFDL0MsT0FBTzVCLEtBQUs2QixLQUFLLENBQUM5QixPQUFPLEtBQUssR0FBRyxlQUFlO0FBQ3BEO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM0QixnQkFBZ0JGLElBQUksRUFBRVAsR0FBRyxFQUFFQyxHQUFHLEVBQUU7SUFDckMsdUZBQXVGO0lBQ3ZGLElBQUlXLE1BQU0sSUFBSVosTUFBTUM7SUFDcEIsNkRBQTZEO0lBQzdELElBQUlZLFFBQVEsQ0FBQyxJQUFJakQsZUFBZTtRQUFDMkM7UUFBTTtRQUFHSztLQUFJLEVBQUVFLFNBQVMsS0FBS2QsR0FBRSxJQUFLO0lBQ3JFLE9BQU8sQ0FBQ2EsUUFBUUQsTUFBTTtBQUMxQjtBQUNBLG1CQUFtQjtBQUNuQixTQUFTRyxpQkFBaUJDLElBQUksRUFBRTtJQUM1QixPQUFPO1FBQ0hBLEtBQUtDLFdBQVc7UUFDaEJELEtBQUtFLFFBQVE7UUFDYkYsS0FBS0csT0FBTztRQUNaSCxLQUFLSSxRQUFRO1FBQ2JKLEtBQUtLLFVBQVU7UUFDZkwsS0FBS00sVUFBVTtRQUNmTixLQUFLTyxlQUFlO0tBQ3ZCO0FBQ0w7QUFDQSxTQUFTQyxpQkFBaUI1RixDQUFDLEVBQUU7SUFDekIsT0FBTyxJQUFJNkYsS0FBSzdGLENBQUMsQ0FBQyxFQUFFLEVBQUVBLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBR0EsQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJLEdBQUcsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsRUFDeERBLENBQUMsQ0FBQyxFQUFFLElBQUksR0FBR0EsQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHQSxDQUFDLENBQUMsRUFBRSxJQUFJO0FBQ2xDO0FBQ0EsU0FBUytCLGVBQWVxRCxJQUFJLEVBQUU7SUFDMUIsT0FBTztRQUNIQSxLQUFLM0IsY0FBYztRQUNuQjJCLEtBQUsxQixXQUFXO1FBQ2hCMEIsS0FBS3pCLFVBQVU7UUFDZnlCLEtBQUt2QixXQUFXO1FBQ2hCdUIsS0FBS3JCLGFBQWE7UUFDbEJxQixLQUFLbkIsYUFBYTtRQUNsQm1CLEtBQUtVLGtCQUFrQjtLQUMxQjtBQUNMO0FBQ0EsU0FBUzlELGVBQWVoQyxDQUFDLEVBQUU7SUFDdkIsc0VBQXNFO0lBQ3RFLGdDQUFnQztJQUNoQyxJQUFJQSxFQUFFMUYsTUFBTSxLQUFLLEdBQUc7UUFDaEIwRixJQUFJQSxFQUFFK0YsTUFBTSxDQUFDO1lBQUM7U0FBRTtJQUNwQixDQUFDO0lBQ0QsT0FBTyxJQUFJRixLQUFLQSxLQUFLRyxHQUFHLENBQUNyRixLQUFLLENBQUNrRixNQUFNN0Y7QUFDekM7QUFDQSxjQUFjO0FBQ2QsU0FBU2lHLFlBQVluRSxDQUFDLEVBQUU7SUFDcEIsT0FBTyxDQUFDb0UsTUFBTXBFLEVBQUVTLE9BQU87QUFDM0I7QUFDQSxTQUFTaUIsU0FBUzFCLENBQUMsRUFBRTtJQUNqQixPQUFPQSxFQUFFK0IsV0FBVyxLQUFLLE9BQU8sS0FBSyxLQUNqQy9CLEVBQUVpQyxhQUFhLEtBQUssT0FBTyxLQUMzQmpDLEVBQUVtQyxhQUFhLEtBQUssT0FDcEJuQyxFQUFFZ0Usa0JBQWtCO0FBQzVCO0FBRUEsU0FBU0ssb0JBQW9CQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsY0FBYyxFQUFFQyxZQUFZLEVBQUU7SUFDckUsT0FBTztRQUNIQyxZQUFZeEk7UUFDWm9JLE9BQU9BO1FBQ1BDLE9BQU9BO1FBQ1BDLGdCQUFnQkEsa0JBQWtCLElBQUksR0FBRyxJQUFJLEdBQUdBLGNBQWM7UUFDOURDLGNBQWNBLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxHQUFHQSxZQUFZO0lBQzVEO0FBQ0o7QUFFQSxJQUFJRSxpQkFBaUJwTyxPQUFPUixTQUFTLENBQUM0TyxjQUFjO0FBQ3BELG1EQUFtRDtBQUNuRCx5R0FBeUc7QUFDekcsU0FBU0MsV0FBV0MsUUFBUSxFQUFFQyxlQUFlLEVBQUU7SUFDM0MsSUFBSUMsT0FBTyxDQUFDO0lBQ1osSUFBSUQsaUJBQWlCO1FBQ2pCLElBQUssSUFBSUUsVUFBVUYsZ0JBQWlCO1lBQ2hDLElBQUlHLGNBQWMsRUFBRTtZQUNwQiwrRUFBK0U7WUFDL0UsSUFBSyxJQUFJMU0sSUFBSXNNLFNBQVNyTSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7Z0JBQzlDLElBQUlpQixNQUFNcUwsUUFBUSxDQUFDdE0sRUFBRSxDQUFDeU0sT0FBTztnQkFDN0IsSUFBSSxPQUFPeEwsUUFBUSxZQUFZQSxLQUFLO29CQUNoQ3lMLFlBQVlDLE9BQU8sQ0FBQzFMO2dCQUN4QixPQUNLLElBQUlBLFFBQVEyTCxXQUFXO29CQUN4QkosSUFBSSxDQUFDQyxPQUFPLEdBQUd4TCxLQUFLLG9EQUFvRDtvQkFDeEUsS0FBTTtnQkFDVixDQUFDO1lBQ0w7WUFDQSw0REFBNEQ7WUFDNUQsSUFBSXlMLFlBQVl6TSxNQUFNLEVBQUU7Z0JBQ3BCdU0sSUFBSSxDQUFDQyxPQUFPLEdBQUdKLFdBQVdLO1lBQzlCLENBQUM7UUFDTDtJQUNKLENBQUM7SUFDRCw2REFBNkQ7SUFDN0QsSUFBSyxJQUFJMU0sSUFBSXNNLFNBQVNyTSxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7UUFDOUMsSUFBSWEsUUFBUXlMLFFBQVEsQ0FBQ3RNLEVBQUU7UUFDdkIsSUFBSyxJQUFJNk0sVUFBVWhNLE1BQU87WUFDdEIsSUFBSSxDQUFFZ00sQ0FBQUEsVUFBVUwsSUFBRyxHQUFJO2dCQUNuQkEsSUFBSSxDQUFDSyxPQUFPLEdBQUdoTSxLQUFLLENBQUNnTSxPQUFPO1lBQ2hDLENBQUM7UUFDTDtJQUNKO0lBQ0EsT0FBT0w7QUFDWDtBQUNBLFNBQVNNLFdBQVdDLElBQUksRUFBRTdILElBQUksRUFBRTtJQUM1QixJQUFJOEgsV0FBVyxDQUFDO0lBQ2hCLElBQUssSUFBSXZKLE9BQU9zSixLQUFNO1FBQ2xCLElBQUk3SCxLQUFLNkgsSUFBSSxDQUFDdEosSUFBSSxFQUFFQSxNQUFNO1lBQ3RCdUosUUFBUSxDQUFDdkosSUFBSSxHQUFHc0osSUFBSSxDQUFDdEosSUFBSTtRQUM3QixDQUFDO0lBQ0w7SUFDQSxPQUFPdUo7QUFDWDtBQUNBLFNBQVNDLFFBQVFGLElBQUksRUFBRTdILElBQUksRUFBRTtJQUN6QixJQUFJZ0ksVUFBVSxDQUFDO0lBQ2YsSUFBSyxJQUFJekosT0FBT3NKLEtBQU07UUFDbEJHLE9BQU8sQ0FBQ3pKLElBQUksR0FBR3lCLEtBQUs2SCxJQUFJLENBQUN0SixJQUFJLEVBQUVBO0lBQ25DO0lBQ0EsT0FBT3lKO0FBQ1g7QUFDQSxTQUFTQyxZQUFZeEgsQ0FBQyxFQUFFO0lBQ3BCLElBQUlvSCxPQUFPLENBQUM7SUFDWixJQUFLLElBQUlLLEtBQUssR0FBR0MsTUFBTTFILEdBQUd5SCxLQUFLQyxJQUFJcE4sTUFBTSxFQUFFbU4sS0FBTTtRQUM3QyxJQUFJRSxPQUFPRCxHQUFHLENBQUNELEdBQUc7UUFDbEJMLElBQUksQ0FBQ08sS0FBSyxHQUFHLElBQUk7SUFDckI7SUFDQSxPQUFPUDtBQUNYO0FBQ0EsU0FBU1EsbUJBQW1CNUgsQ0FBQyxFQUFFVCxJQUFJLEVBQUU7SUFDakMsSUFBSTZILE9BQU8sQ0FBQztJQUNaLElBQUssSUFBSS9NLElBQUksR0FBR0EsSUFBSTJGLEVBQUUxRixNQUFNLEVBQUVELEtBQUssRUFBRztRQUNsQyxJQUFJd04sUUFBUXRJLEtBQUtTLENBQUMsQ0FBQzNGLEVBQUUsRUFBRUE7UUFDdkIrTSxJQUFJLENBQUNTLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBR0EsS0FBSyxDQUFDLEVBQUU7SUFDN0I7SUFDQSxPQUFPVDtBQUNYO0FBQ0EsU0FBU1Usa0JBQWtCQyxHQUFHLEVBQUU7SUFDNUIsSUFBSS9ILElBQUksRUFBRTtJQUNWLElBQUssSUFBSWxDLE9BQU9pSyxJQUFLO1FBQ2pCL0gsRUFBRXZGLElBQUksQ0FBQ3NOLEdBQUcsQ0FBQ2pLLElBQUk7SUFDbkI7SUFDQSxPQUFPa0M7QUFDWDtBQUNBLFNBQVNnSSxhQUFhdkksSUFBSSxFQUFFQyxJQUFJLEVBQUU7SUFDOUIsSUFBSUQsU0FBU0MsTUFBTTtRQUNmLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxJQUFLLElBQUk1QixPQUFPMkIsS0FBTTtRQUNsQixJQUFJZ0gsZUFBZTFNLElBQUksQ0FBQzBGLE1BQU0zQixNQUFNO1lBQ2hDLElBQUksQ0FBRUEsQ0FBQUEsT0FBTzRCLElBQUcsR0FBSTtnQkFDaEIsT0FBTyxLQUFLO1lBQ2hCLENBQUM7UUFDTCxDQUFDO0lBQ0w7SUFDQSxJQUFLLElBQUk1QixPQUFPNEIsS0FBTTtRQUNsQixJQUFJK0csZUFBZTFNLElBQUksQ0FBQzJGLE1BQU01QixNQUFNO1lBQ2hDLElBQUkyQixJQUFJLENBQUMzQixJQUFJLEtBQUs0QixJQUFJLENBQUM1QixJQUFJLEVBQUU7Z0JBQ3pCLE9BQU8sS0FBSztZQUNoQixDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFDQSxTQUFTbUssZ0JBQWdCeEksSUFBSSxFQUFFQyxJQUFJLEVBQUU7SUFDakMsSUFBSXdJLE9BQU8sRUFBRTtJQUNiLElBQUssSUFBSXBLLE9BQU8yQixLQUFNO1FBQ2xCLElBQUlnSCxlQUFlMU0sSUFBSSxDQUFDMEYsTUFBTTNCLE1BQU07WUFDaEMsSUFBSSxDQUFFQSxDQUFBQSxPQUFPNEIsSUFBRyxHQUFJO2dCQUNoQndJLEtBQUt6TixJQUFJLENBQUNxRDtZQUNkLENBQUM7UUFDTCxDQUFDO0lBQ0w7SUFDQSxJQUFLLElBQUlBLE9BQU80QixLQUFNO1FBQ2xCLElBQUkrRyxlQUFlMU0sSUFBSSxDQUFDMkYsTUFBTTVCLE1BQU07WUFDaEMsSUFBSTJCLElBQUksQ0FBQzNCLElBQUksS0FBSzRCLElBQUksQ0FBQzVCLElBQUksRUFBRTtnQkFDekJvSyxLQUFLek4sSUFBSSxDQUFDcUQ7WUFDZCxDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsT0FBT29LO0FBQ1g7QUFDQSxTQUFTQyxZQUFZQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFO0lBQ3BELElBQUlBLGtCQUFrQixLQUFLLEdBQUc7UUFBRUEsZ0JBQWdCLENBQUM7SUFBRyxDQUFDO0lBQ3JELElBQUlGLGFBQWFDLFVBQVU7UUFDdkIsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELElBQUssSUFBSXZLLE9BQU91SyxTQUFVO1FBQ3RCLElBQUl2SyxPQUFPc0ssWUFBWUcsZUFBZUgsUUFBUSxDQUFDdEssSUFBSSxFQUFFdUssUUFBUSxDQUFDdkssSUFBSSxFQUFFd0ssYUFBYSxDQUFDeEssSUFBSTthQUNqRjtZQUNELE9BQU8sS0FBSztRQUNoQixDQUFDO0lBQ0w7SUFDQSwrQ0FBK0M7SUFDL0MsSUFBSyxJQUFJQSxPQUFPc0ssU0FBVTtRQUN0QixJQUFJLENBQUV0SyxDQUFBQSxPQUFPdUssUUFBTyxHQUFJO1lBQ3BCLE9BQU8sS0FBSztRQUNoQixDQUFDO0lBQ0w7SUFDQSxPQUFPLElBQUk7QUFDZjtBQUNBOztBQUVBLEdBQ0EsU0FBU0UsZUFBZUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRTtJQUM1QyxJQUFJRixTQUFTQyxRQUFRQyxlQUFlLElBQUksRUFBRTtRQUN0QyxPQUFPLElBQUk7SUFDZixDQUFDO0lBQ0QsSUFBSUEsWUFBWTtRQUNaLE9BQU9BLFdBQVdGLE1BQU1DO0lBQzVCLENBQUM7SUFDRCxPQUFPLEtBQUs7QUFDaEI7QUFDQSxTQUFTRSxnQkFBZ0J2QixJQUFJLEVBQUV3QixVQUFVLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO0lBQ3ZELElBQUlGLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWE7SUFBRyxDQUFDO0lBQzlDLElBQUlFLFNBQVMsS0FBSyxHQUFHO1FBQUVBLE9BQU87SUFBRyxDQUFDO0lBQ2xDLElBQUlDLE1BQU0sRUFBRTtJQUNaLElBQUlGLFlBQVksSUFBSSxFQUFFO1FBQ2xCQSxXQUFXeFEsT0FBTzZQLElBQUksQ0FBQ2QsTUFBTTlNLE1BQU07SUFDdkMsQ0FBQztJQUNELElBQUssSUFBSUQsSUFBSXVPLFlBQVl2TyxJQUFJd08sVUFBVXhPLEtBQUt5TyxLQUFNO1FBQzlDLElBQUl4TixNQUFNOEwsSUFBSSxDQUFDL00sRUFBRTtRQUNqQixJQUFJaUIsUUFBUTJMLFdBQVc7WUFDbkI4QixJQUFJdE8sSUFBSSxDQUFDYTtRQUNiLENBQUM7SUFDTDtJQUNBLE9BQU95TjtBQUNYO0FBRUEsU0FBU0MsZUFBZUMsT0FBTyxFQUFFQyxhQUFhLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFO0lBQ3JFLElBQUssSUFBSS9PLElBQUksR0FBR0EsSUFBSStPLGVBQWU5TyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUMvQyxJQUFJZ1AsU0FBU0QsY0FBYyxDQUFDL08sRUFBRSxDQUFDaVAsS0FBSyxDQUFDTCxTQUFTRTtRQUM5QyxJQUFJRSxRQUFRO1lBQ1IsSUFBSUUsU0FBU04sUUFBUU0sTUFBTTtZQUMzQixJQUFJQSxVQUFVLElBQUksRUFBRTtnQkFDaEJBLFNBQVNMO2dCQUNULElBQUlLLFVBQVUsSUFBSSxFQUFFO29CQUNoQkEsU0FBU0YsT0FBT0csV0FBVztvQkFDM0IsSUFBSUQsVUFBVSxJQUFJLEVBQUU7d0JBQ2hCQSxTQUFTLEtBQUs7b0JBQ2xCLENBQUM7Z0JBQ0wsQ0FBQztZQUNMLENBQUM7WUFDRCxPQUFPO2dCQUNIQSxRQUFRQTtnQkFDUkUsVUFBVUosT0FBT0ksUUFBUTtnQkFDekJDLFVBQVVMLE9BQU9LLFFBQVE7Z0JBQ3pCQyxRQUFRdFA7WUFDWjtRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU8sSUFBSTtBQUNmO0FBQ0EsU0FBU3VQLGdCQUFnQkMsVUFBVSxFQUFFQyxZQUFZLEVBQUVuUyxPQUFPLEVBQUU7SUFDeEQsSUFBSXdSLFVBQVV4UixRQUFRd1IsT0FBTyxFQUFFWSxjQUFjcFMsUUFBUW9TLFdBQVcsRUFBRUMsVUFBVXJTLFFBQVFxUyxPQUFPO0lBQzNGLElBQUlDLE9BQU9KLFdBQVdJLElBQUksRUFBRUMsWUFBWUwsV0FBV0ssU0FBUztJQUM1RCxzQ0FBc0M7SUFDdEMsbURBQW1EO0lBQ25EQSxZQUFZL0MsV0FBVytDLFdBQVcsU0FBVUMsUUFBUSxFQUFFO1FBQUUsT0FBTyxDQUFDRixJQUFJLENBQUNFLFNBQVMvRCxLQUFLLENBQUMsQ0FBQ2dFLFlBQVk7SUFBRTtJQUNuRyxJQUFLLElBQUloRSxTQUFTNkQsS0FBTTtRQUNwQixJQUFJSSxNQUFNSixJQUFJLENBQUM3RCxNQUFNO1FBQ3JCLElBQUlpRSxJQUFJRCxZQUFZLEVBQUU7WUFDbEIsSUFBSVgsV0FBV1ksSUFBSUQsWUFBWSxDQUFDWCxRQUFRO1lBQ3hDLElBQUksQ0FBQ0EsVUFBVTtnQkFDWEEsV0FBV1ksSUFBSWQsTUFBTSxHQUNqQlMsUUFBUU0sMEJBQTBCLEdBQ2xDTixRQUFRTyx5QkFBeUI7WUFDekMsQ0FBQztZQUNELElBQUlDLFNBQVNDLHNCQUFzQkosS0FBS1osVUFBVUssY0FBY1gsU0FBU1ksWUFBWVgsY0FBYztZQUNuRyxJQUFLLElBQUkzQixLQUFLLEdBQUdpRCxXQUFXRixRQUFRL0MsS0FBS2lELFNBQVNwUSxNQUFNLEVBQUVtTixLQUFNO2dCQUM1RCxJQUFJa0QsUUFBUUQsUUFBUSxDQUFDakQsR0FBRztnQkFDeEIsSUFBSTBDLFdBQVdoRSxvQkFBb0JDLE9BQU87b0JBQ3RDdUUsT0FBT0E7b0JBQ1BDLEtBQUt6QixRQUFROUssR0FBRyxDQUFDc00sT0FBT2xCO2dCQUM1QjtnQkFDQVMsU0FBUyxDQUFDQyxTQUFTM0QsVUFBVSxDQUFDLEdBQUcyRDtZQUNyQztRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU87UUFBRUYsTUFBTUE7UUFBTUMsV0FBV0E7SUFBVTtBQUM5QztBQUNBOztBQUVBLEdBQ0EsU0FBU08sc0JBQXNCSSxRQUFRLEVBQUVwQixRQUFRLEVBQUVLLFlBQVksRUFBRVgsT0FBTyxFQUFFQyxjQUFjLEVBQUU7SUFDdEYsSUFBSTBCLFVBQVUxQixjQUFjLENBQUN5QixTQUFTVCxZQUFZLENBQUNULE1BQU0sQ0FBQztJQUMxRCxJQUFJb0IsVUFBVUQsUUFBUUUsTUFBTSxDQUFDSCxTQUFTVCxZQUFZLENBQUNWLFFBQVEsRUFBRTtRQUN6RGlCLE9BQU94QixRQUFROEIsUUFBUSxDQUFDbkIsYUFBYWEsS0FBSyxFQUFFbEI7UUFDNUNtQixLQUFLZCxhQUFhYyxHQUFHO0lBQ3pCLEdBQUd6QjtJQUNILDZGQUE2RjtJQUM3RixJQUFJMEIsU0FBU3RCLE1BQU0sRUFBRTtRQUNqQndCLFVBQVVBLFFBQVFHLEdBQUcsQ0FBQ3JJO0lBQzFCLENBQUM7SUFDRCxPQUFPa0k7QUFDWDtBQUVBLElBQUlJLGlCQUFpQjtJQUFDO0lBQVM7SUFBVTtJQUFRO0NBQWU7QUFDaEUsSUFBSUMsV0FBVztBQUNmLHVCQUF1QjtBQUN2QixTQUFTQyxlQUFlek0sS0FBSyxFQUFFME0sSUFBSSxFQUFFO0lBQ2pDLElBQUkzUDtJQUNKLElBQUksT0FBT2lELFVBQVUsVUFBVTtRQUMzQixPQUFPMk0sWUFBWTNNO0lBQ3ZCLENBQUM7SUFDRCxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsT0FBTztRQUNwQyxPQUFPNE0sWUFBWTVNO0lBQ3ZCLENBQUM7SUFDRCxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQixPQUFPNE0sWUFBYTdQLENBQUFBLEtBQUssQ0FBQyxHQUFHQSxFQUFFLENBQUMyUCxRQUFRLGVBQWUsR0FBRzFNLE9BQU9qRCxFQUFFO0lBQ3ZFLENBQUM7SUFDRCxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVM0UCxZQUFZbEwsQ0FBQyxFQUFFO0lBQ3BCLElBQUl5QixJQUFJc0osU0FBU0ssSUFBSSxDQUFDcEw7SUFDdEIsSUFBSXlCLEdBQUc7UUFDSCxJQUFJNEosT0FBTzVKLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDeEIsT0FBTztZQUNIaUIsT0FBTztZQUNQQyxRQUFRO1lBQ1JDLE1BQU15SSxPQUFRNUosQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBRzZKLFNBQVM3SixDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQztZQUMzQ3NCLGNBQWNzSSxPQUFRLEVBQUM1SixDQUFDLENBQUMsRUFBRSxHQUFHNkosU0FBUzdKLENBQUMsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSyxLQUFLLE9BQzlELFFBRDZFO1lBQzVFQSxDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHNkosU0FBUzdKLENBQUMsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLElBQUksS0FBSyxPQUN2QyxVQUR3RDtZQUN2REEsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBRzZKLFNBQVM3SixDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxJQUFJLE9BQU8sVUFBVTtZQUNsREEsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBRzZKLFNBQVM3SixDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRyxLQUFLO1lBQVIsQ0FBQztRQUV0QztJQUNKLENBQUM7SUFDRCxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVMwSixZQUFZekQsR0FBRyxFQUFFO0lBQ3RCLElBQUkwQixXQUFXO1FBQ1gxRyxPQUFPZ0YsSUFBSWhGLEtBQUssSUFBSWdGLElBQUlwRCxJQUFJLElBQUk7UUFDaEMzQixRQUFRK0UsSUFBSS9FLE1BQU0sSUFBSStFLElBQUk2RCxLQUFLLElBQUk7UUFDbkMzSSxNQUFNOEUsSUFBSTlFLElBQUksSUFBSThFLElBQUk4RCxHQUFHLElBQUk7UUFDN0J6SSxjQUFjLENBQUMyRSxJQUFJK0QsS0FBSyxJQUFJL0QsSUFBSWdFLElBQUksSUFBSSxLQUFLLEtBQUssS0FBSyxPQUNuRCxRQURrRTtRQUNqRWhFLENBQUFBLElBQUlpRSxPQUFPLElBQUlqRSxJQUFJa0UsTUFBTSxJQUFJLEtBQUssS0FBSyxPQUN4QyxVQUR5RDtRQUN4RGxFLENBQUFBLElBQUltRSxPQUFPLElBQUluRSxJQUFJb0UsTUFBTSxJQUFJLEtBQUssT0FBTyxVQUFVO1FBQ25EcEUsQ0FBQUEsSUFBSTNFLFlBQVksSUFBSTJFLElBQUlxRSxXQUFXLElBQUlyRSxJQUFJc0UsRUFBRSxJQUFJO0lBQzFEO0lBQ0EsSUFBSUMsUUFBUXZFLElBQUl1RSxLQUFLLElBQUl2RSxJQUFJd0UsSUFBSTtJQUNqQyxJQUFJRCxPQUFPO1FBQ1A3QyxTQUFTeEcsSUFBSSxJQUFJcUosUUFBUTtRQUN6QjdDLFNBQVMrQyxjQUFjLEdBQUcsSUFBSTtJQUNsQyxDQUFDO0lBQ0QsT0FBTy9DO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBU2dELGVBQWVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO0lBQzVCLE9BQU9ELEdBQUczSixLQUFLLEtBQUs0SixHQUFHNUosS0FBSyxJQUN4QjJKLEdBQUcxSixNQUFNLEtBQUsySixHQUFHM0osTUFBTSxJQUN2QjBKLEdBQUd6SixJQUFJLEtBQUswSixHQUFHMUosSUFBSSxJQUNuQnlKLEdBQUd0SixZQUFZLEtBQUt1SixHQUFHdkosWUFBWTtBQUMzQztBQUNBLFNBQVN3SixZQUFZQyxHQUFHLEVBQUU7SUFDdEIsSUFBSSxDQUFDQSxJQUFJOUosS0FBSyxJQUFJLENBQUM4SixJQUFJN0osTUFBTSxJQUFJLENBQUM2SixJQUFJekosWUFBWSxFQUFFO1FBQ2hELE9BQU95SixJQUFJNUosSUFBSTtJQUNuQixDQUFDO0lBQ0QsT0FBTztBQUNYO0FBQ0EsY0FBYztBQUNkLFNBQVM2SixhQUFhSixFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUMxQixPQUFPO1FBQ0g1SixPQUFPMkosR0FBRzNKLEtBQUssR0FBRzRKLEdBQUc1SixLQUFLO1FBQzFCQyxRQUFRMEosR0FBRzFKLE1BQU0sR0FBRzJKLEdBQUczSixNQUFNO1FBQzdCQyxNQUFNeUosR0FBR3pKLElBQUksR0FBRzBKLEdBQUcxSixJQUFJO1FBQ3ZCRyxjQUFjc0osR0FBR3RKLFlBQVksR0FBR3VKLEdBQUd2SixZQUFZO0lBQ25EO0FBQ0o7QUFDQSxTQUFTMkosa0JBQWtCSixFQUFFLEVBQUVELEVBQUUsRUFBRTtJQUMvQixPQUFPO1FBQ0gzSixPQUFPNEosR0FBRzVKLEtBQUssR0FBRzJKLEdBQUczSixLQUFLO1FBQzFCQyxRQUFRMkosR0FBRzNKLE1BQU0sR0FBRzBKLEdBQUcxSixNQUFNO1FBQzdCQyxNQUFNMEosR0FBRzFKLElBQUksR0FBR3lKLEdBQUd6SixJQUFJO1FBQ3ZCRyxjQUFjdUosR0FBR3ZKLFlBQVksR0FBR3NKLEdBQUd0SixZQUFZO0lBQ25EO0FBQ0o7QUFDQSxTQUFTNEosaUJBQWlCMUosQ0FBQyxFQUFFbkMsQ0FBQyxFQUFFO0lBQzVCLE9BQU87UUFDSDRCLE9BQU9PLEVBQUVQLEtBQUssR0FBRzVCO1FBQ2pCNkIsUUFBUU0sRUFBRU4sTUFBTSxHQUFHN0I7UUFDbkI4QixNQUFNSyxFQUFFTCxJQUFJLEdBQUc5QjtRQUNmaUMsY0FBY0UsRUFBRUYsWUFBWSxHQUFHakM7SUFDbkM7QUFDSjtBQUNBLGNBQWM7QUFDZCx3RUFBd0U7QUFDeEUsU0FBUzhMLGFBQWFKLEdBQUcsRUFBRTtJQUN2QixPQUFPSyxZQUFZTCxPQUFPO0FBQzlCO0FBQ0EsU0FBU00sY0FBY04sR0FBRyxFQUFFO0lBQ3hCLE9BQU9LLFlBQVlMLE9BQU87QUFDOUI7QUFDQSxTQUFTSyxZQUFZTCxHQUFHLEVBQUU7SUFDdEIsT0FBT08sVUFBVVAsT0FBTztBQUM1QjtBQUNBLFNBQVNRLGVBQWVSLEdBQUcsRUFBRTtJQUN6QixPQUFPTyxVQUFVUCxPQUFRLFFBQU8sRUFBQztBQUNyQztBQUNBLFNBQVNTLGVBQWVULEdBQUcsRUFBRTtJQUN6QixPQUFPTyxVQUFVUCxPQUFPO0FBQzVCO0FBQ0EsU0FBU08sVUFBVVAsR0FBRyxFQUFFO0lBQ3BCLE9BQU9BLElBQUk5SixLQUFLLEdBQUksT0FBTSxLQUFJLElBQzFCOEosSUFBSTdKLE1BQU0sR0FBSSxNQUFLLEtBQUksSUFDdkI2SixJQUFJNUosSUFBSSxHQUFHLFFBQ1g0SixJQUFJekosWUFBWTtBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQixTQUFTbUsscUJBQXFCQyxTQUFTLEVBQUVDLFdBQVcsRUFBRTtJQUNsRCxJQUFJMUUsTUFBTSxJQUFJO0lBQ2QsSUFBSyxJQUFJMU8sSUFBSSxHQUFHQSxJQUFJOFEsZUFBZTdRLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQy9DLElBQUlpUixPQUFPSCxjQUFjLENBQUM5USxFQUFFO1FBQzVCLElBQUlvVCxXQUFXLENBQUNuQyxLQUFLLEVBQUU7WUFDbkIsSUFBSW9DLFdBQVdGLFNBQVMsQ0FBQ2xDLEtBQUssR0FBR21DLFdBQVcsQ0FBQ25DLEtBQUs7WUFDbEQsSUFBSSxDQUFDcEssTUFBTXdNLGFBQWMzRSxRQUFRLElBQUksSUFBSUEsUUFBUTJFLFVBQVc7Z0JBQ3hELE9BQU8sSUFBSTtZQUNmLENBQUM7WUFDRDNFLE1BQU0yRTtRQUNWLE9BQ0ssSUFBSUYsU0FBUyxDQUFDbEMsS0FBSyxFQUFFO1lBQ3RCLDBDQUEwQztZQUMxQyxPQUFPLElBQUk7UUFDZixDQUFDO0lBQ0w7SUFDQSxPQUFPdkM7QUFDWDtBQUNBLFNBQVM0RSw0QkFBNEJkLEdBQUcsRUFBRTtJQUN0QyxJQUFJUixLQUFLUSxJQUFJekosWUFBWTtJQUN6QixJQUFJaUosSUFBSTtRQUNKLElBQUlBLEtBQUssU0FBUyxHQUFHO1lBQ2pCLE9BQU87Z0JBQUVmLE1BQU07Z0JBQWVzQyxPQUFPdkI7WUFBRztRQUM1QyxDQUFDO1FBQ0QsSUFBSUEsS0FBTSxRQUFPLEVBQUMsTUFBTyxHQUFHO1lBQ3hCLE9BQU87Z0JBQUVmLE1BQU07Z0JBQVVzQyxPQUFPdkIsS0FBSztZQUFLO1FBQzlDLENBQUM7UUFDRCxJQUFJQSxLQUFNLFFBQU8sS0FBSyxFQUFDLE1BQU8sR0FBRztZQUM3QixPQUFPO2dCQUFFZixNQUFNO2dCQUFVc0MsT0FBT3ZCLEtBQU0sUUFBTyxFQUFDO1lBQUc7UUFDckQsQ0FBQztRQUNELElBQUlBLElBQUk7WUFDSixPQUFPO2dCQUFFZixNQUFNO2dCQUFRc0MsT0FBT3ZCLEtBQU0sUUFBTyxLQUFLLEVBQUM7WUFBRztRQUN4RCxDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlRLElBQUk1SixJQUFJLEVBQUU7UUFDVixJQUFJNEosSUFBSUwsY0FBYyxJQUFJSyxJQUFJNUosSUFBSSxHQUFHLE1BQU0sR0FBRztZQUMxQyxPQUFPO2dCQUFFcUksTUFBTTtnQkFBUXNDLE9BQU9mLElBQUk1SixJQUFJLEdBQUc7WUFBRTtRQUMvQyxDQUFDO1FBQ0QsT0FBTztZQUFFcUksTUFBTTtZQUFPc0MsT0FBT2YsSUFBSTVKLElBQUk7UUFBQztJQUMxQyxDQUFDO0lBQ0QsSUFBSTRKLElBQUk3SixNQUFNLEVBQUU7UUFDWixPQUFPO1lBQUVzSSxNQUFNO1lBQVNzQyxPQUFPZixJQUFJN0osTUFBTTtRQUFDO0lBQzlDLENBQUM7SUFDRCxJQUFJNkosSUFBSTlKLEtBQUssRUFBRTtRQUNYLE9BQU87WUFBRXVJLE1BQU07WUFBUXNDLE9BQU9mLElBQUk5SixLQUFLO1FBQUM7SUFDNUMsQ0FBQztJQUNELE9BQU87UUFBRXVJLE1BQU07UUFBZXNDLE9BQU87SUFBRTtBQUMzQztBQUVBLCtCQUErQjtBQUMvQixTQUFTQyxlQUFlMUosTUFBTSxFQUFFMkosY0FBYyxFQUFFQyxhQUFhLEVBQUU7SUFDM0QsSUFBSUEsa0JBQWtCLEtBQUssR0FBRztRQUFFQSxnQkFBZ0IsS0FBSztJQUFFLENBQUM7SUFDeEQsSUFBSTFOLElBQUk4RCxPQUFPNkosV0FBVztJQUMxQjNOLElBQUlBLEVBQUVXLE9BQU8sQ0FBQyxRQUFRO0lBQ3RCLElBQUkrTSxlQUFlO1FBQ2YxTixJQUFJQSxFQUFFVyxPQUFPLENBQUMsY0FBYztJQUNoQyxDQUFDO0lBQ0QsSUFBSVgsRUFBRS9GLE1BQU0sR0FBRyxJQUFJO1FBQ2YsSUFBSXdULGtCQUFrQixJQUFJLEVBQUU7WUFDeEJ6TixJQUFJQSxFQUFFVyxPQUFPLENBQUMsS0FBSztRQUN2QixPQUNLLElBQUk4TSxtQkFBbUIsR0FBRztZQUMzQnpOLElBQUlBLEVBQUVXLE9BQU8sQ0FBQyxLQUFLaU4scUJBQXFCSCxnQkFBZ0IsSUFBSTtRQUNoRSxDQUFDO0lBQ0QsaURBQWlEO0lBQ3JELENBQUM7SUFDRCxPQUFPek47QUFDWDtBQUNBLDBDQUEwQztBQUMxQyw0REFBNEQ7QUFDNUQsOEJBQThCO0FBQzlCLFNBQVM2TixnQkFBZ0IvSixNQUFNLEVBQUU7SUFDN0IsT0FBT0EsT0FBTzZKLFdBQVcsR0FBR2hOLE9BQU8sQ0FBQyxRQUFRO0FBQ2hEO0FBQ0EsOERBQThEO0FBQzlELFNBQVNtTixvQkFBb0JoSyxNQUFNLEVBQUU7SUFDakMsT0FBT2hFLFNBQVNnRSxPQUFPTixXQUFXLElBQUksS0FBSyxNQUN2QzFELFNBQVNnRSxPQUFPSixhQUFhLElBQUksS0FBSyxNQUN0QzVELFNBQVNnRSxPQUFPRixhQUFhLElBQUk7QUFDekM7QUFDQSxTQUFTZ0sscUJBQXFCakMsT0FBTyxFQUFFb0MsS0FBSyxFQUFFO0lBQzFDLElBQUlBLFVBQVUsS0FBSyxHQUFHO1FBQUVBLFFBQVEsS0FBSztJQUFFLENBQUM7SUFDeEMsSUFBSTFDLE9BQU9NLFVBQVUsSUFBSSxNQUFNLEdBQUc7SUFDbEMsSUFBSXFDLE1BQU1uTCxLQUFLbUwsR0FBRyxDQUFDckM7SUFDbkIsSUFBSUYsUUFBUTVJLEtBQUs2QixLQUFLLENBQUNzSixNQUFNO0lBQzdCLElBQUlDLE9BQU9wTCxLQUFLQyxLQUFLLENBQUNrTCxNQUFNO0lBQzVCLElBQUlELE9BQU87UUFDUCxPQUFPMUMsT0FBT3ZMLFNBQVMyTCxPQUFPLEtBQUssTUFBTTNMLFNBQVNtTyxNQUFNO0lBQzVELENBQUM7SUFDRCxPQUFPLFFBQVE1QyxPQUFPSSxRQUFTd0MsQ0FBQUEsT0FBTyxNQUFNbk8sU0FBU21PLE1BQU0sS0FBSyxFQUFFO0FBQ3RFO0FBRUEsMkJBQTJCO0FBQzNCLFNBQVNDLFlBQVlDLEtBQUssRUFBRUMsUUFBUSxFQUFFO0lBQ2xDLElBQUlDLFlBQVk7SUFDaEIsSUFBSXJVLElBQUk7SUFDUixNQUFPQSxJQUFJbVUsTUFBTWxVLE1BQU0sQ0FBRTtRQUNyQixJQUFJa1UsS0FBSyxDQUFDblUsRUFBRSxLQUFLb1UsVUFBVTtZQUN2QkQsTUFBTUcsTUFBTSxDQUFDdFUsR0FBRztZQUNoQnFVLGFBQWE7UUFDakIsT0FDSztZQUNEclUsS0FBSztRQUNULENBQUM7SUFDTDtJQUNBLE9BQU9xVTtBQUNYO0FBQ0EsU0FBU0UsY0FBY0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLFlBQVksRUFBRTtJQUN6QyxJQUFJRixPQUFPQyxJQUFJO1FBQ1gsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELElBQUkxTyxNQUFNeU8sR0FBR3ZVLE1BQU07SUFDbkIsSUFBSUQ7SUFDSixJQUFJK0YsUUFBUTBPLEdBQUd4VSxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxJQUFLRCxJQUFJLEdBQUdBLElBQUkrRixLQUFLL0YsS0FBSyxFQUFHO1FBQ3pCLElBQUksQ0FBRTBVLENBQUFBLGVBQWVBLGFBQWFGLEVBQUUsQ0FBQ3hVLEVBQUUsRUFBRXlVLEVBQUUsQ0FBQ3pVLEVBQUUsSUFBSXdVLEVBQUUsQ0FBQ3hVLEVBQUUsS0FBS3lVLEVBQUUsQ0FBQ3pVLEVBQUUsR0FBRztZQUNoRSxPQUFPLEtBQUs7UUFDaEIsQ0FBQztJQUNMO0lBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFFQSxTQUFTMlUsUUFBUUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRTtJQUNwRCxJQUFJQztJQUNKLElBQUlDO0lBQ0osT0FBTyxXQUFZO1FBQ2YsSUFBSUMsVUFBVSxFQUFFO1FBQ2hCLElBQUssSUFBSTdILEtBQUssR0FBR0EsS0FBSzhILFVBQVVqVixNQUFNLEVBQUVtTixLQUFNO1lBQzFDNkgsT0FBTyxDQUFDN0gsR0FBRyxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUMvQjtRQUNBLElBQUksQ0FBQzJILGFBQWE7WUFDZEMsYUFBYUosV0FBV3RPLEtBQUssQ0FBQyxJQUFJLEVBQUUyTztRQUN4QyxPQUNLLElBQUksQ0FBQ1YsY0FBY1EsYUFBYUUsVUFBVTtZQUMzQyxJQUFJSCxjQUFjO2dCQUNkQSxhQUFhRTtZQUNqQixDQUFDO1lBQ0QsSUFBSXRHLE1BQU1rRyxXQUFXdE8sS0FBSyxDQUFDLElBQUksRUFBRTJPO1lBQ2pDLElBQUksQ0FBQ0osZUFBZSxDQUFDQSxZQUFZbkcsS0FBS3NHLGFBQWE7Z0JBQy9DQSxhQUFhdEc7WUFDakIsQ0FBQztRQUNMLENBQUM7UUFDRHFHLGNBQWNFO1FBQ2QsT0FBT0Q7SUFDWDtBQUNKO0FBQ0EsU0FBU0csY0FBY1AsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRTtJQUMxRCxJQUFJTSxRQUFRLElBQUk7SUFDaEIsSUFBSUM7SUFDSixJQUFJTDtJQUNKLE9BQU8sU0FBVU0sTUFBTSxFQUFFO1FBQ3JCLElBQUksQ0FBQ0QsWUFBWTtZQUNiTCxhQUFhSixXQUFXbFYsSUFBSSxDQUFDMFYsT0FBT0U7UUFDeEMsT0FDSyxJQUFJLENBQUMzSCxhQUFhMEgsWUFBWUMsU0FBUztZQUN4QyxJQUFJUixjQUFjO2dCQUNkQSxhQUFhRTtZQUNqQixDQUFDO1lBQ0QsSUFBSXRHLE1BQU1rRyxXQUFXbFYsSUFBSSxDQUFDMFYsT0FBT0U7WUFDakMsSUFBSSxDQUFDVCxlQUFlLENBQUNBLFlBQVluRyxLQUFLc0csYUFBYTtnQkFDL0NBLGFBQWF0RztZQUNqQixDQUFDO1FBQ0wsQ0FBQztRQUNEMkcsYUFBYUM7UUFDYixPQUFPTjtJQUNYO0FBQ0o7QUFDQSxTQUFTTyxpQkFDVFgsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRTtJQUNuQyxJQUFJTSxRQUFRLElBQUk7SUFDaEIsSUFBSUksaUJBQWlCLEVBQUU7SUFDdkIsSUFBSUMsaUJBQWlCLEVBQUU7SUFDdkIsT0FBTyxTQUFVQyxVQUFVLEVBQUU7UUFDekIsSUFBSUMsYUFBYUgsZUFBZXZWLE1BQU07UUFDdEMsSUFBSTJWLFNBQVNGLFdBQVd6VixNQUFNO1FBQzlCLElBQUlELElBQUk7UUFDUixNQUFPQSxJQUFJMlYsWUFBWTNWLEtBQUssRUFBRztZQUMzQixJQUFJLENBQUMwVixVQUFVLENBQUMxVixFQUFFLEVBQUU7Z0JBQ2hCLElBQUk4VSxjQUFjO29CQUNkQSxhQUFhVyxjQUFjLENBQUN6VixFQUFFO2dCQUNsQyxDQUFDO1lBQ0wsT0FDSyxJQUFJLENBQUN1VSxjQUFjaUIsY0FBYyxDQUFDeFYsRUFBRSxFQUFFMFYsVUFBVSxDQUFDMVYsRUFBRSxHQUFHO2dCQUN2RCxJQUFJOFUsY0FBYztvQkFDZEEsYUFBYVcsY0FBYyxDQUFDelYsRUFBRTtnQkFDbEMsQ0FBQztnQkFDRCxJQUFJME8sTUFBTWtHLFdBQVd0TyxLQUFLLENBQUM4TyxPQUFPTSxVQUFVLENBQUMxVixFQUFFO2dCQUMvQyxJQUFJLENBQUM2VSxlQUFlLENBQUNBLFlBQVluRyxLQUFLK0csY0FBYyxDQUFDelYsRUFBRSxHQUFHO29CQUN0RHlWLGNBQWMsQ0FBQ3pWLEVBQUUsR0FBRzBPO2dCQUN4QixDQUFDO1lBQ0wsQ0FBQztRQUNMO1FBQ0EsTUFBTzFPLElBQUk0VixRQUFRNVYsS0FBSyxFQUFHO1lBQ3ZCeVYsY0FBYyxDQUFDelYsRUFBRSxHQUFHNFUsV0FBV3RPLEtBQUssQ0FBQzhPLE9BQU9NLFVBQVUsQ0FBQzFWLEVBQUU7UUFDN0Q7UUFDQXdWLGlCQUFpQkU7UUFDakJELGVBQWVuQixNQUFNLENBQUNzQixTQUFTLGdCQUFnQjtRQUMvQyxPQUFPSDtJQUNYO0FBQ0o7QUFDQSxTQUFTSSxnQkFBZ0JqQixVQUFVLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFO0lBQzVELElBQUlNLFFBQVEsSUFBSTtJQUNoQixJQUFJVSxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixPQUFPLFNBQVVDLFVBQVUsRUFBRTtRQUN6QixJQUFJQyxhQUFhLENBQUM7UUFDbEIsSUFBSyxJQUFJeFMsT0FBT3VTLFdBQVk7WUFDeEIsSUFBSSxDQUFDRCxjQUFjLENBQUN0UyxJQUFJLEVBQUU7Z0JBQ3RCd1MsVUFBVSxDQUFDeFMsSUFBSSxHQUFHbVIsV0FBV3RPLEtBQUssQ0FBQzhPLE9BQU9ZLFVBQVUsQ0FBQ3ZTLElBQUk7WUFDN0QsT0FDSyxJQUFJLENBQUM4USxjQUFjdUIsY0FBYyxDQUFDclMsSUFBSSxFQUFFdVMsVUFBVSxDQUFDdlMsSUFBSSxHQUFHO2dCQUMzRCxJQUFJcVIsY0FBYztvQkFDZEEsYUFBYWlCLGNBQWMsQ0FBQ3RTLElBQUk7Z0JBQ3BDLENBQUM7Z0JBQ0QsSUFBSWlMLE1BQU1rRyxXQUFXdE8sS0FBSyxDQUFDOE8sT0FBT1ksVUFBVSxDQUFDdlMsSUFBSTtnQkFDakR3UyxVQUFVLENBQUN4UyxJQUFJLEdBQUcsZUFBZ0JvUixZQUFZbkcsS0FBS3FILGNBQWMsQ0FBQ3RTLElBQUksSUFDaEVzUyxjQUFjLENBQUN0UyxJQUFJLEdBQ25CaUwsR0FBRztZQUNiLE9BQ0s7Z0JBQ0R1SCxVQUFVLENBQUN4UyxJQUFJLEdBQUdzUyxjQUFjLENBQUN0UyxJQUFJO1lBQ3pDLENBQUM7UUFDTDtRQUNBcVMsaUJBQWlCRTtRQUNqQkQsaUJBQWlCRTtRQUNqQixPQUFPQTtJQUNYO0FBQ0o7QUFFQSxJQUFJQyxtQ0FBbUM7SUFDbkNoRSxNQUFNO0lBQ05pRSxXQUFXO0lBQ1hDLGdCQUFnQjtJQUNoQkMsVUFBVTtJQUNWQyxZQUFZO0FBQ2hCO0FBQ0EsSUFBSUMsZ0NBQWdDO0lBQ2hDQyxjQUFjO0lBQ2RDLEtBQUs7SUFDTG5NLE1BQU07SUFDTmlILE9BQU87SUFDUEMsS0FBSztJQUNMa0YsU0FBUztJQUNUaEYsTUFBTTtJQUNORSxRQUFRO0lBQ1JFLFFBQVE7QUFDWjtBQUNBLElBQUk2RSxjQUFjLHFCQUFxQiw2QkFBNkI7QUFDcEUsSUFBSUMsV0FBVyxNQUFNLDRCQUE0QjtBQUNqRCxJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsU0FBUyxXQUFXLG9CQUFvQjtBQUM1QyxJQUFJQyxTQUFTO0FBQ2IsSUFBSUMsa0JBQWtCLFdBQVcsR0FBSSxXQUFZO0lBQzdDLFNBQVNBLGdCQUFnQkMsY0FBYyxFQUFFO1FBQ3JDLElBQUlDLG9CQUFvQixDQUFDO1FBQ3pCLElBQUlDLG1CQUFtQixDQUFDO1FBQ3hCLElBQUlDLFdBQVc7UUFDZixJQUFLLElBQUkzSyxVQUFVd0ssZUFBZ0I7WUFDL0IsSUFBSXhLLFVBQVV5SixrQ0FBa0M7Z0JBQzVDaUIsZ0JBQWdCLENBQUMxSyxPQUFPLEdBQUd3SyxjQUFjLENBQUN4SyxPQUFPO2dCQUNqRDJLLFdBQVd2TyxLQUFLd08sR0FBRyxDQUFDbkIsZ0NBQWdDLENBQUN6SixPQUFPLEVBQUUySztZQUNsRSxPQUNLO2dCQUNERixpQkFBaUIsQ0FBQ3pLLE9BQU8sR0FBR3dLLGNBQWMsQ0FBQ3hLLE9BQU87Z0JBQ2xELElBQUlBLFVBQVU4SiwrQkFBK0I7b0JBQ3pDYSxXQUFXdk8sS0FBS3dPLEdBQUcsQ0FBQ2QsNkJBQTZCLENBQUM5SixPQUFPLEVBQUUySztnQkFDL0QsQ0FBQztZQUNMLENBQUM7UUFDTDtRQUNBLElBQUksQ0FBQ0YsaUJBQWlCLEdBQUdBO1FBQ3pCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdBO1FBQ3hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNFLG1CQUFtQixHQUFHM0MsUUFBUTJDO0lBQ3ZDO0lBQ0FOLGdCQUFnQnhaLFNBQVMsQ0FBQ2dCLE1BQU0sR0FBRyxTQUFVdU0sSUFBSSxFQUFFek4sT0FBTyxFQUFFO1FBQ3hELE9BQU8sSUFBSSxDQUFDZ2EsbUJBQW1CLENBQUMsSUFBSSxDQUFDSixpQkFBaUIsRUFBRSxJQUFJLENBQUNDLGdCQUFnQixFQUFFN1osU0FBU3lOO0lBQzVGO0lBQ0FpTSxnQkFBZ0J4WixTQUFTLENBQUMrWixXQUFXLEdBQUcsU0FBVWpILEtBQUssRUFBRUMsR0FBRyxFQUFFalQsT0FBTyxFQUFFa2Esc0JBQXNCLEVBQUU7UUFDM0YsSUFBSWxXLEtBQUssSUFBSSxFQUFFNFYsb0JBQW9CNVYsR0FBRzRWLGlCQUFpQixFQUFFQyxtQkFBbUI3VixHQUFHNlYsZ0JBQWdCO1FBQy9GLElBQUlNLGVBQWVDLDBCQUEwQnBILE1BQU14RyxNQUFNLEVBQUV5RyxJQUFJekcsTUFBTSxFQUFFeE0sUUFBUXFhLGNBQWM7UUFDN0YsSUFBSSxDQUFDRixjQUFjO1lBQ2YsT0FBTyxJQUFJLENBQUNqWixNQUFNLENBQUM4UixPQUFPaFQ7UUFDOUIsQ0FBQztRQUNELElBQUlzYSx3QkFBd0JIO1FBQzVCLElBQUlHLHdCQUF3QixLQUFLLHFFQUFxRTtRQUNqR1YsQ0FBQUEsa0JBQWtCNU0sSUFBSSxLQUFLLGFBQWE0TSxrQkFBa0I1TSxJQUFJLEtBQUssU0FBUSxLQUMzRTRNLENBQUFBLGtCQUFrQjNGLEtBQUssS0FBSyxhQUFhMkYsa0JBQWtCM0YsS0FBSyxLQUFLLFNBQVEsS0FDN0UyRixDQUFBQSxrQkFBa0IxRixHQUFHLEtBQUssYUFBYTBGLGtCQUFrQjFGLEdBQUcsS0FBSyxTQUFRLEdBQUk7WUFDOUVvRyx3QkFBd0IsR0FBRyxrRUFBa0U7UUFDakcsQ0FBQztRQUNELElBQUlDLFFBQVEsSUFBSSxDQUFDclosTUFBTSxDQUFDOFIsT0FBT2hUO1FBQy9CLElBQUl3YSxRQUFRLElBQUksQ0FBQ3RaLE1BQU0sQ0FBQytSLEtBQUtqVDtRQUM3QixJQUFJdWEsVUFBVUMsT0FBTztZQUNqQixPQUFPRDtRQUNYLENBQUM7UUFDRCxJQUFJRSxtQkFBbUJDLGdDQUFnQ2QsbUJBQW1CVTtRQUMxRSxJQUFJSyx3QkFBd0JYLG9CQUFvQlMsa0JBQWtCWixrQkFBa0I3WjtRQUNwRixJQUFJNGEsV0FBV0Qsc0JBQXNCM0g7UUFDckMsSUFBSTZILFdBQVdGLHNCQUFzQjFIO1FBQ3JDLElBQUk2SCxZQUFZQyxvQkFBb0JSLE9BQU9LLFVBQVVKLE9BQU9LO1FBQzVELElBQUloQyxZQUFZZ0IsaUJBQWlCaEIsU0FBUyxJQUFJcUIsMEJBQTBCbGEsUUFBUWdiLGdCQUFnQixJQUFJO1FBQ3BHLElBQUlGLFdBQVc7WUFDWCxPQUFPQSxVQUFVRyxNQUFNLEdBQUdMLFdBQVcvQixZQUFZZ0MsV0FBV0MsVUFBVUksS0FBSztRQUMvRSxDQUFDO1FBQ0QsT0FBT1gsUUFBUTFCLFlBQVkyQjtJQUMvQjtJQUNBZCxnQkFBZ0J4WixTQUFTLENBQUNpYixjQUFjLEdBQUcsV0FBWTtRQUNuRCxPQUFRLElBQUksQ0FBQ3JCLFFBQVE7WUFDakIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU87WUFDWCxLQUFLO2dCQUNELE9BQU87WUFDWCxLQUFLO2dCQUNELE9BQU87WUFDWCxLQUFLO2dCQUNELE9BQU87WUFDWDtnQkFDSSxPQUFPLFFBQVEsVUFBVTtRQUNqQztJQUNKO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVNNLG9CQUFvQkosaUJBQWlCLEVBQUVDLGdCQUFnQixFQUFFN1osT0FBTyxFQUFFO0lBQ3ZFLElBQUlvYixzQkFBc0IxYSxPQUFPNlAsSUFBSSxDQUFDcUosbUJBQW1CalgsTUFBTTtJQUMvRCxJQUFJeVksd0JBQXdCLEtBQUt4QixrQkFBa0JWLFlBQVksS0FBSyxTQUFTO1FBQ3pFLE9BQU8sU0FBVXpMLElBQUksRUFBRTtZQUFFLE9BQVE2SSxxQkFBcUI3SSxLQUFLMEksY0FBYztRQUFJO0lBQ2pGLENBQUM7SUFDRCxJQUFJaUYsd0JBQXdCLEtBQUt2QixpQkFBaUJqRixJQUFJLEVBQUU7UUFDcEQsT0FBTyxTQUFVbkgsSUFBSSxFQUFFO1lBQUUsT0FBUTROLGlCQUFpQnJiLFFBQVFzYixpQkFBaUIsQ0FBQzdOLEtBQUtqQixNQUFNLEdBQUd4TSxRQUFRdWIsUUFBUSxFQUFFdmIsUUFBUXdiLFlBQVksRUFBRXhiLFFBQVF5YixNQUFNLEVBQUU1QixpQkFBaUJqRixJQUFJO1FBQUk7SUFDL0ssQ0FBQztJQUNELE9BQU84RywwQkFBMEI5QixtQkFBbUJDLGtCQUFrQjdaO0FBQzFFO0FBQ0EsU0FBUzBiLDBCQUEwQjlCLGlCQUFpQixFQUFFQyxnQkFBZ0IsRUFBRTdaLE9BQU8sRUFBRTtJQUM3RTRaLG9CQUFvQnRhLCtDQUFRQSxDQUFDLENBQUMsR0FBR3NhLG9CQUFvQixPQUFPO0lBQzVEQyxtQkFBbUJ2YSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUd1YSxtQkFBbUIsT0FBTztJQUMxRDhCLGlCQUFpQi9CLG1CQUFtQkM7SUFDcENELGtCQUFrQmdDLFFBQVEsR0FBRyxPQUFPLCtEQUErRDtJQUNuRyxJQUFJQyxlQUFlLElBQUlDLEtBQUtDLGNBQWMsQ0FBQy9iLFFBQVF5YixNQUFNLENBQUNPLEtBQUssRUFBRXBDO0lBQ2pFLElBQUlxQyxZQUFZLFVBQVU7SUFDMUIsSUFBSXBDLGlCQUFpQmYsY0FBYyxFQUFFO1FBQ2pDLElBQUlvRCxZQUFZNWMsK0NBQVFBLENBQUMsQ0FBQyxHQUFHc2E7UUFDN0IsT0FBT3NDLFVBQVU1SCxNQUFNLEVBQUUsNkRBQTZEO1FBQ3RGMkgsYUFBYSxJQUFJSCxLQUFLQyxjQUFjLENBQUMvYixRQUFReWIsTUFBTSxDQUFDTyxLQUFLLEVBQUVFO0lBQy9ELENBQUM7SUFDRCxPQUFPLFNBQVV6TyxJQUFJLEVBQUU7UUFDbkIsSUFBSWpCLFNBQVNpQixLQUFLakIsTUFBTTtRQUN4QixJQUFJdEw7UUFDSixJQUFJK2EsY0FBYyxDQUFDelAsT0FBT0osYUFBYSxJQUFJO1lBQ3ZDbEwsU0FBUythO1FBQ2IsT0FDSztZQUNEL2EsU0FBUzJhO1FBQ2IsQ0FBQztRQUNELElBQUluVCxJQUFJeEgsT0FBT0EsTUFBTSxDQUFDc0w7UUFDdEIsT0FBTzJQLFlBQVl6VCxHQUFHK0UsTUFBTW1NLG1CQUFtQkMsa0JBQWtCN1o7SUFDckU7QUFDSjtBQUNBLFNBQVMyYixpQkFBaUIvQixpQkFBaUIsRUFBRUMsZ0JBQWdCLEVBQUU7SUFDM0Qsa0VBQWtFO0lBQ2xFLDRDQUE0QztJQUM1QyxJQUFJRCxrQkFBa0JWLFlBQVksRUFBRTtRQUNoQyxJQUFJLENBQUNVLGtCQUFrQnhGLElBQUksRUFBRTtZQUN6QndGLGtCQUFrQnhGLElBQUksR0FBRztRQUM3QixDQUFDO1FBQ0QsSUFBSSxDQUFDd0Ysa0JBQWtCdEYsTUFBTSxFQUFFO1lBQzNCc0Ysa0JBQWtCdEYsTUFBTSxHQUFHO1FBQy9CLENBQUM7SUFDTCxDQUFDO0lBQ0Qsb0NBQW9DO0lBQ3BDLElBQUlzRixrQkFBa0JWLFlBQVksS0FBSyxRQUFRO1FBQzNDVSxrQkFBa0JWLFlBQVksR0FBRztJQUNyQyxDQUFDO0lBQ0QseURBQXlEO0lBQ3pELElBQUlXLGlCQUFpQmYsY0FBYyxJQUFLYyxDQUFBQSxrQkFBa0JwRixNQUFNLElBQUlvRixrQkFBa0JuRixXQUFXLEdBQUc7UUFDaEcsT0FBT29GLGlCQUFpQmYsY0FBYztJQUMxQyxDQUFDO0FBQ0w7QUFDQSxTQUFTcUQsWUFBWXpULENBQUMsRUFBRStFLElBQUksRUFBRW1NLGlCQUFpQixFQUFFQyxnQkFBZ0IsRUFBRTdaLE9BQU8sRUFBRTtJQUN4RTBJLElBQUlBLEVBQUVXLE9BQU8sQ0FBQ21RLFFBQVEsS0FBSyx1RUFBdUU7SUFDbEcsSUFBSUksa0JBQWtCVixZQUFZLEtBQUssU0FBUztRQUM1Q3hRLElBQUkwVCxhQUFhMVQsR0FBRyxRQUFTa1QsUUFBUSxLQUFLLFNBQVNuTyxLQUFLMEksY0FBYyxJQUFJLElBQUksR0FDMUUsUUFDQUcscUJBQXFCN0ksS0FBSzBJLGNBQWMsQ0FBQztJQUNqRCxDQUFDO0lBQ0QsSUFBSTBELGlCQUFpQmIsVUFBVSxFQUFFO1FBQzdCdFEsSUFBSUEsRUFBRVcsT0FBTyxDQUFDaVEsVUFBVSxJQUFJK0MsSUFBSTtJQUNwQyxDQUFDO0lBQ0QsSUFBSXhDLGlCQUFpQmYsY0FBYyxFQUFFO1FBQ2pDcFEsSUFBSUEsRUFBRVcsT0FBTyxDQUFDLE9BQU8sS0FBSyx5Q0FBeUM7SUFDdkUsQ0FBQztJQUNELHFFQUFxRTtJQUNyRSxxREFBcUQ7SUFDckQsSUFBSXdRLGlCQUFpQmQsUUFBUSxLQUFLLEtBQUssRUFBRTtRQUNyQ3JRLElBQUlBLEVBQUVXLE9BQU8sQ0FBQ2dRLGFBQWEsSUFBSWdELElBQUk7SUFDdkMsT0FDSyxJQUFJeEMsaUJBQWlCZCxRQUFRLEtBQUssVUFBVTtRQUM3Q3JRLElBQUlBLEVBQUVXLE9BQU8sQ0FBQ2dRLGFBQWEsU0FBVTVPLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1lBQUUsT0FBT0EsR0FBRzRSLGlCQUFpQjtRQUFJO0lBQ2xGLE9BQ0ssSUFBSXpDLGlCQUFpQmQsUUFBUSxLQUFLLFNBQVM7UUFDNUNyUSxJQUFJQSxFQUFFVyxPQUFPLENBQUNnUSxhQUFhLFNBQVU1TyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtZQUFFLE9BQU9BLEdBQUc0UixpQkFBaUIsS0FBSztRQUFLO0lBQ3hGLE9BQ0ssSUFBSXpDLGlCQUFpQmQsUUFBUSxLQUFLLGFBQWE7UUFDaERyUSxJQUFJQSxFQUFFVyxPQUFPLENBQUNnUSxhQUFhLFNBQVU1TyxFQUFFLEVBQUU7WUFBRSxPQUFPQSxHQUFHNlIsaUJBQWlCO1FBQUk7SUFDOUUsQ0FBQztJQUNENVQsSUFBSUEsRUFBRVcsT0FBTyxDQUFDa1EsZ0JBQWdCO0lBQzlCN1EsSUFBSUEsRUFBRTJULElBQUk7SUFDVixPQUFPM1Q7QUFDWDtBQUNBLFNBQVMwVCxhQUFhMVQsQ0FBQyxFQUFFNlQsTUFBTSxFQUFFO0lBQzdCLElBQUlDLFdBQVcsS0FBSztJQUNwQjlULElBQUlBLEVBQUVXLE9BQU8sQ0FBQ29RLFFBQVEsV0FBWTtRQUM5QitDLFdBQVcsSUFBSTtRQUNmLE9BQU9EO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsSUFBSSxDQUFDQyxVQUFVO1FBQ1g5VCxLQUFLLE1BQU02VDtJQUNmLENBQUM7SUFDRCxPQUFPN1Q7QUFDWDtBQUNBLFNBQVMyUyxpQkFBaUJvQixHQUFHLEVBQUVsQixRQUFRLEVBQUVDLFlBQVksRUFBRUMsTUFBTSxFQUFFaUIsT0FBTyxFQUFFO0lBQ3BFLElBQUlDLFFBQVEsRUFBRTtJQUNkLElBQUlELFlBQVksUUFBUTtRQUNwQkMsTUFBTTdaLElBQUksQ0FBQzBZO0lBQ2YsT0FDSyxJQUFJa0IsWUFBWSxXQUFXQSxZQUFZLFVBQVU7UUFDbERDLE1BQU03WixJQUFJLENBQUN5WTtJQUNmLENBQUM7SUFDRCxJQUFJbUIsWUFBWSxVQUFVQSxZQUFZLFNBQVM7UUFDM0NDLE1BQU03WixJQUFJLENBQUM7SUFDZixDQUFDO0lBQ0Q2WixNQUFNN1osSUFBSSxDQUFDMlksT0FBT21CLGtCQUFrQixDQUFDMWIsTUFBTSxDQUFDdWI7SUFDNUMsSUFBSWhCLE9BQU9wSixPQUFPLENBQUN3SyxTQUFTLEtBQUssT0FBTztRQUNwQ0YsTUFBTUcsT0FBTztJQUNqQixDQUFDO0lBQ0QsT0FBT0gsTUFBTUksSUFBSSxDQUFDO0FBQ3RCO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLFNBQVMzQywwQkFBMEJyRixFQUFFLEVBQUVDLEVBQUUsRUFBRWdJLEVBQUUsRUFBRTtJQUMzQyxJQUFJQSxHQUFHQyxhQUFhLENBQUNsSSxRQUFRaUksR0FBR0MsYUFBYSxDQUFDakksS0FBSztRQUMvQyxPQUFPO0lBQ1gsQ0FBQztJQUNELElBQUlnSSxHQUFHRSxjQUFjLENBQUNuSSxRQUFRaUksR0FBR0UsY0FBYyxDQUFDbEksS0FBSztRQUNqRCxPQUFPO0lBQ1gsQ0FBQztJQUNELElBQUlnSSxHQUFHRyxZQUFZLENBQUNwSSxRQUFRaUksR0FBR0csWUFBWSxDQUFDbkksS0FBSztRQUM3QyxPQUFPO0lBQ1gsQ0FBQztJQUNELElBQUluSixTQUFTa0osUUFBUWxKLFNBQVNtSixLQUFLO1FBQy9CLE9BQU87SUFDWCxDQUFDO0lBQ0QsT0FBTztBQUNYO0FBQ0EsU0FBUzBGLGdDQUFnQ3JJLE9BQU8sRUFBRStLLFdBQVcsRUFBRTtJQUMzRCxJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixJQUFLLElBQUk5TixVQUFVOEMsUUFBUztRQUN4QixJQUFJLENBQUU5QyxDQUFBQSxVQUFVMEosNkJBQTRCLEtBQU0sdUNBQXVDO1FBQ3JGQSw2QkFBNkIsQ0FBQzFKLE9BQU8sSUFBSTZOLGFBQWE7WUFDdERDLGNBQWMsQ0FBQzlOLE9BQU8sR0FBRzhDLE9BQU8sQ0FBQzlDLE9BQU87UUFDNUMsQ0FBQztJQUNMO0lBQ0EsT0FBTzhOO0FBQ1g7QUFDQSxTQUFTdEMsb0JBQW9CUixLQUFLLEVBQUVLLFFBQVEsRUFBRUosS0FBSyxFQUFFSyxRQUFRLEVBQUU7SUFDM0QsSUFBSXlDLEtBQUs7SUFDVCxNQUFPQSxLQUFLL0MsTUFBTTVYLE1BQU0sQ0FBRTtRQUN0QixJQUFJNGEsU0FBU2hELE1BQU1pRCxPQUFPLENBQUM1QyxVQUFVMEM7UUFDckMsSUFBSUMsV0FBVyxDQUFDLEdBQUc7WUFDZixLQUFNO1FBQ1YsQ0FBQztRQUNELElBQUlFLFVBQVVsRCxNQUFNNVIsTUFBTSxDQUFDLEdBQUc0VTtRQUM5QkQsS0FBS0MsU0FBUzNDLFNBQVNqWSxNQUFNO1FBQzdCLElBQUkrYSxTQUFTbkQsTUFBTTVSLE1BQU0sQ0FBQzJVO1FBQzFCLElBQUlLLEtBQUs7UUFDVCxNQUFPQSxLQUFLbkQsTUFBTTdYLE1BQU0sQ0FBRTtZQUN0QixJQUFJaWIsU0FBU3BELE1BQU1nRCxPQUFPLENBQUMzQyxVQUFVOEM7WUFDckMsSUFBSUMsV0FBVyxDQUFDLEdBQUc7Z0JBQ2YsS0FBTTtZQUNWLENBQUM7WUFDRCxJQUFJQyxVQUFVckQsTUFBTTdSLE1BQU0sQ0FBQyxHQUFHaVY7WUFDOUJELEtBQUtDLFNBQVMvQyxTQUFTbFksTUFBTTtZQUM3QixJQUFJbWIsU0FBU3RELE1BQU03UixNQUFNLENBQUNnVjtZQUMxQixJQUFJRixZQUFZSSxXQUFXSCxXQUFXSSxRQUFRO2dCQUMxQyxPQUFPO29CQUNIN0MsUUFBUXdDO29CQUNSdkMsT0FBT3dDO2dCQUNYO1lBQ0osQ0FBQztRQUNMO0lBQ0o7SUFDQSxPQUFPLElBQUk7QUFDZjtBQUVBLFNBQVNLLGtCQUFrQkMsUUFBUSxFQUFFM0QsY0FBYyxFQUFFO0lBQ2pELElBQUloUyxJQUFJZ1MsZUFBZTRELGFBQWEsQ0FBQ0QsU0FBU3hSLE1BQU07SUFDcEQsT0FBTztRQUNIQSxRQUFRd1IsU0FBU3hSLE1BQU07UUFDdkIySixnQkFBZ0I2SCxTQUFTN0gsY0FBYztRQUN2Q1UsT0FBT3hPO1FBQ1AyRSxNQUFNM0UsQ0FBQyxDQUFDLEVBQUU7UUFDVjRMLE9BQU81TCxDQUFDLENBQUMsRUFBRTtRQUNYNkwsS0FBSzdMLENBQUMsQ0FBQyxFQUFFO1FBQ1QrTCxNQUFNL0wsQ0FBQyxDQUFDLEVBQUU7UUFDVmlNLFFBQVFqTSxDQUFDLENBQUMsRUFBRTtRQUNabU0sUUFBUW5NLENBQUMsQ0FBQyxFQUFFO1FBQ1pvTSxhQUFhcE0sQ0FBQyxDQUFDLEVBQUU7SUFDckI7QUFDSjtBQUVBLFNBQVM2ViwyQkFBMkJsTCxLQUFLLEVBQUVDLEdBQUcsRUFBRWpULE9BQU8sRUFBRWthLHNCQUFzQixFQUFFO0lBQzdFLElBQUlpRSxZQUFZSixrQkFBa0IvSyxPQUFPaFQsUUFBUXFhLGNBQWM7SUFDL0QsSUFBSStELFVBQVVuTCxNQUFNOEssa0JBQWtCOUssS0FBS2pULFFBQVFxYSxjQUFjLElBQUksSUFBSTtJQUN6RSxPQUFPO1FBQ0g1TSxNQUFNMFE7UUFDTm5MLE9BQU9tTDtRQUNQbEwsS0FBS21MO1FBQ0x4QyxVQUFVNWIsUUFBUTRiLFFBQVE7UUFDMUJ5QyxhQUFhcmUsUUFBUXliLE1BQU0sQ0FBQ08sS0FBSztRQUNqQ2hCLGtCQUFrQmQsMEJBQTBCbGEsUUFBUWdiLGdCQUFnQjtJQUN4RTtBQUNKO0FBRUE7O0FBRUEsR0FDQTs7O0FBR0EsR0FDQSxJQUFJc0QsZUFBZSxXQUFXLEdBQUksV0FBWTtJQUMxQyxTQUFTQSxhQUFhQyxNQUFNLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2xCO0lBQ0FELGFBQWFwZSxTQUFTLENBQUNnQixNQUFNLEdBQUcsU0FBVXVNLElBQUksRUFBRXpOLE9BQU8sRUFBRWthLHNCQUFzQixFQUFFO1FBQzdFLE9BQU9sYSxRQUFRd2UsWUFBWSxDQUFDLElBQUksQ0FBQ0QsTUFBTSxFQUFFTCwyQkFBMkJ6USxNQUFNLElBQUksRUFBRXpOLFNBQVNrYTtJQUM3RjtJQUNBb0UsYUFBYXBlLFNBQVMsQ0FBQytaLFdBQVcsR0FBRyxTQUFVakgsS0FBSyxFQUFFQyxHQUFHLEVBQUVqVCxPQUFPLEVBQUVrYSxzQkFBc0IsRUFBRTtRQUN4RixPQUFPbGEsUUFBUXdlLFlBQVksQ0FBQyxJQUFJLENBQUNELE1BQU0sRUFBRUwsMkJBQTJCbEwsT0FBT0MsS0FBS2pULFNBQVNrYTtJQUM3RjtJQUNBLE9BQU9vRTtBQUNYO0FBRUEsSUFBSUcsZ0JBQWdCLFdBQVcsR0FBSSxXQUFZO0lBQzNDLFNBQVNBLGNBQWM3VyxJQUFJLEVBQUU7UUFDekIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2hCO0lBQ0E2VyxjQUFjdmUsU0FBUyxDQUFDZ0IsTUFBTSxHQUFHLFNBQVV1TSxJQUFJLEVBQUV6TixPQUFPLEVBQUVrYSxzQkFBc0IsRUFBRTtRQUM5RSxPQUFPLElBQUksQ0FBQ3RTLElBQUksQ0FBQ3NXLDJCQUEyQnpRLE1BQU0sSUFBSSxFQUFFek4sU0FBU2thO0lBQ3JFO0lBQ0F1RSxjQUFjdmUsU0FBUyxDQUFDK1osV0FBVyxHQUFHLFNBQVVqSCxLQUFLLEVBQUVDLEdBQUcsRUFBRWpULE9BQU8sRUFBRWthLHNCQUFzQixFQUFFO1FBQ3pGLE9BQU8sSUFBSSxDQUFDdFMsSUFBSSxDQUFDc1csMkJBQTJCbEwsT0FBT0MsS0FBS2pULFNBQVNrYTtJQUNyRTtJQUNBLE9BQU91RTtBQUNYO0FBRUEsU0FBU0MsZ0JBQWdCelgsS0FBSyxFQUFFO0lBQzVCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxPQUFPO1FBQ3BDLE9BQU8sSUFBSXlTLGdCQUFnQnpTO0lBQy9CLENBQUM7SUFDRCxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUMzQixPQUFPLElBQUlxWCxhQUFhclg7SUFDNUIsQ0FBQztJQUNELElBQUksT0FBT0EsVUFBVSxZQUFZO1FBQzdCLE9BQU8sSUFBSXdYLGNBQWN4WDtJQUM3QixDQUFDO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLElBQUkwWCx1QkFBdUI7SUFDdkJDLGlCQUFpQkM7SUFDakJDLGtCQUFrQkQ7SUFDbEIvTSxVQUFVNEI7SUFDVnFMLHNCQUFzQkY7SUFDdEJHLGFBQWFIO0lBQ2JJLGVBQWVKO0lBQ2ZsTSw0QkFBNEJlO0lBQzVCZCwyQkFBMkJjO0lBQzNCd0wsa0JBQWtCeEw7SUFDbEJ5TCxZQUFZekw7SUFDWjBMLGlCQUFpQkM7SUFDakJDLGFBQWE1TDtJQUNiNkwsYUFBYTdMO0lBQ2I4TCxrQkFBa0JkO0lBQ2xCZSxjQUFjL0w7SUFDZGdNLGNBQWNoTTtJQUNkaU0sZUFBZWQ7SUFDZmUsZUFBZWY7SUFDZmdCLHVCQUF1QnZaO0lBQ3ZCd1oscUJBQXFCeFo7SUFDckJ5WixvQkFBb0JWO0lBQ3BCVyxZQUFZWDtJQUNaWSxpQkFBaUJ2QjtJQUNqQndCLHFCQUFxQnJCO0lBQ3JCc0Isa0JBQWtCdEI7SUFDbEJ1QixtQkFBbUJ2QjtJQUNuQndCLHNCQUFzQnhCO0lBQ3RCeUIsbUJBQW1CekI7SUFDbkIwQixnQkFBZ0IxQjtJQUNoQjJCLGlCQUFpQjNCO0lBQ2pCNEIsb0JBQW9CNUI7SUFDcEI2QixhQUFhcGE7SUFDYnFhLGFBQWFDO0lBQ2JDLFVBQVV4QjtJQUNWeUIsdUJBQXVCakM7SUFDdkJrQyxhQUFhMUI7SUFDYjJCLHNCQUFzQm5DO0lBQ3RCb0MsbUJBQW1CcEM7SUFDbkJxQyxvQkFBb0JyQztJQUNwQnNDLHVCQUF1QnRDO0lBQ3ZCdUMsVUFBVS9CO0lBQ1ZnQyxnQkFBZ0J4QztJQUNoQnlDLGNBQWN6QztJQUNkMEMsaUJBQWlCMUM7SUFDakIyQyxjQUFjbkM7SUFDZG9DLHdCQUF3QjVDO0lBQ3hCNkMscUJBQXFCN0M7SUFDckI4QyxzQkFBc0I5QztJQUN0QitDLHlCQUF5Qi9DO0lBQ3pCZ0QscUJBQXFCeEM7SUFDckJ5QyxjQUFjekM7SUFDZDBDLFlBQVl6YjtJQUNaMGIsVUFBVTFiO0lBQ1YyYixlQUFlM2I7SUFDZnNWLFVBQVV0VjtJQUNWNGIsU0FBU3JEO0lBQ1RwRCxRQUFRb0Q7SUFDUnNELGFBQWE3YjtJQUNiOGIsb0JBQW9CeEI7SUFDcEJ5QixZQUFZaEQ7SUFDWmlELHdCQUF3QmpEO0lBQ3hCa0QsY0FBY2xEO0lBQ2RtRCxZQUFZM0Q7SUFDWjRELFlBQVl6YjtJQUNaMGIsa0JBQWtCckQ7SUFDbEJzRCxvQkFBb0J0RDtJQUNwQnVELG1CQUFtQmhDO0lBQ25CaUMsZ0JBQWdCakM7SUFDaEJrQyxzQkFBc0JsQztJQUN0Qm1DLFlBQVkxRDtJQUNaMkQsUUFBUW5FO0lBQ1JvRSxlQUFlcEU7SUFDZmhDLFdBQVd2VztJQUNYNGMsa0JBQWtCeEU7SUFDbEJ5RSx5QkFBeUI5RDtJQUN6QitELGtCQUFrQi9EO0lBQ2xCZ0UsaUJBQWlCaEU7SUFDakI5RCxVQUFValY7SUFDVmtWLGNBQWNsVjtJQUNkZ2QsMkJBQTJCakU7SUFDM0JrRSxlQUFlMUU7SUFDZjJFLGFBQWEzRTtJQUNiNEUsS0FBSzVFO0lBQ0w2RSxvQkFBb0I3RTtJQUNwQjhFLG1CQUFtQjlFO0lBQ25CK0UsdUJBQXVCL0U7SUFDdkJnRixZQUFZaEY7SUFDWnROLGVBQWU4TjtJQUNmeUUsb0JBQW9CakY7SUFDcEJrRixvQkFBb0JsRjtJQUNwQm1GLGNBQWMxZDtJQUNkMmQsb0JBQW9CNUU7SUFDcEI2RSx1QkFBdUI3RTtJQUN2QjhFLGNBQWN0RjtJQUNkdUYsaUJBQWlCdkY7SUFDakJ3RixZQUFZeEY7SUFDWnlGLHNCQUFzQmhlO0lBQ3RCaWUsa0JBQWtCamU7SUFDbEJrZSxnQkFBZ0JsZTtJQUNoQm1lLFlBQVluZTtJQUNab2UsaUJBQWlCN0Y7SUFDakI4RixjQUFjOUY7SUFDZCtGLGVBQWUvRjtJQUNmZ0csa0JBQWtCaEc7SUFDbEJpRyxrQkFBa0JqRztJQUNsQmtHLGVBQWVsRztJQUNmbUcsYUFBYW5HO0lBQ2JvRyxXQUFXNUY7SUFDWDZGLGdCQUFnQjVlO0lBQ2hCNmUsaUJBQWlCdEc7SUFDakJ1RyxvQkFBb0J2RztJQUNwQndHLGlCQUFpQnhHO0lBQ2pCeUcsa0JBQWtCekc7SUFDbEIwRyxxQkFBcUIxRztJQUNyQjJHLHFCQUFxQjNHO0lBQ3JCNEcsa0JBQWtCNUc7SUFDbEI2RyxtQkFBbUI3RztJQUNuQjhHLHNCQUFzQjlHO0lBQ3RCK0csY0FBYy9HO0lBQ2RnSCxpQkFBaUJoSDtJQUNqQmlILGFBQWFsRjtJQUNibUYsbUJBQW1CclM7SUFDbkJzUyxZQUFZMWY7SUFDWjJmLGtCQUFrQnBIO0lBQ2xCcUgsZUFBZXJIO0lBQ2ZzSCxnQkFBZ0J0SDtJQUNoQnVILG1CQUFtQnZIO0lBQ25Cd0gsY0FBY3pGO0lBQ2QwRixVQUFVakg7SUFDVmtILGlCQUFpQjdIO0lBQ2pCOEgsZUFBZTVGO0lBQ2Y2RixjQUFjNUg7SUFDZDZILGNBQWM3SDtJQUNkOEgsbUJBQW1CL0Y7SUFDbkJnRyxZQUFZdkg7SUFDWndILHNCQUFzQmpHO0lBQ3RCa0cscUJBQXFCbEc7SUFDckJtRyxjQUFjMUg7SUFDZDJILGVBQWVwRztJQUNmcUcsZ0JBQWdCckc7SUFDaEJzRyxlQUFldEc7SUFDZnVHLGtCQUFrQnZHO0lBQ2xCd0csa0JBQWtCL0g7SUFDbEJnSSxTQUFTeEk7SUFDVHlJLFVBQVUxRztJQUNWMkcsVUFBVTNHO0lBQ1Y0RyxlQUFlbGhCO0lBQ2ZtaEIsZUFBZS9UO0lBQ2ZnVSxZQUFZN0k7SUFDWjhJLFdBQVd0STtJQUNYdUksZ0JBQWdCdkk7SUFDaEJ3SSxZQUFZaEo7SUFDWmlKLGNBQWNqSjtJQUNka0osYUFBYWxKO0lBQ2JtSixrQkFBa0IzSTtJQUNsQix3RkFBd0Y7SUFDeEY0SSxjQUFjM2hCO0lBQ2Q0aEIsVUFBVXJKO0lBQ1ZzSixhQUFhdEo7SUFDYnVKLFdBQVc5aEI7SUFDWCtoQixVQUFVL2hCO0lBQ1ZnaUIsV0FBV2hpQjtJQUNYaWlCLGVBQWUxSjtJQUNmMkosb0JBQW9CM0o7SUFDcEI0SixpQkFBaUI1SjtJQUNqQjZKLGtCQUFrQjdKO0lBQ2xCOEoscUJBQXFCOUo7QUFDekI7QUFDQSxvRkFBb0Y7QUFDcEYsY0FBYztBQUNkLElBQUkrSix1QkFBdUI7SUFDdkI1RSxjQUFjO0lBQ2RuRSx1QkFBdUI7SUFDdkJDLHFCQUFxQjtJQUNyQmxOLDJCQUEyQjtJQUMzQkQsNEJBQTRCO1FBQUV1QixLQUFLO0lBQUU7SUFDckM2TCxvQkFBb0IsS0FBSztJQUN6QmIsa0JBQWtCO0lBQ2xCYyxZQUFZLElBQUk7SUFDaEJVLGFBQWE7SUFDYkMsYUFBYTtJQUNiaEIsZUFBZTtRQUNYM00sT0FBTztRQUNQNlYsUUFBUTtRQUNSNVYsS0FBSztJQUNUO0lBQ0E0TixVQUFVLElBQUk7SUFDZEUsYUFBYSxLQUFLO0lBQ2xCRCx1QkFBdUI7SUFDdkJNLFVBQVUsS0FBSztJQUNmSSxjQUFjLEtBQUs7SUFDbkJyQyxZQUFZO0lBQ1pDLGlCQUFpQixJQUFJO0lBQ3JCRSxhQUFhO0lBQ2JDLGFBQWE7SUFDYnNDLHFCQUFxQixJQUFJO0lBQ3pCQyxjQUFjLElBQUk7SUFDbEJDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxlQUFlO0lBQ2ZyRyxVQUFVO0lBQ1ZzRyxTQUFTLEVBQUU7SUFDWHpHLFFBQVE7SUFDUjBHLGFBQWE7SUFDYkMsb0JBQW9CO0lBQ3BCQyxZQUFZLElBQUk7SUFDaEJDLHdCQUF3QixLQUFLO0lBQzdCQyxjQUFjLElBQUk7SUFDbEJDLFlBQVk7SUFDWkMsWUFBWTtJQUNaakQsa0JBQWtCO1FBQUV2TCxPQUFPO1FBQVFDLEtBQUs7UUFBV2xILE1BQU07SUFBVTtJQUNuRTJWLG9CQUFvQixJQUFJO0lBQ3hCQyxtQkFBbUI7SUFDbkJDLGdCQUFnQjtJQUNoQkMsc0JBQXNCO0lBQ3RCQyxZQUFZLEtBQUs7SUFDakJ1RCxVQUFVLEtBQUs7SUFDZk0sWUFBWSxLQUFLO0lBQ2pCSyxnQkFBZ0I7SUFDaEJDLGVBQWU7SUFDZkMsa0JBQWtCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixJQUFJMkIsNkJBQTZCO0lBQzdCQyxVQUFVbEs7SUFDVm1LLFdBQVduSztJQUNYb0ssVUFBVXBLO0lBQ1ZxSyxhQUFhcks7SUFDYnNLLGFBQWF0SztJQUNidUssY0FBY3ZLO0lBQ2R3SyxZQUFZeEs7SUFDWnlLLGlCQUFpQnpLO0lBQ2pCMEssaUJBQWlCMUs7SUFDakIySyxRQUFRM0s7SUFDUjRLLFVBQVU1SztJQUNWNkssU0FBUzdLO0lBQ1QsV0FBVztJQUNYOEssVUFBVTlLO0lBQ1YrSyxjQUFjL0s7SUFDZGdMLGFBQWFoTDtJQUNiaUwsY0FBY2pMO0lBQ2RrTCxnQkFBZ0JsTDtJQUNoQm1MLFNBQVNuTDtJQUNUb0wsZ0JBQWdCcEw7QUFDcEI7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLElBQUlxTCwyQkFBMkI7SUFDM0JDLFlBQVl0TDtJQUNadUwsYUFBYXZMO0lBQ2J3TCxPQUFPeEw7SUFDUHdJLFNBQVN4STtJQUNUeUwsZUFBZXpMO0lBQ2YwTCxRQUFRMUw7SUFDUjJMLGNBQWMzTDtBQUNsQjtBQUNBLElBQUk0TCw2QkFBNkI7SUFDN0I5SyxlQUFlK0s7SUFDZjlLLGVBQWU4SztJQUNmUCxZQUFZTztJQUNaTixhQUFhTTtJQUNiMUwsYUFBYTBMO0lBQ2JqRCxlQUFlaUQ7QUFDbkI7QUFDQSxTQUFTQSxvQkFBb0JyaUIsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7SUFDL0IsSUFBSSxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxZQUFZRCxLQUFLQyxHQUFHO1FBQzFELE9BQU8rSCxhQUFhaEksR0FBR0M7SUFDM0IsQ0FBQztJQUNELE9BQU9ELE1BQU1DO0FBQ2pCO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixJQUFJcWlCLHVCQUF1QjtJQUN2QnRxQixNQUFNaUc7SUFDTnNrQixXQUFXL0w7SUFDWHNMLFlBQVk3akI7SUFDWnVrQixlQUFldmtCO0lBQ2Z3a0IsMkJBQTJCak07SUFDM0JrTSxnQkFBZ0IxTDtJQUNoQjJMLFlBQVluTTtJQUNab00sU0FBU3BNO0lBQ1RxTSxVQUFVck07SUFDVnNNLGFBQWF0TTtBQUNqQjtBQUNBLGFBQWE7QUFDYix1R0FBdUc7QUFDdkcsU0FBU3VNLGdCQUFnQkMsVUFBVSxFQUFFO0lBQ2pDLE9BQU90YyxXQUFXc2MsWUFBWVo7QUFDbEM7QUFDQSxTQUFTYSxZQUFZcmtCLEtBQUssRUFBRXNrQixRQUFRLEVBQUU7SUFDbEMsSUFBSWphLFVBQVUsQ0FBQztJQUNmLElBQUlrYSxRQUFRLENBQUM7SUFDYixJQUFLLElBQUlob0IsWUFBWStuQixTQUFVO1FBQzNCLElBQUkvbkIsWUFBWXlELE9BQU87WUFDbkJxSyxPQUFPLENBQUM5TixTQUFTLEdBQUcrbkIsUUFBUSxDQUFDL25CLFNBQVMsQ0FBQ3lELEtBQUssQ0FBQ3pELFNBQVM7UUFDMUQsQ0FBQztJQUNMO0lBQ0EsSUFBSyxJQUFJQSxZQUFZeUQsTUFBTztRQUN4QixJQUFJLENBQUV6RCxDQUFBQSxZQUFZK25CLFFBQU8sR0FBSTtZQUN6QkMsS0FBSyxDQUFDaG9CLFNBQVMsR0FBR3lELEtBQUssQ0FBQ3pELFNBQVM7UUFDckMsQ0FBQztJQUNMO0lBQ0EsT0FBTztRQUFFOE4sU0FBU0E7UUFBU2thLE9BQU9BO0lBQU07QUFDNUM7QUFDQSxTQUFTM00sU0FBUzRNLEdBQUcsRUFBRTtJQUNuQixPQUFPQTtBQUNYO0FBRUEsU0FBU0MsWUFBWUMsU0FBUyxFQUFFQyxXQUFXLEVBQUU1ckIsT0FBTyxFQUFFNnJCLGNBQWMsRUFBRTtJQUNsRSxJQUFJM1osYUFBYTRaO0lBQ2pCLElBQUlDLGdCQUFnQkMsbUJBQW1CaHNCO0lBQ3ZDLElBQUssSUFBSThQLEtBQUssR0FBR21jLGNBQWNOLFdBQVc3YixLQUFLbWMsWUFBWXRwQixNQUFNLEVBQUVtTixLQUFNO1FBQ3JFLElBQUlvYyxXQUFXRCxXQUFXLENBQUNuYyxHQUFHO1FBQzlCLElBQUlJLFFBQVFpYyxXQUFXRCxVQUFVTixhQUFhNXJCLFNBQVM2ckIsZ0JBQWdCRTtRQUN2RSxJQUFJN2IsT0FBTztZQUNQa2Msa0JBQWtCbGMsT0FBT2dDO1FBQzdCLENBQUM7SUFDTDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTa2Esa0JBQWtCbGMsS0FBSyxFQUFFZ0MsVUFBVSxFQUFFO0lBQzFDLElBQUlBLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWE0WjtJQUF5QixDQUFDO0lBQ3BFNVosV0FBV0ksSUFBSSxDQUFDcEMsTUFBTXdDLEdBQUcsQ0FBQ2pFLEtBQUssQ0FBQyxHQUFHeUIsTUFBTXdDLEdBQUc7SUFDNUMsSUFBSXhDLE1BQU1zQyxRQUFRLEVBQUU7UUFDaEJOLFdBQVdLLFNBQVMsQ0FBQ3JDLE1BQU1zQyxRQUFRLENBQUMzRCxVQUFVLENBQUMsR0FBR3FCLE1BQU1zQyxRQUFRO0lBQ3BFLENBQUM7SUFDRCxPQUFPTjtBQUNYO0FBQ0Esd0ZBQXdGO0FBQ3hGLHdDQUF3QztBQUN4Qyw0RUFBNEU7QUFDNUUsU0FBU21hLGtCQUFrQm5hLFVBQVUsRUFBRXJELFVBQVUsRUFBRTtJQUMvQyxJQUFJMkQsV0FBV04sV0FBV0ssU0FBUyxDQUFDMUQsV0FBVztJQUMvQyxJQUFJMkQsVUFBVTtRQUNWLElBQUk4WixRQUFRcGEsV0FBV0ksSUFBSSxDQUFDRSxTQUFTL0QsS0FBSyxDQUFDO1FBQzNDLHVDQUF1QztRQUN2QyxJQUFJOGQsV0FBV0MscUJBQXFCdGEsWUFBWSxTQUFVdWEsT0FBTyxFQUFFO1lBQUUsT0FBT0MsbUJBQW1CSixPQUFPRztRQUFVO1FBQ2hILG1CQUFtQjtRQUNuQixpRUFBaUU7UUFDakVGLFNBQVNqYSxJQUFJLENBQUNnYSxNQUFNN2QsS0FBSyxDQUFDLEdBQUc2ZDtRQUM3QkMsU0FBU2hhLFNBQVMsQ0FBQ0MsU0FBUzNELFVBQVUsQ0FBQyxHQUFHMkQ7UUFDMUMsT0FBTytaO0lBQ1gsQ0FBQztJQUNELE9BQU9UO0FBQ1g7QUFDQSxTQUFTWSxtQkFBbUJDLElBQUksRUFBRUMsSUFBSSxFQUFFO0lBQ3BDLE9BQU92TixRQUFRc04sS0FBS0UsT0FBTyxJQUFJRixLQUFLRSxPQUFPLEtBQUtELEtBQUtDLE9BQU87QUFDaEU7QUFDQSxTQUFTZix3QkFBd0I7SUFDN0IsT0FBTztRQUFFeFosTUFBTSxDQUFDO1FBQUdDLFdBQVcsQ0FBQztJQUFFO0FBQ3JDO0FBQ0EsU0FBU3VhLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUU7SUFDdEMsT0FBTztRQUNIMWEsTUFBTWhULCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUd5dEIsT0FBT3phLElBQUksR0FBRzBhLE9BQU8xYSxJQUFJO1FBQ3JEQyxXQUFXalQsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR3l0QixPQUFPeGEsU0FBUyxHQUFHeWEsT0FBT3phLFNBQVM7SUFDeEU7QUFDSjtBQUNBLFNBQVNpYSxxQkFBcUJ0YSxVQUFVLEVBQUUrYSxVQUFVLEVBQUU7SUFDbEQsSUFBSTNhLE9BQU85QyxXQUFXMEMsV0FBV0ksSUFBSSxFQUFFMmE7SUFDdkMsSUFBSTFhLFlBQVkvQyxXQUFXMEMsV0FBV0ssU0FBUyxFQUFFLFNBQVVDLFFBQVEsRUFBRTtRQUFFLE9BQVFGLElBQUksQ0FBQ0UsU0FBUy9ELEtBQUssQ0FBQyxDQUFDLGdCQUFnQjs7SUFDakg7SUFDSCxPQUFPO1FBQUU2RCxNQUFNQTtRQUFNQyxXQUFXQTtJQUFVO0FBQzlDO0FBQ0EsU0FBUzJhLHFCQUFxQkMsTUFBTSxFQUFFQyxHQUFHLEVBQUU7SUFDdkMsSUFBSTlhLE9BQU82YSxPQUFPN2EsSUFBSSxFQUFFQyxZQUFZNGEsT0FBTzVhLFNBQVM7SUFDcEQsSUFBSThhLGVBQWUsQ0FBQztJQUNwQixJQUFJQyxvQkFBb0IsQ0FBQztJQUN6QixJQUFLLElBQUk3ZSxTQUFTNkQsS0FBTTtRQUNwQixJQUFJLENBQUM4YSxJQUFJOWEsSUFBSSxDQUFDN0QsTUFBTSxFQUFFO1lBQ2xCNGUsWUFBWSxDQUFDNWUsTUFBTSxHQUFHNkQsSUFBSSxDQUFDN0QsTUFBTTtRQUNyQyxDQUFDO0lBQ0w7SUFDQSxJQUFLLElBQUlJLGNBQWMwRCxVQUFXO1FBQzlCLElBQUksQ0FBQzZhLElBQUk3YSxTQUFTLENBQUMxRCxXQUFXLElBQUksMEJBQTBCO1FBQ3hEd2UsWUFBWSxDQUFDOWEsU0FBUyxDQUFDMUQsV0FBVyxDQUFDSixLQUFLLENBQUMsQ0FBQywyQkFBMkI7VUFDdkU7WUFDRTZlLGlCQUFpQixDQUFDemUsV0FBVyxHQUFHMEQsU0FBUyxDQUFDMUQsV0FBVztRQUN6RCxDQUFDO0lBQ0w7SUFDQSxPQUFPO1FBQ0h5RCxNQUFNK2E7UUFDTjlhLFdBQVcrYTtJQUNmO0FBQ0o7QUFFQSxTQUFTQyxvQkFBb0J0bUIsS0FBSyxFQUFFakgsT0FBTyxFQUFFO0lBQ3pDLElBQUlzSCxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDdEIsT0FBT3lrQixZQUFZemtCLE9BQU8sSUFBSSxFQUFFakgsU0FBUyxJQUFJLEdBQUcsc0JBQXNCO0lBQzFFLENBQUM7SUFDRCxJQUFJLE9BQU9pSCxVQUFVLFlBQVlBLE9BQU87UUFDcEMsT0FBT3lrQixZQUFZO1lBQUN6a0I7U0FBTSxFQUFFLElBQUksRUFBRWpILFNBQVMsSUFBSSxHQUFHLHNCQUFzQjtJQUM1RSxDQUFDO0lBQ0QsSUFBSWlILFNBQVMsSUFBSSxFQUFFO1FBQ2YsT0FBT1gsT0FBT1c7SUFDbEIsQ0FBQztJQUNELE9BQU8sSUFBSTtBQUNmO0FBRUEsU0FBU3VtQixnQkFBZ0IvQixHQUFHLEVBQUU7SUFDMUIsSUFBSW5rQixNQUFNQyxPQUFPLENBQUNra0IsTUFBTTtRQUNwQixPQUFPQTtJQUNYLENBQUM7SUFDRCxJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixPQUFPQSxJQUFJcGtCLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBQ0QsT0FBTyxFQUFFO0FBQ2I7QUFFQSx1REFBdUQ7QUFDdkQsb0NBQW9DO0FBQ3BDLDZGQUE2RjtBQUM3RixJQUFJb21CLG9CQUFvQjtJQUNwQi9RLFNBQVNwVztJQUNUOGEsVUFBVS9CO0lBQ1ZxTyxlQUFlck87SUFDZnNPLGtCQUFrQnRPO0lBQ2xCdU8sWUFBWS9PO0lBQ1pnUCxTQUFTaFA7SUFDVGlQLE9BQU9qUDtJQUNQa1AsV0FBV1A7SUFDWHhDLFlBQVl3QztJQUNaUSxPQUFPMW5CO0lBQ1AybkIsaUJBQWlCM25CO0lBQ2pCNG5CLGFBQWE1bkI7SUFDYjZuQixXQUFXN25CO0FBQ2Y7QUFDQSxJQUFJOG5CLGlCQUFpQjtJQUNqQjFSLFNBQVMsSUFBSTtJQUNiZ1IsZUFBZSxJQUFJO0lBQ25CQyxrQkFBa0IsSUFBSTtJQUN0QlUsYUFBYSxFQUFFO0lBQ2ZSLFNBQVMsSUFBSTtJQUNiUyxRQUFRLEVBQUU7SUFDVkwsaUJBQWlCO0lBQ2pCQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWG5ELFlBQVksRUFBRTtBQUNsQjtBQUNBLFNBQVN1RCxjQUFjamQsT0FBTyxFQUFFdFIsT0FBTyxFQUFFO0lBQ3JDLElBQUk0dEIsYUFBYUwsb0JBQW9CamMsUUFBUXNjLFVBQVUsRUFBRTV0QjtJQUN6RCxPQUFPO1FBQ0gwYyxTQUFTcEwsUUFBUW9MLE9BQU8sSUFBSSxJQUFJO1FBQ2hDZ1IsZUFBZXBjLFFBQVFvYyxhQUFhLElBQUksSUFBSSxHQUFHcGMsUUFBUW9jLGFBQWEsR0FBR3BjLFFBQVE4UCxRQUFRO1FBQ3ZGdU0sa0JBQWtCcmMsUUFBUXFjLGdCQUFnQixJQUFJLElBQUksR0FBR3JjLFFBQVFxYyxnQkFBZ0IsR0FBR3JjLFFBQVE4UCxRQUFRO1FBQ2hHaU4sYUFBYVQsY0FBYyxJQUFJLEdBQUc7WUFBQ0E7U0FBVyxHQUFHLEVBQUU7UUFDbkRDLFNBQVN2YyxRQUFRdWMsT0FBTyxJQUFJLElBQUksR0FBR3ZjLFFBQVF1YyxPQUFPLEdBQUcsSUFBSTtRQUN6RFMsUUFBUWhkLFFBQVF3YyxLQUFLLElBQUksSUFBSSxHQUFHO1lBQUN4YyxRQUFRd2MsS0FBSztTQUFDLEdBQUcsRUFBRTtRQUNwREcsaUJBQWlCM2MsUUFBUTJjLGVBQWUsSUFBSTNjLFFBQVEwYyxLQUFLLElBQUk7UUFDN0RFLGFBQWE1YyxRQUFRNGMsV0FBVyxJQUFJNWMsUUFBUTBjLEtBQUssSUFBSTtRQUNyREcsV0FBVzdjLFFBQVE2YyxTQUFTLElBQUk7UUFDaENuRCxZQUFZLENBQUMxWixRQUFReWMsU0FBUyxJQUFJLEVBQUUsRUFBRTNmLE1BQU0sQ0FBQ2tELFFBQVEwWixVQUFVLElBQUksRUFBRTtJQUN6RTtBQUNKO0FBQ0EsK0NBQStDO0FBQy9DLFNBQVN3RCxnQkFBZ0JDLEdBQUcsRUFBRTtJQUMxQixPQUFPQSxJQUFJeGxCLE1BQU0sQ0FBQ3lsQixvQkFBb0JOO0FBQzFDO0FBQ0EsU0FBU00sbUJBQW1CQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUN0QyxPQUFPO1FBQ0hsUyxTQUFTa1MsTUFBTWxTLE9BQU8sSUFBSSxJQUFJLEdBQUdrUyxNQUFNbFMsT0FBTyxHQUFHaVMsTUFBTWpTLE9BQU87UUFDOURnUixlQUFla0IsTUFBTWxCLGFBQWEsSUFBSSxJQUFJLEdBQUdrQixNQUFNbEIsYUFBYSxHQUFHaUIsTUFBTWpCLGFBQWE7UUFDdEZDLGtCQUFrQmlCLE1BQU1qQixnQkFBZ0IsSUFBSSxJQUFJLEdBQUdpQixNQUFNakIsZ0JBQWdCLEdBQUdnQixNQUFNaEIsZ0JBQWdCO1FBQ2xHVSxhQUFhTSxNQUFNTixXQUFXLENBQUNqZ0IsTUFBTSxDQUFDd2dCLE1BQU1QLFdBQVc7UUFDdkRSLFNBQVMsT0FBT2UsTUFBTWYsT0FBTyxLQUFLLFlBQVllLE1BQU1mLE9BQU8sR0FBR2MsTUFBTWQsT0FBTztRQUMzRVMsUUFBUUssTUFBTUwsTUFBTSxDQUFDbGdCLE1BQU0sQ0FBQ3dnQixNQUFNTixNQUFNO1FBQ3hDTCxpQkFBaUJXLE1BQU1YLGVBQWUsSUFBSVUsTUFBTVYsZUFBZTtRQUMvREMsYUFBYVUsTUFBTVYsV0FBVyxJQUFJUyxNQUFNVCxXQUFXO1FBQ25EQyxXQUFXUyxNQUFNVCxTQUFTLElBQUlRLE1BQU1SLFNBQVM7UUFDN0NuRCxZQUFZMkQsTUFBTTNELFVBQVUsQ0FBQzVjLE1BQU0sQ0FBQ3dnQixNQUFNNUQsVUFBVTtJQUN4RDtBQUNKO0FBRUEsSUFBSTZELDBCQUEwQjtJQUMxQkMsSUFBSXhvQjtJQUNKdW1CLFNBQVN2bUI7SUFDVHlvQixPQUFPem9CO0lBQ1ByRixLQUFLcUY7SUFDTDBvQixhQUFhM1A7QUFDakI7QUFDQSxJQUFJNFAsc0JBQXNCO0lBQ3RCamMsT0FBTzZMO0lBQ1A1TCxLQUFLNEw7SUFDTHBSLE1BQU1vUjtJQUNOak4sUUFBUXlOO0FBQ1o7QUFDQSxJQUFJNlAsaUJBQWlCNXZCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHdXZCLDBCQUEwQkksc0JBQXNCO0lBQUVFLGVBQWV0UTtBQUFTO0FBQzlILFNBQVNzTixXQUFXVixHQUFHLEVBQUVHLFdBQVcsRUFBRTVyQixPQUFPLEVBQUU2ckIsY0FBYyxFQUFFTixRQUFRLEVBQUU7SUFDckUsSUFBSUEsYUFBYSxLQUFLLEdBQUc7UUFBRUEsV0FBV1MsbUJBQW1CaHNCO0lBQVUsQ0FBQztJQUNwRSxJQUFJZ0UsS0FBS29yQixlQUFlM0QsS0FBS3pyQixTQUFTdXJCLFdBQVdqYSxVQUFVdE4sR0FBR3NOLE9BQU8sRUFBRWthLFFBQVF4bkIsR0FBR3duQixLQUFLO0lBQ3ZGLElBQUlqYSxnQkFBZ0I4ZCx1QkFBdUJ6RCxhQUFhNXJCO0lBQ3hELElBQUlzdkIsZUFBZWplLGVBQWVDLFNBQVNDLGVBQWV2UixRQUFRd1IsT0FBTyxFQUFFeFIsUUFBUW9TLFdBQVcsQ0FBQ1gsY0FBYztJQUM3RyxJQUFJNmQsY0FBYztRQUNkLElBQUk1YyxNQUFNNmMsY0FBY2plLFNBQVNrYSxPQUFPSSxjQUFjQSxZQUFZdHJCLFFBQVEsR0FBRyxFQUFFLEVBQUVndkIsYUFBYTFkLE1BQU0sRUFBRXlOLFFBQVFpUSxhQUFheGQsUUFBUSxHQUFHOVI7UUFDdEkwUyxJQUFJRCxZQUFZLEdBQUc7WUFDZlQsUUFBUXNkLGFBQWF0ZCxNQUFNO1lBQzNCRCxVQUFVdWQsYUFBYXZkLFFBQVE7WUFDL0JELFVBQVV3ZCxhQUFheGQsUUFBUTtRQUNuQztRQUNBLE9BQU87WUFBRVksS0FBS0E7WUFBS0YsVUFBVSxJQUFJO1FBQUM7SUFDdEMsQ0FBQztJQUNELElBQUlnZCxZQUFZQyxZQUFZbmUsU0FBU0MsZUFBZXZSLFNBQVM2ckI7SUFDN0QsSUFBSTJELFdBQVc7UUFDWCxJQUFJOWMsTUFBTTZjLGNBQWNqZSxTQUFTa2EsT0FBT0ksY0FBY0EsWUFBWXRyQixRQUFRLEdBQUcsRUFBRSxFQUFFa3ZCLFVBQVU1ZCxNQUFNLEVBQUU0ZCxVQUFVRSxNQUFNLEVBQUUxdkI7UUFDckgsSUFBSXdTLFdBQVdoRSxvQkFBb0JrRSxJQUFJakUsS0FBSyxFQUFFK2dCLFVBQVU5Z0IsS0FBSyxFQUFFOGdCLFVBQVU3Z0IsY0FBYyxFQUFFNmdCLFVBQVU1Z0IsWUFBWTtRQUMvRyxPQUFPO1lBQUU4RCxLQUFLQTtZQUFLRixVQUFVQTtRQUFTO0lBQzFDLENBQUM7SUFDRCxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVM0YyxlQUFlM0QsR0FBRyxFQUFFenJCLE9BQU8sRUFBRXVyQixRQUFRLEVBQUU7SUFDNUMsSUFBSUEsYUFBYSxLQUFLLEdBQUc7UUFBRUEsV0FBV1MsbUJBQW1CaHNCO0lBQVUsQ0FBQztJQUNwRSxPQUFPc3JCLFlBQVlHLEtBQUtGO0FBQzVCO0FBQ0EsU0FBU1MsbUJBQW1CaHNCLE9BQU8sRUFBRTtJQUNqQyxPQUFPViwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR211QixvQkFBb0J5QixpQkFBaUJsdkIsUUFBUW9TLFdBQVcsQ0FBQzJaLGFBQWE7QUFDaEg7QUFDQTs7O0FBR0EsR0FDQSxTQUFTd0QsY0FBY2plLE9BQU8sRUFBRWthLEtBQUssRUFBRWxyQixRQUFRLEVBQUVzUixNQUFNLEVBQUU4ZCxNQUFNLEVBQUUxdkIsT0FBTyxFQUFFO0lBQ3RFLElBQUkwUyxNQUFNO1FBQ05xYyxPQUFPemQsUUFBUXlkLEtBQUssSUFBSTtRQUN4QmxDLFNBQVN2YixRQUFRdWIsT0FBTyxJQUFJO1FBQzVCaHNCLFVBQVV5USxRQUFRd2QsRUFBRSxJQUFJO1FBQ3hCN3RCLEtBQUtxUSxRQUFRclEsR0FBRyxJQUFJO1FBQ3BCd1IsY0FBYyxJQUFJO1FBQ2xCaEUsT0FBT3BJO1FBQ1AvRixVQUFVQTtRQUNWc1IsUUFBUUE7UUFDUjhkLFFBQVFBO1FBQ1JWLGFBQWExZCxRQUFRMGQsV0FBVztRQUNoQ1csSUFBSXBCLGNBQWNqZCxTQUFTdFI7UUFDM0JtdkIsZUFBZTd2QiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFJZ1MsUUFBUTZkLGFBQWEsSUFBSSxDQUFDLElBQUszRDtJQUN6RTtJQUNBLElBQUssSUFBSTFiLEtBQUssR0FBRzlMLEtBQUtoRSxRQUFRb1MsV0FBVyxDQUFDd2Qsb0JBQW9CLEVBQUU5ZixLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07UUFDbEYsSUFBSStmLGNBQWM3ckIsRUFBRSxDQUFDOEwsR0FBRztRQUN4QnhRLCtDQUFRQSxDQUFDb1QsS0FBS21kLFlBQVl2ZTtJQUM5QjtJQUNBLGtEQUFrRDtJQUNsRDVRLE9BQU9vdkIsTUFBTSxDQUFDcGQsSUFBSWlkLEVBQUUsQ0FBQzNFLFVBQVU7SUFDL0J0cUIsT0FBT292QixNQUFNLENBQUNwZCxJQUFJeWMsYUFBYTtJQUMvQixPQUFPemM7QUFDWDtBQUNBLFNBQVMrYyxZQUFZbmUsT0FBTyxFQUFFQyxhQUFhLEVBQUV2UixPQUFPLEVBQUU2ckIsY0FBYyxFQUFFO0lBQ2xFLElBQUlqYSxTQUFTTixRQUFRTSxNQUFNO0lBQzNCLElBQUltZTtJQUNKLElBQUlDLGNBQWMsSUFBSTtJQUN0QixJQUFJTixTQUFTLEtBQUs7SUFDbEIsSUFBSU87SUFDSixJQUFJQyxZQUFZLElBQUk7SUFDcEIsSUFBSUMsYUFBYTdlLFFBQVEwQixLQUFLLElBQUksSUFBSSxHQUFHMUIsUUFBUTBCLEtBQUssR0FBRzFCLFFBQVE3RCxJQUFJO0lBQ3JFc2lCLFlBQVkvdkIsUUFBUXdSLE9BQU8sQ0FBQzRlLGdCQUFnQixDQUFDRDtJQUM3QyxJQUFJSixXQUFXO1FBQ1hDLGNBQWNELFVBQVV2akIsTUFBTTtJQUNsQyxPQUNLLElBQUksQ0FBQ3FmLGdCQUFnQjtRQUN0QixPQUFPLElBQUk7SUFDZixDQUFDO0lBQ0QsSUFBSXZhLFFBQVEyQixHQUFHLElBQUksSUFBSSxFQUFFO1FBQ3JCZ2QsVUFBVWp3QixRQUFRd1IsT0FBTyxDQUFDNGUsZ0JBQWdCLENBQUM5ZSxRQUFRMkIsR0FBRztJQUMxRCxDQUFDO0lBQ0QsSUFBSXJCLFVBQVUsSUFBSSxFQUFFO1FBQ2hCLElBQUlMLGlCQUFpQixJQUFJLEVBQUU7WUFDdkJLLFNBQVNMO1FBQ2IsT0FDSztZQUNELG1DQUFtQztZQUNuQ0ssU0FBUyxDQUFDLENBQUNtZSxhQUFhQSxVQUFVTSxpQkFBaUIsS0FDOUMsRUFBQ0osV0FBV0EsUUFBUUksaUJBQWlCO1FBQzlDLENBQUM7SUFDTCxDQUFDO0lBQ0QsSUFBSXplLFVBQVVvZSxhQUFhO1FBQ3ZCQSxjQUFjOWtCLFdBQVc4a0I7SUFDN0IsQ0FBQztJQUNELElBQUlDLFNBQVM7UUFDVEMsWUFBWUQsUUFBUXpqQixNQUFNO1FBQzFCLElBQUlvRixRQUFRO1lBQ1JzZSxZQUFZaGxCLFdBQVdnbEI7UUFDM0IsQ0FBQztRQUNELElBQUlGLGVBQWVFLGFBQWFGLGFBQWE7WUFDekNFLFlBQVksSUFBSTtRQUNwQixDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlBLFdBQVc7UUFDWFIsU0FBUyxJQUFJO0lBQ2pCLE9BQ0ssSUFBSSxDQUFDN0QsZ0JBQWdCO1FBQ3RCNkQsU0FBUzF2QixRQUFRcVMsT0FBTyxDQUFDME4sa0JBQWtCLElBQUksS0FBSztRQUNwRG1RLFlBQVlsd0IsUUFBUXdSLE9BQU8sQ0FBQzlLLEdBQUcsQ0FBQ3NwQixhQUFhcGUsU0FDekM1UixRQUFRcVMsT0FBTyxDQUFDTSwwQkFBMEIsR0FDMUMzUyxRQUFRcVMsT0FBTyxDQUFDTyx5QkFBeUI7SUFDakQsQ0FBQztJQUNELE9BQU87UUFDSGhCLFFBQVFBO1FBQ1I4ZCxRQUFRQTtRQUNSaGhCLE9BQU87WUFBRXNFLE9BQU9nZDtZQUFhL2MsS0FBS2lkO1FBQVU7UUFDNUN2aEIsZ0JBQWdCb2hCLFlBQVlBLFVBQVVPLFNBQVMsR0FBRyxJQUFJO1FBQ3REMWhCLGNBQWNxaEIsVUFBVUEsUUFBUUssU0FBUyxHQUFHLElBQUk7SUFDcEQ7QUFDSjtBQUNBLFNBQVNqQix1QkFBdUJ6RCxXQUFXLEVBQUU1ckIsT0FBTyxFQUFFO0lBQ2xELElBQUlvUixNQUFNLElBQUk7SUFDZCxJQUFJd2EsYUFBYTtRQUNieGEsTUFBTXdhLFlBQVlyYSxhQUFhO0lBQ25DLENBQUM7SUFDRCxJQUFJSCxPQUFPLElBQUksRUFBRTtRQUNiQSxNQUFNcFIsUUFBUXFTLE9BQU8sQ0FBQ2QsYUFBYTtJQUN2QyxDQUFDO0lBQ0QsT0FBT0g7QUFDWDtBQUVBO3NIQUNzSCxHQUN0SCxtRkFBbUY7QUFDbkYsNkRBQTZEO0FBQzdELFNBQVNtZix1QkFBdUJDLFVBQVUsRUFBRTtJQUN4QyxJQUFJQyxTQUFTbGxCLEtBQUs2QixLQUFLLENBQUN6QyxTQUFTNmxCLFdBQVd4ZCxLQUFLLEVBQUV3ZCxXQUFXdmQsR0FBRyxNQUFNO0lBQ3ZFLElBQUlELFFBQVE5SCxXQUFXc2xCLFdBQVd4ZCxLQUFLO0lBQ3ZDLElBQUlDLE1BQU0zSSxRQUFRMEksT0FBT3lkO0lBQ3pCLE9BQU87UUFBRXpkLE9BQU9BO1FBQU9DLEtBQUtBO0lBQUk7QUFDcEM7QUFDQSx3R0FBd0c7QUFDeEcsNENBQTRDO0FBQzVDLFNBQVN5ZCx1QkFBdUJGLFVBQVUsRUFBRXRSLGdCQUFnQixFQUFFO0lBQzFELElBQUlBLHFCQUFxQixLQUFLLEdBQUc7UUFBRUEsbUJBQW1CeEwsZUFBZTtJQUFJLENBQUM7SUFDMUUsSUFBSWlkLFdBQVcsSUFBSTtJQUNuQixJQUFJQyxTQUFTLElBQUk7SUFDakIsSUFBSUosV0FBV3ZkLEdBQUcsRUFBRTtRQUNoQjJkLFNBQVMxbEIsV0FBV3NsQixXQUFXdmQsR0FBRztRQUNsQyxJQUFJNGQsWUFBWUwsV0FBV3ZkLEdBQUcsQ0FBQ3JJLE9BQU8sS0FBS2dtQixPQUFPaG1CLE9BQU8sSUFBSSxrQ0FBa0M7UUFDL0Ysa0ZBQWtGO1FBQ2xGLHFGQUFxRjtRQUNyRix3RUFBd0U7UUFDeEUsSUFBSWltQixhQUFhQSxhQUFhcGIsVUFBVXlKLG1CQUFtQjtZQUN2RDBSLFNBQVN0bUIsUUFBUXNtQixRQUFRO1FBQzdCLENBQUM7SUFDTCxDQUFDO0lBQ0QsSUFBSUosV0FBV3hkLEtBQUssRUFBRTtRQUNsQjJkLFdBQVd6bEIsV0FBV3NsQixXQUFXeGQsS0FBSyxHQUFHLDRDQUE0QztRQUNyRixxR0FBcUc7UUFDckcsSUFBSTRkLFVBQVVBLFVBQVVELFVBQVU7WUFDOUJDLFNBQVN0bUIsUUFBUXFtQixVQUFVO1FBQy9CLENBQUM7SUFDTCxDQUFDO0lBQ0QsT0FBTztRQUFFM2QsT0FBTzJkO1FBQVUxZCxLQUFLMmQ7SUFBTztBQUMxQztBQUNBLG1DQUFtQztBQUNuQyxTQUFTRSxnQkFBZ0JwaUIsS0FBSyxFQUFFO0lBQzVCLElBQUlvWixlQUFlNEksdUJBQXVCaGlCO0lBQzFDLE9BQU8vRCxTQUFTbWQsYUFBYTlVLEtBQUssRUFBRThVLGFBQWE3VSxHQUFHLElBQUk7QUFDNUQ7QUFDQSxTQUFTOGQsVUFBVUMsS0FBSyxFQUFFQyxLQUFLLEVBQUV6ZixPQUFPLEVBQUUwZixTQUFTLEVBQUU7SUFDakQsSUFBSUEsY0FBYyxRQUFRO1FBQ3RCLE9BQU94ZCxlQUFlbEMsUUFBUTJmLGNBQWMsQ0FBQ0gsT0FBT0MsUUFBUTtJQUNoRSxDQUFDO0lBQ0QsSUFBSUMsY0FBYyxTQUFTO1FBQ3ZCLE9BQU94ZCxlQUFlbEMsUUFBUTRmLGVBQWUsQ0FBQ0osT0FBT0MsUUFBUTtJQUNqRSxDQUFDO0lBQ0QsT0FBT2ptQixlQUFlZ21CLE9BQU9DLFFBQVEscUJBQXFCO0FBQzlEO0FBRUEsU0FBU0ksV0FBV3BxQixLQUFLLEVBQUV1SyxPQUFPLEVBQUU7SUFDaEMsSUFBSXdCLFFBQVEsSUFBSTtJQUNoQixJQUFJQyxNQUFNLElBQUk7SUFDZCxJQUFJaE0sTUFBTStMLEtBQUssRUFBRTtRQUNiQSxRQUFReEIsUUFBUThmLFlBQVksQ0FBQ3JxQixNQUFNK0wsS0FBSztJQUM1QyxDQUFDO0lBQ0QsSUFBSS9MLE1BQU1nTSxHQUFHLEVBQUU7UUFDWEEsTUFBTXpCLFFBQVE4ZixZQUFZLENBQUNycUIsTUFBTWdNLEdBQUc7SUFDeEMsQ0FBQztJQUNELElBQUksQ0FBQ0QsU0FBUyxDQUFDQyxLQUFLO1FBQ2hCLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxJQUFJRCxTQUFTQyxPQUFPQSxNQUFNRCxPQUFPO1FBQzdCLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxPQUFPO1FBQUVBLE9BQU9BO1FBQU9DLEtBQUtBO0lBQUk7QUFDcEM7QUFDQSxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLFNBQVNzZSxhQUFhQyxNQUFNLEVBQUVDLGVBQWUsRUFBRTtJQUMzQyxJQUFJQyxpQkFBaUIsRUFBRTtJQUN2QixJQUFJMWUsUUFBUXllLGdCQUFnQnplLEtBQUssRUFBRSw0REFBNEQ7SUFDL0YsSUFBSXRRO0lBQ0osSUFBSWl2QjtJQUNKLHNFQUFzRTtJQUN0RUgsT0FBT0ksSUFBSSxDQUFDQztJQUNaLElBQUtudkIsSUFBSSxHQUFHQSxJQUFJOHVCLE9BQU83dUIsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDbkNpdkIsWUFBWUgsTUFBTSxDQUFDOXVCLEVBQUU7UUFDckIsMERBQTBEO1FBQzFELElBQUlpdkIsVUFBVTNlLEtBQUssR0FBR0EsT0FBTztZQUN6QjBlLGVBQWU1dUIsSUFBSSxDQUFDO2dCQUFFa1EsT0FBT0E7Z0JBQU9DLEtBQUswZSxVQUFVM2UsS0FBSztZQUFDO1FBQzdELENBQUM7UUFDRCxJQUFJMmUsVUFBVTFlLEdBQUcsR0FBR0QsT0FBTztZQUN2QkEsUUFBUTJlLFVBQVUxZSxHQUFHO1FBQ3pCLENBQUM7SUFDTDtJQUNBLDhEQUE4RDtJQUM5RCxJQUFJRCxRQUFReWUsZ0JBQWdCeGUsR0FBRyxFQUFFO1FBQzdCeWUsZUFBZTV1QixJQUFJLENBQUM7WUFBRWtRLE9BQU9BO1lBQU9DLEtBQUt3ZSxnQkFBZ0J4ZSxHQUFHO1FBQUM7SUFDakUsQ0FBQztJQUNELE9BQU95ZTtBQUNYO0FBQ0EsU0FBU0csY0FBY0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7SUFDbkMsT0FBT0QsT0FBTzllLEtBQUssQ0FBQ3BJLE9BQU8sS0FBS21uQixPQUFPL2UsS0FBSyxDQUFDcEksT0FBTyxJQUFJLDBCQUEwQjtBQUN0RjtBQUNBLFNBQVNvbkIsZ0JBQWdCRixNQUFNLEVBQUVDLE1BQU0sRUFBRTtJQUNyQyxJQUFJL2UsUUFBUThlLE9BQU85ZSxLQUFLLEVBQUVDLE1BQU02ZSxPQUFPN2UsR0FBRztJQUMxQyxJQUFJZ2YsV0FBVyxJQUFJO0lBQ25CLElBQUlGLE9BQU8vZSxLQUFLLEtBQUssSUFBSSxFQUFFO1FBQ3ZCLElBQUlBLFVBQVUsSUFBSSxFQUFFO1lBQ2hCQSxRQUFRK2UsT0FBTy9lLEtBQUs7UUFDeEIsT0FDSztZQUNEQSxRQUFRLElBQUk5RSxLQUFLM0MsS0FBS3dPLEdBQUcsQ0FBQy9HLE1BQU1wSSxPQUFPLElBQUltbkIsT0FBTy9lLEtBQUssQ0FBQ3BJLE9BQU87UUFDbkUsQ0FBQztJQUNMLENBQUM7SUFDRCxJQUFJbW5CLE9BQU85ZSxHQUFHLElBQUksSUFBSSxFQUFFO1FBQ3BCLElBQUlBLFFBQVEsSUFBSSxFQUFFO1lBQ2RBLE1BQU04ZSxPQUFPOWUsR0FBRztRQUNwQixPQUNLO1lBQ0RBLE1BQU0sSUFBSS9FLEtBQUszQyxLQUFLd0IsR0FBRyxDQUFDa0csSUFBSXJJLE9BQU8sSUFBSW1uQixPQUFPOWUsR0FBRyxDQUFDckksT0FBTztRQUM3RCxDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlvSSxVQUFVLElBQUksSUFBSUMsUUFBUSxJQUFJLElBQUlELFFBQVFDLEtBQUs7UUFDL0NnZixXQUFXO1lBQUVqZixPQUFPQTtZQUFPQyxLQUFLQTtRQUFJO0lBQ3hDLENBQUM7SUFDRCxPQUFPZ2Y7QUFDWDtBQUNBLFNBQVNDLFlBQVlKLE1BQU0sRUFBRUMsTUFBTSxFQUFFO0lBQ2pDLE9BQU8sQ0FBQ0QsT0FBTzllLEtBQUssS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHOGUsT0FBTzllLEtBQUssQ0FBQ3BJLE9BQU8sRUFBRSxNQUFPbW5CLENBQUFBLE9BQU8vZSxLQUFLLEtBQUssSUFBSSxHQUFHLElBQUksR0FBRytlLE9BQU8vZSxLQUFLLENBQUNwSSxPQUFPLEVBQUUsS0FDckgsQ0FBQ2tuQixPQUFPN2UsR0FBRyxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUc2ZSxPQUFPN2UsR0FBRyxDQUFDckksT0FBTyxFQUFFLE1BQU9tbkIsQ0FBQUEsT0FBTzllLEdBQUcsS0FBSyxJQUFJLEdBQUcsSUFBSSxHQUFHOGUsT0FBTzllLEdBQUcsQ0FBQ3JJLE9BQU8sRUFBRTtBQUNsSDtBQUNBLFNBQVN1bkIsZ0JBQWdCTCxNQUFNLEVBQUVDLE1BQU0sRUFBRTtJQUNyQyxPQUFPLENBQUNELE9BQU83ZSxHQUFHLEtBQUssSUFBSSxJQUFJOGUsT0FBTy9lLEtBQUssS0FBSyxJQUFJLElBQUk4ZSxPQUFPN2UsR0FBRyxHQUFHOGUsT0FBTy9lLEtBQUssS0FDNUU4ZSxDQUFBQSxPQUFPOWUsS0FBSyxLQUFLLElBQUksSUFBSStlLE9BQU85ZSxHQUFHLEtBQUssSUFBSSxJQUFJNmUsT0FBTzllLEtBQUssR0FBRytlLE9BQU85ZSxHQUFHO0FBQ2xGO0FBQ0EsU0FBU21mLG1CQUFtQkMsVUFBVSxFQUFFQyxVQUFVLEVBQUU7SUFDaEQsT0FBTyxDQUFDRCxXQUFXcmYsS0FBSyxLQUFLLElBQUksSUFBS3NmLFdBQVd0ZixLQUFLLEtBQUssSUFBSSxJQUFJc2YsV0FBV3RmLEtBQUssSUFBSXFmLFdBQVdyZixLQUFLLEtBQ2xHcWYsQ0FBQUEsV0FBV3BmLEdBQUcsS0FBSyxJQUFJLElBQUtxZixXQUFXcmYsR0FBRyxLQUFLLElBQUksSUFBSXFmLFdBQVdyZixHQUFHLElBQUlvZixXQUFXcGYsR0FBRztBQUNoRztBQUNBLFNBQVNzZixvQkFBb0I3akIsS0FBSyxFQUFFakIsSUFBSSxFQUFFO0lBQ3RDLE9BQU8sQ0FBQ2lCLE1BQU1zRSxLQUFLLEtBQUssSUFBSSxJQUFJdkYsUUFBUWlCLE1BQU1zRSxLQUFLLEtBQzlDdEUsQ0FBQUEsTUFBTXVFLEdBQUcsS0FBSyxJQUFJLElBQUl4RixPQUFPaUIsTUFBTXVFLEdBQUc7QUFDL0M7QUFDQSxtRUFBbUU7QUFDbkUsa0VBQWtFO0FBQ2xFLFNBQVN1Zix1QkFBdUIva0IsSUFBSSxFQUFFaUIsS0FBSyxFQUFFO0lBQ3pDLElBQUlBLE1BQU1zRSxLQUFLLElBQUksSUFBSSxJQUFJdkYsT0FBT2lCLE1BQU1zRSxLQUFLLEVBQUU7UUFDM0MsT0FBT3RFLE1BQU1zRSxLQUFLO0lBQ3RCLENBQUM7SUFDRCxJQUFJdEUsTUFBTXVFLEdBQUcsSUFBSSxJQUFJLElBQUl4RixRQUFRaUIsTUFBTXVFLEdBQUcsRUFBRTtRQUN4QyxPQUFPLElBQUkvRSxLQUFLUSxNQUFNdUUsR0FBRyxDQUFDckksT0FBTyxLQUFLO0lBQzFDLENBQUM7SUFDRCxPQUFPNkM7QUFDWDtBQUVBOztBQUVBLEdBQ0EsU0FBU2dsQixnQkFBZ0J2Z0IsVUFBVSxFQUFFd2dCLFlBQVksRUFBRXZnQixZQUFZLEVBQUUrTSxnQkFBZ0IsRUFBRTtJQUMvRSxJQUFJeVQscUJBQXFCLENBQUM7SUFDMUIsSUFBSUMsbUJBQW1CLENBQUM7SUFDeEIsSUFBSUMsZUFBZSxDQUFDO0lBQ3BCLElBQUlDLFdBQVcsRUFBRTtJQUNqQixJQUFJQyxXQUFXLEVBQUU7SUFDakIsSUFBSUMsV0FBV0MsZ0JBQWdCL2dCLFdBQVdJLElBQUksRUFBRW9nQjtJQUNoRCxJQUFLLElBQUlqa0IsU0FBU3lELFdBQVdJLElBQUksQ0FBRTtRQUMvQixJQUFJSSxNQUFNUixXQUFXSSxJQUFJLENBQUM3RCxNQUFNO1FBQ2hDLElBQUlraEIsS0FBS3FELFFBQVEsQ0FBQ3RnQixJQUFJakUsS0FBSyxDQUFDO1FBQzVCLElBQUlraEIsR0FBR2pULE9BQU8sS0FBSyxzQkFBc0I7WUFDckMsSUFBSWhLLElBQUltYSxPQUFPLEVBQUU7Z0JBQ2I4RixrQkFBa0IsQ0FBQ2pnQixJQUFJbWEsT0FBTyxDQUFDLEdBQUcsRUFBRTtnQkFDcEMsSUFBSSxDQUFDZ0csWUFBWSxDQUFDbmdCLElBQUltYSxPQUFPLENBQUMsRUFBRTtvQkFDNUJnRyxZQUFZLENBQUNuZ0IsSUFBSW1hLE9BQU8sQ0FBQyxHQUFHbmE7Z0JBQ2hDLENBQUM7WUFDTCxPQUNLO2dCQUNEa2dCLGdCQUFnQixDQUFDbmtCLE1BQU0sR0FBRyxFQUFFO1lBQ2hDLENBQUM7UUFDTCxDQUFDO0lBQ0w7SUFDQSxJQUFLLElBQUlJLGNBQWNxRCxXQUFXSyxTQUFTLENBQUU7UUFDekMsSUFBSUMsV0FBV04sV0FBV0ssU0FBUyxDQUFDMUQsV0FBVztRQUMvQyxJQUFJNkQsTUFBTVIsV0FBV0ksSUFBSSxDQUFDRSxTQUFTL0QsS0FBSyxDQUFDO1FBQ3pDLElBQUlraEIsS0FBS3FELFFBQVEsQ0FBQ3RnQixJQUFJakUsS0FBSyxDQUFDO1FBQzVCLElBQUl5a0IsWUFBWTFnQixTQUFTOUQsS0FBSztRQUM5QixJQUFJeWtCLGNBQWMsQ0FBRXpnQixJQUFJZCxNQUFNLElBQUlzTixtQkFDOUJ3Uix1QkFBdUJ3QyxXQUFXaFUsb0JBQ2xDZ1UsU0FBUztRQUNiLElBQUlFLGNBQWNwQixnQkFBZ0JtQixhQUFhaGhCO1FBQy9DLElBQUlpaEIsYUFBYTtZQUNiLElBQUl6RCxHQUFHalQsT0FBTyxLQUFLLHNCQUFzQjtnQkFDckMsSUFBSWhLLElBQUltYSxPQUFPLEVBQUU7b0JBQ2I4RixrQkFBa0IsQ0FBQ2pnQixJQUFJbWEsT0FBTyxDQUFDLENBQUMvcEIsSUFBSSxDQUFDc3dCO2dCQUN6QyxPQUNLO29CQUNEUixnQkFBZ0IsQ0FBQ3BnQixTQUFTL0QsS0FBSyxDQUFDLENBQUMzTCxJQUFJLENBQUNzd0I7Z0JBQzFDLENBQUM7WUFDTCxPQUNLLElBQUl6RCxHQUFHalQsT0FBTyxLQUFLLFFBQVE7Z0JBQzNCaVQsQ0FBQUEsR0FBR2pULE9BQU8sS0FBSyxlQUFlb1csV0FBV0MsUUFBUSxFQUFFandCLElBQUksQ0FBQztvQkFDckQ0UCxLQUFLQTtvQkFDTGlkLElBQUlBO29CQUNKbmQsVUFBVUE7b0JBQ1Y5RCxPQUFPMGtCO29CQUNQQyxTQUFTRixZQUFZbmdCLEtBQUssSUFBSW1nQixZQUFZbmdCLEtBQUssQ0FBQ3BJLE9BQU8sT0FBT3dvQixZQUFZcGdCLEtBQUssQ0FBQ3BJLE9BQU87b0JBQ3ZGMG9CLE9BQU9ILFlBQVlsZ0IsR0FBRyxJQUFJa2dCLFlBQVlsZ0IsR0FBRyxDQUFDckksT0FBTyxPQUFPd29CLFlBQVluZ0IsR0FBRyxDQUFDckksT0FBTztnQkFDbkY7WUFDSixDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsSUFBSyxJQUFJaWlCLFdBQVc4RixtQkFBb0I7UUFDcEMsSUFBSW5CLFNBQVNtQixrQkFBa0IsQ0FBQzlGLFFBQVE7UUFDeEMsSUFBSTZFLGlCQUFpQkgsYUFBYUMsUUFBUXJmO1FBQzFDLElBQUssSUFBSXJDLEtBQUssR0FBR3lqQixtQkFBbUI3QixnQkFBZ0I1aEIsS0FBS3lqQixpQkFBaUI1d0IsTUFBTSxFQUFFbU4sS0FBTTtZQUNwRixJQUFJMGpCLGdCQUFnQkQsZ0JBQWdCLENBQUN6akIsR0FBRztZQUN4QyxJQUFJNEMsTUFBTW1nQixZQUFZLENBQUNoRyxRQUFRO1lBQy9CLElBQUk4QyxLQUFLcUQsUUFBUSxDQUFDdGdCLElBQUlqRSxLQUFLLENBQUM7WUFDNUJxa0IsU0FBU2h3QixJQUFJLENBQUM7Z0JBQ1Y0UCxLQUFLQTtnQkFDTGlkLElBQUlBO2dCQUNKbmQsVUFBVSxJQUFJO2dCQUNkOUQsT0FBTzhrQjtnQkFDUEgsU0FBUyxLQUFLO2dCQUNkQyxPQUFPLEtBQUs7WUFDaEI7UUFDSjtJQUNKO0lBQ0EsSUFBSyxJQUFJN2tCLFNBQVNta0IsaUJBQWtCO1FBQ2hDLElBQUlwQixTQUFTb0IsZ0JBQWdCLENBQUNua0IsTUFBTTtRQUNwQyxJQUFJaWpCLGlCQUFpQkgsYUFBYUMsUUFBUXJmO1FBQzFDLElBQUssSUFBSW5PLEtBQUssR0FBR3l2QixtQkFBbUIvQixnQkFBZ0IxdEIsS0FBS3l2QixpQkFBaUI5d0IsTUFBTSxFQUFFcUIsS0FBTTtZQUNwRixJQUFJd3ZCLGdCQUFnQkMsZ0JBQWdCLENBQUN6dkIsR0FBRztZQUN4Qzh1QixTQUFTaHdCLElBQUksQ0FBQztnQkFDVjRQLEtBQUtSLFdBQVdJLElBQUksQ0FBQzdELE1BQU07Z0JBQzNCa2hCLElBQUlxRCxRQUFRLENBQUN2a0IsTUFBTTtnQkFDbkIrRCxVQUFVLElBQUk7Z0JBQ2Q5RCxPQUFPOGtCO2dCQUNQSCxTQUFTLEtBQUs7Z0JBQ2RDLE9BQU8sS0FBSztZQUNoQjtRQUNKO0lBQ0o7SUFDQSxPQUFPO1FBQUVJLElBQUlaO1FBQVVhLElBQUlaO0lBQVM7QUFDeEM7QUFDQSxTQUFTYSxlQUFlbGhCLEdBQUcsRUFBRTtJQUN6QixPQUFPQSxJQUFJaWQsRUFBRSxDQUFDalQsT0FBTyxLQUFLLGdCQUFnQmhLLElBQUlpZCxFQUFFLENBQUNqVCxPQUFPLEtBQUs7QUFDakU7QUFDQSxTQUFTbVgsU0FBU3p5QixFQUFFLEVBQUUweUIsR0FBRyxFQUFFO0lBQ3ZCMXlCLEdBQUcyeUIsS0FBSyxHQUFHRDtBQUNmO0FBQ0EsU0FBU0UsU0FBUzV5QixFQUFFLEVBQUU7SUFDbEIsT0FBT0EsR0FBRzJ5QixLQUFLLElBQ1gzeUIsR0FBR0MsVUFBVSxDQUFDMHlCLEtBQUssSUFBSSxrQkFBa0I7SUFDekMsSUFBSTtBQUNaO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVNkLGdCQUFnQmdCLFNBQVMsRUFBRXZCLFlBQVksRUFBRTtJQUM5QyxPQUFPL2lCLFFBQVFza0IsV0FBVyxTQUFVL2dCLFFBQVEsRUFBRTtRQUFFLE9BQU9naEIsZUFBZWhoQixVQUFVd2Y7SUFBZTtBQUNuRztBQUNBLFNBQVN3QixlQUFlaGhCLFFBQVEsRUFBRXdmLFlBQVksRUFBRTtJQUM1QyxJQUFJakUsTUFBTSxFQUFFO0lBQ1osSUFBSWlFLFlBQVksQ0FBQyxHQUFHLEVBQUU7UUFDbEJqRSxJQUFJM3JCLElBQUksQ0FBQzR2QixZQUFZLENBQUMsR0FBRztJQUM3QixDQUFDO0lBQ0QsSUFBSUEsWUFBWSxDQUFDeGYsU0FBU3pFLEtBQUssQ0FBQyxFQUFFO1FBQzlCZ2dCLElBQUkzckIsSUFBSSxDQUFDNHZCLFlBQVksQ0FBQ3hmLFNBQVN6RSxLQUFLLENBQUM7SUFDekMsQ0FBQztJQUNEZ2dCLElBQUkzckIsSUFBSSxDQUFDb1EsU0FBU3ljLEVBQUU7SUFDcEIsT0FBT25CLGdCQUFnQkM7QUFDM0I7QUFDQSxTQUFTMEYsY0FBY0MsSUFBSSxFQUFFQyxlQUFlLEVBQUU7SUFDMUMsSUFBSUMsT0FBT0YsS0FBSzdnQixHQUFHLENBQUNnaEI7SUFDcEJELEtBQUsxQyxJQUFJLENBQUMsU0FBVTlwQixJQUFJLEVBQUVDLElBQUksRUFBRTtRQUFFLE9BQU9GLG9CQUFvQkMsTUFBTUMsTUFBTXNzQjtJQUFrQjtJQUMzRixPQUFPQyxLQUFLL2dCLEdBQUcsQ0FBQyxTQUFVaWhCLENBQUMsRUFBRTtRQUFFLE9BQU9BLEVBQUVDLElBQUk7SUFBRTtBQUNsRDtBQUNBLGlFQUFpRTtBQUNqRSxTQUFTRixtQkFBbUJULEdBQUcsRUFBRTtJQUM3QixJQUFJWSxhQUFhWixJQUFJWSxVQUFVO0lBQy9CLElBQUl4aEIsV0FBV3doQixXQUFXaGlCLEdBQUc7SUFDN0IsSUFBSWhFLFFBQVFnbUIsV0FBV2xpQixRQUFRLEdBQUdraUIsV0FBV2xpQixRQUFRLENBQUM5RCxLQUFLLEdBQUdnbUIsV0FBV2htQixLQUFLO0lBQzlFLElBQUlzRSxRQUFRdEUsTUFBTXNFLEtBQUssR0FBR3RFLE1BQU1zRSxLQUFLLENBQUNwSSxPQUFPLEtBQUssQ0FBQyxFQUFFLDZDQUE2QztJQUNsRyxJQUFJcUksTUFBTXZFLE1BQU11RSxHQUFHLEdBQUd2RSxNQUFNdUUsR0FBRyxDQUFDckksT0FBTyxLQUFLLENBQUMsRUFBRSxJQUFJO0lBQ25ELE9BQU90TCwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBRzRULFNBQVNpYyxhQUFhLEdBQUdqYyxXQUFXO1FBQUU0YixJQUFJNWIsU0FBU3JTLFFBQVE7UUFBRW1TLE9BQU9BO1FBQ3RHQyxLQUFLQTtRQUFLbkIsVUFBVW1CLE1BQU1EO1FBQU9wQixRQUFRZ1AsT0FBTzFOLFNBQVN0QixNQUFNO1FBQUc2aUIsTUFBTVg7SUFBSTtBQUNwRjtBQUNBLFNBQVNhLG9CQUFvQmIsR0FBRyxFQUFFOXpCLE9BQU8sRUFBRTtJQUN2QyxJQUFJb1MsY0FBY3BTLFFBQVFvUyxXQUFXO0lBQ3JDLElBQUl3aUIsZUFBZXhpQixZQUFZeWlCLHVCQUF1QjtJQUN0RCxJQUFJN3dCLEtBQUs4dkIsSUFBSVksVUFBVSxFQUFFaGlCLE1BQU0xTyxHQUFHME8sR0FBRyxFQUFFaWQsS0FBSzNyQixHQUFHMnJCLEVBQUU7SUFDakQsSUFBSWhzQixNQUFNZ3NCLEdBQUdqQyxhQUFhO0lBQzFCLElBQUssSUFBSTVkLEtBQUssR0FBR2dsQixpQkFBaUJGLGNBQWM5a0IsS0FBS2dsQixlQUFlbnlCLE1BQU0sRUFBRW1OLEtBQU07UUFDOUUsSUFBSWlsQixjQUFjRCxjQUFjLENBQUNobEIsR0FBRztRQUNwQ25NLE1BQU1veEIsWUFBWXB4QixLQUFLK08sS0FBS2lkLElBQUkzdkI7SUFDcEM7SUFDQSxPQUFPMkQ7QUFDWDtBQUNBLFNBQVNxeEIseUJBQXlCbEIsR0FBRyxFQUFFOXpCLE9BQU8sRUFBRTtJQUM1QyxPQUFPOHpCLElBQUlULE9BQU8sSUFBSVMsSUFBSVksVUFBVSxDQUFDL0UsRUFBRSxDQUFDaEMsZ0JBQWdCLElBQUkzdEIsUUFBUXFTLE9BQU8sQ0FBQzhRLHVCQUF1QjtBQUN2RztBQUNBLFNBQVM4Uix1QkFBdUJuQixHQUFHLEVBQUU5ekIsT0FBTyxFQUFFO0lBQzFDLE9BQU84ekIsSUFBSVIsS0FBSyxJQUFJUSxJQUFJWSxVQUFVLENBQUMvRSxFQUFFLENBQUNoQyxnQkFBZ0I7QUFDMUQ7QUFDQSxTQUFTdUgsaUJBQWlCcEIsR0FBRyxFQUFFcUIsVUFBVSxFQUFFbjFCLE9BQU8sRUFBRW8xQix1QkFBdUIsRUFDM0VDLHNCQUFzQixFQUN0QkMsYUFBYSxFQUFFQyxXQUFXLEVBQUU7SUFDeEIsSUFBSS9qQixVQUFVeFIsUUFBUXdSLE9BQU8sRUFBRWEsVUFBVXJTLFFBQVFxUyxPQUFPO0lBQ3hELElBQUkrUSxtQkFBbUIvUSxRQUFRK1EsZ0JBQWdCLEVBQUVDLGtCQUFrQmhSLFFBQVFnUixlQUFlO0lBQzFGLElBQUluUSxXQUFXNGdCLElBQUlZLFVBQVUsQ0FBQ2hpQixHQUFHO0lBQ2pDLElBQUk4aUIsZ0JBQWdCMUIsSUFBSVksVUFBVSxDQUFDbGlCLFFBQVE7SUFDM0MsSUFBSTRRLG9CQUFvQixJQUFJLEVBQUU7UUFDMUJBLG1CQUFtQmdTLDRCQUE0QixLQUFLO0lBQ3hELENBQUM7SUFDRCxJQUFJL1IsbUJBQW1CLElBQUksRUFBRTtRQUN6QkEsa0JBQWtCZ1MsMkJBQTJCLEtBQUs7SUFDdEQsQ0FBQztJQUNELElBQUlJLGtCQUFrQkQsY0FBYzltQixLQUFLLENBQUNzRSxLQUFLO0lBQy9DLElBQUkwaUIsZ0JBQWdCRixjQUFjOW1CLEtBQUssQ0FBQ3VFLEdBQUc7SUFDM0MsSUFBSTBpQixXQUFXTCxpQkFBaUJ4QixJQUFJOWdCLEtBQUssSUFBSThnQixJQUFJWSxVQUFVLENBQUNobUIsS0FBSyxDQUFDc0UsS0FBSztJQUN2RSxJQUFJNGlCLFNBQVNMLGVBQWV6QixJQUFJN2dCLEdBQUcsSUFBSTZnQixJQUFJWSxVQUFVLENBQUNobUIsS0FBSyxDQUFDdUUsR0FBRztJQUMvRCxJQUFJNGlCLGFBQWEzcUIsV0FBV3VxQixpQkFBaUI3cUIsT0FBTyxPQUFPTSxXQUFXeXFCLFVBQVUvcUIsT0FBTztJQUN2RixJQUFJa3JCLFdBQVc1cUIsV0FBV1gsTUFBTW1yQixlQUFlLENBQUMsSUFBSTlxQixPQUFPLE9BQU9NLFdBQVdYLE1BQU1xckIsUUFBUSxDQUFDLElBQUlockIsT0FBTztJQUN2RyxJQUFJd1ksb0JBQW9CLENBQUNsUSxTQUFTdEIsTUFBTSxJQUFLaWtCLENBQUFBLGNBQWNDLFFBQU8sR0FBSTtRQUNsRUgsV0FBV0UsYUFBYUosa0JBQWtCRSxRQUFRO1FBQ2xEQyxTQUFTRSxXQUFXSixnQkFBZ0JFLE1BQU07UUFDMUMsSUFBSXZTLG1CQUFtQm5RLFNBQVN3YyxNQUFNLEVBQUU7WUFDcEMsT0FBT2xlLFFBQVF5SSxXQUFXLENBQUMwYixVQUFVQyxRQUFRVCxZQUFZO2dCQUNyRHhtQixnQkFBZ0IybUIsZ0JBQWdCLElBQUksR0FBR0UsY0FBYzdtQixjQUFjO2dCQUNuRUMsY0FBYzJtQixjQUFjLElBQUksR0FBR0MsY0FBYzVtQixZQUFZO1lBQ2pFO1FBQ0osQ0FBQztRQUNELE9BQU80QyxRQUFRdFEsTUFBTSxDQUFDeTBCLFVBQVVSLFlBQVk7WUFDeEM3RSxXQUFXZ0YsZ0JBQWdCLElBQUksR0FBR0UsY0FBYzdtQixjQUFjO1FBQ2xFO0lBQ0osQ0FBQztJQUNELE9BQU87QUFDWDtBQUNBLFNBQVNvbkIsV0FBV2pDLEdBQUcsRUFBRWtDLFVBQVUsRUFBRUMsT0FBTyxFQUFFO0lBQzFDLElBQUlDLFdBQVdwQyxJQUFJWSxVQUFVLENBQUNobUIsS0FBSztJQUNuQyxPQUFPO1FBQ0h5bkIsUUFBUUQsU0FBU2pqQixHQUFHLEdBQUlnakIsQ0FBQUEsV0FBV0QsV0FBV2hqQixLQUFLO1FBQ25Eb2pCLFVBQVVGLFNBQVNsakIsS0FBSyxJQUFLaWpCLENBQUFBLFdBQVdELFdBQVcvaUIsR0FBRztRQUN0RG9qQixTQUFTTCxjQUFjekQsb0JBQW9CeUQsWUFBWUUsU0FBU2xqQixLQUFLO0lBQ3pFO0FBQ0o7QUFDQSxTQUFTc2pCLG1CQUFtQi95QixLQUFLLEVBQUU7SUFDL0IsSUFBSXluQixhQUFhO1FBQUM7S0FBVztJQUM3QixJQUFJem5CLE1BQU1nekIsUUFBUSxFQUFFO1FBQ2hCdkwsV0FBV2xvQixJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUNELElBQUlTLE1BQU1pekIsV0FBVyxFQUFFO1FBQ25CeEwsV0FBV2xvQixJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUNELElBQUlTLE1BQU1rekIsZ0JBQWdCLElBQUlsekIsTUFBTW16QixjQUFjLEVBQUU7UUFDaEQxTCxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSVMsTUFBTW96QixVQUFVLEVBQUU7UUFDbEIzTCxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSVMsTUFBTXF6QixVQUFVLEVBQUU7UUFDbEI1TCxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSVMsTUFBTXN6QixVQUFVLEVBQUU7UUFDbEI3TCxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSVMsTUFBTTh2QixPQUFPLEVBQUU7UUFDZnJJLFdBQVdsb0IsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFDRCxJQUFJUyxNQUFNK3ZCLEtBQUssRUFBRTtRQUNidEksV0FBV2xvQixJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUNELElBQUlTLE1BQU00eUIsTUFBTSxFQUFFO1FBQ2RuTCxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSVMsTUFBTTh5QixPQUFPLEVBQUU7UUFDZnJMLFdBQVdsb0IsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFDRCxJQUFJUyxNQUFNNnlCLFFBQVEsRUFBRTtRQUNoQnBMLFdBQVdsb0IsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFDRCxPQUFPa29CO0FBQ1g7QUFDQSxTQUFTOEwsbUJBQW1CcEMsVUFBVSxFQUFFO0lBQ3BDLE9BQU9BLFdBQVdsaUIsUUFBUSxHQUNwQmtpQixXQUFXbGlCLFFBQVEsQ0FBQzNELFVBQVUsR0FDOUI2bEIsV0FBV2hpQixHQUFHLENBQUNqRSxLQUFLLEdBQUcsTUFBTWltQixXQUFXaG1CLEtBQUssQ0FBQ3NFLEtBQUssQ0FBQ3FELFdBQVcsRUFBRTtBQUN2RSxpRkFBaUY7QUFDckY7QUFDQSxTQUFTMGdCLGtCQUFrQmpELEdBQUcsRUFBRTl6QixPQUFPLEVBQUU7SUFDckMsSUFBSWdFLEtBQUs4dkIsSUFBSVksVUFBVSxFQUFFaGlCLE1BQU0xTyxHQUFHME8sR0FBRyxFQUFFRixXQUFXeE8sR0FBR3dPLFFBQVE7SUFDN0QsSUFBSXZSLE1BQU15UixJQUFJelIsR0FBRztJQUNqQixJQUFJQSxLQUFLO1FBQ0wsT0FBTztZQUFFKzFCLE1BQU0vMUI7UUFBSTtJQUN2QixDQUFDO0lBQ0QsSUFBSWcyQixVQUFVajNCLFFBQVFpM0IsT0FBTyxFQUFFNWtCLFVBQVVyUyxRQUFRcVMsT0FBTztJQUN4RCxJQUFJMlYsbUJBQW1CM1YsUUFBUTJWLGdCQUFnQjtJQUMvQyxJQUFJQSxvQkFBb0IsSUFBSSxFQUFFO1FBQzFCQSxtQkFBbUJ0VixJQUFJc2MsV0FBVztRQUNsQyxJQUFJaEgsb0JBQW9CLElBQUksRUFBRTtZQUMxQkEsbUJBQW1CM0ksUUFBUTRYLFFBQVFDLFdBQVcsQ0FBQztRQUNuRCxDQUFDO0lBQ0wsQ0FBQztJQUNELHFDQUFxQztJQUNyQyxJQUFJbFAsa0JBQWtCO1FBQ2xCLCtGQUErRjtRQUMvRixPQUFPaGlCLHdCQUF3QixTQUFVakMsRUFBRSxFQUFFO1lBQ3pDa3pCLFFBQVFFLE9BQU8sQ0FBQyxjQUFjO2dCQUMxQi8xQixJQUFJMkMsR0FBR0ksTUFBTTtnQkFDYml6QixPQUFPLElBQUlDLFNBQVNyM0IsU0FBUzBTLEtBQUtGO2dCQUNsQzhrQixTQUFTdnpCO2dCQUNUd3pCLE1BQU12M0IsUUFBUXczQixPQUFPO1lBQ3pCO1FBQ0o7SUFDSixDQUFDO0lBQ0QsT0FBTyxDQUFDO0FBQ1o7QUFFQSxJQUFJQyxpQkFBaUI7SUFDakJ6a0IsT0FBTzZMO0lBQ1A1TCxLQUFLNEw7SUFDTGpOLFFBQVF5TjtBQUNaO0FBQ0EsU0FBU3FZLGNBQWNqTSxHQUFHLEVBQUVqYSxPQUFPLEVBQUVtbUIsZUFBZSxFQUFFO0lBQ2xELElBQUlDLE9BQU9DLGtCQUFrQnBNLEtBQUtqYTtJQUNsQyxJQUFJOUMsUUFBUWtwQixLQUFLbHBCLEtBQUs7SUFDdEIsSUFBSSxDQUFDQSxNQUFNc0UsS0FBSyxFQUFFO1FBQ2QsT0FBTyxJQUFJO0lBQ2YsQ0FBQztJQUNELElBQUksQ0FBQ3RFLE1BQU11RSxHQUFHLEVBQUU7UUFDWixJQUFJMGtCLG1CQUFtQixJQUFJLEVBQUU7WUFDekIsT0FBTyxJQUFJO1FBQ2YsQ0FBQztRQUNEanBCLE1BQU11RSxHQUFHLEdBQUd6QixRQUFROUssR0FBRyxDQUFDZ0ksTUFBTXNFLEtBQUssRUFBRTJrQjtJQUN6QyxDQUFDO0lBQ0QsT0FBT0M7QUFDWDtBQUNBOzs7QUFHQSxHQUNBLFNBQVNDLGtCQUFrQnBNLEdBQUcsRUFBRWphLE9BQU8sRUFBRTtJQUNyQyxJQUFJeE4sS0FBS3NuQixZQUFZRyxLQUFLZ00saUJBQWlCSyxnQkFBZ0I5ekIsR0FBR3NOLE9BQU8sRUFBRWthLFFBQVF4bkIsR0FBR3duQixLQUFLO0lBQ3ZGLElBQUl1RSxZQUFZK0gsY0FBYzlrQixLQUFLLEdBQUd4QixRQUFRNGUsZ0JBQWdCLENBQUMwSCxjQUFjOWtCLEtBQUssSUFBSSxJQUFJO0lBQzFGLElBQUlpZCxVQUFVNkgsY0FBYzdrQixHQUFHLEdBQUd6QixRQUFRNGUsZ0JBQWdCLENBQUMwSCxjQUFjN2tCLEdBQUcsSUFBSSxJQUFJO0lBQ3BGLElBQUlyQixTQUFTa21CLGNBQWNsbUIsTUFBTTtJQUNqQyxJQUFJQSxVQUFVLElBQUksRUFBRTtRQUNoQkEsU0FBUyxhQUFjbWUsVUFBVU0saUJBQWlCLElBQzdDLEVBQUNKLFdBQVdBLFFBQVFJLGlCQUFpQjtJQUM5QyxDQUFDO0lBQ0QsT0FBTy93QiwrQ0FBUUEsQ0FBQztRQUFFb1AsT0FBTztZQUNqQnNFLE9BQU8rYyxZQUFZQSxVQUFVdmpCLE1BQU0sR0FBRyxJQUFJO1lBQzFDeUcsS0FBS2dkLFVBQVVBLFFBQVF6akIsTUFBTSxHQUFHLElBQUk7UUFDeEM7UUFBR29GLFFBQVFBO0lBQU8sR0FBRzRaO0FBQzdCO0FBQ0EsU0FBU3VNLGlCQUFpQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7SUFDcEMsT0FBTy9GLFlBQVk4RixNQUFNdHBCLEtBQUssRUFBRXVwQixNQUFNdnBCLEtBQUssS0FDdkNzcEIsTUFBTXBtQixNQUFNLEtBQUtxbUIsTUFBTXJtQixNQUFNLElBQzdCc21CLGlCQUFpQkYsT0FBT0M7QUFDaEM7QUFDQSw2QkFBNkI7QUFDN0IsU0FBU0MsaUJBQWlCRixLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUNwQyxJQUFLLElBQUl6MEIsWUFBWXkwQixNQUFPO1FBQ3hCLElBQUl6MEIsYUFBYSxXQUFXQSxhQUFhLFVBQVU7WUFDL0MsSUFBSXcwQixLQUFLLENBQUN4MEIsU0FBUyxLQUFLeTBCLEtBQUssQ0FBQ3owQixTQUFTLEVBQUU7Z0JBQ3JDLE9BQU8sS0FBSztZQUNoQixDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsOERBQThEO0lBQzlELHNEQUFzRDtJQUN0RCxJQUFLLElBQUlBLFlBQVl3MEIsTUFBTztRQUN4QixJQUFJLENBQUV4MEIsQ0FBQUEsWUFBWXkwQixLQUFJLEdBQUk7WUFDdEIsT0FBTyxLQUFLO1FBQ2hCLENBQUM7SUFDTDtJQUNBLE9BQU8sSUFBSTtBQUNmO0FBQ0EsU0FBU0UsaUJBQWlCUCxJQUFJLEVBQUVwbUIsT0FBTyxFQUFFO0lBQ3JDLE9BQU9sUywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHODRCLGNBQWNSLEtBQUtscEIsS0FBSyxFQUFFOEMsU0FBU29tQixLQUFLaG1CLE1BQU0sSUFBSTtRQUFFQSxRQUFRZ21CLEtBQUtobUIsTUFBTTtJQUFDO0FBQ3pHO0FBQ0EsU0FBU3ltQiwwQkFBMEIzcEIsS0FBSyxFQUFFOEMsT0FBTyxFQUFFOG1CLFFBQVEsRUFBRTtJQUN6RCxPQUFPaDVCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc4NEIsY0FBYzFwQixPQUFPOEMsU0FBUzhtQixZQUFZO1FBQUUxYyxVQUFVcEssUUFBUW9LLFFBQVE7SUFBQztBQUN4RztBQUNBLFNBQVN3YyxjQUFjMXBCLEtBQUssRUFBRThDLE9BQU8sRUFBRThtQixRQUFRLEVBQUU7SUFDN0MsT0FBTztRQUNIdGxCLE9BQU94QixRQUFRK21CLE1BQU0sQ0FBQzdwQixNQUFNc0UsS0FBSztRQUNqQ0MsS0FBS3pCLFFBQVErbUIsTUFBTSxDQUFDN3BCLE1BQU11RSxHQUFHO1FBQzdCdWxCLFVBQVVobkIsUUFBUWluQixTQUFTLENBQUMvcEIsTUFBTXNFLEtBQUssRUFBRTtZQUFFc2xCLFVBQVVBO1FBQVM7UUFDOURJLFFBQVFsbkIsUUFBUWluQixTQUFTLENBQUMvcEIsTUFBTXVFLEdBQUcsRUFBRTtZQUFFcWxCLFVBQVVBO1FBQVM7SUFDOUQ7QUFDSjtBQUNBLFNBQVNLLG9CQUFvQkMsUUFBUSxFQUFFbEcsWUFBWSxFQUFFMXlCLE9BQU8sRUFBRTtJQUMxRCxJQUFJb1IsTUFBTWdlLGVBQWU7UUFBRWhPLFVBQVUsS0FBSztJQUFDLEdBQUdwaEI7SUFDOUMsSUFBSTBTLE1BQU02YyxjQUFjbmUsSUFBSUUsT0FBTyxFQUFFRixJQUFJb2EsS0FBSyxFQUFFLElBQ2hEb04sU0FBU2huQixNQUFNLEVBQUUsSUFBSSxFQUNyQjVSO0lBQ0EsT0FBTztRQUNIMFMsS0FBS0E7UUFDTGlkLElBQUl1RSxlQUFleGhCLEtBQUtnZ0I7UUFDeEJsZ0IsVUFBVWhFLG9CQUFvQmtFLElBQUlqRSxLQUFLLEVBQUVtcUIsU0FBU2xxQixLQUFLO1FBQ3ZEQSxPQUFPa3FCLFNBQVNscUIsS0FBSztRQUNyQjJrQixTQUFTLElBQUk7UUFDYkMsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUVBLFNBQVN1RixrQkFBa0JDLFNBQVMsRUFBRUMsR0FBRyxFQUFFLzRCLE9BQU8sRUFBRTtJQUNoREEsUUFBUWkzQixPQUFPLENBQUNFLE9BQU8sQ0FBQyxVQUFVNzNCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUcwNUIsNEJBQTRCRixXQUFXOTRCLFdBQVc7UUFBRXMzQixTQUFTeUIsTUFBTUEsSUFBSUUsU0FBUyxHQUFHLElBQUk7UUFBRTFCLE1BQU12M0IsUUFBUXczQixPQUFPLElBQUl4M0IsUUFBUWs1QixXQUFXLENBQUMzQixJQUFJO0lBQUM7QUFDdk07QUFDQSxTQUFTNEIsb0JBQW9CSixHQUFHLEVBQUUvNEIsT0FBTyxFQUFFO0lBQ3ZDQSxRQUFRaTNCLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLFlBQVk7UUFDaENHLFNBQVN5QixNQUFNQSxJQUFJRSxTQUFTLEdBQUcsSUFBSTtRQUNuQzFCLE1BQU12M0IsUUFBUXczQixPQUFPLElBQUl4M0IsUUFBUWs1QixXQUFXLENBQUMzQixJQUFJO0lBQ3JEO0FBQ0o7QUFDQSxTQUFTeUIsNEJBQTRCSixRQUFRLEVBQUU1NEIsT0FBTyxFQUFFO0lBQ3BELElBQUl1RCxRQUFRLENBQUM7SUFDYixJQUFLLElBQUl1TSxLQUFLLEdBQUc5TCxLQUFLaEUsUUFBUW9TLFdBQVcsQ0FBQ2duQixrQkFBa0IsRUFBRXRwQixLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07UUFDaEYsSUFBSXVwQixZQUFZcjFCLEVBQUUsQ0FBQzhMLEdBQUc7UUFDdEJ4USwrQ0FBUUEsQ0FBQ2lFLE9BQU84MUIsVUFBVVQsVUFBVTU0QjtJQUN4QztJQUNBViwrQ0FBUUEsQ0FBQ2lFLE9BQU80MEIsaUJBQWlCUyxVQUFVNTRCLFFBQVF3UixPQUFPO0lBQzFELE9BQU9qTztBQUNYO0FBQ0EsOEZBQThGO0FBQzlGLHlDQUF5QztBQUN6QyxTQUFTKzFCLG1CQUFtQjFuQixNQUFNLEVBQUVwRixNQUFNLEVBQUV4TSxPQUFPLEVBQUU7SUFDakQsSUFBSXdSLFVBQVV4UixRQUFRd1IsT0FBTyxFQUFFYSxVQUFVclMsUUFBUXFTLE9BQU87SUFDeEQsSUFBSVksTUFBTXpHO0lBQ1YsSUFBSW9GLFFBQVE7UUFDUnFCLE1BQU0vSCxXQUFXK0g7UUFDakJBLE1BQU16QixRQUFROUssR0FBRyxDQUFDdU0sS0FBS1osUUFBUU0sMEJBQTBCO0lBQzdELE9BQ0s7UUFDRE0sTUFBTXpCLFFBQVE5SyxHQUFHLENBQUN1TSxLQUFLWixRQUFRTyx5QkFBeUI7SUFDNUQsQ0FBQztJQUNELE9BQU9LO0FBQ1g7QUFFQSxvRUFBb0U7QUFDcEUsU0FBU3NtQiwwQkFBMEJybkIsVUFBVSxFQUFFc25CLGVBQWUsRUFBRUMsUUFBUSxFQUFFejVCLE9BQU8sRUFBRTtJQUMvRSxJQUFJMDVCLGVBQWV6RyxnQkFBZ0IvZ0IsV0FBV0ksSUFBSSxFQUFFa25CO0lBQ3BELElBQUl0cUIsT0FBTzRjO0lBQ1gsSUFBSyxJQUFJcmQsU0FBU3lELFdBQVdJLElBQUksQ0FBRTtRQUMvQixJQUFJSSxNQUFNUixXQUFXSSxJQUFJLENBQUM3RCxNQUFNO1FBQ2hDUyxLQUFLb0QsSUFBSSxDQUFDN0QsTUFBTSxHQUFHa3JCLHdCQUF3QmpuQixLQUFLZ25CLFlBQVksQ0FBQ2pyQixNQUFNLEVBQUVnckIsVUFBVXo1QjtJQUNuRjtJQUNBLElBQUssSUFBSTZPLGNBQWNxRCxXQUFXSyxTQUFTLENBQUU7UUFDekMsSUFBSUMsV0FBV04sV0FBV0ssU0FBUyxDQUFDMUQsV0FBVztRQUMvQyxJQUFJNkQsTUFBTXhELEtBQUtvRCxJQUFJLENBQUNFLFNBQVMvRCxLQUFLLENBQUMsRUFBRSwyQ0FBMkM7UUFDaEZTLEtBQUtxRCxTQUFTLENBQUMxRCxXQUFXLEdBQUcrcUIsNkJBQTZCcG5CLFVBQVVFLEtBQUtnbkIsWUFBWSxDQUFDbG5CLFNBQVMvRCxLQUFLLENBQUMsRUFBRWdyQixVQUFVejVCO0lBQ3JIO0lBQ0EsT0FBT2tQO0FBQ1g7QUFDQSxTQUFTeXFCLHdCQUF3QnptQixRQUFRLEVBQUUybUIsV0FBVyxFQUFFSixRQUFRLEVBQUV6NUIsT0FBTyxFQUFFO0lBQ3ZFLElBQUk4M0IsZ0JBQWdCMkIsU0FBUzNCLGFBQWEsSUFBSSxDQUFDO0lBQy9DLHdFQUF3RTtJQUN4RSw2RUFBNkU7SUFDN0UsMkRBQTJEO0lBQzNELElBQUlBLGNBQWNwSSxNQUFNLElBQUksSUFBSSxJQUM1Qm1LLFlBQVlsTSxnQkFBZ0IsSUFDM0I4TCxDQUFBQSxTQUFTSyxVQUFVLElBQUlMLFNBQVNNLFFBQVEsR0FBRztRQUM1Q2pDLGNBQWNwSSxNQUFNLEdBQUcsSUFBSSxFQUFFLCtCQUErQjtJQUNoRSxDQUFDO0lBQ0QsSUFBSXNLLE9BQU8xNkIsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc0VCxXQUFXNGtCLGdCQUFnQjtRQUFFbkksSUFBSXJ3QiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHNFQsU0FBU3ljLEVBQUUsR0FBR21JLGNBQWNuSSxFQUFFO0lBQUU7SUFDakksSUFBSThKLFNBQVN0SyxhQUFhLEVBQUU7UUFDeEI2SyxLQUFLN0ssYUFBYSxHQUFHN3ZCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUcwNkIsS0FBSzdLLGFBQWEsR0FBR3NLLFNBQVN0SyxhQUFhO0lBQzFGLENBQUM7SUFDRCxJQUFLLElBQUlyZixLQUFLLEdBQUc5TCxLQUFLaEUsUUFBUW9TLFdBQVcsQ0FBQzZuQix3QkFBd0IsRUFBRW5xQixLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07UUFDdEYsSUFBSW9xQixVQUFVbDJCLEVBQUUsQ0FBQzhMLEdBQUc7UUFDcEJvcUIsUUFBUUYsTUFBTVAsVUFBVXo1QjtJQUM1QjtJQUNBLElBQUksQ0FBQ2c2QixLQUFLdEssTUFBTSxJQUFJMXZCLFFBQVFxUyxPQUFPLENBQUMwTixrQkFBa0IsRUFBRTtRQUNwRGlhLEtBQUt0SyxNQUFNLEdBQUcsSUFBSTtJQUN0QixDQUFDO0lBQ0QsT0FBT3NLO0FBQ1g7QUFDQSxTQUFTSiw2QkFBNkJwRSxhQUFhLEVBQUV0aUIsUUFBUSxFQUM3RDJtQixXQUFXLEVBQUVKLFFBQVEsRUFBRXo1QixPQUFPLEVBQUU7SUFDNUIsSUFBSXdSLFVBQVV4UixRQUFRd1IsT0FBTztJQUM3QixJQUFJMm9CLGNBQWNWLFNBQVMzQixhQUFhLElBQUkyQixTQUFTM0IsYUFBYSxDQUFDbG1CLE1BQU0sS0FBSyxJQUFJO0lBQ2xGLElBQUl3b0IsV0FBV1gsU0FBUzNCLGFBQWEsSUFBSTJCLFNBQVMzQixhQUFhLENBQUNwSSxNQUFNLEtBQUssS0FBSztJQUNoRixJQUFJc0ssT0FBTzE2QiwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdrMkI7SUFDeEIsSUFBSTJFLGFBQWE7UUFDYkgsS0FBS3RyQixLQUFLLEdBQUc2aEIsdUJBQXVCeUosS0FBS3RyQixLQUFLO0lBQ2xELENBQUM7SUFDRCxJQUFJK3FCLFNBQVNZLFVBQVUsSUFBSVIsWUFBWW5NLGFBQWEsRUFBRTtRQUNsRHNNLEtBQUt0ckIsS0FBSyxHQUFHO1lBQ1RzRSxPQUFPeEIsUUFBUTlLLEdBQUcsQ0FBQ3N6QixLQUFLdHJCLEtBQUssQ0FBQ3NFLEtBQUssRUFBRXltQixTQUFTWSxVQUFVO1lBQ3hEcG5CLEtBQUt6QixRQUFROUssR0FBRyxDQUFDc3pCLEtBQUt0ckIsS0FBSyxDQUFDdUUsR0FBRyxFQUFFd21CLFNBQVNZLFVBQVU7UUFDeEQ7SUFDSixDQUFDO0lBQ0QsSUFBSVosU0FBU0ssVUFBVSxJQUFJRCxZQUFZbE0sZ0JBQWdCLEVBQUU7UUFDckRxTSxLQUFLdHJCLEtBQUssR0FBRztZQUNUc0UsT0FBT3hCLFFBQVE5SyxHQUFHLENBQUNzekIsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLLEVBQUV5bUIsU0FBU0ssVUFBVTtZQUN4RDdtQixLQUFLK21CLEtBQUt0ckIsS0FBSyxDQUFDdUUsR0FBRztRQUN2QjtJQUNKLENBQUM7SUFDRCxJQUFJd21CLFNBQVNNLFFBQVEsSUFBSUYsWUFBWWxNLGdCQUFnQixFQUFFO1FBQ25EcU0sS0FBS3RyQixLQUFLLEdBQUc7WUFDVHNFLE9BQU9nbkIsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLO1lBQ3ZCQyxLQUFLekIsUUFBUTlLLEdBQUcsQ0FBQ3N6QixLQUFLdHJCLEtBQUssQ0FBQ3VFLEdBQUcsRUFBRXdtQixTQUFTTSxRQUFRO1FBQ3REO0lBQ0osQ0FBQztJQUNELElBQUlLLFVBQVU7UUFDVkosS0FBS3RyQixLQUFLLEdBQUc7WUFDVHNFLE9BQU9nbkIsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLO1lBQ3ZCQyxLQUFLcW1CLG1CQUFtQnBtQixTQUFTdEIsTUFBTSxFQUFFb29CLEtBQUt0ckIsS0FBSyxDQUFDc0UsS0FBSyxFQUFFaFQ7UUFDL0Q7SUFDSixDQUFDO0lBQ0QsNkRBQTZEO0lBQzdELHdCQUF3QjtJQUN4QixJQUFJa1QsU0FBU3RCLE1BQU0sRUFBRTtRQUNqQm9vQixLQUFLdHJCLEtBQUssR0FBRztZQUNUc0UsT0FBTzlILFdBQVc4dUIsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLO1lBQ2xDQyxLQUFLL0gsV0FBVzh1QixLQUFLdHJCLEtBQUssQ0FBQ3VFLEdBQUc7UUFDbEM7SUFDSixDQUFDO0lBQ0QsMkJBQTJCO0lBQzNCLElBQUkrbUIsS0FBS3RyQixLQUFLLENBQUN1RSxHQUFHLEdBQUcrbUIsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLLEVBQUU7UUFDbkNnbkIsS0FBS3RyQixLQUFLLENBQUN1RSxHQUFHLEdBQUdxbUIsbUJBQW1CcG1CLFNBQVN0QixNQUFNLEVBQUVvb0IsS0FBS3RyQixLQUFLLENBQUNzRSxLQUFLLEVBQUVoVDtJQUMzRSxDQUFDO0lBQ0QsT0FBT2c2QjtBQUNYO0FBRUEsb0RBQW9EO0FBQ3BELG1DQUFtQztBQUNuQyxJQUFJTSxVQUFVLFdBQVcsR0FBSSxXQUFZO0lBQ3JDLFNBQVNBLFFBQVFqNkIsSUFBSSxFQUFFazZCLGNBQWMsRUFBRS9vQixPQUFPLEVBQUU7UUFDNUMsSUFBSSxDQUFDblIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2s2QixjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQy9vQixPQUFPLEdBQUdBO0lBQ25CO0lBQ0E5USxPQUFPQyxjQUFjLENBQUMyNUIsUUFBUXA2QixTQUFTLEVBQUUsWUFBWTtRQUNqRFUsS0FBSyxXQUFZO1lBQ2IsT0FBTyxJQUFJLENBQUMyNUIsY0FBYyxHQUFHckIsV0FBVztRQUM1QztRQUNBcDRCLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzI1QixRQUFRcDZCLFNBQVMsRUFBRSxTQUFTO1FBQzlDVSxLQUFLLFdBQVk7WUFDYixPQUFPLElBQUksQ0FBQzI1QixjQUFjLEdBQUdDLFNBQVM7UUFDMUM7UUFDQTE1QixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMyNUIsUUFBUXA2QixTQUFTLEVBQUUsZUFBZTtRQUNwRFUsS0FBSyxXQUFZO1lBQ2IsT0FBTyxJQUFJLENBQUM0USxPQUFPLENBQUMrbUIsTUFBTSxDQUFDLElBQUksQ0FBQ2dDLGNBQWMsR0FBR0UsV0FBVyxDQUFDQyxXQUFXLENBQUMxbkIsS0FBSztRQUNsRjtRQUNBbFMsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMjVCLFFBQVFwNkIsU0FBUyxFQUFFLGFBQWE7UUFDbERVLEtBQUssV0FBWTtZQUNiLE9BQU8sSUFBSSxDQUFDNFEsT0FBTyxDQUFDK21CLE1BQU0sQ0FBQyxJQUFJLENBQUNnQyxjQUFjLEdBQUdFLFdBQVcsQ0FBQ0MsV0FBVyxDQUFDem5CLEdBQUc7UUFDaEY7UUFDQW5TLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzI1QixRQUFRcDZCLFNBQVMsRUFBRSxnQkFBZ0I7UUFDckRVLEtBQUssV0FBWTtZQUNiLE9BQU8sSUFBSSxDQUFDNFEsT0FBTyxDQUFDK21CLE1BQU0sQ0FBQyxJQUFJLENBQUNnQyxjQUFjLEdBQUdFLFdBQVcsQ0FBQ0UsWUFBWSxDQUFDM25CLEtBQUs7UUFDbkY7UUFDQWxTLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzI1QixRQUFRcDZCLFNBQVMsRUFBRSxjQUFjO1FBQ25EVSxLQUFLLFdBQVk7WUFDYixPQUFPLElBQUksQ0FBQzRRLE9BQU8sQ0FBQyttQixNQUFNLENBQUMsSUFBSSxDQUFDZ0MsY0FBYyxHQUFHRSxXQUFXLENBQUNFLFlBQVksQ0FBQzFuQixHQUFHO1FBQ2pGO1FBQ0FuUyxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBdTVCLFFBQVFwNkIsU0FBUyxDQUFDMDZCLFNBQVMsR0FBRyxTQUFVbDNCLElBQUksRUFBRTtRQUMxQyxPQUFPLElBQUksQ0FBQzYyQixjQUFjLEdBQUdsb0IsT0FBTyxDQUFDM08sS0FBSyxFQUFFLGdDQUFnQztJQUNoRjtJQUNBLE9BQU80MkI7QUFDWDtBQUVBLElBQUlPLHdCQUF3QjtJQUN4Qi9MLElBQUl4b0I7SUFDSmlMLGVBQWU4TjtJQUNmcGUsS0FBS3FGO0lBQ0xwRixRQUFRb0Y7SUFDUmlrQixRQUFRMUw7SUFDUjZFLG9CQUFvQjdFO0lBQ3BCLGtDQUFrQztJQUNsQ2ljLFNBQVNqYztJQUNUa2MsU0FBU2xjO0FBQ2I7QUFDQSxTQUFTbWMsaUJBQWlCdlAsR0FBRyxFQUFFenJCLE9BQU8sRUFBRXVyQixRQUFRLEVBQUU7SUFDOUMsSUFBSUEsYUFBYSxLQUFLLEdBQUc7UUFBRUEsV0FBVzBQLHlCQUF5Qmo3QjtJQUFVLENBQUM7SUFDMUUsSUFBSWs3QjtJQUNKLElBQUksT0FBT3pQLFFBQVEsVUFBVTtRQUN6QnlQLFNBQVM7WUFBRWo2QixLQUFLd3FCO1FBQUk7SUFDeEIsT0FDSyxJQUFJLE9BQU9BLFFBQVEsY0FBY25rQixNQUFNQyxPQUFPLENBQUNra0IsTUFBTTtRQUN0RHlQLFNBQVM7WUFBRTNRLFFBQVFrQjtRQUFJO0lBQzNCLE9BQ0ssSUFBSSxPQUFPQSxRQUFRLFlBQVlBLEtBQUs7UUFDckN5UCxTQUFTelA7SUFDYixDQUFDO0lBQ0QsSUFBSXlQLFFBQVE7UUFDUixJQUFJbDNCLEtBQUtzbkIsWUFBWTRQLFFBQVEzUCxXQUFXamEsVUFBVXROLEdBQUdzTixPQUFPLEVBQUVrYSxRQUFReG5CLEdBQUd3bkIsS0FBSztRQUM5RSxJQUFJMlAsVUFBVUMscUJBQXFCOXBCLFNBQVN0UjtRQUM1QyxJQUFJbTdCLFNBQVM7WUFDVCxPQUFPO2dCQUNIRSxNQUFNNVA7Z0JBQ042UCxZQUFZLEtBQUs7Z0JBQ2pCQyxlQUFlO2dCQUNmQyxZQUFZLElBQUk7Z0JBQ2hCanFCLGVBQWVELFFBQVFDLGFBQWE7Z0JBQ3BDbVMsb0JBQW9CcFMsUUFBUW9TLGtCQUFrQjtnQkFDOUNvWCxTQUFTeHBCLFFBQVF3cEIsT0FBTztnQkFDeEJDLFNBQVN6cEIsUUFBUXlwQixPQUFPO2dCQUN4Qmw2QixVQUFVeVEsUUFBUXdkLEVBQUUsSUFBSTtnQkFDeEJ4dUIsVUFBVStGO2dCQUNWbzFCLGFBQWFOLFFBQVFNLFdBQVc7Z0JBQ2hDejZCLE1BQU1tNkIsUUFBUW42QixJQUFJO2dCQUNsQjJ1QixJQUFJcEIsY0FBY2pkLFNBQVN0UjtnQkFDM0JtdkIsZUFBZTNEO1lBQ25CO1FBQ0osQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVN5UCx5QkFBeUJqN0IsT0FBTyxFQUFFO0lBQ3ZDLE9BQU9WLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHbXVCLG9CQUFvQm9OLHdCQUF3Qjc2QixRQUFRb1MsV0FBVyxDQUFDc3BCLG1CQUFtQjtBQUM3SDtBQUNBLFNBQVNOLHFCQUFxQjNQLEdBQUcsRUFBRXpyQixPQUFPLEVBQUU7SUFDeEMsSUFBSXNTLE9BQU90UyxRQUFRb1MsV0FBVyxDQUFDdXBCLGVBQWU7SUFDOUMsSUFBSyxJQUFJajVCLElBQUk0UCxLQUFLM1AsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO1FBQzFDLElBQUlnUSxNQUFNSixJQUFJLENBQUM1UCxFQUFFO1FBQ2pCLElBQUkxQixPQUFPMFIsSUFBSWtwQixTQUFTLENBQUNuUTtRQUN6QixJQUFJenFCLE1BQU07WUFDTixPQUFPO2dCQUFFeTZCLGFBQWEvNEI7Z0JBQUcxQixNQUFNQTtZQUFLO1FBQ3hDLENBQUM7SUFDTDtJQUNBLE9BQU8sSUFBSTtBQUNmO0FBRUEsU0FBUzY2QixrQkFBa0JDLFdBQVcsRUFBRUMsTUFBTSxFQUFFO0lBQzVDLE9BQVFBLE9BQU8xN0IsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPMDdCLE9BQU9DLFVBQVU7UUFDNUI7WUFDSSxPQUFPRjtJQUNmO0FBQ0o7QUFDQSxTQUFTRyxlQUFlNXBCLE9BQU8sRUFBRWIsT0FBTyxFQUFFO0lBQ3RDLElBQUkwcUIsbUJBQW1CN3BCLFFBQVFtUixXQUFXO0lBQzFDLDBDQUEwQztJQUMxQyxJQUFJMFksb0JBQW9CLElBQUksRUFBRTtRQUMxQixPQUFPMXFCLFFBQVE4ZixZQUFZLENBQUM0SztJQUNoQyxDQUFDO0lBQ0QsT0FBT0MsT0FBTzlwQixRQUFRb1IsR0FBRyxFQUFFalMsVUFBVSxpQ0FBaUM7QUFDMUU7QUFDQSxTQUFTMnFCLE9BQU9DLFFBQVEsRUFBRTVxQixPQUFPLEVBQUU7SUFDL0IsSUFBSSxPQUFPNHFCLGFBQWEsWUFBWTtRQUNoQ0EsV0FBV0E7SUFDZixDQUFDO0lBQ0QsSUFBSUEsWUFBWSxJQUFJLEVBQUU7UUFDbEIsT0FBTzVxQixRQUFRNnFCLGVBQWU7SUFDbEMsQ0FBQztJQUNELE9BQU83cUIsUUFBUThmLFlBQVksQ0FBQzhLO0FBQ2hDO0FBRUEsSUFBSUUsY0FBYyxXQUFXLEdBQUksV0FBWTtJQUN6QyxTQUFTQSxjQUFjLENBQ3ZCO0lBQ0FBLFlBQVlwOEIsU0FBUyxDQUFDcTZCLGNBQWMsR0FBRyxXQUFZO1FBQy9DLE9BQU8sSUFBSSxDQUFDZ0Msa0JBQWtCLENBQUNoQyxjQUFjO0lBQ2pEO0lBQ0ErQixZQUFZcDhCLFNBQVMsQ0FBQ0UsUUFBUSxHQUFHLFNBQVUyN0IsTUFBTSxFQUFFO1FBQy9DLE9BQU8sSUFBSSxDQUFDUSxrQkFBa0IsQ0FBQ244QixRQUFRLENBQUMyN0I7SUFDNUM7SUFDQXI3QixPQUFPQyxjQUFjLENBQUMyN0IsWUFBWXA4QixTQUFTLEVBQUUsUUFBUTtRQUNqRFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUMyNUIsY0FBYyxHQUFHL0MsT0FBTztRQUFFLEVBQUUsaUJBQWlCOztRQUU1RTEyQixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBdTdCLFlBQVlwOEIsU0FBUyxDQUFDczhCLGNBQWMsR0FBRyxTQUFVOTJCLFFBQVEsRUFBRTtRQUN2REE7SUFDSjtJQUNBNDJCLFlBQVlwOEIsU0FBUyxDQUFDdThCLFVBQVUsR0FBRyxXQUFZO1FBQzNDLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQyxXQUFXLElBQUk7SUFDaEM7SUFDQSxVQUFVO0lBQ1Ysb0hBQW9IO0lBQ3BIbUYsWUFBWXA4QixTQUFTLENBQUN3OEIsU0FBUyxHQUFHLFNBQVVoNUIsSUFBSSxFQUFFQyxHQUFHLEVBQUU7UUFDbkQsSUFBSSxDQUFDdkQsUUFBUSxDQUFDO1lBQ1ZDLE1BQU07WUFDTnM4QixZQUFZajVCO1lBQ1prNUIsZ0JBQWdCajVCO1FBQ3BCO0lBQ0o7SUFDQTI0QixZQUFZcDhCLFNBQVMsQ0FBQzA2QixTQUFTLEdBQUcsU0FBVWwzQixJQUFJLEVBQUU7UUFDOUMsT0FBTyxJQUFJLENBQUM2NEIsa0JBQWtCLENBQUNNLDJCQUEyQixDQUFDbjVCLEtBQUs7SUFDcEU7SUFDQTQ0QixZQUFZcDhCLFNBQVMsQ0FBQzQ4Qix1QkFBdUIsR0FBRyxXQUFZO1FBQ3hELE9BQU9wOEIsT0FBTzZQLElBQUksQ0FBQyxJQUFJLENBQUNncUIsY0FBYyxHQUFHd0MsbUJBQW1CO0lBQ2hFO0lBQ0EsVUFBVTtJQUNWLG9IQUFvSDtJQUNwSFQsWUFBWXA4QixTQUFTLENBQUM4OEIsRUFBRSxHQUFHLFNBQVVDLFdBQVcsRUFBRXY0QixPQUFPLEVBQUU7UUFDdkQsSUFBSTYzQixxQkFBcUIsSUFBSSxDQUFDQSxrQkFBa0I7UUFDaEQsSUFBSUEsbUJBQW1CVyw4QkFBOEIsQ0FBQ0QsWUFBWSxFQUFFO1lBQ2hFVixtQkFBbUJ0RixPQUFPLENBQUMrRixFQUFFLENBQUNDLGFBQWF2NEI7UUFDL0MsT0FDSztZQUNEeTRCLFFBQVFDLElBQUksQ0FBQyw0QkFBNEJILGNBQWM7UUFDM0QsQ0FBQztJQUNMO0lBQ0FYLFlBQVlwOEIsU0FBUyxDQUFDbTlCLEdBQUcsR0FBRyxTQUFVSixXQUFXLEVBQUV2NEIsT0FBTyxFQUFFO1FBQ3hELElBQUksQ0FBQzYzQixrQkFBa0IsQ0FBQ3RGLE9BQU8sQ0FBQ29HLEdBQUcsQ0FBQ0osYUFBYXY0QjtJQUNyRDtJQUNBLDJCQUEyQjtJQUMzQjQzQixZQUFZcDhCLFNBQVMsQ0FBQ2kzQixPQUFPLEdBQUcsU0FBVThGLFdBQVcsRUFBRTtRQUNuRCxJQUFJajVCO1FBQ0osSUFBSThFLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSWdILEtBQUssR0FBR0EsS0FBSzhILFVBQVVqVixNQUFNLEVBQUVtTixLQUFNO1lBQzFDaEgsSUFBSSxDQUFDZ0gsS0FBSyxFQUFFLEdBQUc4SCxTQUFTLENBQUM5SCxHQUFHO1FBQ2hDO1FBQ0M5TCxDQUFBQSxLQUFLLElBQUksQ0FBQ3U0QixrQkFBa0IsQ0FBQ3RGLE9BQU8sRUFBRUUsT0FBTyxDQUFDbnVCLEtBQUssQ0FBQ2hGLElBQUl6RSxvREFBYUEsQ0FBQztZQUFDMDlCO1NBQVksRUFBRW4wQjtJQUMxRjtJQUNBLE9BQU87SUFDUCxvSEFBb0g7SUFDcEh3ekIsWUFBWXA4QixTQUFTLENBQUNvOUIsVUFBVSxHQUFHLFNBQVVDLFFBQVEsRUFBRUMsV0FBVyxFQUFFO1FBQ2hFLElBQUkxbEIsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQzBrQixjQUFjLENBQUMsV0FBWTtZQUM1QjFrQixNQUFNMlIsUUFBUTtZQUNkLElBQUkrVCxhQUFhO2dCQUNiLElBQUlBLFlBQVl4cUIsS0FBSyxJQUFJd3FCLFlBQVl2cUIsR0FBRyxFQUFFO29CQUN0QzZFLE1BQU0xWCxRQUFRLENBQUM7d0JBQ1hDLE1BQU07d0JBQ05rOUIsVUFBVUE7b0JBQ2Q7b0JBQ0F6bEIsTUFBTTFYLFFBQVEsQ0FBQzt3QkFDWEMsTUFBTTt3QkFDTnM4QixZQUFZO3dCQUNaQyxnQkFBZ0JZO29CQUNwQjtnQkFDSixPQUNLO29CQUNELElBQUloc0IsVUFBVXNHLE1BQU15aUIsY0FBYyxHQUFHL29CLE9BQU87b0JBQzVDc0csTUFBTTFYLFFBQVEsQ0FBQzt3QkFDWEMsTUFBTTt3QkFDTms5QixVQUFVQTt3QkFDVnZCLFlBQVl4cUIsUUFBUThmLFlBQVksQ0FBQ2tNO29CQUNyQztnQkFDSixDQUFDO1lBQ0wsT0FDSztnQkFDRDFsQixNQUFNMVgsUUFBUSxDQUFDO29CQUNYQyxNQUFNO29CQUNOazlCLFVBQVVBO2dCQUNkO1lBQ0osQ0FBQztRQUNMO0lBQ0o7SUFDQSxrREFBa0Q7SUFDbEQsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQmpCLFlBQVlwOEIsU0FBUyxDQUFDdTlCLE1BQU0sR0FBRyxTQUFVekIsVUFBVSxFQUFFdUIsUUFBUSxFQUFFO1FBQzNELElBQUlHLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJb0Q7UUFDSkosV0FBV0EsWUFBWSxPQUFPLHNCQUFzQjtRQUNwREksT0FBT0QsTUFBTUUsU0FBUyxDQUFDTCxTQUFTLElBQUksSUFBSSxDQUFDTSxlQUFlLENBQUNOO1FBQ3pELElBQUksQ0FBQzlULFFBQVE7UUFDYixJQUFJa1UsTUFBTTtZQUNOLElBQUksQ0FBQ3Y5QixRQUFRLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ05rOUIsVUFBVUksS0FBS3Q5QixJQUFJO2dCQUNuQjI3QixZQUFZQTtZQUNoQjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUM1N0IsUUFBUSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOMjdCLFlBQVlBO1lBQ2hCO1FBQ0osQ0FBQztJQUNMO0lBQ0Esb0ZBQW9GO0lBQ3BGLGdFQUFnRTtJQUNoRU0sWUFBWXA4QixTQUFTLENBQUMyOUIsZUFBZSxHQUFHLFNBQVVscUIsSUFBSSxFQUFFO1FBQ3BELElBQUkzUCxLQUFLLElBQUksQ0FBQ3UyQixjQUFjLElBQUlxRCxZQUFZNTVCLEdBQUc0NUIsU0FBUyxFQUFFRSxnQkFBZ0I5NUIsR0FBRzg1QixhQUFhO1FBQzFGLElBQUlDLFlBQVksRUFBRSxDQUFDM3ZCLE1BQU0sQ0FBQzB2QixjQUFjRSxNQUFNLEdBQUdGLGNBQWNFLE1BQU0sQ0FBQ0MsZ0JBQWdCLEdBQUcsRUFBRSxFQUFFSCxjQUFjSSxNQUFNLEdBQUdKLGNBQWNJLE1BQU0sQ0FBQ0QsZ0JBQWdCLEdBQUcsRUFBRTtRQUM5SixJQUFJdjdCO1FBQ0osSUFBSWk3QjtRQUNKLElBQUssSUFBSUosWUFBWUssVUFBVztZQUM1QkcsVUFBVWo3QixJQUFJLENBQUN5NkI7UUFDbkI7UUFDQSxJQUFLNzZCLElBQUksR0FBR0EsSUFBSXE3QixVQUFVcDdCLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1lBQ3RDaTdCLE9BQU9DLFNBQVMsQ0FBQ0csU0FBUyxDQUFDcjdCLEVBQUUsQ0FBQztZQUM5QixJQUFJaTdCLE1BQU07Z0JBQ04sSUFBSUEsS0FBS1EsVUFBVSxLQUFLeHFCLE1BQU07b0JBQzFCLE9BQU9ncUI7Z0JBQ1gsQ0FBQztZQUNMLENBQUM7UUFDTDtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0EsZUFBZTtJQUNmLG9IQUFvSDtJQUNwSHJCLFlBQVlwOEIsU0FBUyxDQUFDaytCLElBQUksR0FBRyxXQUFZO1FBQ3JDLElBQUksQ0FBQzNVLFFBQVE7UUFDYixJQUFJLENBQUNycEIsUUFBUSxDQUFDO1lBQUVDLE1BQU07UUFBTztJQUNqQztJQUNBaThCLFlBQVlwOEIsU0FBUyxDQUFDbStCLElBQUksR0FBRyxXQUFZO1FBQ3JDLElBQUksQ0FBQzVVLFFBQVE7UUFDYixJQUFJLENBQUNycEIsUUFBUSxDQUFDO1lBQUVDLE1BQU07UUFBTztJQUNqQztJQUNBaThCLFlBQVlwOEIsU0FBUyxDQUFDbytCLFFBQVEsR0FBRyxXQUFZO1FBQ3pDLElBQUlaLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJLENBQUM5USxRQUFRO1FBQ2IsSUFBSSxDQUFDcnBCLFFBQVEsQ0FBQztZQUNWQyxNQUFNO1lBQ04yN0IsWUFBWTBCLE1BQU1sc0IsT0FBTyxDQUFDK3NCLFFBQVEsQ0FBQ2IsTUFBTTVCLFdBQVcsRUFBRSxDQUFDO1FBQzNEO0lBQ0o7SUFDQVEsWUFBWXA4QixTQUFTLENBQUNzK0IsUUFBUSxHQUFHLFdBQVk7UUFDekMsSUFBSWQsUUFBUSxJQUFJLENBQUNuRCxjQUFjO1FBQy9CLElBQUksQ0FBQzlRLFFBQVE7UUFDYixJQUFJLENBQUNycEIsUUFBUSxDQUFDO1lBQ1ZDLE1BQU07WUFDTjI3QixZQUFZMEIsTUFBTWxzQixPQUFPLENBQUMrc0IsUUFBUSxDQUFDYixNQUFNNUIsV0FBVyxFQUFFO1FBQzFEO0lBQ0o7SUFDQVEsWUFBWXA4QixTQUFTLENBQUN1K0IsS0FBSyxHQUFHLFdBQVk7UUFDdEMsSUFBSWYsUUFBUSxJQUFJLENBQUNuRCxjQUFjO1FBQy9CLElBQUksQ0FBQzlRLFFBQVE7UUFDYixJQUFJLENBQUNycEIsUUFBUSxDQUFDO1lBQ1ZDLE1BQU07WUFDTjI3QixZQUFZRyxPQUFPdUIsTUFBTWdCLGVBQWUsQ0FBQ2piLEdBQUcsRUFBRWlhLE1BQU1sc0IsT0FBTztRQUMvRDtJQUNKO0lBQ0E4cUIsWUFBWXA4QixTQUFTLENBQUN5K0IsUUFBUSxHQUFHLFNBQVVDLGNBQWMsRUFBRTtRQUN2RCxJQUFJbEIsUUFBUSxJQUFJLENBQUNuRCxjQUFjO1FBQy9CLElBQUksQ0FBQzlRLFFBQVE7UUFDYixJQUFJLENBQUNycEIsUUFBUSxDQUFDO1lBQ1ZDLE1BQU07WUFDTjI3QixZQUFZMEIsTUFBTWxzQixPQUFPLENBQUM4ZixZQUFZLENBQUNzTjtRQUMzQztJQUNKO0lBQ0F0QyxZQUFZcDhCLFNBQVMsQ0FBQzIrQixhQUFhLEdBQUcsU0FBVUMsVUFBVSxFQUFFO1FBQ3hELElBQUlwQixRQUFRLElBQUksQ0FBQ25ELGNBQWM7UUFDL0IsSUFBSXdFLFFBQVFyckIsZUFBZW9yQjtRQUMzQixJQUFJQyxPQUFPO1lBQ1AsSUFBSSxDQUFDdFYsUUFBUTtZQUNiLElBQUksQ0FBQ3JwQixRQUFRLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ04yN0IsWUFBWTBCLE1BQU1sc0IsT0FBTyxDQUFDOUssR0FBRyxDQUFDZzNCLE1BQU01QixXQUFXLEVBQUVpRDtZQUNyRDtRQUNKLENBQUM7SUFDTDtJQUNBLG1CQUFtQjtJQUNuQnpDLFlBQVlwOEIsU0FBUyxDQUFDME4sT0FBTyxHQUFHLFdBQVk7UUFDeEMsSUFBSTh2QixRQUFRLElBQUksQ0FBQ25ELGNBQWM7UUFDL0IsT0FBT21ELE1BQU1sc0IsT0FBTyxDQUFDK21CLE1BQU0sQ0FBQ21GLE1BQU01QixXQUFXO0lBQ2pEO0lBQ0Esd0JBQXdCO0lBQ3hCLG9IQUFvSDtJQUNwSFEsWUFBWXA4QixTQUFTLENBQUM4K0IsVUFBVSxHQUFHLFNBQVVyekIsQ0FBQyxFQUFFOUMsU0FBUyxFQUFFO1FBQ3ZELElBQUkySSxVQUFVLElBQUksQ0FBQytvQixjQUFjLEdBQUcvb0IsT0FBTztRQUMzQyxPQUFPQSxRQUFRdFEsTUFBTSxDQUFDc1EsUUFBUThmLFlBQVksQ0FBQzNsQixJQUFJK1MsZ0JBQWdCN1Y7SUFDbkU7SUFDQSxpREFBaUQ7SUFDakR5ekIsWUFBWXA4QixTQUFTLENBQUMrWixXQUFXLEdBQUcsU0FBVWxGLEVBQUUsRUFBRUMsRUFBRSxFQUFFaXFCLFFBQVEsRUFBRTtRQUM1RCxJQUFJenRCLFVBQVUsSUFBSSxDQUFDK29CLGNBQWMsR0FBRy9vQixPQUFPO1FBQzNDLE9BQU9BLFFBQVF5SSxXQUFXLENBQUN6SSxRQUFROGYsWUFBWSxDQUFDdmMsS0FBS3ZELFFBQVE4ZixZQUFZLENBQUN0YyxLQUFLMEosZ0JBQWdCdWdCLFdBQVdBO0lBQzlHO0lBQ0EzQyxZQUFZcDhCLFNBQVMsQ0FBQ3U0QixTQUFTLEdBQUcsU0FBVTlzQixDQUFDLEVBQUUyc0IsUUFBUSxFQUFFO1FBQ3JELElBQUk5bUIsVUFBVSxJQUFJLENBQUMrb0IsY0FBYyxHQUFHL29CLE9BQU87UUFDM0MsT0FBT0EsUUFBUWluQixTQUFTLENBQUNqbkIsUUFBUThmLFlBQVksQ0FBQzNsQixJQUFJO1lBQUUyc0IsVUFBVUE7UUFBUztJQUMzRTtJQUNBLDhDQUE4QztJQUM5QyxvSEFBb0g7SUFDcEgsK0VBQStFO0lBQy9FLGtDQUFrQztJQUNsQ2dFLFlBQVlwOEIsU0FBUyxDQUFDc3BCLE1BQU0sR0FBRyxTQUFVMFYsU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDekQsSUFBSUM7UUFDSixJQUFJRCxXQUFXLElBQUksRUFBRTtZQUNqQixJQUFJRCxVQUFVbHNCLEtBQUssSUFBSSxJQUFJLEVBQUU7Z0JBQ3pCb3NCLGlCQUFpQkY7WUFDckIsT0FDSztnQkFDREUsaUJBQWlCO29CQUNicHNCLE9BQU9rc0I7b0JBQ1Bqc0IsS0FBSyxJQUFJO2dCQUNiO1lBQ0osQ0FBQztRQUNMLE9BQ0s7WUFDRG1zQixpQkFBaUI7Z0JBQ2Jwc0IsT0FBT2tzQjtnQkFDUGpzQixLQUFLa3NCO1lBQ1Q7UUFDSixDQUFDO1FBQ0QsSUFBSXpCLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJekIsWUFBWXBCLGNBQWMwSCxnQkFBZ0IxQixNQUFNbHNCLE9BQU8sRUFBRWtDLGVBQWU7WUFBRXBJLE1BQU07UUFBRTtRQUN0RixJQUFJd3RCLFdBQVc7WUFDWCxJQUFJLENBQUMxNEIsUUFBUSxDQUFDO2dCQUFFQyxNQUFNO2dCQUFnQnk0QixXQUFXQTtZQUFVO1lBQzNERCxrQkFBa0JDLFdBQVcsSUFBSSxFQUFFNEU7UUFDdkMsQ0FBQztJQUNMO0lBQ0EsZ0JBQWdCO0lBQ2hCcEIsWUFBWXA4QixTQUFTLENBQUN1cEIsUUFBUSxHQUFHLFNBQVVzUCxHQUFHLEVBQUU7UUFDNUMsSUFBSTJFLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJbUQsTUFBTTJCLGFBQWEsRUFBRTtZQUNyQixJQUFJLENBQUNqL0IsUUFBUSxDQUFDO2dCQUFFQyxNQUFNO1lBQWlCO1lBQ3ZDODRCLG9CQUFvQkosS0FBSzJFO1FBQzdCLENBQUM7SUFDTDtJQUNBLG9CQUFvQjtJQUNwQixvSEFBb0g7SUFDcEhwQixZQUFZcDhCLFNBQVMsQ0FBQ28vQixRQUFRLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxXQUFXLEVBQUU7UUFDaEUsSUFBSUQsc0JBQXNCbEksVUFBVTtZQUNoQyxJQUFJM2tCLE1BQU02c0IsV0FBV0UsSUFBSTtZQUN6QixJQUFJanRCLFdBQVcrc0IsV0FBV0csU0FBUztZQUNuQyxJQUFJQyxjQUFjLElBQUksQ0FBQ3BGLGNBQWM7WUFDckMseURBQXlEO1lBQ3pELElBQUksQ0FBQ29GLFlBQVl6dEIsVUFBVSxDQUFDSSxJQUFJLENBQUNJLElBQUlqRSxLQUFLLENBQUMsRUFBRTtnQkFDekMsSUFBSSxDQUFDck8sUUFBUSxDQUFDO29CQUNWQyxNQUFNO29CQUNONlIsWUFBWWthLGtCQUFrQjt3QkFBRTFaLEtBQUtBO3dCQUFLRixVQUFVQTtvQkFBUztnQkFDakU7Z0JBQ0EsSUFBSSxDQUFDb3RCLGVBQWUsQ0FBQ0w7WUFDekIsQ0FBQztZQUNELE9BQU9BO1FBQ1gsQ0FBQztRQUNELElBQUk3QixRQUFRLElBQUksQ0FBQ25ELGNBQWM7UUFDL0IsSUFBSTNPO1FBQ0osSUFBSTRULHVCQUF1QnovQixnQkFBZ0I7WUFDdkM2ckIsY0FBYzRULFlBQVl2L0IsbUJBQW1CO1FBQ2pELE9BQ0ssSUFBSSxPQUFPdS9CLGdCQUFnQixXQUFXO1lBQ3ZDLElBQUlBLGFBQWE7Z0JBQ2I1VCxjQUFjemIsa0JBQWtCdXRCLE1BQU1sVCxZQUFZLENBQUMsQ0FBQyxFQUFFO1lBQzFELENBQUM7UUFDTCxPQUNLLElBQUlnVixlQUFlLElBQUksRUFBRTtZQUMxQixJQUFJSyxZQUFZLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNOLGNBQWMsaUNBQWlDO1lBQ3ZGLElBQUksQ0FBQ0ssV0FBVztnQkFDWjFDLFFBQVFDLElBQUksQ0FBQyw2Q0FBOENvQyxjQUFjLE1BQU8sYUFBYTtnQkFDN0YsT0FBTyxJQUFJO1lBQ2YsQ0FBQztZQUNENVQsY0FBY2lVLFVBQVU1L0IsbUJBQW1CO1FBQy9DLENBQUM7UUFDRCxJQUFJaVEsUUFBUWljLFdBQVdvVCxZQUFZM1QsYUFBYThSLE9BQU8sS0FBSztRQUM1RCxJQUFJeHRCLE9BQU87WUFDUCxJQUFJNnZCLGNBQWMsSUFBSTFJLFNBQVNxRyxPQUFPeHRCLE1BQU13QyxHQUFHLEVBQUV4QyxNQUFNd0MsR0FBRyxDQUFDRCxZQUFZLEdBQUcsSUFBSSxHQUFHdkMsTUFBTXNDLFFBQVE7WUFDL0YsSUFBSSxDQUFDcFMsUUFBUSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNONlIsWUFBWWthLGtCQUFrQmxjO1lBQ2xDO1lBQ0EsSUFBSSxDQUFDMHZCLGVBQWUsQ0FBQ0c7WUFDckIsT0FBT0E7UUFDWCxDQUFDO1FBQ0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQXpELFlBQVlwOEIsU0FBUyxDQUFDMC9CLGVBQWUsR0FBRyxTQUFVSSxRQUFRLEVBQUU7UUFDeEQsSUFBSWxvQixRQUFRLElBQUk7UUFDaEIsSUFBSW1mLFVBQVUsSUFBSSxDQUFDc0QsY0FBYyxHQUFHdEQsT0FBTztRQUMzQ0EsUUFBUUUsT0FBTyxDQUFDLFlBQVk7WUFDeEJDLE9BQU80STtZQUNQQyxlQUFlLEVBQUU7WUFDakJDLFFBQVEsV0FBWTtnQkFDaEJwb0IsTUFBTTFYLFFBQVEsQ0FBQztvQkFDWEMsTUFBTTtvQkFDTjZSLFlBQVlpdUIsZ0JBQWdCSDtnQkFDaEM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxpQkFBaUI7SUFDakIxRCxZQUFZcDhCLFNBQVMsQ0FBQ2tnQyxZQUFZLEdBQUcsU0FBVXRSLEVBQUUsRUFBRTtRQUMvQyxJQUFJNE8sUUFBUSxJQUFJLENBQUNuRCxjQUFjO1FBQy9CLElBQUl2MkIsS0FBSzA1QixNQUFNeHJCLFVBQVUsRUFBRUksT0FBT3RPLEdBQUdzTyxJQUFJLEVBQUVDLFlBQVl2TyxHQUFHdU8sU0FBUztRQUNuRXVjLEtBQUt4b0IsT0FBT3dvQjtRQUNaLElBQUssSUFBSXJnQixTQUFTNkQsS0FBTTtZQUNwQixJQUFJSSxNQUFNSixJQUFJLENBQUM3RCxNQUFNO1lBQ3JCLElBQUlpRSxJQUFJN1IsUUFBUSxLQUFLaXVCLElBQUk7Z0JBQ3JCLElBQUlwYyxJQUFJRCxZQUFZLEVBQUU7b0JBQ2xCLE9BQU8sSUFBSTRrQixTQUFTcUcsT0FBT2hyQixLQUFLLElBQUk7Z0JBQ3hDLENBQUM7Z0JBQ0QsSUFBSyxJQUFJN0QsY0FBYzBELFVBQVc7b0JBQzlCLElBQUlDLFdBQVdELFNBQVMsQ0FBQzFELFdBQVc7b0JBQ3BDLElBQUkyRCxTQUFTL0QsS0FBSyxLQUFLaUUsSUFBSWpFLEtBQUssRUFBRTt3QkFDOUIsT0FBTyxJQUFJNG9CLFNBQVNxRyxPQUFPaHJCLEtBQUtGO29CQUNwQyxDQUFDO2dCQUNMO1lBQ0osQ0FBQztRQUNMO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQThwQixZQUFZcDhCLFNBQVMsQ0FBQ21nQyxTQUFTLEdBQUcsV0FBWTtRQUMxQyxJQUFJVixjQUFjLElBQUksQ0FBQ3BGLGNBQWM7UUFDckMsT0FBTytGLGVBQWVYLFlBQVl6dEIsVUFBVSxFQUFFeXRCO0lBQ2xEO0lBQ0FyRCxZQUFZcDhCLFNBQVMsQ0FBQ3FnQyxlQUFlLEdBQUcsV0FBWTtRQUNoRCxJQUFJLENBQUNuZ0MsUUFBUSxDQUFDO1lBQUVDLE1BQU07UUFBb0I7SUFDOUM7SUFDQSwyQkFBMkI7SUFDM0Isb0hBQW9IO0lBQ3BIaThCLFlBQVlwOEIsU0FBUyxDQUFDc2dDLGVBQWUsR0FBRyxXQUFZO1FBQ2hELElBQUk5QyxRQUFRLElBQUksQ0FBQ25ELGNBQWM7UUFDL0IsSUFBSWtHLGFBQWEvQyxNQUFNbFQsWUFBWTtRQUNuQyxJQUFJa1csYUFBYSxFQUFFO1FBQ25CLElBQUssSUFBSUMsY0FBY0YsV0FBWTtZQUMvQkMsV0FBVzU5QixJQUFJLENBQUMsSUFBSS9DLGVBQWUyOUIsT0FBTytDLFVBQVUsQ0FBQ0UsV0FBVztRQUNwRTtRQUNBLE9BQU9EO0lBQ1g7SUFDQXBFLFlBQVlwOEIsU0FBUyxDQUFDNC9CLGtCQUFrQixHQUFHLFNBQVVoUixFQUFFLEVBQUU7UUFDckQsSUFBSTRPLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJa0csYUFBYS9DLE1BQU1sVCxZQUFZO1FBQ25Dc0UsS0FBS3hvQixPQUFPd29CO1FBQ1osSUFBSyxJQUFJeHVCLFlBQVltZ0MsV0FBWTtZQUM3QixJQUFJQSxVQUFVLENBQUNuZ0MsU0FBUyxDQUFDTyxRQUFRLEtBQUtpdUIsSUFBSTtnQkFDdEMsT0FBTyxJQUFJL3VCLGVBQWUyOUIsT0FBTytDLFVBQVUsQ0FBQ25nQyxTQUFTO1lBQ3pELENBQUM7UUFDTDtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0FnOEIsWUFBWXA4QixTQUFTLENBQUMwZ0MsY0FBYyxHQUFHLFNBQVVwQixXQUFXLEVBQUU7UUFDMUQsSUFBSTlCLFFBQVEsSUFBSSxDQUFDbkQsY0FBYztRQUMvQixJQUFJaUYsdUJBQXVCei9CLGdCQUFnQjtZQUN2Qyx5REFBeUQ7WUFDekQsSUFBSSxDQUFDMjlCLE1BQU1sVCxZQUFZLENBQUNnVixZQUFZdi9CLG1CQUFtQixDQUFDSyxRQUFRLENBQUMsRUFBRTtnQkFDL0QsSUFBSSxDQUFDRixRQUFRLENBQUM7b0JBQ1ZDLE1BQU07b0JBQ053Z0MsU0FBUzt3QkFBQ3JCLFlBQVl2L0IsbUJBQW1CO3FCQUFDO2dCQUM5QztZQUNKLENBQUM7WUFDRCxPQUFPdS9CO1FBQ1gsQ0FBQztRQUNELElBQUk1VCxjQUFjb1AsaUJBQWlCd0UsYUFBYTlCO1FBQ2hELElBQUk5UixhQUFhO1lBQ2IsSUFBSSxDQUFDeHJCLFFBQVEsQ0FBQztnQkFBRUMsTUFBTTtnQkFBcUJ3Z0MsU0FBUztvQkFBQ2pWO2lCQUFZO1lBQUM7WUFDbEUsT0FBTyxJQUFJN3JCLGVBQWUyOUIsT0FBTzlSO1FBQ3JDLENBQUM7UUFDRCxPQUFPLElBQUk7SUFDZjtJQUNBMFEsWUFBWXA4QixTQUFTLENBQUM0Z0MscUJBQXFCLEdBQUcsV0FBWTtRQUN0RCxJQUFJLENBQUMxZ0MsUUFBUSxDQUFDO1lBQUVDLE1BQU07UUFBMkI7SUFDckQ7SUFDQWk4QixZQUFZcDhCLFNBQVMsQ0FBQzZnQyxhQUFhLEdBQUcsV0FBWTtRQUM5QyxJQUFJLENBQUMzZ0MsUUFBUSxDQUFDO1lBQUVDLE1BQU07WUFBdUJJLFdBQVcsSUFBSTtRQUFDO0lBQ2pFO0lBQ0EsU0FBUztJQUNULG9IQUFvSDtJQUNwSDY3QixZQUFZcDhCLFNBQVMsQ0FBQzhnQyxZQUFZLEdBQUcsU0FBVUMsU0FBUyxFQUFFO1FBQ3RELElBQUlDLE9BQU94dEIsZUFBZXV0QjtRQUMxQixJQUFJQyxNQUFNO1lBQ04sSUFBSSxDQUFDL0osT0FBTyxDQUFDLGtCQUFrQjtnQkFBRStKLE1BQU1BO1lBQUs7UUFDaEQsQ0FBQztJQUNMO0lBQ0EsT0FBTzVFO0FBQ1g7QUFFQSxJQUFJakYsV0FBVyxXQUFXLEdBQUksV0FBWTtJQUN0Qyx1RkFBdUY7SUFDdkYsaUZBQWlGO0lBQ2pGLFNBQVNBLFNBQVNyM0IsT0FBTyxFQUFFMFMsR0FBRyxFQUFFRixRQUFRLEVBQUU7UUFDdEMsSUFBSSxDQUFDMnVCLFFBQVEsR0FBR25oQztRQUNoQixJQUFJLENBQUN5L0IsSUFBSSxHQUFHL3NCO1FBQ1osSUFBSSxDQUFDZ3RCLFNBQVMsR0FBR2x0QixZQUFZLElBQUk7SUFDckM7SUFDQTs7SUFFQSxHQUNBNmtCLFNBQVNuM0IsU0FBUyxDQUFDa2hDLE9BQU8sR0FBRyxTQUFVMTlCLElBQUksRUFBRUMsR0FBRyxFQUFFO1FBQzlDLElBQUlLLElBQUlDO1FBQ1IsSUFBSVAsUUFBUXVyQixxQkFBcUI7WUFDN0JrTyxRQUFRQyxJQUFJLENBQUM7UUFDYixxQ0FBcUM7UUFDekMsT0FDSyxJQUFJMTVCLFNBQVMsTUFBTTtZQUNwQkMsTUFBTWtyQix1QkFBdUIsQ0FBQ25yQixLQUFLLENBQUNDO1lBQ3BDLElBQUksQ0FBQzA5QixNQUFNLENBQUM7Z0JBQ1J2SixlQUFlO29CQUFFajNCLFVBQVU4QztnQkFBSTtZQUNuQztRQUNKLE9BQ0ssSUFBSUQsUUFBUW1yQix5QkFBeUI7WUFDdENsckIsTUFBTWtyQix1QkFBdUIsQ0FBQ25yQixLQUFLLENBQUNDO1lBQ3BDLElBQUksQ0FBQzA5QixNQUFNLENBQUM7Z0JBQ1J2SixlQUFnQjl6QixDQUFBQSxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDTixLQUFLLEdBQUdDLEtBQUtLLEVBQUU7WUFDL0M7UUFDSixPQUNLLElBQUlOLFFBQVErcEIsbUJBQW1CO1lBQ2hDLElBQUlrQyxLQUFLbEMsaUJBQWlCLENBQUMvcEIsS0FBSyxDQUFDQztZQUNqQyxJQUFJRCxTQUFTLFNBQVM7Z0JBQ2xCaXNCLEtBQUs7b0JBQUUxQixpQkFBaUJ0cUI7b0JBQUt1cUIsYUFBYXZxQjtnQkFBSTtZQUNsRCxPQUNLLElBQUlELFNBQVMsWUFBWTtnQkFDMUJpc0IsS0FBSztvQkFBRWpDLGVBQWUvcEI7b0JBQUtncUIsa0JBQWtCaHFCO2dCQUFJO1lBQ3JELE9BQ0s7Z0JBQ0Rnc0IsS0FBTTFyQixDQUFBQSxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDUCxLQUFLLEdBQUdDLEtBQUtNLEVBQUU7WUFDckMsQ0FBQztZQUNELElBQUksQ0FBQ285QixNQUFNLENBQUM7Z0JBQ1J2SixlQUFlO29CQUFFbkksSUFBSUE7Z0JBQUc7WUFDNUI7UUFDSixPQUNLO1lBQ0R3TixRQUFRQyxJQUFJLENBQUMseUJBQXlCMTVCLE9BQU87UUFDakQsQ0FBQztJQUNMO0lBQ0EyekIsU0FBU24zQixTQUFTLENBQUNvaEMsZUFBZSxHQUFHLFNBQVU1OUIsSUFBSSxFQUFFQyxHQUFHLEVBQUU7UUFDdEQsSUFBSUs7UUFDSixJQUFJLENBQUNxOUIsTUFBTSxDQUFDO1lBQ1JsUyxlQUFnQm5yQixDQUFBQSxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDTixLQUFLLEdBQUdDLEtBQUtLLEVBQUU7UUFDL0M7SUFDSjtJQUNBcXpCLFNBQVNuM0IsU0FBUyxDQUFDcWhDLFFBQVEsR0FBRyxTQUFVcFIsVUFBVSxFQUFFOWQsT0FBTyxFQUFFO1FBQ3pELElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQUVBLFVBQVUsQ0FBQztRQUFHLENBQUM7UUFDekMsSUFBSWIsVUFBVSxJQUFJLENBQUMydkIsUUFBUSxDQUFDM3ZCLE9BQU87UUFDbkMsSUFBSXdCLFFBQVF4QixRQUFROGYsWUFBWSxDQUFDbkI7UUFDakMsSUFBSW5kLFNBQVMsSUFBSSxDQUFDMHNCLFNBQVMsRUFBRTtZQUN6QixJQUFJOEIsZ0JBQWdCLElBQUksQ0FBQzlCLFNBQVMsQ0FBQ2h4QixLQUFLO1lBQ3hDLElBQUlvckIsYUFBYS9JLFVBQVV5USxjQUFjeHVCLEtBQUssRUFBRUEsT0FBT3hCLFNBQVNhLFFBQVFvdkIsV0FBVyxHQUFHLHVCQUF1QjtZQUM3RyxJQUFJcHZCLFFBQVFxdkIsZ0JBQWdCLEVBQUU7Z0JBQzFCLElBQUksQ0FBQ0wsTUFBTSxDQUFDO29CQUFFaEgsWUFBWVA7Z0JBQVc7WUFDekMsT0FDSztnQkFDRCxJQUFJLENBQUN1SCxNQUFNLENBQUM7b0JBQUV2SCxZQUFZQTtnQkFBVztZQUN6QyxDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0F6QyxTQUFTbjNCLFNBQVMsQ0FBQ3loQyxNQUFNLEdBQUcsU0FBVUMsUUFBUSxFQUFFdnZCLE9BQU8sRUFBRTtRQUNyRCxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUFFQSxVQUFVLENBQUM7UUFBRyxDQUFDO1FBQ3pDLElBQUliLFVBQVUsSUFBSSxDQUFDMnZCLFFBQVEsQ0FBQzN2QixPQUFPO1FBQ25DLElBQUl5QjtRQUNKLElBQUkydUIsWUFBWSxJQUFJLEVBQUU7WUFDbEIzdUIsTUFBTXpCLFFBQVE4ZixZQUFZLENBQUNzUTtZQUMzQixJQUFJLENBQUMzdUIsS0FBSztnQkFDTixRQUFRLDhCQUE4QjtZQUMxQyxDQUFDO1FBQ0wsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDeXNCLFNBQVMsRUFBRTtZQUNoQixJQUFJenNCLEtBQUs7Z0JBQ0wsSUFBSThtQixXQUFXaEosVUFBVSxJQUFJLENBQUMyTyxTQUFTLENBQUNoeEIsS0FBSyxDQUFDdUUsR0FBRyxFQUFFQSxLQUFLekIsU0FBU2EsUUFBUW92QixXQUFXO2dCQUNwRixJQUFJLENBQUNKLE1BQU0sQ0FBQztvQkFBRXRILFVBQVVBO2dCQUFTO1lBQ3JDLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDc0gsTUFBTSxDQUFDO29CQUFFdkosZUFBZTt3QkFBRXBJLFFBQVEsS0FBSztvQkFBQztnQkFBRTtZQUNuRCxDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EySCxTQUFTbjNCLFNBQVMsQ0FBQzJoQyxRQUFRLEdBQUcsU0FBVTFSLFVBQVUsRUFBRXlSLFFBQVEsRUFBRXZ2QixPQUFPLEVBQUU7UUFDbkUsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFBRUEsVUFBVSxDQUFDO1FBQUcsQ0FBQztRQUN6QyxJQUFJYixVQUFVLElBQUksQ0FBQzJ2QixRQUFRLENBQUMzdkIsT0FBTztRQUNuQyxJQUFJc21CLGdCQUFnQjtZQUFFbG1CLFFBQVFTLFFBQVFULE1BQU07UUFBQztRQUM3QyxJQUFJb0IsUUFBUXhCLFFBQVE4ZixZQUFZLENBQUNuQjtRQUNqQyxJQUFJbGQ7UUFDSixJQUFJLENBQUNELE9BQU87WUFDUixRQUFRLDhCQUE4QjtRQUMxQyxDQUFDO1FBQ0QsSUFBSTR1QixZQUFZLElBQUksRUFBRTtZQUNsQjN1QixNQUFNekIsUUFBUThmLFlBQVksQ0FBQ3NRO1lBQzNCLElBQUksQ0FBQzN1QixLQUFLO2dCQUNOO1lBQ0osQ0FBQztRQUNMLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQ3lzQixTQUFTLEVBQUU7WUFDaEIsSUFBSThCLGdCQUFnQixJQUFJLENBQUM5QixTQUFTLENBQUNoeEIsS0FBSztZQUN4QyxtRUFBbUU7WUFDbkUsc0VBQXNFO1lBQ3RFLElBQUkyRCxRQUFRVCxNQUFNLEtBQUssSUFBSSxFQUFFO2dCQUN6QjR2QixnQkFBZ0JqUix1QkFBdUJpUjtZQUMzQyxDQUFDO1lBQ0QsSUFBSTFILGFBQWEvSSxVQUFVeVEsY0FBY3h1QixLQUFLLEVBQUVBLE9BQU94QixTQUFTYSxRQUFRb3ZCLFdBQVc7WUFDbkYsSUFBSXh1QixLQUFLO2dCQUNMLElBQUk4bUIsV0FBV2hKLFVBQVV5USxjQUFjdnVCLEdBQUcsRUFBRUEsS0FBS3pCLFNBQVNhLFFBQVFvdkIsV0FBVztnQkFDN0UsSUFBSTNzQixlQUFlZ2xCLFlBQVlDLFdBQVc7b0JBQ3RDLElBQUksQ0FBQ3NILE1BQU0sQ0FBQzt3QkFBRWhILFlBQVlQO3dCQUFZaEMsZUFBZUE7b0JBQWM7Z0JBQ3ZFLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDdUosTUFBTSxDQUFDO3dCQUFFdkgsWUFBWUE7d0JBQVlDLFVBQVVBO3dCQUFVakMsZUFBZUE7b0JBQWM7Z0JBQzNGLENBQUM7WUFDTCxPQUNLO2dCQUNEQSxjQUFjcEksTUFBTSxHQUFHLEtBQUs7Z0JBQzVCLElBQUksQ0FBQzJSLE1BQU0sQ0FBQztvQkFBRWhILFlBQVlQO29CQUFZaEMsZUFBZUE7Z0JBQWM7WUFDdkUsQ0FBQztRQUNMLENBQUM7SUFDTDtJQUNBVCxTQUFTbjNCLFNBQVMsQ0FBQzRoQyxTQUFTLEdBQUcsU0FBVWhELFVBQVUsRUFBRTtRQUNqRCxJQUFJQyxRQUFRcnJCLGVBQWVvckI7UUFDM0IsSUFBSUMsT0FBTztZQUNQLElBQUksQ0FBQ3NDLE1BQU0sQ0FBQztnQkFBRXZILFlBQVlpRjtZQUFNO1FBQ3BDLENBQUM7SUFDTDtJQUNBMUgsU0FBU24zQixTQUFTLENBQUM2aEMsT0FBTyxHQUFHLFNBQVVqRCxVQUFVLEVBQUU7UUFDL0MsSUFBSUMsUUFBUXJyQixlQUFlb3JCO1FBQzNCLElBQUlDLE9BQU87WUFDUCxJQUFJLENBQUNzQyxNQUFNLENBQUM7Z0JBQUV0SCxVQUFVZ0Y7WUFBTTtRQUNsQyxDQUFDO0lBQ0w7SUFDQTFILFNBQVNuM0IsU0FBUyxDQUFDOGhDLFNBQVMsR0FBRyxTQUFVbEQsVUFBVSxFQUFFO1FBQ2pELElBQUlDLFFBQVFyckIsZUFBZW9yQjtRQUMzQixJQUFJQyxPQUFPO1lBQ1AsSUFBSSxDQUFDc0MsTUFBTSxDQUFDO2dCQUFFaEgsWUFBWTBFO1lBQU07UUFDcEMsQ0FBQztJQUNMO0lBQ0ExSCxTQUFTbjNCLFNBQVMsQ0FBQytoQyxTQUFTLEdBQUcsU0FBVXJ3QixNQUFNLEVBQUVTLE9BQU8sRUFBRTtRQUN0RCxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUFFQSxVQUFVLENBQUM7UUFBRyxDQUFDO1FBQ3pDLElBQUl5bEIsZ0JBQWdCO1lBQUVsbUIsUUFBUUE7UUFBTztRQUNyQyxJQUFJOHZCLG1CQUFtQnJ2QixRQUFRcXZCLGdCQUFnQjtRQUMvQyxJQUFJQSxvQkFBb0IsSUFBSSxFQUFFO1lBQzFCQSxtQkFBbUIsSUFBSSxDQUFDUCxRQUFRLENBQUM5dUIsT0FBTyxDQUFDaVEsc0JBQXNCO1FBQ25FLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQ21kLElBQUksQ0FBQzd0QixNQUFNLEtBQUtBLFFBQVE7WUFDN0JrbUIsY0FBY3BJLE1BQU0sR0FBR2dTO1FBQzNCLENBQUM7UUFDRCxJQUFJLENBQUNMLE1BQU0sQ0FBQztZQUFFdkosZUFBZUE7UUFBYztJQUMvQztJQUNBVCxTQUFTbjNCLFNBQVMsQ0FBQytaLFdBQVcsR0FBRyxTQUFVaW9CLFdBQVcsRUFBRTtRQUNwRCxJQUFJMXdCLFVBQVUsSUFBSSxDQUFDMnZCLFFBQVEsQ0FBQzN2QixPQUFPO1FBQ25DLElBQUlnQixXQUFXLElBQUksQ0FBQ2t0QixTQUFTO1FBQzdCLElBQUk3MkIsWUFBWTZWLGdCQUFnQndqQjtRQUNoQyxJQUFJLElBQUksQ0FBQ3pDLElBQUksQ0FBQy9QLE1BQU0sRUFBRTtZQUNsQixPQUFPbGUsUUFBUXlJLFdBQVcsQ0FBQ3pILFNBQVM5RCxLQUFLLENBQUNzRSxLQUFLLEVBQUVSLFNBQVM5RCxLQUFLLENBQUN1RSxHQUFHLEVBQUVwSyxXQUFXO2dCQUM1RThGLGdCQUFnQjZELFNBQVM3RCxjQUFjO2dCQUN2Q0MsY0FBYzRELFNBQVM1RCxZQUFZO1lBQ3ZDO1FBQ0osQ0FBQztRQUNELE9BQU80QyxRQUFRdFEsTUFBTSxDQUFDc1IsU0FBUzlELEtBQUssQ0FBQ3NFLEtBQUssRUFBRW5LLFdBQVc7WUFDbkR5bkIsV0FBVzlkLFNBQVM3RCxjQUFjO1FBQ3RDO0lBQ0o7SUFDQTBvQixTQUFTbjNCLFNBQVMsQ0FBQ21oQyxNQUFNLEdBQUcsU0FBVTVILFFBQVEsRUFBRTtRQUM1QyxJQUFJam5CLFdBQVcsSUFBSSxDQUFDa3RCLFNBQVM7UUFDN0IsSUFBSWx0QixVQUFVO1lBQ1YsSUFBSUUsTUFBTSxJQUFJLENBQUMrc0IsSUFBSTtZQUNuQixJQUFJMEMsWUFBWSxJQUFJLENBQUNoQixRQUFRO1lBQzdCLElBQUlpQixlQUFlRCxVQUFVNUgsY0FBYyxHQUFHcm9CLFVBQVU7WUFDeEQsSUFBSW13QixpQkFBaUJoVyxrQkFBa0IrVixjQUFjNXZCLFNBQVMzRCxVQUFVO1lBQ3hFLElBQUkycUIsa0JBQWtCO2dCQUNsQixJQUFJO29CQUNBOWMsU0FBUztvQkFDVGdSLGVBQWUsSUFBSTtvQkFDbkJDLGtCQUFrQixJQUFJO29CQUN0QlUsYUFBYSxFQUFFO29CQUNmUixTQUFTLElBQUk7b0JBQ2JTLFFBQVEsRUFBRTtvQkFDVkwsaUJBQWlCO29CQUNqQkMsYUFBYTtvQkFDYkMsV0FBVztvQkFDWG5ELFlBQVksRUFBRTtnQkFDbEI7WUFDSjtZQUNBcVgsaUJBQWlCOUksMEJBQTBCOEksZ0JBQWdCN0ksaUJBQWlCQyxVQUFVMEk7WUFDdEYsSUFBSUcsV0FBVyxJQUFJakwsU0FBUzhLLFdBQVd6dkIsS0FBS0YsV0FBVyxXQUFXO1lBQ2xFLElBQUksQ0FBQ2l0QixJQUFJLEdBQUc0QyxlQUFlL3ZCLElBQUksQ0FBQ0ksSUFBSWpFLEtBQUssQ0FBQztZQUMxQyxJQUFJLENBQUNpeEIsU0FBUyxHQUFHMkMsZUFBZTl2QixTQUFTLENBQUNDLFNBQVMzRCxVQUFVLENBQUM7WUFDOURzekIsVUFBVS9oQyxRQUFRLENBQUM7Z0JBQ2ZDLE1BQU07Z0JBQ042UixZQUFZbXdCO1lBQ2hCO1lBQ0FGLFVBQVVsTCxPQUFPLENBQUNFLE9BQU8sQ0FBQyxlQUFlO2dCQUNyQ21MLFVBQVVBO2dCQUNWbEwsT0FBTyxJQUFJO2dCQUNYNkksZUFBZUssZUFBZStCLGdCQUFnQkYsV0FBVzN2QjtnQkFDekQwdEIsUUFBUSxXQUFZO29CQUNoQmlDLFVBQVUvaEMsUUFBUSxDQUFDO3dCQUNmQyxNQUFNO3dCQUNONlIsWUFBWWt3QjtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKLENBQUM7SUFDTDtJQUNBL0ssU0FBU24zQixTQUFTLENBQUNDLE1BQU0sR0FBRyxXQUFZO1FBQ3BDLElBQUlILFVBQVUsSUFBSSxDQUFDbWhDLFFBQVE7UUFDM0IsSUFBSW9CLFVBQVVwQyxnQkFBZ0IsSUFBSTtRQUNsQ25nQyxRQUFRSSxRQUFRLENBQUM7WUFDYkMsTUFBTTtZQUNONlIsWUFBWXF3QjtRQUNoQjtRQUNBdmlDLFFBQVFpM0IsT0FBTyxDQUFDRSxPQUFPLENBQUMsZUFBZTtZQUNuQ0MsT0FBTyxJQUFJO1lBQ1g2SSxlQUFlLEVBQUU7WUFDakJDLFFBQVEsV0FBWTtnQkFDaEJsZ0MsUUFBUUksUUFBUSxDQUFDO29CQUNiQyxNQUFNO29CQUNONlIsWUFBWXF3QjtnQkFDaEI7WUFDSjtRQUNKO0lBQ0o7SUFDQTdoQyxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsVUFBVTtRQUNoRFUsS0FBSyxXQUFZO1lBQ2IsSUFBSU4sV0FBVyxJQUFJLENBQUNtL0IsSUFBSSxDQUFDbi9CLFFBQVE7WUFDakMsSUFBSUEsVUFBVTtnQkFDVixPQUFPLElBQUlQLGVBQWUsSUFBSSxDQUFDb2hDLFFBQVEsRUFBRSxJQUFJLENBQUNBLFFBQVEsQ0FBQzVHLGNBQWMsR0FBRy9QLFlBQVksQ0FBQ2xxQixTQUFTO1lBQ2xHLENBQUM7WUFDRCxPQUFPLElBQUk7UUFDZjtRQUNBUSxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsU0FBUztRQUMvQ1UsS0FBSyxXQUFZO1lBQ2IsT0FBTyxJQUFJLENBQUM4K0IsU0FBUyxHQUNqQixJQUFJLENBQUN5QixRQUFRLENBQUMzdkIsT0FBTyxDQUFDK21CLE1BQU0sQ0FBQyxJQUFJLENBQUNtSCxTQUFTLENBQUNoeEIsS0FBSyxDQUFDc0UsS0FBSyxJQUN2RCxJQUFJO1FBQ1o7UUFDQWxTLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxPQUFPO1FBQzdDVSxLQUFLLFdBQVk7WUFDYixPQUFPLElBQUssQ0FBQzgrQixTQUFTLElBQUksSUFBSSxDQUFDRCxJQUFJLENBQUMvUCxNQUFNLEdBQ3RDLElBQUksQ0FBQ3lSLFFBQVEsQ0FBQzN2QixPQUFPLENBQUMrbUIsTUFBTSxDQUFDLElBQUksQ0FBQ21ILFNBQVMsQ0FBQ2h4QixLQUFLLENBQUN1RSxHQUFHLElBQ3JELElBQUk7UUFDWjtRQUNBblMsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLFlBQVk7UUFDbERVLEtBQUssV0FBWTtZQUNiLElBQUk0UixXQUFXLElBQUksQ0FBQ2t0QixTQUFTO1lBQzdCLElBQUlsdEIsVUFBVTtnQkFDVixPQUFPLElBQUksQ0FBQzJ1QixRQUFRLENBQUMzdkIsT0FBTyxDQUFDaW5CLFNBQVMsQ0FBQ2ptQixTQUFTOUQsS0FBSyxDQUFDc0UsS0FBSyxFQUFFO29CQUN6RHNsQixVQUFVLElBQUksQ0FBQ21ILElBQUksQ0FBQzd0QixNQUFNO29CQUMxQjBlLFdBQVc5ZCxTQUFTN0QsY0FBYztnQkFDdEM7WUFDSixDQUFDO1lBQ0QsT0FBTztRQUNYO1FBQ0E3TixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsVUFBVTtRQUNoRFUsS0FBSyxXQUFZO1lBQ2IsSUFBSTRSLFdBQVcsSUFBSSxDQUFDa3RCLFNBQVM7WUFDN0IsSUFBSWx0QixZQUFZLElBQUksQ0FBQ2l0QixJQUFJLENBQUMvUCxNQUFNLEVBQUU7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDeVIsUUFBUSxDQUFDM3ZCLE9BQU8sQ0FBQ2luQixTQUFTLENBQUNqbUIsU0FBUzlELEtBQUssQ0FBQ3VFLEdBQUcsRUFBRTtvQkFDdkRxbEIsVUFBVSxJQUFJLENBQUNtSCxJQUFJLENBQUM3dEIsTUFBTTtvQkFDMUIwZSxXQUFXOWQsU0FBUzVELFlBQVk7Z0JBQ3BDO1lBQ0osQ0FBQztZQUNELE9BQU87UUFDWDtRQUNBOU4sWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLE1BQU07UUFDNUMsMkNBQTJDO1FBQzNDLDZEQUE2RDtRQUM3RFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUM2K0IsSUFBSSxDQUFDNStCLFFBQVE7UUFBRTtRQUM5Q0MsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLFdBQVc7UUFDakRVLEtBQUssV0FBWTtZQUFFLE9BQU8sSUFBSSxDQUFDNitCLElBQUksQ0FBQzVTLE9BQU87UUFBRTtRQUM3Qy9yQixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsVUFBVTtRQUNoRFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUM2K0IsSUFBSSxDQUFDN3RCLE1BQU07UUFBRTtRQUM1QzlRLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxTQUFTO1FBQy9DVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUMxUSxLQUFLO1FBQUU7UUFDM0NqdUIsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLE9BQU87UUFDN0NVLEtBQUssV0FBWTtZQUFFLE9BQU8sSUFBSSxDQUFDNitCLElBQUksQ0FBQ3grQixHQUFHO1FBQUU7UUFDekNILFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxXQUFXO1FBQ2pEVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUM5UCxFQUFFLENBQUNqVCxPQUFPLElBQUk7UUFBUSxFQUFFLHVDQUF1Qzs7UUFFbkc1YixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsaUJBQWlCO1FBQ3ZEVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUM5UCxFQUFFLENBQUNqQyxhQUFhO1FBQUU7UUFDdEQ1c0IsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLG9CQUFvQjtRQUMxRFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUM2K0IsSUFBSSxDQUFDOVAsRUFBRSxDQUFDaEMsZ0JBQWdCO1FBQUU7UUFDekQ3c0IsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLGNBQWM7UUFDcERVLEtBQUssV0FBWTtZQUFFLE9BQU8sSUFBSSxDQUFDNitCLElBQUksQ0FBQzlQLEVBQUUsQ0FBQ3RCLFdBQVcsQ0FBQyxFQUFFLElBQUksSUFBSTtRQUFFO1FBQy9EdnRCLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxXQUFXO1FBQ2pEVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUM5UCxFQUFFLENBQUM5QixPQUFPO1FBQUU7UUFDaEQvc0IsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLFNBQVM7UUFDL0NVLEtBQUssV0FBWTtZQUFFLE9BQU8sSUFBSSxDQUFDNitCLElBQUksQ0FBQzlQLEVBQUUsQ0FBQ3JCLE1BQU0sQ0FBQyxFQUFFLElBQUksSUFBSTtRQUFFO1FBQzFEeHRCLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxtQkFBbUI7UUFDekRVLEtBQUssV0FBWTtZQUFFLE9BQU8sSUFBSSxDQUFDNitCLElBQUksQ0FBQzlQLEVBQUUsQ0FBQzFCLGVBQWU7UUFBRTtRQUN4RG50QixZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBTCxPQUFPQyxjQUFjLENBQUMwMkIsU0FBU24zQixTQUFTLEVBQUUsZUFBZTtRQUNyRFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUM2K0IsSUFBSSxDQUFDOVAsRUFBRSxDQUFDekIsV0FBVztRQUFFO1FBQ3BEcHRCLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FMLE9BQU9DLGNBQWMsQ0FBQzAyQixTQUFTbjNCLFNBQVMsRUFBRSxhQUFhO1FBQ25EVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUM5UCxFQUFFLENBQUN4QixTQUFTO1FBQUU7UUFDbERydEIsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLGNBQWM7UUFDcEQsc0ZBQXNGO1FBQ3RGVSxLQUFLLFdBQVk7WUFBRSxPQUFPLElBQUksQ0FBQzYrQixJQUFJLENBQUM5UCxFQUFFLENBQUMzRSxVQUFVO1FBQUU7UUFDbkRscUIsWUFBWSxLQUFLO1FBQ2pCQyxjQUFjLElBQUk7SUFDdEI7SUFDQUwsT0FBT0MsY0FBYyxDQUFDMDJCLFNBQVNuM0IsU0FBUyxFQUFFLGlCQUFpQjtRQUN2RFUsS0FBSyxXQUFZO1lBQUUsT0FBTyxJQUFJLENBQUM2K0IsSUFBSSxDQUFDdFEsYUFBYTtRQUFFO1FBQ25EcnVCLFlBQVksS0FBSztRQUNqQkMsY0FBYyxJQUFJO0lBQ3RCO0lBQ0FzMkIsU0FBU24zQixTQUFTLENBQUNzaUMsYUFBYSxHQUFHLFNBQVV2RCxRQUFRLEVBQUU7UUFDbkQsSUFBSUEsYUFBYSxLQUFLLEdBQUc7WUFBRUEsV0FBVyxDQUFDO1FBQUcsQ0FBQztRQUMzQyxJQUFJdnNCLE1BQU0sSUFBSSxDQUFDK3NCLElBQUk7UUFDbkIsSUFBSTlQLEtBQUtqZCxJQUFJaWQsRUFBRTtRQUNmLElBQUkzckIsS0FBSyxJQUFJLEVBQUV3MEIsV0FBV3gwQixHQUFHdzBCLFFBQVEsRUFBRUUsU0FBUzEwQixHQUFHMDBCLE1BQU07UUFDekQsSUFBSXRuQixNQUFNLENBQUM7UUFDWCxJQUFJc0IsSUFBSXFjLEtBQUssRUFBRTtZQUNYM2QsSUFBSTJkLEtBQUssR0FBR3JjLElBQUlxYyxLQUFLO1FBQ3pCLENBQUM7UUFDRCxJQUFJeUosVUFBVTtZQUNWcG5CLElBQUk0QixLQUFLLEdBQUd3bEI7UUFDaEIsQ0FBQztRQUNELElBQUlFLFFBQVE7WUFDUnRuQixJQUFJNkIsR0FBRyxHQUFHeWxCO1FBQ2QsQ0FBQztRQUNELElBQUlobUIsSUFBSTdSLFFBQVEsRUFBRTtZQUNkdVEsSUFBSTBkLEVBQUUsR0FBR3BjLElBQUk3UixRQUFRO1FBQ3pCLENBQUM7UUFDRCxJQUFJNlIsSUFBSW1hLE9BQU8sRUFBRTtZQUNiemIsSUFBSXliLE9BQU8sR0FBR25hLElBQUltYSxPQUFPO1FBQzdCLENBQUM7UUFDRCxJQUFJbmEsSUFBSXpSLEdBQUcsRUFBRTtZQUNUbVEsSUFBSW5RLEdBQUcsR0FBR3lSLElBQUl6UixHQUFHO1FBQ3JCLENBQUM7UUFDRCxJQUFJMHVCLEdBQUdqVCxPQUFPLElBQUlpVCxHQUFHalQsT0FBTyxLQUFLLFFBQVE7WUFDckN0TCxJQUFJc0wsT0FBTyxHQUFHaVQsR0FBR2pULE9BQU87UUFDNUIsQ0FBQztRQUNELGlEQUFpRDtRQUNqRCx3RUFBd0U7UUFDeEUsSUFBSXVpQixTQUFTd0QsYUFBYSxJQUFJOVMsR0FBRzFCLGVBQWUsSUFBSTBCLEdBQUcxQixlQUFlLEtBQUswQixHQUFHekIsV0FBVyxFQUFFO1lBQ3ZGOWMsSUFBSTRjLEtBQUssR0FBRzJCLEdBQUcxQixlQUFlO1FBQ2xDLE9BQ0s7WUFDRCxJQUFJMEIsR0FBRzFCLGVBQWUsRUFBRTtnQkFDcEI3YyxJQUFJNmMsZUFBZSxHQUFHMEIsR0FBRzFCLGVBQWU7WUFDNUMsQ0FBQztZQUNELElBQUkwQixHQUFHekIsV0FBVyxFQUFFO2dCQUNoQjljLElBQUk4YyxXQUFXLEdBQUd5QixHQUFHekIsV0FBVztZQUNwQyxDQUFDO1FBQ0wsQ0FBQztRQUNELElBQUl5QixHQUFHeEIsU0FBUyxFQUFFO1lBQ2QvYyxJQUFJK2MsU0FBUyxHQUFHd0IsR0FBR3hCLFNBQVM7UUFDaEMsQ0FBQztRQUNELElBQUl3QixHQUFHM0UsVUFBVSxDQUFDcm9CLE1BQU0sRUFBRTtZQUN0QnlPLElBQUk0WixVQUFVLEdBQUcyRSxHQUFHM0UsVUFBVTtRQUNsQyxDQUFDO1FBQ0QsSUFBSXRxQixPQUFPNlAsSUFBSSxDQUFDbUMsSUFBSXljLGFBQWEsRUFBRXhzQixNQUFNLEVBQUU7WUFDdkMsSUFBSXM4QixTQUFTeUQscUJBQXFCLEVBQUU7Z0JBQ2hDcGpDLCtDQUFRQSxDQUFDOFIsS0FBS3NCLElBQUl5YyxhQUFhO1lBQ25DLE9BQ0s7Z0JBQ0QvZCxJQUFJK2QsYUFBYSxHQUFHemMsSUFBSXljLGFBQWE7WUFDekMsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPL2Q7SUFDWDtJQUNBaW1CLFNBQVNuM0IsU0FBUyxDQUFDeWlDLE1BQU0sR0FBRyxXQUFZO1FBQ3BDLE9BQU8sSUFBSSxDQUFDSCxhQUFhO0lBQzdCO0lBQ0EsT0FBT25MO0FBQ1g7QUFDQSxTQUFTOEksZ0JBQWdCSCxRQUFRLEVBQUU7SUFDL0IsSUFBSWg4QixJQUFJQztJQUNSLElBQUl5TyxNQUFNc3RCLFNBQVNQLElBQUk7SUFDdkIsSUFBSWp0QixXQUFXd3RCLFNBQVNOLFNBQVM7SUFDakMsT0FBTztRQUNIcHRCLE1BQU90TyxDQUFBQSxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDME8sSUFBSWpFLEtBQUssQ0FBQyxHQUFHaUUsS0FBSzFPLEVBQUU7UUFDdkN1TyxXQUFXQyxXQUNKdk8sQ0FBQUEsS0FBSyxDQUFDLEdBQUdBLEVBQUUsQ0FBQ3VPLFNBQVMzRCxVQUFVLENBQUMsR0FBRzJELFVBQVV2TyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2hFO0FBQ0o7QUFDQSxTQUFTcThCLGVBQWVwdUIsVUFBVSxFQUFFbFMsT0FBTyxFQUFFNGlDLGVBQWUsRUFBRTtJQUMxRCxJQUFJdHdCLE9BQU9KLFdBQVdJLElBQUksRUFBRUMsWUFBWUwsV0FBV0ssU0FBUztJQUM1RCxJQUFJc3dCLFlBQVksRUFBRTtJQUNsQixJQUFJQyxvQkFBb0JGLGtCQUFrQkEsZ0JBQWdCL3pCLFVBQVUsR0FBRyxFQUFFO0lBQ3pFLElBQUssSUFBSWlnQixNQUFNdmMsVUFBVztRQUN0QixJQUFJQyxXQUFXRCxTQUFTLENBQUN1YyxHQUFHO1FBQzVCLElBQUlwYyxNQUFNSixJQUFJLENBQUNFLFNBQVMvRCxLQUFLLENBQUM7UUFDOUIsSUFBSStELFNBQVMzRCxVQUFVLEtBQUtpMEIsbUJBQW1CO1lBQzNDRCxVQUFVLy9CLElBQUksQ0FBQyxJQUFJdTBCLFNBQVNyM0IsU0FBUzBTLEtBQUtGO1FBQzlDLENBQUM7SUFDTDtJQUNBLE9BQU9xd0I7QUFDWDtBQUVBLElBQUlFLHlCQUF5QixDQUFDO0FBQzlCLFNBQVNDLHVCQUF1QnQvQixJQUFJLEVBQUV1L0IsUUFBUSxFQUFFO0lBQzVDRixzQkFBc0IsQ0FBQ3IvQixLQUFLLEdBQUd1L0I7QUFDbkM7QUFDQSxTQUFTQyxxQkFBcUJ4L0IsSUFBSSxFQUFFO0lBQ2hDLE9BQU8sSUFBSXEvQixzQkFBc0IsQ0FBQ3IvQixLQUFLO0FBQzNDO0FBQ0EsSUFBSXkvQiwwQkFBMEIsV0FBVyxHQUFJLFdBQVk7SUFDckQsU0FBU0EsMEJBQTBCLENBQ25DO0lBQ0FBLHdCQUF3QmpqQyxTQUFTLENBQUMrYyxhQUFhLEdBQUcsU0FBVXRSLENBQUMsRUFBRTtRQUMzRCxPQUFPQSxFQUFFRyxjQUFjO0lBQzNCO0lBQ0FxM0Isd0JBQXdCampDLFNBQVMsQ0FBQ2dkLGNBQWMsR0FBRyxTQUFVdlIsQ0FBQyxFQUFFO1FBQzVELE9BQU9BLEVBQUVJLFdBQVc7SUFDeEI7SUFDQW8zQix3QkFBd0JqakMsU0FBUyxDQUFDaWQsWUFBWSxHQUFHLFNBQVV4UixDQUFDLEVBQUU7UUFDMUQsT0FBT0EsRUFBRUssVUFBVTtJQUN2QjtJQUNBbTNCLHdCQUF3QmpqQyxTQUFTLENBQUNrakMsYUFBYSxHQUFHLFNBQVVDLEdBQUcsRUFBRTtRQUM3RCxPQUFPaDVCLGVBQWVnNUI7SUFDMUI7SUFDQUYsd0JBQXdCampDLFNBQVMsQ0FBQytkLGFBQWEsR0FBRyxTQUFVelIsTUFBTSxFQUFFO1FBQ2hFLE9BQU9wQyxlQUFlb0M7SUFDMUI7SUFDQSxPQUFPMjJCO0FBQ1g7QUFDQUgsdUJBQXVCLFdBQVdHO0FBRWxDLElBQUlHLFNBQVM7QUFDYixTQUFTM3hCLE1BQU16SSxHQUFHLEVBQUU7SUFDaEIsSUFBSWlCLElBQUltNUIsT0FBT3h2QixJQUFJLENBQUM1SztJQUNwQixJQUFJaUIsR0FBRztRQUNILElBQUlxQyxTQUFTLElBQUkwQixLQUFLQSxLQUFLRyxHQUFHLENBQUN1UyxPQUFPelcsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBR3lXLE9BQU96VyxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFeVcsT0FBT3pXLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSXlXLE9BQU96VyxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUl5VyxPQUFPelcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJeVcsT0FBT3pXLENBQUMsQ0FBQyxHQUFHLElBQUksSUFBSUEsQ0FBQyxDQUFDLEdBQUcsR0FBR3lXLE9BQU8sT0FBT3pXLENBQUMsQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDO1FBQzlMLElBQUltRSxZQUFZOUIsU0FBUztZQUNyQixJQUFJMkosaUJBQWlCLElBQUk7WUFDekIsSUFBSWhNLENBQUMsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1BnTSxpQkFBaUIsQ0FBQ2hNLENBQUMsQ0FBQyxHQUFHLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFLeVcsQ0FBQUEsT0FBT3pXLENBQUMsQ0FBQyxHQUFHLElBQUksS0FBSyxLQUM5RHlXLE9BQU96VyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUM7WUFDekIsQ0FBQztZQUNELE9BQU87Z0JBQ0hxQyxRQUFRQTtnQkFDUjZqQixtQkFBbUIsQ0FBQ2xtQixDQUFDLENBQUMsRUFBRTtnQkFDeEJnTSxnQkFBZ0JBO1lBQ3BCO1FBQ0osQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPLElBQUk7QUFDZjtBQUVBLElBQUlvdEIsVUFBVSxXQUFXLEdBQUksV0FBWTtJQUNyQyxTQUFTQSxRQUFRdEUsUUFBUSxFQUFFO1FBQ3ZCLElBQUlyakIsV0FBVyxJQUFJLENBQUNBLFFBQVEsR0FBR3FqQixTQUFTcmpCLFFBQVE7UUFDaEQsSUFBSTRuQixrQkFBa0I1bkIsYUFBYSxXQUFXQSxhQUFhO1FBQzNELElBQUlxakIsU0FBU3dFLGlCQUFpQixJQUFJRCxpQkFBaUI7WUFDL0MsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxJQUFJeEUsU0FBU3dFLGlCQUFpQixDQUFDN25CO1FBQzVELENBQUM7UUFDRCxJQUFJLENBQUM4bkIsZ0JBQWdCLEdBQUdya0IsUUFBUSxDQUFDbWtCLG1CQUFtQixJQUFJLENBQUNDLGlCQUFpQjtRQUMxRSxJQUFJLENBQUNwcEIsY0FBYyxHQUFHNm9CLHFCQUFxQmpFLFNBQVM1a0IsY0FBYztRQUNsRSxJQUFJLENBQUNvQixNQUFNLEdBQUd3akIsU0FBU3hqQixNQUFNO1FBQzdCLElBQUksQ0FBQ2tvQixPQUFPLEdBQUcxRSxTQUFTeGpCLE1BQU0sQ0FBQzdHLElBQUksQ0FBQ25JLEdBQUc7UUFDdkMsSUFBSSxDQUFDbTNCLE9BQU8sR0FBRzNFLFNBQVN4akIsTUFBTSxDQUFDN0csSUFBSSxDQUFDbEksR0FBRztRQUN2QyxJQUFJdXlCLFNBQVNuZSxxQkFBcUIsS0FBSyxPQUFPO1lBQzFDLElBQUksQ0FBQzZpQixPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNuQixDQUFDO1FBQ0QsSUFBSSxPQUFPM0UsU0FBUzNYLFFBQVEsS0FBSyxVQUFVO1lBQ3ZDLElBQUksQ0FBQ3FjLE9BQU8sR0FBRzFFLFNBQVMzWCxRQUFRO1FBQ3BDLENBQUM7UUFDRCxJQUFJLE9BQU8yWCxTQUFTbmUscUJBQXFCLEtBQUssWUFBWTtZQUN0RCxJQUFJLENBQUMraUIsY0FBYyxHQUFHNUUsU0FBU25lLHFCQUFxQjtRQUN4RCxDQUFDO1FBQ0QsSUFBSSxDQUFDdkYsUUFBUSxHQUFHMGpCLFNBQVMxakIsUUFBUSxJQUFJLElBQUksR0FBRzBqQixTQUFTMWpCLFFBQVEsR0FBRzBqQixTQUFTeGpCLE1BQU0sQ0FBQ3BKLE9BQU8sQ0FBQ2tKLFFBQVE7UUFDaEcsSUFBSSxDQUFDQyxZQUFZLEdBQUcsQ0FBQ3lqQixTQUFTempCLFlBQVksSUFBSSxJQUFJLEdBQUd5akIsU0FBU3pqQixZQUFZLEdBQUd5akIsU0FBU3hqQixNQUFNLENBQUNwSixPQUFPLENBQUNtSixZQUFZLEtBQUssSUFBSSxDQUFDRCxRQUFRO1FBQ25JLElBQUksQ0FBQ2lELFlBQVksR0FBR3lnQixTQUFTemdCLFlBQVk7UUFDekMsSUFBSSxDQUFDeEQsZ0JBQWdCLEdBQUdpa0IsU0FBU2prQixnQkFBZ0I7SUFDckQ7SUFDQSxxQkFBcUI7SUFDckJ1b0IsUUFBUXJqQyxTQUFTLENBQUNveEIsWUFBWSxHQUFHLFNBQVVycUIsS0FBSyxFQUFFO1FBQzlDLElBQUlqRyxPQUFPLElBQUksQ0FBQ292QixnQkFBZ0IsQ0FBQ25wQjtRQUNqQyxJQUFJakcsU0FBUyxJQUFJLEVBQUU7WUFDZixPQUFPLElBQUk7UUFDZixDQUFDO1FBQ0QsT0FBT0EsS0FBS3dMLE1BQU07SUFDdEI7SUFDQSsyQixRQUFRcmpDLFNBQVMsQ0FBQ204QixlQUFlLEdBQUcsV0FBWTtRQUM1QyxJQUFJLElBQUksQ0FBQ3FILGdCQUFnQixFQUFFO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDSSxpQkFBaUIsQ0FBQyxJQUFJNTFCLE9BQU90RCxPQUFPO1FBQ3BELENBQUM7UUFDRCwyREFBMkQ7UUFDM0Qsc0RBQXNEO1FBQ3RELE9BQU9QLGVBQWVtRCxpQkFBaUIsSUFBSVU7SUFDL0M7SUFDQXExQixRQUFRcmpDLFNBQVMsQ0FBQ2t3QixnQkFBZ0IsR0FBRyxTQUFVbnBCLEtBQUssRUFBRTtRQUNsRCxJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUMzQixPQUFPLElBQUksQ0FBQzBLLEtBQUssQ0FBQzFLO1FBQ3RCLENBQUM7UUFDRCxJQUFJdUYsU0FBUyxJQUFJO1FBQ2pCLElBQUksT0FBT3ZGLFVBQVUsVUFBVTtZQUMzQnVGLFNBQVMsSUFBSSxDQUFDczNCLGlCQUFpQixDQUFDNzhCO1FBQ3BDLE9BQ0ssSUFBSUEsaUJBQWlCaUgsTUFBTTtZQUM1QmpILFFBQVFBLE1BQU0yRCxPQUFPO1lBQ3JCLElBQUksQ0FBQzJELE1BQU10SCxRQUFRO2dCQUNmdUYsU0FBUyxJQUFJLENBQUNzM0IsaUJBQWlCLENBQUM3OEI7WUFDcEMsQ0FBQztRQUNMLE9BQ0ssSUFBSUssTUFBTUMsT0FBTyxDQUFDTixRQUFRO1lBQzNCdUYsU0FBU25DLGVBQWVwRDtRQUM1QixDQUFDO1FBQ0QsSUFBSXVGLFdBQVcsSUFBSSxJQUFJLENBQUM4QixZQUFZOUIsU0FBUztZQUN6QyxPQUFPLElBQUk7UUFDZixDQUFDO1FBQ0QsT0FBTztZQUFFQSxRQUFRQTtZQUFRNmpCLG1CQUFtQixLQUFLO1lBQUVDLFdBQVcsSUFBSTtRQUFDO0lBQ3ZFO0lBQ0FpVCxRQUFRcmpDLFNBQVMsQ0FBQ3lSLEtBQUssR0FBRyxTQUFVakosQ0FBQyxFQUFFO1FBQ25DLElBQUlpVSxRQUFRaEwsTUFBTWpKO1FBQ2xCLElBQUlpVSxVQUFVLElBQUksRUFBRTtZQUNoQixPQUFPLElBQUk7UUFDZixDQUFDO1FBQ0QsSUFBSW5RLFNBQVNtUSxNQUFNblEsTUFBTTtRQUN6QixJQUFJOGpCLFlBQVksSUFBSTtRQUNwQixJQUFJM1QsTUFBTXhHLGNBQWMsS0FBSyxJQUFJLEVBQUU7WUFDL0IsSUFBSSxJQUFJLENBQUN1dEIsZ0JBQWdCLEVBQUU7Z0JBQ3ZCbDNCLFNBQVMsSUFBSSxDQUFDczNCLGlCQUFpQixDQUFDdDNCLE9BQU81QixPQUFPLEtBQUsrUixNQUFNeEcsY0FBYyxHQUFHLEtBQUs7WUFDbkYsT0FDSztnQkFDRG1hLFlBQVkzVCxNQUFNeEcsY0FBYztZQUNwQyxDQUFDO1FBQ0wsQ0FBQztRQUNELE9BQU87WUFBRTNKLFFBQVFBO1lBQVE2akIsbUJBQW1CMVQsTUFBTTBULGlCQUFpQjtZQUFFQyxXQUFXQTtRQUFVO0lBQzlGO0lBQ0EsWUFBWTtJQUNaaVQsUUFBUXJqQyxTQUFTLENBQUM2akMsT0FBTyxHQUFHLFNBQVV2M0IsTUFBTSxFQUFFO1FBQzFDLE9BQU8sSUFBSSxDQUFDNk4sY0FBYyxDQUFDNEMsYUFBYSxDQUFDelE7SUFDN0M7SUFDQSsyQixRQUFRcmpDLFNBQVMsQ0FBQ3lOLFFBQVEsR0FBRyxTQUFVbkIsTUFBTSxFQUFFO1FBQzNDLE9BQU8sSUFBSSxDQUFDNk4sY0FBYyxDQUFDNkMsY0FBYyxDQUFDMVE7SUFDOUM7SUFDQSx1QkFBdUI7SUFDdkIrMkIsUUFBUXJqQyxTQUFTLENBQUN3RyxHQUFHLEdBQUcsU0FBVThGLE1BQU0sRUFBRTBJLEdBQUcsRUFBRTtRQUMzQyxJQUFJN00sSUFBSSxJQUFJLENBQUNnUyxjQUFjLENBQUM0RCxhQUFhLENBQUN6UjtRQUMxQ25FLENBQUMsQ0FBQyxFQUFFLElBQUk2TSxJQUFJOUosS0FBSztRQUNqQi9DLENBQUMsQ0FBQyxFQUFFLElBQUk2TSxJQUFJN0osTUFBTTtRQUNsQmhELENBQUMsQ0FBQyxFQUFFLElBQUk2TSxJQUFJNUosSUFBSTtRQUNoQmpELENBQUMsQ0FBQyxFQUFFLElBQUk2TSxJQUFJekosWUFBWTtRQUN4QixPQUFPLElBQUksQ0FBQzRPLGNBQWMsQ0FBQytvQixhQUFhLENBQUMvNkI7SUFDN0M7SUFDQWs3QixRQUFRcmpDLFNBQVMsQ0FBQ29ULFFBQVEsR0FBRyxTQUFVOUcsTUFBTSxFQUFFMEksR0FBRyxFQUFFO1FBQ2hELElBQUk3TSxJQUFJLElBQUksQ0FBQ2dTLGNBQWMsQ0FBQzRELGFBQWEsQ0FBQ3pSO1FBQzFDbkUsQ0FBQyxDQUFDLEVBQUUsSUFBSTZNLElBQUk5SixLQUFLO1FBQ2pCL0MsQ0FBQyxDQUFDLEVBQUUsSUFBSTZNLElBQUk3SixNQUFNO1FBQ2xCaEQsQ0FBQyxDQUFDLEVBQUUsSUFBSTZNLElBQUk1SixJQUFJO1FBQ2hCakQsQ0FBQyxDQUFDLEVBQUUsSUFBSTZNLElBQUl6SixZQUFZO1FBQ3hCLE9BQU8sSUFBSSxDQUFDNE8sY0FBYyxDQUFDK29CLGFBQWEsQ0FBQy82QjtJQUM3QztJQUNBazdCLFFBQVFyakMsU0FBUyxDQUFDcStCLFFBQVEsR0FBRyxTQUFVL3hCLE1BQU0sRUFBRWhELENBQUMsRUFBRTtRQUM5QyxJQUFJbkIsSUFBSSxJQUFJLENBQUNnUyxjQUFjLENBQUM0RCxhQUFhLENBQUN6UjtRQUMxQ25FLENBQUMsQ0FBQyxFQUFFLElBQUltQjtRQUNSLE9BQU8sSUFBSSxDQUFDNlEsY0FBYyxDQUFDK29CLGFBQWEsQ0FBQy82QjtJQUM3QztJQUNBazdCLFFBQVFyakMsU0FBUyxDQUFDOGpDLFNBQVMsR0FBRyxTQUFVeDNCLE1BQU0sRUFBRWhELENBQUMsRUFBRTtRQUMvQyxJQUFJbkIsSUFBSSxJQUFJLENBQUNnUyxjQUFjLENBQUM0RCxhQUFhLENBQUN6UjtRQUMxQ25FLENBQUMsQ0FBQyxFQUFFLElBQUltQjtRQUNSLE9BQU8sSUFBSSxDQUFDNlEsY0FBYyxDQUFDK29CLGFBQWEsQ0FBQy82QjtJQUM3QztJQUNBLHNCQUFzQjtJQUN0Qms3QixRQUFRcmpDLFNBQVMsQ0FBQ2l4QixjQUFjLEdBQUcsU0FBVTFtQixFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNqRCxJQUFJMlAsaUJBQWlCLElBQUksQ0FBQ0EsY0FBYztRQUN4QyxJQUFJeE8sU0FBU3BCLFFBQVFvQixTQUFTbkIsT0FDMUIyUCxlQUFlOEMsWUFBWSxDQUFDMVMsUUFBUTRQLGVBQWU4QyxZQUFZLENBQUN6UyxPQUNoRTJQLGVBQWU2QyxjQUFjLENBQUN6UyxRQUFRNFAsZUFBZTZDLGNBQWMsQ0FBQ3hTLEtBQUs7WUFDekUsT0FBTzJQLGVBQWU0QyxhQUFhLENBQUN2UyxNQUFNMlAsZUFBZTRDLGFBQWEsQ0FBQ3hTO1FBQzNFLENBQUM7UUFDRCxPQUFPLElBQUk7SUFDZjtJQUNBODRCLFFBQVFyakMsU0FBUyxDQUFDa3hCLGVBQWUsR0FBRyxTQUFVM21CLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ2xELElBQUkyUCxpQkFBaUIsSUFBSSxDQUFDQSxjQUFjO1FBQ3hDLElBQUl4TyxTQUFTcEIsUUFBUW9CLFNBQVNuQixPQUMxQjJQLGVBQWU4QyxZQUFZLENBQUMxUyxRQUFRNFAsZUFBZThDLFlBQVksQ0FBQ3pTLEtBQUs7WUFDckUsT0FBTyxlQUFnQndTLGNBQWMsQ0FBQ3hTLE1BQU0yUCxlQUFlNkMsY0FBYyxDQUFDelMsTUFDdEUsQ0FBQzRQLGVBQWU0QyxhQUFhLENBQUN2UyxNQUFNMlAsZUFBZTRDLGFBQWEsQ0FBQ3hTLEdBQUUsSUFBSztRQUNoRixDQUFDO1FBQ0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxtQkFBbUI7SUFDbkI4NEIsUUFBUXJqQyxTQUFTLENBQUMrakMsaUJBQWlCLEdBQUcsU0FBVXg1QixFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNwRCxJQUFJbEIsSUFBSSxJQUFJLENBQUMybkIsY0FBYyxDQUFDMW1CLElBQUlDO1FBQ2hDLElBQUlsQixNQUFNLElBQUksRUFBRTtZQUNaLE9BQU87Z0JBQUVtSyxNQUFNO2dCQUFRc0MsT0FBT3pNO1lBQUU7UUFDcEMsQ0FBQztRQUNEQSxJQUFJLElBQUksQ0FBQzRuQixlQUFlLENBQUMzbUIsSUFBSUM7UUFDN0IsSUFBSWxCLE1BQU0sSUFBSSxFQUFFO1lBQ1osT0FBTztnQkFBRW1LLE1BQU07Z0JBQVNzQyxPQUFPek07WUFBRTtRQUNyQyxDQUFDO1FBQ0RBLElBQUlrQyxlQUFlakIsSUFBSUM7UUFDdkIsSUFBSWxCLE1BQU0sSUFBSSxFQUFFO1lBQ1osT0FBTztnQkFBRW1LLE1BQU07Z0JBQVFzQyxPQUFPek07WUFBRTtRQUNwQyxDQUFDO1FBQ0RBLElBQUlvQyxjQUFjbkIsSUFBSUM7UUFDdEIsSUFBSWxCLE1BQU0sSUFBSSxFQUFFO1lBQ1osT0FBTztnQkFBRW1LLE1BQU07Z0JBQU9zQyxPQUFPek07WUFBRTtRQUNuQyxDQUFDO1FBQ0RBLElBQUlxQixVQUFVSixJQUFJQztRQUNsQixJQUFJbkIsTUFBTUMsSUFBSTtZQUNWLE9BQU87Z0JBQUVtSyxNQUFNO2dCQUFRc0MsT0FBT3pNO1lBQUU7UUFDcEMsQ0FBQztRQUNEQSxJQUFJc0IsWUFBWUwsSUFBSUM7UUFDcEIsSUFBSW5CLE1BQU1DLElBQUk7WUFDVixPQUFPO2dCQUFFbUssTUFBTTtnQkFBVXNDLE9BQU96TTtZQUFFO1FBQ3RDLENBQUM7UUFDREEsSUFBSXVCLFlBQVlOLElBQUlDO1FBQ3BCLElBQUluQixNQUFNQyxJQUFJO1lBQ1YsT0FBTztnQkFBRW1LLE1BQU07Z0JBQVVzQyxPQUFPek07WUFBRTtRQUN0QyxDQUFDO1FBQ0QsT0FBTztZQUFFbUssTUFBTTtZQUFlc0MsT0FBT3ZMLEdBQUdFLE9BQU8sS0FBS0gsR0FBR0csT0FBTztRQUFHO0lBQ3JFO0lBQ0EyNEIsUUFBUXJqQyxTQUFTLENBQUNna0MscUJBQXFCLEdBQUcsU0FBVXo1QixFQUFFLEVBQUVDLEVBQUUsRUFBRWlCLENBQUMsRUFBRTtRQUMzRCxrQ0FBa0M7UUFDbEMsSUFBSXc0QjtRQUNKLElBQUl4NEIsRUFBRVAsS0FBSyxFQUFFO1lBQ1QrNEIsT0FBTyxJQUFJLENBQUNoVCxjQUFjLENBQUMxbUIsSUFBSUM7WUFDL0IsSUFBSXk1QixTQUFTLElBQUksRUFBRTtnQkFDZixPQUFPQSxPQUFPN3VCLGFBQWEzSjtZQUMvQixDQUFDO1FBQ0wsQ0FBQztRQUNELElBQUlBLEVBQUVOLE1BQU0sRUFBRTtZQUNWODRCLE9BQU8sSUFBSSxDQUFDL1MsZUFBZSxDQUFDM21CLElBQUlDO1lBQ2hDLElBQUl5NUIsU0FBUyxJQUFJLEVBQUU7Z0JBQ2YsT0FBT0EsT0FBTzN1QixjQUFjN0o7WUFDaEMsQ0FBQztRQUNMLENBQUM7UUFDRCxJQUFJQSxFQUFFTCxJQUFJLEVBQUU7WUFDUjY0QixPQUFPdjRCLGNBQWNuQixJQUFJQztZQUN6QixJQUFJeTVCLFNBQVMsSUFBSSxFQUFFO2dCQUNmLE9BQU9BLE9BQU81dUIsWUFBWTVKO1lBQzlCLENBQUM7UUFDTCxDQUFDO1FBQ0QsT0FBTyxDQUFDakIsR0FBR0UsT0FBTyxLQUFLSCxHQUFHRyxPQUFPLEVBQUMsSUFBSzZLLFVBQVU5SjtJQUNyRDtJQUNBLFdBQVc7SUFDWCwwREFBMEQ7SUFDMUQ0M0IsUUFBUXJqQyxTQUFTLENBQUNra0MsT0FBTyxHQUFHLFNBQVVqNkIsQ0FBQyxFQUFFd0osSUFBSSxFQUFFO1FBQzNDLElBQUlBLFNBQVMsUUFBUTtZQUNqQixPQUFPLElBQUksQ0FBQzB3QixXQUFXLENBQUNsNkI7UUFDNUIsQ0FBQztRQUNELElBQUl3SixTQUFTLFNBQVM7WUFDbEIsT0FBTyxJQUFJLENBQUMyd0IsWUFBWSxDQUFDbjZCO1FBQzdCLENBQUM7UUFDRCxJQUFJd0osU0FBUyxRQUFRO1lBQ2pCLE9BQU8sSUFBSSxDQUFDNHdCLFdBQVcsQ0FBQ3A2QjtRQUM1QixDQUFDO1FBQ0QsSUFBSXdKLFNBQVMsT0FBTztZQUNoQixPQUFPekksV0FBV2Y7UUFDdEIsQ0FBQztRQUNELElBQUl3SixTQUFTLFFBQVE7WUFDakIsT0FBTzFILFlBQVk5QjtRQUN2QixDQUFDO1FBQ0QsSUFBSXdKLFNBQVMsVUFBVTtZQUNuQixPQUFPeEgsY0FBY2hDO1FBQ3pCLENBQUM7UUFDRCxJQUFJd0osU0FBUyxVQUFVO1lBQ25CLE9BQU90SCxjQUFjbEM7UUFDekIsQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0FvNUIsUUFBUXJqQyxTQUFTLENBQUNta0MsV0FBVyxHQUFHLFNBQVVsNkIsQ0FBQyxFQUFFO1FBQ3pDLE9BQU8sSUFBSSxDQUFDa1EsY0FBYyxDQUFDK29CLGFBQWEsQ0FBQztZQUNyQyxJQUFJLENBQUMvb0IsY0FBYyxDQUFDNEMsYUFBYSxDQUFDOVM7U0FDckM7SUFDTDtJQUNBbzVCLFFBQVFyakMsU0FBUyxDQUFDb2tDLFlBQVksR0FBRyxTQUFVbjZCLENBQUMsRUFBRTtRQUMxQyxPQUFPLElBQUksQ0FBQ2tRLGNBQWMsQ0FBQytvQixhQUFhLENBQUM7WUFDckMsSUFBSSxDQUFDL29CLGNBQWMsQ0FBQzRDLGFBQWEsQ0FBQzlTO1lBQ2xDLElBQUksQ0FBQ2tRLGNBQWMsQ0FBQzZDLGNBQWMsQ0FBQy9TO1NBQ3RDO0lBQ0w7SUFDQW81QixRQUFRcmpDLFNBQVMsQ0FBQ3FrQyxXQUFXLEdBQUcsU0FBVXA2QixDQUFDLEVBQUU7UUFDekMsT0FBTyxJQUFJLENBQUNrUSxjQUFjLENBQUMrb0IsYUFBYSxDQUFDO1lBQ3JDLElBQUksQ0FBQy9vQixjQUFjLENBQUM0QyxhQUFhLENBQUM5UztZQUNsQyxJQUFJLENBQUNrUSxjQUFjLENBQUM2QyxjQUFjLENBQUMvUztZQUNuQ0EsRUFBRTZCLFVBQVUsS0FBTSxDQUFDN0IsRUFBRW9ELFNBQVMsS0FBSyxJQUFJLENBQUNvMkIsT0FBTyxHQUFHLEtBQUs7U0FDMUQ7SUFDTDtJQUNBLGNBQWM7SUFDZEosUUFBUXJqQyxTQUFTLENBQUNvYixpQkFBaUIsR0FBRyxTQUFVOU8sTUFBTSxFQUFFO1FBQ3BELElBQUksSUFBSSxDQUFDcTNCLGNBQWMsRUFBRTtZQUNyQixPQUFPLElBQUksQ0FBQ0EsY0FBYyxDQUFDLElBQUksQ0FBQ3RMLE1BQU0sQ0FBQy9yQjtRQUMzQyxDQUFDO1FBQ0QsT0FBT0QsV0FBV0MsUUFBUSxJQUFJLENBQUNtM0IsT0FBTyxFQUFFLElBQUksQ0FBQ0MsT0FBTztJQUN4RDtJQUNBLG9DQUFvQztJQUNwQ0wsUUFBUXJqQyxTQUFTLENBQUNnQixNQUFNLEdBQUcsU0FBVXNMLE1BQU0sRUFBRTNELFNBQVMsRUFBRTI3QixXQUFXLEVBQUU7UUFDakUsSUFBSUEsZ0JBQWdCLEtBQUssR0FBRztZQUFFQSxjQUFjLENBQUM7UUFBRyxDQUFDO1FBQ2pELE9BQU8zN0IsVUFBVTNILE1BQU0sQ0FBQztZQUNwQnNMLFFBQVFBO1lBQ1IySixnQkFBZ0JxdUIsWUFBWWxVLFNBQVMsSUFBSSxJQUFJLEdBQ3pDa1UsWUFBWWxVLFNBQVMsR0FDckIsSUFBSSxDQUFDbVUsZUFBZSxDQUFDajRCLE9BQU87UUFDcEMsR0FBRyxJQUFJO0lBQ1g7SUFDQSsyQixRQUFRcmpDLFNBQVMsQ0FBQytaLFdBQVcsR0FBRyxTQUFVakgsS0FBSyxFQUFFQyxHQUFHLEVBQUVwSyxTQUFTLEVBQUUyN0IsV0FBVyxFQUFFO1FBQzFFLElBQUlBLGdCQUFnQixLQUFLLEdBQUc7WUFBRUEsY0FBYyxDQUFDO1FBQUcsQ0FBQztRQUNqRCxJQUFJQSxZQUFZRSxjQUFjLEVBQUU7WUFDNUJ6eEIsTUFBTTFJLE1BQU0wSSxLQUFLLENBQUM7UUFDdEIsQ0FBQztRQUNELE9BQU9wSyxVQUFVb1IsV0FBVyxDQUFDO1lBQ3pCek4sUUFBUXdHO1lBQ1JtRCxnQkFBZ0JxdUIsWUFBWTcxQixjQUFjLElBQUksSUFBSSxHQUM5QzYxQixZQUFZNzFCLGNBQWMsR0FDMUIsSUFBSSxDQUFDODFCLGVBQWUsQ0FBQ3p4QixNQUFNO1FBQ25DLEdBQUc7WUFDQ3hHLFFBQVF5RztZQUNSa0QsZ0JBQWdCcXVCLFlBQVk1MUIsWUFBWSxJQUFJLElBQUksR0FDNUM0MUIsWUFBWTUxQixZQUFZLEdBQ3hCLElBQUksQ0FBQzYxQixlQUFlLENBQUN4eEIsSUFBSTtRQUNqQyxHQUFHLElBQUksRUFBRXV4QixZQUFZeHBCLGdCQUFnQjtJQUN6QztJQUNBOzs7SUFHQSxHQUNBdW9CLFFBQVFyakMsU0FBUyxDQUFDdTRCLFNBQVMsR0FBRyxTQUFVanNCLE1BQU0sRUFBRW00QixZQUFZLEVBQUU7UUFDMUQsSUFBSUEsaUJBQWlCLEtBQUssR0FBRztZQUFFQSxlQUFlLENBQUM7UUFBRyxDQUFDO1FBQ25ELElBQUl4dUIsaUJBQWlCLElBQUk7UUFDekIsSUFBSSxDQUFDd3VCLGFBQWFDLGtCQUFrQixFQUFFO1lBQ2xDLElBQUlELGFBQWFyVSxTQUFTLElBQUksSUFBSSxFQUFFO2dCQUNoQ25hLGlCQUFpQnd1QixhQUFhclUsU0FBUztZQUMzQyxPQUNLO2dCQUNEbmEsaUJBQWlCLElBQUksQ0FBQ3N1QixlQUFlLENBQUNqNEI7WUFDMUMsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPMEosZUFBZTFKLFFBQVEySixnQkFBZ0J3dUIsYUFBYXJNLFFBQVE7SUFDdkU7SUFDQSxXQUFXO0lBQ1hpTCxRQUFRcmpDLFNBQVMsQ0FBQzRqQyxpQkFBaUIsR0FBRyxTQUFVcHZCLEVBQUUsRUFBRTtRQUNoRCxJQUFJLElBQUksQ0FBQ2tILFFBQVEsS0FBSyxTQUFTO1lBQzNCLE9BQU92UixlQUFlbUQsaUJBQWlCLElBQUlVLEtBQUt3RztRQUNwRCxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUNrSCxRQUFRLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQzZuQixpQkFBaUIsRUFBRTtZQUNwRCxPQUFPLElBQUl2MUIsS0FBS3dHO1FBQ3BCLENBQUM7UUFDRCxPQUFPckssZUFBZSxJQUFJLENBQUNvNUIsaUJBQWlCLENBQUNvQixnQkFBZ0IsQ0FBQ253QjtJQUNsRTtJQUNBNnVCLFFBQVFyakMsU0FBUyxDQUFDdWtDLGVBQWUsR0FBRyxTQUFVdDZCLENBQUMsRUFBRTtRQUM3QyxJQUFJLElBQUksQ0FBQ3lSLFFBQVEsS0FBSyxTQUFTO1lBQzNCLE9BQU8sQ0FBQzNOLGlCQUFpQjdELGVBQWVELElBQUkyNkIsaUJBQWlCLElBQUksOENBQThDO1FBQ25ILENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQ2xwQixRQUFRLEtBQUssT0FBTztZQUN6QixPQUFPO1FBQ1gsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDNm5CLGlCQUFpQixFQUFFO1lBQ3hCLE9BQU8sSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQ3NCLGNBQWMsQ0FBQzM2QixlQUFlRDtRQUNoRSxDQUFDO1FBQ0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxhQUFhO0lBQ2JvNUIsUUFBUXJqQyxTQUFTLENBQUNxNEIsTUFBTSxHQUFHLFNBQVVwdUIsQ0FBQyxFQUFFbW1CLFNBQVMsRUFBRTtRQUMvQyxJQUFJLElBQUksQ0FBQzFVLFFBQVEsS0FBSyxTQUFTO1lBQzNCLE9BQU8zTixpQkFBaUI3RCxlQUFlRDtRQUMzQyxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUN5UixRQUFRLEtBQUssT0FBTztZQUN6QixPQUFPLElBQUkxTixLQUFLL0QsRUFBRVMsT0FBTyxLQUFLLHdCQUF3QjtRQUMxRCxDQUFDO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQzY0QixpQkFBaUIsRUFBRTtZQUN6QixPQUFPLElBQUl2MUIsS0FBSy9ELEVBQUVTLE9BQU8sS0FBTTBsQixDQUFBQSxhQUFhO1FBQ2hELENBQUM7UUFDRCxPQUFPLElBQUlwaUIsS0FBSy9ELEVBQUVTLE9BQU8sS0FDckIsSUFBSSxDQUFDNjRCLGlCQUFpQixDQUFDc0IsY0FBYyxDQUFDMzZCLGVBQWVELE1BQU0sT0FBTztJQUMxRTtJQUNBLE9BQU9vNUI7QUFDWDtBQUVBLElBQUl5QixnQkFBZ0IsRUFBRTtBQUV0QixJQUFJQyx3QkFBd0I7SUFDeEJDLE1BQU07SUFDTnR3QixNQUFNO1FBQ0ZuSSxLQUFLO1FBQ0xDLEtBQUs7SUFDVDtJQUNBbVEsV0FBVztJQUNYc04sWUFBWTtRQUNSaVUsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkUsVUFBVTtRQUNWeHhCLE1BQU07UUFDTnl4QixPQUFPO1FBQ1B4cUIsT0FBTztRQUNQVyxNQUFNO1FBQ05WLEtBQUs7UUFDTGl4QixNQUFNO0lBQ1Y7SUFDQTVwQixVQUFVO0lBQ1ZDLGNBQWM7SUFDZDRNLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxXQUFXO0lBQ1h0QyxZQUFZO0lBQ1pTLGNBQWM7SUFDZHdCLGNBQWM7QUFDbEI7QUFDQSxJQUFJbWQsZ0JBQWdCOWxDLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUcybEMsd0JBQXdCO0lBQzlELDBEQUEwRDtJQUMxRCxzREFBc0Q7SUFDdEQ3YSxhQUFhO1FBQ1RnVSxNQUFNO1FBQ05DLE1BQU07UUFDTkksT0FBTyxTQUFVdFUsVUFBVSxFQUFFeFcsSUFBSSxFQUFFO1lBQy9CLE9BQU8sU0FBVSxRQUNYLFVBQ0EsVUFBVXdXLFVBQVU7UUFDOUI7SUFDSjtJQUFHakMsVUFBVTtJQUFXQyxhQUFhO0lBQVl6QixjQUFjLFNBQVUyZSxRQUFRLEVBQUU7UUFDL0UsT0FBTyxVQUFVQSxXQUFXLGdCQUFpQkEsQ0FBQUEsYUFBYSxJQUFJLEtBQUssR0FBRztJQUMxRTtBQUFFO0FBQ04sU0FBU0MsbUJBQW1CQyxrQkFBa0IsRUFBRTtJQUM1QyxJQUFJQyxjQUFjRCxtQkFBbUI1aUMsTUFBTSxHQUFHLElBQUk0aUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDTCxJQUFJLEdBQUcsSUFBSTtJQUNuRixJQUFJTyxnQkFBZ0JULGNBQWM1MkIsTUFBTSxDQUFDbTNCO0lBQ3pDLElBQUlHLGVBQWU7UUFDZkMsSUFBSVA7SUFDUjtJQUNBLElBQUssSUFBSXQxQixLQUFLLEdBQUc4MUIsa0JBQWtCSCxlQUFlMzFCLEtBQUs4MUIsZ0JBQWdCampDLE1BQU0sRUFBRW1OLEtBQU07UUFDakYsSUFBSSsxQixZQUFZRCxlQUFlLENBQUM5MUIsR0FBRztRQUNuQzQxQixZQUFZLENBQUNHLFVBQVVYLElBQUksQ0FBQyxHQUFHVztJQUNuQztJQUNBLE9BQU87UUFDSHR5QixLQUFLbXlCO1FBQ0xGLGFBQWFBO0lBQ2pCO0FBQ0o7QUFDQSxTQUFTTSxZQUFZQyxhQUFhLEVBQUVDLFNBQVMsRUFBRTtJQUMzQyxJQUFJLE9BQU9ELGtCQUFrQixZQUFZLENBQUN6K0IsTUFBTUMsT0FBTyxDQUFDdytCLGdCQUFnQjtRQUNwRSxPQUFPRSxZQUFZRixjQUFjYixJQUFJLEVBQUU7WUFBQ2EsY0FBY2IsSUFBSTtTQUFDLEVBQUVhO0lBQ2pFLENBQUM7SUFDRCxPQUFPRyxZQUFZSCxlQUFlQztBQUN0QztBQUNBLFNBQVNFLFlBQVlDLE9BQU8sRUFBRUgsU0FBUyxFQUFFO0lBQ3JDLElBQUlocUIsUUFBUSxFQUFFLENBQUM1TixNQUFNLENBQUMrM0IsV0FBVyxFQUFFLEdBQUcsd0JBQXdCO0lBQzlELElBQUkxYSxNQUFNMmEsZUFBZXBxQixPQUFPZ3FCLGNBQWNaO0lBQzlDLE9BQU9hLFlBQVlFLFNBQVNucUIsT0FBT3lQO0FBQ3ZDO0FBQ0EsU0FBUzJhLGVBQWVwcUIsS0FBSyxFQUFFZ3FCLFNBQVMsRUFBRTtJQUN0QyxJQUFLLElBQUl0akMsSUFBSSxHQUFHQSxJQUFJc1osTUFBTXJaLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3RDLElBQUlpYSxRQUFRWCxLQUFLLENBQUN0WixFQUFFLENBQUM0WixpQkFBaUIsR0FBR2pWLEtBQUssQ0FBQztRQUMvQyxJQUFLLElBQUl4RSxJQUFJOFosTUFBTWhhLE1BQU0sRUFBRUUsSUFBSSxHQUFHQSxLQUFLLEVBQUc7WUFDdEMsSUFBSXdqQyxXQUFXMXBCLE1BQU0ycEIsS0FBSyxDQUFDLEdBQUd6akMsR0FBR2thLElBQUksQ0FBQztZQUN0QyxJQUFJaXBCLFNBQVMsQ0FBQ0ssU0FBUyxFQUFFO2dCQUNyQixPQUFPTCxTQUFTLENBQUNLLFNBQVM7WUFDOUIsQ0FBQztRQUNMO0lBQ0o7SUFDQSxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVNKLFlBQVlFLE9BQU8sRUFBRW5xQixLQUFLLEVBQUV5UCxHQUFHLEVBQUU7SUFDdEMsSUFBSThhLFNBQVN4M0IsV0FBVztRQUFDazJCO1FBQXVCeFo7S0FBSSxFQUFFO1FBQUM7S0FBYTtJQUNwRSxPQUFPOGEsT0FBT3JCLElBQUksRUFBRSxzQ0FBc0M7SUFDMUQsSUFBSXR3QixPQUFPMnhCLE9BQU8zeEIsSUFBSTtJQUN0QixPQUFPMnhCLE9BQU8zeEIsSUFBSTtJQUNsQixPQUFPO1FBQ0h1eEIsU0FBU0E7UUFDVG5xQixPQUFPQTtRQUNQcEgsTUFBTUE7UUFDTmdJLG9CQUFvQixJQUFJZCxLQUFLMHFCLFlBQVksQ0FBQ0w7UUFDMUM5ekIsU0FBU2swQjtJQUNiO0FBQ0o7QUFFQSxTQUFTdkgsV0FBV3lILFNBQVMsRUFBRXAwQixPQUFPLEVBQUU7SUFDcEMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFBRUEsVUFBVSxDQUFDO0lBQUcsQ0FBQztJQUN6QyxJQUFJYixVQUFVazFCLGVBQWVyMEI7SUFDN0IsSUFBSXhKLFlBQVk2VixnQkFBZ0JyTTtJQUNoQyxJQUFJczBCLFdBQVduMUIsUUFBUTRlLGdCQUFnQixDQUFDcVc7SUFDeEMsSUFBSSxDQUFDRSxVQUFVO1FBQ1gsT0FBTztJQUNYLENBQUM7SUFDRCxPQUFPbjFCLFFBQVF0USxNQUFNLENBQUN5bEMsU0FBU242QixNQUFNLEVBQUUzRCxXQUFXO1FBQzlDeW5CLFdBQVdxVyxTQUFTclcsU0FBUztJQUNqQztBQUNKO0FBQ0EsU0FBU3JXLFlBQVlrVyxVQUFVLEVBQUV5UixRQUFRLEVBQUV2dkIsT0FBTyxFQUFFO0lBQ2hELElBQUliLFVBQVVrMUIsZUFBZSxPQUFPcjBCLFlBQVksWUFBWUEsVUFBVUEsVUFBVSxDQUFDLENBQUMsR0FBRyw2QkFBNkI7SUFDbEgsSUFBSXhKLFlBQVk2VixnQkFBZ0JyTTtJQUNoQyxJQUFJMGQsWUFBWXZlLFFBQVE0ZSxnQkFBZ0IsQ0FBQ0Q7SUFDekMsSUFBSUYsVUFBVXplLFFBQVE0ZSxnQkFBZ0IsQ0FBQ3dSO0lBQ3ZDLElBQUksQ0FBQzdSLGFBQWEsQ0FBQ0UsU0FBUztRQUN4QixPQUFPO0lBQ1gsQ0FBQztJQUNELE9BQU96ZSxRQUFReUksV0FBVyxDQUFDOFYsVUFBVXZqQixNQUFNLEVBQUV5akIsUUFBUXpqQixNQUFNLEVBQUUzRCxXQUFXO1FBQ3BFOEYsZ0JBQWdCb2hCLFVBQVVPLFNBQVM7UUFDbkMxaEIsY0FBY3FoQixRQUFRSyxTQUFTO1FBQy9Cb1UsZ0JBQWdCcnlCLFFBQVFxeUIsY0FBYztRQUN0QzFwQixrQkFBa0I0TixxQkFBcUIvSSxxQkFBcUI7SUFDaEU7QUFDSjtBQUNBLCtCQUErQjtBQUMvQixTQUFTNm1CLGVBQWV6SCxRQUFRLEVBQUU7SUFDOUIsSUFBSXhqQixTQUFTcXFCLFlBQVk3RyxTQUFTeGpCLE1BQU0sSUFBSSxNQUFNNnBCLG1CQUFtQixFQUFFLEVBQUUveEIsR0FBRyxHQUFHLHVDQUF1QztJQUN0SCxPQUFPLElBQUlnd0IsUUFBUWprQywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUM7UUFBRXNjLFVBQVVnTixxQkFBcUJoTixRQUFRO1FBQUV2QixnQkFBZ0I7SUFBVSxHQUFHNGtCLFdBQVc7UUFBRXhqQixRQUFRQTtJQUFPO0FBQzdJO0FBRUEsSUFBSW1yQixlQUFlO0lBQ2ZDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxZQUFZO1FBQUM7UUFBRztRQUFHO1FBQUc7UUFBRztLQUFFO0lBQzNCcnFCLFNBQVM7SUFDVHNPLFlBQVk7SUFDWjZCLFNBQVM7QUFDYjtBQUNBOztBQUVBLEdBQ0EsU0FBU21hLG1CQUFtQi8vQixLQUFLLEVBQUVqSCxPQUFPLEVBQUU7SUFDeEMsT0FBTzByQixZQUFZdWIsYUFBYWhnQyxRQUFRLElBQUksRUFBRWpIO0FBQ2xEO0FBQ0EsU0FBU2luQyxhQUFhaGdDLEtBQUssRUFBRTtJQUN6QixJQUFJaWdDO0lBQ0osSUFBSWpnQyxVQUFVLElBQUksRUFBRTtRQUNoQmlnQyxVQUFVO1lBQUMsQ0FBQztTQUFFLEVBQUUsaUNBQWlDO0lBQ3JELE9BQ0ssSUFBSTUvQixNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDM0IsbUVBQW1FO1FBQ25FaWdDLFVBQVVqZ0MsTUFBTWtnQyxNQUFNLENBQUMsU0FBVUMsTUFBTSxFQUFFO1lBQUUsT0FBT0EsT0FBT0wsVUFBVTtRQUFFO0lBQ3pFLE9BQ0ssSUFBSSxPQUFPOS9CLFVBQVUsWUFBWUEsT0FBTztRQUN6Q2lnQyxVQUFVO1lBQUNqZ0M7U0FBTTtJQUNyQixPQUNLO1FBQ0RpZ0MsVUFBVSxFQUFFO0lBQ2hCLENBQUM7SUFDREEsVUFBVUEsUUFBUTN6QixHQUFHLENBQUMsU0FBVTZ6QixNQUFNLEVBQUU7UUFBRSxPQUFROW5DLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdzbkMsZUFBZVE7SUFBVTtJQUNqRyxPQUFPRjtBQUNYO0FBRUEsU0FBU0csZ0JBQWdCQyxLQUFLLEVBQUVDLElBQUksRUFBRTtJQUNsQyxPQUFPRCxNQUFNRSxJQUFJLElBQUlELEtBQUtDLElBQUksSUFDMUJGLE1BQU1FLElBQUksR0FBR0QsS0FBS0UsS0FBSyxJQUN2QkgsTUFBTUksR0FBRyxJQUFJSCxLQUFLRyxHQUFHLElBQ3JCSixNQUFNSSxHQUFHLEdBQUdILEtBQUtJLE1BQU07QUFDL0I7QUFDQSxpSEFBaUg7QUFDakgsU0FBU0MsZUFBZUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7SUFDbEMsSUFBSTEyQixNQUFNO1FBQ05vMkIsTUFBTWo4QixLQUFLd08sR0FBRyxDQUFDOHRCLE1BQU1MLElBQUksRUFBRU0sTUFBTU4sSUFBSTtRQUNyQ0MsT0FBT2w4QixLQUFLd0IsR0FBRyxDQUFDODZCLE1BQU1KLEtBQUssRUFBRUssTUFBTUwsS0FBSztRQUN4Q0MsS0FBS244QixLQUFLd08sR0FBRyxDQUFDOHRCLE1BQU1ILEdBQUcsRUFBRUksTUFBTUosR0FBRztRQUNsQ0MsUUFBUXA4QixLQUFLd0IsR0FBRyxDQUFDODZCLE1BQU1GLE1BQU0sRUFBRUcsTUFBTUgsTUFBTTtJQUMvQztJQUNBLElBQUl2MkIsSUFBSW8yQixJQUFJLEdBQUdwMkIsSUFBSXEyQixLQUFLLElBQUlyMkIsSUFBSXMyQixHQUFHLEdBQUd0MkIsSUFBSXUyQixNQUFNLEVBQUU7UUFDOUMsT0FBT3YyQjtJQUNYLENBQUM7SUFDRCxPQUFPLEtBQUs7QUFDaEI7QUFDQSxTQUFTMjJCLGNBQWNSLElBQUksRUFBRVMsTUFBTSxFQUFFQyxNQUFNLEVBQUU7SUFDekMsT0FBTztRQUNIVCxNQUFNRCxLQUFLQyxJQUFJLEdBQUdRO1FBQ2xCUCxPQUFPRixLQUFLRSxLQUFLLEdBQUdPO1FBQ3BCTixLQUFLSCxLQUFLRyxHQUFHLEdBQUdPO1FBQ2hCTixRQUFRSixLQUFLSSxNQUFNLEdBQUdNO0lBQzFCO0FBQ0o7QUFDQSxxRkFBcUY7QUFDckYsU0FBU0MsZUFBZVosS0FBSyxFQUFFQyxJQUFJLEVBQUU7SUFDakMsT0FBTztRQUNIQyxNQUFNajhCLEtBQUt3QixHQUFHLENBQUN4QixLQUFLd08sR0FBRyxDQUFDdXRCLE1BQU1FLElBQUksRUFBRUQsS0FBS0MsSUFBSSxHQUFHRCxLQUFLRSxLQUFLO1FBQzFEQyxLQUFLbjhCLEtBQUt3QixHQUFHLENBQUN4QixLQUFLd08sR0FBRyxDQUFDdXRCLE1BQU1JLEdBQUcsRUFBRUgsS0FBS0csR0FBRyxHQUFHSCxLQUFLSSxNQUFNO0lBQzVEO0FBQ0o7QUFDQSw0REFBNEQ7QUFDNUQsU0FBU1EsY0FBY1osSUFBSSxFQUFFO0lBQ3pCLE9BQU87UUFDSEMsTUFBTSxDQUFDRCxLQUFLQyxJQUFJLEdBQUdELEtBQUtFLEtBQUssSUFBSTtRQUNqQ0MsS0FBSyxDQUFDSCxLQUFLRyxHQUFHLEdBQUdILEtBQUtJLE1BQU0sSUFBSTtJQUNwQztBQUNKO0FBQ0EsOEVBQThFO0FBQzlFLFNBQVNTLFdBQVdDLE1BQU0sRUFBRUMsTUFBTSxFQUFFO0lBQ2hDLE9BQU87UUFDSGQsTUFBTWEsT0FBT2IsSUFBSSxHQUFHYyxPQUFPZCxJQUFJO1FBQy9CRSxLQUFLVyxPQUFPWCxHQUFHLEdBQUdZLE9BQU9aLEdBQUc7SUFDaEM7QUFDSjtBQUVBLElBQUlhO0FBQ0osU0FBU0Msd0JBQXdCO0lBQzdCLElBQUlELHNCQUFzQixJQUFJLEVBQUU7UUFDNUJBLHFCQUFxQkU7SUFDekIsQ0FBQztJQUNELE9BQU9GO0FBQ1g7QUFDQSxTQUFTRSw0QkFBNEI7SUFDakMsa0VBQWtFO0lBQ2xFLHFGQUFxRjtJQUNyRixJQUFJLE9BQU8vbUMsYUFBYSxhQUFhO1FBQ2pDLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxJQUFJTixLQUFLTSxTQUFTOUIsYUFBYSxDQUFDO0lBQ2hDd0IsR0FBR3dDLEtBQUssQ0FBQzhrQyxRQUFRLEdBQUc7SUFDcEJ0bkMsR0FBR3dDLEtBQUssQ0FBQzhqQyxHQUFHLEdBQUc7SUFDZnRtQyxHQUFHd0MsS0FBSyxDQUFDNGpDLElBQUksR0FBRztJQUNoQnBtQyxHQUFHdW5DLFNBQVMsR0FBRztJQUNmdm5DLEdBQUd3SSxhQUFhLENBQUMsU0FBU2hHLEtBQUssQ0FBQ29mLE1BQU0sR0FBRztJQUN6QzVoQixHQUFHd0ksYUFBYSxDQUFDLE9BQU9oRyxLQUFLLENBQUNvZixNQUFNLEdBQUc7SUFDdkN0aEIsU0FBUzhFLElBQUksQ0FBQ29pQyxXQUFXLENBQUN4bkM7SUFDMUIsSUFBSXluQyxNQUFNem5DLEdBQUd3SSxhQUFhLENBQUM7SUFDM0IsSUFBSWsvQixXQUFXRCxJQUFJRSxZQUFZLEdBQUc7SUFDbENybkMsU0FBUzhFLElBQUksQ0FBQ2xGLFdBQVcsQ0FBQ0Y7SUFDMUIsT0FBTzBuQztBQUNYO0FBRUEsSUFBSUUsb0JBQW9CbGQseUJBQXlCLDJDQUEyQztBQUM1RixJQUFJbWQsV0FBVyxXQUFXLEdBQUksV0FBWTtJQUN0QyxTQUFTQSxXQUFXO1FBQ2hCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc3eEIsUUFBUSxJQUFJLENBQUM4eEIsb0JBQW9CO1FBQzVELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcveEIsUUFBUSxJQUFJLENBQUNneUIsY0FBYztRQUNyRCxJQUFJLENBQUNDLGVBQWUsR0FBR2p5QixRQUFRLElBQUksQ0FBQ2t5QixnQkFBZ0I7UUFDcEQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR255QixRQUFRLElBQUksQ0FBQ295QixrQkFBa0I7UUFDeEQsSUFBSSxDQUFDQyxjQUFjLEdBQUdyeUIsUUFBUSxJQUFJLENBQUNzeUIsaUJBQWlCO1FBQ3BELElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUd2eUIsUUFBUSxJQUFJLENBQUNzeUIsaUJBQWlCO1FBQ3RELElBQUksQ0FBQ0UsZUFBZSxHQUFHLENBQUMsR0FBRyw4QkFBOEI7SUFDN0Q7SUFDQVosU0FBUy9vQyxTQUFTLENBQUM0cEMsVUFBVSxHQUFHLFNBQVV2bUMsS0FBSyxFQUFFO1FBQzdDLElBQUl1VSxRQUFRLElBQUk7UUFDaEIsSUFBSWl5QixXQUFXLElBQUksQ0FBQ0MsVUFBVSxDQUFDem1DO1FBQy9CLElBQUkwbUMsVUFBVSxJQUFJLENBQUNmLG1CQUFtQixDQUFDM2xDLE1BQU0yTyxVQUFVO1FBQ3ZELElBQUlnNEIsaUJBQWlCLElBQUksQ0FBQ2Qsa0JBQWtCLENBQUM3bEMsTUFBTTg3QixhQUFhO1FBQ2hFLElBQUk4SyxlQUFlLElBQUksQ0FBQ1gsaUJBQWlCLENBQUNqbUMsTUFBTW12QixZQUFZLEVBQUV1WCxVQUFVLHlCQUF5QjtRQUNqRyxJQUFJRyxjQUFjLElBQUksQ0FBQ2QsZUFBZSxDQUFDL2xDLE1BQU0yTyxVQUFVLEVBQUUrM0I7UUFDekQsSUFBSUksYUFBYSxJQUFJLENBQUNYLGNBQWMsQ0FBQ25tQyxNQUFNK21DLFNBQVM7UUFDcEQsSUFBSUMsZUFBZSxJQUFJLENBQUNYLGdCQUFnQixDQUFDcm1DLE1BQU1pbkMsV0FBVztRQUMxRCxJQUFJVixhQUFhLENBQUM7UUFDbEIsSUFBSSxDQUFDRCxlQUFlLEdBQUdsNkIsUUFBUW82QixVQUFVLFNBQVVVLElBQUksRUFBRXRrQyxHQUFHLEVBQUU7WUFBRSxPQUFPMlIsTUFBTSt4QixlQUFlLENBQUMxakMsSUFBSSxJQUFJa1IsUUFBUXF6QjtRQUFxQjtRQUNsSSxJQUFLLElBQUl2a0MsT0FBTzRqQyxTQUFVO1lBQ3RCLElBQUlZLFVBQVVaLFFBQVEsQ0FBQzVqQyxJQUFJO1lBQzNCLElBQUkrTCxhQUFhazRCLFdBQVcsQ0FBQ2prQyxJQUFJLElBQUk2aUM7WUFDckMsSUFBSTRCLGVBQWUsSUFBSSxDQUFDZixlQUFlLENBQUMxakMsSUFBSTtZQUM1QzJqQyxVQUFVLENBQUMzakMsSUFBSSxHQUFHO2dCQUNkb2QsZUFBZW9uQixRQUFRcG5CLGFBQWEsSUFBSWhnQixNQUFNZ2dCLGFBQWE7Z0JBQzNEOGIsZUFBZTZLLGNBQWMsQ0FBQy9qQyxJQUFJLElBQUksSUFBSTtnQkFDMUMrTCxZQUFZQTtnQkFDWndnQixjQUFja1ksYUFBYXJuQyxNQUFNbXZCLFlBQVksQ0FBQyxHQUFHLEVBQUVpWSxRQUFRaGIsRUFBRSxFQUFFd2EsWUFBWSxDQUFDaGtDLElBQUk7Z0JBQ2hGMGtDLGdCQUFnQjM0QixXQUFXSyxTQUFTLENBQUNoUCxNQUFNc25DLGNBQWMsQ0FBQyxHQUFHdG5DLE1BQU1zbkMsY0FBYyxHQUFHLEVBQUU7Z0JBQ3RGUCxXQUFXRCxVQUFVLENBQUNsa0MsSUFBSSxJQUFJLElBQUk7Z0JBQ2xDcWtDLGFBQWFELFlBQVksQ0FBQ3BrQyxJQUFJLElBQUksSUFBSTtZQUMxQztRQUNKO1FBQ0EsT0FBTzJqQztJQUNYO0lBQ0FiLFNBQVMvb0MsU0FBUyxDQUFDbXBDLGNBQWMsR0FBRyxTQUFVelEsUUFBUSxFQUFFO1FBQ3BELElBQUlrUyxZQUFZLENBQUM7UUFDakIsSUFBSWxTLFVBQVU7WUFDVixJQUFJcm9CLE9BQU8sSUFBSSxDQUFDdzZCLGtCQUFrQixDQUFDblM7WUFDbkMsSUFBSyxJQUFJOW9CLEtBQUssR0FBR2s3QixTQUFTejZCLE1BQU1ULEtBQUtrN0IsT0FBT3JvQyxNQUFNLEVBQUVtTixLQUFNO2dCQUN0RCxJQUFJM0osTUFBTTZrQyxNQUFNLENBQUNsN0IsR0FBRztnQkFDcEJnN0IsU0FBUyxDQUFDM2tDLElBQUksR0FBR3l5QjtZQUNyQjtRQUNKLENBQUM7UUFDRCxPQUFPa1M7SUFDWDtJQUNBN0IsU0FBUy9vQyxTQUFTLENBQUNpcEMsb0JBQW9CLEdBQUcsU0FBVWozQixVQUFVLEVBQUU7UUFDNUQsSUFBSTRGLFFBQVEsSUFBSTtRQUNoQixPQUFPbkksUUFBUXVDLFdBQVdJLElBQUksRUFBRSxTQUFVWSxRQUFRLEVBQUU7WUFBRSxPQUFPNEUsTUFBTW16QixrQkFBa0IsQ0FBQy8zQjtRQUFXO0lBQ3JHO0lBQ0ErMUIsU0FBUy9vQyxTQUFTLENBQUNxcEMsZ0JBQWdCLEdBQUcsU0FBVXIzQixVQUFVLEVBQUUrM0IsT0FBTyxFQUFFO1FBQ2pFLElBQUkzM0IsT0FBT0osV0FBV0ksSUFBSSxFQUFFQyxZQUFZTCxXQUFXSyxTQUFTO1FBQzVELElBQUkyNEIsY0FBYyxDQUFDO1FBQ25CLElBQUssSUFBSXo4QixTQUFTNkQsS0FBTTtZQUNwQixJQUFLLElBQUl4QyxLQUFLLEdBQUc5TCxLQUFLaW1DLE9BQU8sQ0FBQ3g3QixNQUFNLEVBQUVxQixLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07Z0JBQ3hELElBQUkzSixNQUFNbkMsRUFBRSxDQUFDOEwsR0FBRztnQkFDaEIsSUFBSSxDQUFDbzdCLFdBQVcsQ0FBQy9rQyxJQUFJLEVBQUU7b0JBQ25CK2tDLFdBQVcsQ0FBQy9rQyxJQUFJLEdBQUcybEI7Z0JBQ3ZCLENBQUM7Z0JBQ0RvZixXQUFXLENBQUMva0MsSUFBSSxDQUFDbU0sSUFBSSxDQUFDN0QsTUFBTSxHQUFHNkQsSUFBSSxDQUFDN0QsTUFBTTtZQUM5QztRQUNKO1FBQ0EsSUFBSyxJQUFJSSxjQUFjMEQsVUFBVztZQUM5QixJQUFJQyxXQUFXRCxTQUFTLENBQUMxRCxXQUFXO1lBQ3BDLElBQUssSUFBSTVLLEtBQUssR0FBR2tuQyxLQUFLbEIsT0FBTyxDQUFDejNCLFNBQVMvRCxLQUFLLENBQUMsRUFBRXhLLEtBQUtrbkMsR0FBR3hvQyxNQUFNLEVBQUVzQixLQUFNO2dCQUNqRSxJQUFJa0MsTUFBTWdsQyxFQUFFLENBQUNsbkMsR0FBRztnQkFDaEIsSUFBSWluQyxXQUFXLENBQUMva0MsSUFBSSxFQUFFO29CQUNsQitrQyxXQUFXLENBQUMva0MsSUFBSSxDQUFDb00sU0FBUyxDQUFDMUQsV0FBVyxHQUFHMkQ7Z0JBQzdDLENBQUM7WUFDTDtRQUNKO1FBQ0EsT0FBTzA0QjtJQUNYO0lBQ0FqQyxTQUFTL29DLFNBQVMsQ0FBQ3VwQyxrQkFBa0IsR0FBRyxTQUFVL1csWUFBWSxFQUFFdVgsT0FBTyxFQUFFO1FBQ3JFLElBQUltQixjQUFjLENBQUM7UUFDbkIsSUFBSyxJQUFJMzhCLFNBQVNpa0IsYUFBYztZQUM1QixJQUFJamtCLE9BQU87Z0JBQ1AsSUFBSyxJQUFJcUIsS0FBSyxHQUFHOUwsS0FBS2ltQyxPQUFPLENBQUN4N0IsTUFBTSxFQUFFcUIsS0FBSzlMLEdBQUdyQixNQUFNLEVBQUVtTixLQUFNO29CQUN4RCxJQUFJM0osTUFBTW5DLEVBQUUsQ0FBQzhMLEdBQUc7b0JBQ2hCLElBQUksQ0FBQ3M3QixXQUFXLENBQUNqbEMsSUFBSSxFQUFFO3dCQUNuQmlsQyxXQUFXLENBQUNqbEMsSUFBSSxHQUFHLENBQUM7b0JBQ3hCLENBQUM7b0JBQ0RpbEMsV0FBVyxDQUFDamxDLElBQUksQ0FBQ3NJLE1BQU0sR0FBR2lrQixZQUFZLENBQUNqa0IsTUFBTTtnQkFDakQ7WUFDSixDQUFDO1FBQ0w7UUFDQSxPQUFPMjhCO0lBQ1g7SUFDQW5DLFNBQVMvb0MsU0FBUyxDQUFDeXBDLGlCQUFpQixHQUFHLFNBQVUwQixXQUFXLEVBQUU7UUFDMUQsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUlELGFBQWE7WUFDYixJQUFJRSxtQkFBbUIsSUFBSSxDQUFDaEMsZ0JBQWdCLENBQUM4QixZQUFZRyxjQUFjLEVBQUUsSUFBSSxDQUFDckMsb0JBQW9CLENBQUNrQyxZQUFZRyxjQUFjO1lBQzdILHNEQUFzRDtZQUN0RCxJQUFJQyxxQkFBcUIsSUFBSSxDQUFDdEMsb0JBQW9CLENBQUNrQyxZQUFZSyxhQUFhO1lBQzVFLElBQUlDLGtCQUFrQixJQUFJLENBQUNwQyxnQkFBZ0IsQ0FBQzhCLFlBQVlLLGFBQWEsRUFBRUQ7WUFDdkUsSUFBSUcsV0FBVyxTQUFVemxDLEdBQUcsRUFBRTtnQkFDMUIsSUFBSSxDQUFDbWxDLFdBQVcsQ0FBQ25sQyxJQUFJLEVBQUU7b0JBQ25CbWxDLFdBQVcsQ0FBQ25sQyxJQUFJLEdBQUc7d0JBQ2ZxbEMsZ0JBQWdCRCxnQkFBZ0IsQ0FBQ3BsQyxJQUFJLElBQUk2aUM7d0JBQ3pDMEMsZUFBZUMsZUFBZSxDQUFDeGxDLElBQUksSUFBSTZpQzt3QkFDdkM2QyxTQUFTUixZQUFZUSxPQUFPO29CQUNoQztnQkFDSixDQUFDO1lBQ0w7WUFDQSxJQUFLLElBQUkxbEMsT0FBT29sQyxpQkFBa0I7Z0JBQzlCSyxTQUFTemxDO1lBQ2I7WUFDQSxJQUFLLElBQUlBLE9BQU93bEMsZ0JBQWlCO2dCQUM3QkMsU0FBU3psQztZQUNiO1FBQ0osQ0FBQztRQUNELE9BQU9tbEM7SUFDWDtJQUNBLE9BQU9yQztBQUNYO0FBQ0EsU0FBU3lCLG1CQUFtQm9CLEtBQUssRUFBRUMsYUFBYSxFQUFFNUIsWUFBWSxFQUFFO0lBQzVELElBQUk2QixZQUFZLEVBQUU7SUFDbEIsSUFBSUYsT0FBTztRQUNQRSxVQUFVbHBDLElBQUksQ0FBQ2dwQztJQUNuQixDQUFDO0lBQ0QsSUFBSUMsZUFBZTtRQUNmQyxVQUFVbHBDLElBQUksQ0FBQ2lwQztJQUNuQixDQUFDO0lBQ0QsSUFBSUUsUUFBUTtRQUNSLElBQUl6ZCxnQkFBZ0J3ZDtJQUN4QjtJQUNBLElBQUk3QixjQUFjO1FBQ2Q3cUMsK0NBQVFBLENBQUMyc0MsT0FBTzlCO0lBQ3BCLENBQUM7SUFDRCxPQUFPOEI7QUFDWDtBQUVBLFNBQVNDLFlBQVl6K0IsSUFBSSxFQUFFdW9CLFVBQVUsRUFBRUMsT0FBTyxFQUFFd0UsV0FBVyxFQUFFO0lBQ3pELE9BQU87UUFDSGh1QixLQUFLZ0IsS0FBS0YsU0FBUztRQUNuQjQrQixZQUFZOXNCLFFBQVFvYixlQUFlLENBQUNsSSxvQkFBb0JrSSxZQUFZQyxXQUFXLEVBQUVqdEI7UUFDakYyK0IsU0FBUy9zQixRQUFRb2IsZUFBZSxDQUFDbEksb0JBQW9Ca0ksWUFBWUUsWUFBWSxFQUFFbHRCO1FBQy9FNG9CLFNBQVNoWCxRQUFRMlcsY0FBY3pELG9CQUFvQnlELFlBQVl2b0I7UUFDL0Qwb0IsUUFBUTlXLFFBQVE0VyxVQUFXeG9CLE9BQU93b0IsVUFBV0QsYUFBY3ZvQixPQUFPdW9CLFdBQVdoakIsS0FBSyxHQUFJLEtBQUs7UUFDM0ZvakIsVUFBVS9XLFFBQVE0VyxVQUFXeG9CLE9BQU93b0IsVUFBV0QsYUFBY3ZvQixRQUFRdW9CLFdBQVcvaUIsR0FBRyxHQUFJLEtBQUs7SUFDaEc7QUFDSjtBQUNBLFNBQVNvNUIsaUJBQWlCcnJDLElBQUksRUFBRXNyQyxLQUFLLEVBQUU7SUFDbkMsSUFBSXRoQixhQUFhO1FBQ2I7UUFDQSxZQUFZL2dCLE9BQU8sQ0FBQ2pKLEtBQUt5TCxHQUFHLENBQUM7S0FDaEM7SUFDRCxJQUFJekwsS0FBS21yQyxVQUFVLEVBQUU7UUFDakJuaEIsV0FBV2xvQixJQUFJLENBQUM7SUFDcEIsT0FDSztRQUNELElBQUk5QixLQUFLcTFCLE9BQU8sRUFBRTtZQUNkckwsV0FBV2xvQixJQUFJLENBQUM7WUFDaEJrb0IsV0FBV2xvQixJQUFJLENBQUN3cEMsTUFBTUMsUUFBUSxDQUFDO1FBQ25DLENBQUM7UUFDRCxJQUFJdnJDLEtBQUttMUIsTUFBTSxFQUFFO1lBQ2JuTCxXQUFXbG9CLElBQUksQ0FBQztRQUNwQixDQUFDO1FBQ0QsSUFBSTlCLEtBQUtvMUIsUUFBUSxFQUFFO1lBQ2ZwTCxXQUFXbG9CLElBQUksQ0FBQztRQUNwQixDQUFDO1FBQ0QsSUFBSTlCLEtBQUtvckMsT0FBTyxFQUFFO1lBQ2RwaEIsV0FBV2xvQixJQUFJLENBQUM7UUFDcEIsQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPa29CO0FBQ1g7QUFDQSxTQUFTd2hCLGtCQUFrQnhyQyxJQUFJLEVBQUVzckMsS0FBSyxFQUFFO0lBQ3BDLElBQUl0aEIsYUFBYTtRQUNiO1FBQ0EsYUFBYS9nQixPQUFPLENBQUNqSixLQUFLeUwsR0FBRyxDQUFDO0tBQ2pDO0lBQ0QsSUFBSXpMLEtBQUttckMsVUFBVSxFQUFFO1FBQ2pCbmhCLFdBQVdsb0IsSUFBSSxDQUFDO0lBQ3BCLE9BQ0s7UUFDRCxJQUFJOUIsS0FBS3ExQixPQUFPLEVBQUU7WUFDZHJMLFdBQVdsb0IsSUFBSSxDQUFDO1lBQ2hCa29CLFdBQVdsb0IsSUFBSSxDQUFDd3BDLE1BQU1DLFFBQVEsQ0FBQztRQUNuQyxDQUFDO1FBQ0QsSUFBSXZyQyxLQUFLbTFCLE1BQU0sRUFBRTtZQUNibkwsV0FBV2xvQixJQUFJLENBQUM7UUFDcEIsQ0FBQztRQUNELElBQUk5QixLQUFLbzFCLFFBQVEsRUFBRTtZQUNmcEwsV0FBV2xvQixJQUFJLENBQUM7UUFDcEIsQ0FBQztJQUNMLENBQUM7SUFDRCxPQUFPa29CO0FBQ1g7QUFFQSxJQUFJeWhCLGFBQWEvdEIsZ0JBQWdCO0lBQUUxUixNQUFNO0lBQVdpSCxPQUFPO0lBQVFDLEtBQUs7QUFBVTtBQUNsRixJQUFJdzRCLGNBQWNodUIsZ0JBQWdCO0lBQUU5SixNQUFNO0FBQU87QUFDakQsU0FBUyszQixrQkFBa0Izc0MsT0FBTyxFQUFFZzhCLFVBQVUsRUFBRXVCLFFBQVEsRUFBRXFQLFVBQVUsRUFBRTtJQUNsRSxJQUFJclAsYUFBYSxLQUFLLEdBQUc7UUFBRUEsV0FBVztJQUFPLENBQUM7SUFDOUMsSUFBSXFQLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWEsSUFBSTtJQUFFLENBQUM7SUFDakQsSUFBSXA3QixVQUFVeFIsUUFBUXdSLE9BQU8sRUFBRWEsVUFBVXJTLFFBQVFxUyxPQUFPLEVBQUU2bUIsY0FBY2w1QixRQUFRazVCLFdBQVc7SUFDM0YsSUFBSTJULFVBQVVyN0IsUUFBUXRRLE1BQU0sQ0FBQzg2QixZQUFZdUIsYUFBYSxTQUFTbVAsY0FBY0QsVUFBVTtJQUN2RixJQUFJcDZCLFFBQVFpVSxRQUFRLEVBQUU7UUFDbEIsSUFBSXdtQixZQUFZdDdCLFFBQVErbUIsTUFBTSxDQUFDeUQ7UUFDL0IsSUFBSStRLG9CQUFvQixTQUFVaHBDLEVBQUUsRUFBRTtZQUNsQyxJQUFJaXBDLGVBQWV6UCxhQUFhLFFBQVFsckIsUUFBUXVNLGVBQWUsR0FDM0QyZSxhQUFhLFNBQVNsckIsUUFBUXlNLGdCQUFnQixHQUFHLElBQUk7WUFDekQsSUFBSSxPQUFPa3VCLGlCQUFpQixZQUFZO2dCQUNwQ0EsYUFBYTVxQyxJQUFJLENBQUM4MkIsYUFBYTFuQixRQUFRK21CLE1BQU0sQ0FBQ3lELGFBQWFqNEI7WUFDL0QsT0FDSztnQkFDRCxJQUFJLE9BQU9pcEMsaUJBQWlCLFVBQVU7b0JBQ2xDelAsV0FBV3lQO2dCQUNmLENBQUM7Z0JBQ0Q5VCxZQUFZdUUsTUFBTSxDQUFDekIsWUFBWXVCO1lBQ25DLENBQUM7UUFDTDtRQUNBLE9BQU9qK0IsK0NBQVFBLENBQUM7WUFBRXl2QixPQUFPbm1CLG1CQUFtQnlKLFFBQVE4VixXQUFXLEVBQUU7Z0JBQUMwa0I7Z0JBQVNDO2FBQVUsRUFBRUQ7WUFBVSxnQkFBZ0I7UUFBRyxHQUFJRCxhQUNsSDltQyxxQkFBcUJpbkMscUJBQ3JCO1lBQUVobkMsU0FBU2duQztRQUFrQixDQUFDO0lBQ3hDLENBQUM7SUFDRCxPQUFPO1FBQUUsY0FBY0Y7SUFBUTtBQUNuQztBQUVBLElBQUlJLHdCQUF3QixJQUFJO0FBQ2hDLFNBQVNDLDBCQUEwQjtJQUMvQixJQUFJRCwwQkFBMEIsSUFBSSxFQUFFO1FBQ2hDQSx3QkFBd0JFO0lBQzVCLENBQUM7SUFDRCxPQUFPRjtBQUNYO0FBQ0EsU0FBU0UsOEJBQThCO0lBQ25DLElBQUlDLFVBQVUxckMsU0FBUzlCLGFBQWEsQ0FBQztJQUNyQzBELFdBQVc4cEMsU0FBUztRQUNoQjFFLFVBQVU7UUFDVmhCLEtBQUssQ0FBQztRQUNORixNQUFNO1FBQ042RixRQUFRO1FBQ1JDLFNBQVM7UUFDVEMsVUFBVTtRQUNWMXdCLFdBQVc7SUFDZjtJQUNBdXdCLFFBQVF6RSxTQUFTLEdBQUc7SUFDcEJqbkMsU0FBUzhFLElBQUksQ0FBQ29pQyxXQUFXLENBQUN3RTtJQUMxQixJQUFJSSxVQUFVSixRQUFRSyxVQUFVO0lBQ2hDLElBQUlyOEIsTUFBTW84QixRQUFRempDLHFCQUFxQixHQUFHeTlCLElBQUksR0FBRzRGLFFBQVFyakMscUJBQXFCLEdBQUd5OUIsSUFBSTtJQUNyRnJtQyxjQUFjaXNDO0lBQ2QsT0FBT2g4QjtBQUNYO0FBRUEsSUFBSXM4QjtBQUNKLFNBQVNDLHFCQUFxQjtJQUMxQixJQUFJLENBQUNELGtCQUFrQjtRQUNuQkEsbUJBQW1CRTtJQUN2QixDQUFDO0lBQ0QsT0FBT0Y7QUFDWDtBQUNBLFNBQVNFLHlCQUF5QjtJQUM5QixJQUFJeHNDLEtBQUtNLFNBQVM5QixhQUFhLENBQUM7SUFDaEN3QixHQUFHd0MsS0FBSyxDQUFDMnBDLFFBQVEsR0FBRztJQUNwQm5zQyxHQUFHd0MsS0FBSyxDQUFDOGtDLFFBQVEsR0FBRztJQUNwQnRuQyxHQUFHd0MsS0FBSyxDQUFDOGpDLEdBQUcsR0FBRztJQUNmdG1DLEdBQUd3QyxLQUFLLENBQUM0akMsSUFBSSxHQUFHO0lBQ2hCOWxDLFNBQVM4RSxJQUFJLENBQUNvaUMsV0FBVyxDQUFDeG5DO0lBQzFCLElBQUlnUSxNQUFNeThCLDRCQUE0QnpzQztJQUN0Q00sU0FBUzhFLElBQUksQ0FBQ2xGLFdBQVcsQ0FBQ0Y7SUFDMUIsT0FBT2dRO0FBQ1g7QUFDQSwrQkFBK0I7QUFDL0IsU0FBU3k4Qiw0QkFBNEJ6c0MsRUFBRSxFQUFFO0lBQ3JDLE9BQU87UUFDSDBzQyxHQUFHMXNDLEdBQUcybkMsWUFBWSxHQUFHM25DLEdBQUcyc0MsWUFBWTtRQUNwQ3BoQyxHQUFHdkwsR0FBRzRzQyxXQUFXLEdBQUc1c0MsR0FBRzZzQyxXQUFXO0lBQ3RDO0FBQ0o7QUFFQSxTQUFTQyxhQUFhOXNDLEVBQUUsRUFBRStzQyxVQUFVLEVBQUU7SUFDbEMsSUFBSUEsZUFBZSxLQUFLLEdBQUc7UUFBRUEsYUFBYSxLQUFLO0lBQUUsQ0FBQztJQUNsRCxJQUFJQyxnQkFBZ0JDLE9BQU9DLGdCQUFnQixDQUFDbHRDO0lBQzVDLElBQUltdEMsYUFBYXY2QixTQUFTbzZCLGNBQWNJLGVBQWUsRUFBRSxPQUFPO0lBQ2hFLElBQUlDLGNBQWN6NkIsU0FBU282QixjQUFjTSxnQkFBZ0IsRUFBRSxPQUFPO0lBQ2xFLElBQUlDLFlBQVkzNkIsU0FBU282QixjQUFjUSxjQUFjLEVBQUUsT0FBTztJQUM5RCxJQUFJQyxlQUFlNzZCLFNBQVNvNkIsY0FBY1UsaUJBQWlCLEVBQUUsT0FBTztJQUNwRSxJQUFJQyxxQkFBcUJsQiw0QkFBNEJ6c0MsS0FBSyxtQkFBbUI7SUFDN0UsSUFBSTR0QyxxQkFBcUJELG1CQUFtQnBpQyxDQUFDLEdBQUc0aEMsYUFBYUU7SUFDN0QsSUFBSVEsa0JBQWtCRixtQkFBbUJqQixDQUFDLEdBQUdhLFlBQVlFO0lBQ3pELElBQUl6OUIsTUFBTTtRQUNObTlCLFlBQVlBO1FBQ1pFLGFBQWFBO1FBQ2JFLFdBQVdBO1FBQ1hFLGNBQWNBO1FBQ2RJLGlCQUFpQkE7UUFDakJDLGVBQWU7UUFDZkMsZ0JBQWdCO0lBQ3BCO0lBQ0EsSUFBSWpDLDZCQUE2QmtCLGNBQWN2eEIsU0FBUyxLQUFLLE9BQU87UUFDaEV6TCxJQUFJODlCLGFBQWEsR0FBR0Y7SUFDeEIsT0FDSztRQUNENTlCLElBQUkrOUIsY0FBYyxHQUFHSDtJQUN6QixDQUFDO0lBQ0QsSUFBSWIsWUFBWTtRQUNaLzhCLElBQUlnK0IsV0FBVyxHQUFHcDdCLFNBQVNvNkIsY0FBY2dCLFdBQVcsRUFBRSxPQUFPO1FBQzdEaCtCLElBQUlpK0IsWUFBWSxHQUFHcjdCLFNBQVNvNkIsY0FBY2lCLFlBQVksRUFBRSxPQUFPO1FBQy9EaitCLElBQUlrK0IsVUFBVSxHQUFHdDdCLFNBQVNvNkIsY0FBY2tCLFVBQVUsRUFBRSxPQUFPO1FBQzNEbCtCLElBQUltK0IsYUFBYSxHQUFHdjdCLFNBQVNvNkIsY0FBY21CLGFBQWEsRUFBRSxPQUFPO0lBQ3JFLENBQUM7SUFDRCxPQUFPbitCO0FBQ1g7QUFDQSxTQUFTbytCLGlCQUFpQnB1QyxFQUFFLEVBQUVxdUMsZUFBZSxFQUFFQyxvQkFBb0IsRUFBRTtJQUNqRSxJQUFJRCxvQkFBb0IsS0FBSyxHQUFHO1FBQUVBLGtCQUFrQixLQUFLO0lBQUUsQ0FBQztJQUM1RCxJQUFJRSxZQUFZRCx1QkFBdUJ0dUMsR0FBRzJJLHFCQUFxQixLQUFLNmxDLFlBQVl4dUMsR0FBRztJQUNuRixJQUFJeXVDLFFBQVEzQixhQUFhOXNDLElBQUlxdUM7SUFDN0IsSUFBSXIrQixNQUFNO1FBQ05vMkIsTUFBTW1JLFVBQVVuSSxJQUFJLEdBQUdxSSxNQUFNdEIsVUFBVSxHQUFHc0IsTUFBTVgsYUFBYTtRQUM3RHpILE9BQU9rSSxVQUFVbEksS0FBSyxHQUFHb0ksTUFBTXBCLFdBQVcsR0FBR29CLE1BQU1WLGNBQWM7UUFDakV6SCxLQUFLaUksVUFBVWpJLEdBQUcsR0FBR21JLE1BQU1sQixTQUFTO1FBQ3BDaEgsUUFBUWdJLFVBQVVoSSxNQUFNLEdBQUdrSSxNQUFNaEIsWUFBWSxHQUFHZ0IsTUFBTVosZUFBZTtJQUN6RTtJQUNBLElBQUlRLGlCQUFpQjtRQUNqQnIrQixJQUFJbzJCLElBQUksSUFBSXFJLE1BQU1ULFdBQVc7UUFDN0JoK0IsSUFBSXEyQixLQUFLLElBQUlvSSxNQUFNUixZQUFZO1FBQy9CaitCLElBQUlzMkIsR0FBRyxJQUFJbUksTUFBTVAsVUFBVTtRQUMzQmwrQixJQUFJdTJCLE1BQU0sSUFBSWtJLE1BQU1OLGFBQWE7SUFDckMsQ0FBQztJQUNELE9BQU9uK0I7QUFDWDtBQUNBLFNBQVN3K0IsWUFBWXh1QyxFQUFFLEVBQUU7SUFDckIsSUFBSW1tQyxPQUFPbm1DLEdBQUcySSxxQkFBcUI7SUFDbkMsT0FBTztRQUNIeTlCLE1BQU1ELEtBQUtDLElBQUksR0FBRzZHLE9BQU95QixXQUFXO1FBQ3BDcEksS0FBS0gsS0FBS0csR0FBRyxHQUFHMkcsT0FBTzBCLFdBQVc7UUFDbEN0SSxPQUFPRixLQUFLRSxLQUFLLEdBQUc0RyxPQUFPeUIsV0FBVztRQUN0Q25JLFFBQVFKLEtBQUtJLE1BQU0sR0FBRzBHLE9BQU8wQixXQUFXO0lBQzVDO0FBQ0o7QUFDQSxTQUFTQyx5QkFBeUI1dUMsRUFBRSxFQUFFO0lBQ2xDLElBQUk2dUMsa0JBQWtCQyxtQkFBbUI5dUM7SUFDekMsSUFBSW1tQyxPQUFPbm1DLEdBQUcySSxxQkFBcUI7SUFDbkMsSUFBSyxJQUFJK0YsS0FBSyxHQUFHcWdDLG9CQUFvQkYsaUJBQWlCbmdDLEtBQUtxZ0Msa0JBQWtCeHRDLE1BQU0sRUFBRW1OLEtBQU07UUFDdkYsSUFBSXNnQyxpQkFBaUJELGlCQUFpQixDQUFDcmdDLEdBQUc7UUFDMUMsSUFBSXVnQyxlQUFlekksZUFBZUwsTUFBTTZJLGVBQWVybUMscUJBQXFCO1FBQzVFLElBQUlzbUMsY0FBYztZQUNkOUksT0FBTzhJO1FBQ1gsT0FDSztZQUNELE9BQU8sSUFBSTtRQUNmLENBQUM7SUFDTDtJQUNBLE9BQU85STtBQUNYO0FBQ0EsU0FBUytJLHdCQUF3Qmx2QyxFQUFFLEVBQUU7SUFDakMsT0FBT0EsR0FBRzJJLHFCQUFxQixHQUFHaVosTUFBTSxHQUFHdXRCLGdCQUFnQm52QztBQUMvRDtBQUNBLFNBQVNtdkMsZ0JBQWdCbnZDLEVBQUUsRUFBRTtJQUN6QixJQUFJb3ZDLFdBQVduQyxPQUFPQyxnQkFBZ0IsQ0FBQ2x0QztJQUN2QyxPQUFPNFMsU0FBU3c4QixTQUFTQyxTQUFTLEVBQUUsTUFDaEN6OEIsU0FBU3c4QixTQUFTRSxZQUFZLEVBQUU7QUFDeEM7QUFDQSx5QkFBeUI7QUFDekIsU0FBU1IsbUJBQW1COXVDLEVBQUUsRUFBRTtJQUM1QixJQUFJNkIsVUFBVSxFQUFFO0lBQ2hCLE1BQU83QixjQUFjb0IsWUFBYTtRQUM5QixJQUFJNHJDLGdCQUFnQkMsT0FBT0MsZ0JBQWdCLENBQUNsdEM7UUFDNUMsSUFBSWd0QyxjQUFjMUYsUUFBUSxLQUFLLFNBQVM7WUFDcEMsS0FBTTtRQUNWLENBQUM7UUFDRCxJQUFJLGdCQUFrQjdrQyxJQUFJLENBQUN1cUMsY0FBY2IsUUFBUSxHQUFHYSxjQUFjdUMsU0FBUyxHQUFHdkMsY0FBY3dDLFNBQVMsR0FBRztZQUNwRzN0QyxRQUFRSCxJQUFJLENBQUMxQjtRQUNqQixDQUFDO1FBQ0RBLEtBQUtBLEdBQUdDLFVBQVU7SUFDdEI7SUFDQSxPQUFPNEI7QUFDWDtBQUVBLDBEQUEwRDtBQUMxRCx3RUFBd0U7QUFDeEUsOEJBQThCO0FBQzlCLGtFQUFrRTtBQUNsRSxTQUFTNHRDLFlBQVlqcEMsSUFBSSxFQUFFa3pCLE9BQU8sRUFBRUMsT0FBTyxFQUFFO0lBQ3pDLHNFQUFzRTtJQUN0RSxnRUFBZ0U7SUFDaEUsSUFBSStWLGFBQWEsS0FBSztJQUN0QixJQUFJQyxpQkFBaUIsV0FBWTtRQUM3QixJQUFJLENBQUNELFlBQVk7WUFDYkEsYUFBYSxJQUFJO1lBQ2pCaFcsUUFBUTl4QixLQUFLLENBQUMsSUFBSSxFQUFFNE8sWUFBWSx5Q0FBeUM7UUFDN0UsQ0FBQztJQUNMO0lBQ0EsSUFBSW81QixpQkFBaUIsV0FBWTtRQUM3QixJQUFJLENBQUNGLFlBQVk7WUFDYkEsYUFBYSxJQUFJO1lBQ2pCLElBQUkvVixTQUFTO2dCQUNUQSxRQUFRL3hCLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxZQUFZLHlDQUF5QztZQUM3RSxDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0EsSUFBSXhHLE1BQU14SixLQUFLbXBDLGdCQUFnQkM7SUFDL0IsSUFBSTUvQixPQUFPLE9BQU9BLElBQUk2L0IsSUFBSSxLQUFLLFlBQVk7UUFDdkM3L0IsSUFBSTYvQixJQUFJLENBQUNGLGdCQUFnQkM7SUFDN0IsQ0FBQztBQUNMO0FBRUEsSUFBSUUsVUFBVSxXQUFXLEdBQUksV0FBWTtJQUNyQyxTQUFTQSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQztRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJO0lBQzNCO0lBQ0FGLFFBQVFoeEMsU0FBUyxDQUFDbXhDLGNBQWMsR0FBRyxTQUFVRCxXQUFXLEVBQUU7UUFDdEQsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3ZCO0lBQ0FGLFFBQVFoeEMsU0FBUyxDQUFDb3hDLFVBQVUsR0FBRyxTQUFVai9CLE9BQU8sRUFBRTtRQUM5QyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQTYrQixRQUFRaHhDLFNBQVMsQ0FBQzg4QixFQUFFLEdBQUcsU0FBVTM4QixJQUFJLEVBQUVxRSxPQUFPLEVBQUU7UUFDNUM2c0MsVUFBVSxJQUFJLENBQUNKLFFBQVEsRUFBRTl3QyxNQUFNcUU7SUFDbkM7SUFDQXdzQyxRQUFRaHhDLFNBQVMsQ0FBQ205QixHQUFHLEdBQUcsU0FBVWg5QixJQUFJLEVBQUVxRSxPQUFPLEVBQUU7UUFDN0M4c0MsZUFBZSxJQUFJLENBQUNMLFFBQVEsRUFBRTl3QyxNQUFNcUU7SUFDeEM7SUFDQXdzQyxRQUFRaHhDLFNBQVMsQ0FBQ2kzQixPQUFPLEdBQUcsU0FBVTkyQixJQUFJLEVBQUU7UUFDeEMsSUFBSXlJLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSWdILEtBQUssR0FBR0EsS0FBSzhILFVBQVVqVixNQUFNLEVBQUVtTixLQUFNO1lBQzFDaEgsSUFBSSxDQUFDZ0gsS0FBSyxFQUFFLEdBQUc4SCxTQUFTLENBQUM5SCxHQUFHO1FBQ2hDO1FBQ0EsSUFBSTJoQyxtQkFBbUIsSUFBSSxDQUFDTixRQUFRLENBQUM5d0MsS0FBSyxJQUFJLEVBQUU7UUFDaEQsSUFBSXF4QyxnQkFBZ0IsSUFBSSxDQUFDci9CLE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU8sQ0FBQ2hTLEtBQUs7UUFDdEQsSUFBSTh3QyxXQUFXLEVBQUUsQ0FBQy9pQyxNQUFNLENBQUNzakMsaUJBQWlCLEVBQUUsRUFBRUQ7UUFDOUMsSUFBSyxJQUFJenRDLEtBQUssR0FBRzJ0QyxhQUFhUixVQUFVbnRDLEtBQUsydEMsV0FBV2h2QyxNQUFNLEVBQUVxQixLQUFNO1lBQ2xFLElBQUlVLFVBQVVpdEMsVUFBVSxDQUFDM3RDLEdBQUc7WUFDNUJVLFFBQVFzRSxLQUFLLENBQUMsSUFBSSxDQUFDb29DLFdBQVcsRUFBRXRvQztRQUNwQztJQUNKO0lBQ0Fvb0MsUUFBUWh4QyxTQUFTLENBQUNnM0IsV0FBVyxHQUFHLFNBQVU3MkIsSUFBSSxFQUFFO1FBQzVDLE9BQU9nZixRQUFRLElBQUssQ0FBQzh4QixRQUFRLENBQUM5d0MsS0FBSyxJQUFJLElBQUksQ0FBQzh3QyxRQUFRLENBQUM5d0MsS0FBSyxDQUFDc0MsTUFBTSxJQUM1RCxJQUFJLENBQUMwUCxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUNoUyxLQUFLO0lBQzNDO0lBQ0EsT0FBTzZ3QztBQUNYO0FBQ0EsU0FBU0ssVUFBVTloQyxJQUFJLEVBQUVwUCxJQUFJLEVBQUVxRSxPQUFPLEVBQUU7SUFDbkMrSyxDQUFBQSxJQUFJLENBQUNwUCxLQUFLLElBQUtvUCxDQUFBQSxJQUFJLENBQUNwUCxLQUFLLEdBQUcsRUFBRSxHQUMxQnlDLElBQUksQ0FBQzRCO0FBQ2Q7QUFDQSxTQUFTOHNDLGVBQWUvaEMsSUFBSSxFQUFFcFAsSUFBSSxFQUFFcUUsT0FBTyxFQUFFO0lBQ3pDLElBQUlBLFNBQVM7UUFDVCxJQUFJK0ssSUFBSSxDQUFDcFAsS0FBSyxFQUFFO1lBQ1pvUCxJQUFJLENBQUNwUCxLQUFLLEdBQUdvUCxJQUFJLENBQUNwUCxLQUFLLENBQUM4bUMsTUFBTSxDQUFDLFNBQVV2L0IsSUFBSSxFQUFFO2dCQUFFLE9BQU9BLFNBQVNsRDtZQUFTO1FBQzlFLENBQUM7SUFDTCxPQUNLO1FBQ0QsT0FBTytLLElBQUksQ0FBQ3BQLEtBQUssRUFBRSx5Q0FBeUM7SUFDaEUsQ0FBQztBQUNMO0FBRUE7Ozs7QUFJQSxHQUNBLElBQUl1eEMsZ0JBQWdCLFdBQVcsR0FBSSxXQUFZO0lBQzNDLFNBQVNBLGNBQWNDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxZQUFZLEVBQUVDLFVBQVUsRUFBRTtRQUM1RCxJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJRyxtQkFBbUIsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBR0osU0FBUzluQyxxQkFBcUIsSUFBSSxnQ0FBZ0M7UUFDakgsSUFBSWdvQyxjQUFjO1lBQ2QsSUFBSSxDQUFDRyxrQkFBa0IsQ0FBQ0QsaUJBQWlCekssSUFBSTtRQUNqRCxDQUFDO1FBQ0QsSUFBSXdLLFlBQVk7WUFDWixJQUFJLENBQUNHLGdCQUFnQixDQUFDRixpQkFBaUJ2SyxHQUFHO1FBQzlDLENBQUM7SUFDTDtJQUNBLHNEQUFzRDtJQUN0RGtLLGNBQWMxeEMsU0FBUyxDQUFDZ3lDLGtCQUFrQixHQUFHLFNBQVVFLGdCQUFnQixFQUFFO1FBQ3JFLElBQUlDLFFBQVEsRUFBRTtRQUNkLElBQUlDLFNBQVMsRUFBRTtRQUNmLElBQUssSUFBSXhpQyxLQUFLLEdBQUc5TCxLQUFLLElBQUksQ0FBQzh0QyxHQUFHLEVBQUVoaUMsS0FBSzlMLEdBQUdyQixNQUFNLEVBQUVtTixLQUFNO1lBQ2xELElBQUkxTyxLQUFLNEMsRUFBRSxDQUFDOEwsR0FBRztZQUNmLElBQUl5M0IsT0FBT25tQyxHQUFHMkkscUJBQXFCO1lBQ25Dc29DLE1BQU12dkMsSUFBSSxDQUFDeWtDLEtBQUtDLElBQUksR0FBRzRLO1lBQ3ZCRSxPQUFPeHZDLElBQUksQ0FBQ3lrQyxLQUFLRSxLQUFLLEdBQUcySztRQUM3QjtRQUNBLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBLHNEQUFzRDtJQUN0RFYsY0FBYzF4QyxTQUFTLENBQUNpeUMsZ0JBQWdCLEdBQUcsU0FBVUksZUFBZSxFQUFFO1FBQ2xFLElBQUlDLE9BQU8sRUFBRTtRQUNiLElBQUlDLFVBQVUsRUFBRTtRQUNoQixJQUFLLElBQUkzaUMsS0FBSyxHQUFHOUwsS0FBSyxJQUFJLENBQUM4dEMsR0FBRyxFQUFFaGlDLEtBQUs5TCxHQUFHckIsTUFBTSxFQUFFbU4sS0FBTTtZQUNsRCxJQUFJMU8sS0FBSzRDLEVBQUUsQ0FBQzhMLEdBQUc7WUFDZixJQUFJeTNCLE9BQU9ubUMsR0FBRzJJLHFCQUFxQjtZQUNuQ3lvQyxLQUFLMXZDLElBQUksQ0FBQ3lrQyxLQUFLRyxHQUFHLEdBQUc2SztZQUNyQkUsUUFBUTN2QyxJQUFJLENBQUN5a0MsS0FBS0ksTUFBTSxHQUFHNEs7UUFDL0I7UUFDQSxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDbkI7SUFDQSx5R0FBeUc7SUFDekcsaURBQWlEO0lBQ2pEYixjQUFjMXhDLFNBQVMsQ0FBQ3d5QyxXQUFXLEdBQUcsU0FBVUMsWUFBWSxFQUFFO1FBQzFELElBQUkzdUMsS0FBSyxJQUFJLEVBQUVxdUMsUUFBUXJ1QyxHQUFHcXVDLEtBQUssRUFBRUMsU0FBU3R1QyxHQUFHc3VDLE1BQU07UUFDbkQsSUFBSTdwQyxNQUFNNHBDLE1BQU0xdkMsTUFBTTtRQUN0QixJQUFJRDtRQUNKLElBQUtBLElBQUksR0FBR0EsSUFBSStGLEtBQUsvRixLQUFLLEVBQUc7WUFDekIsSUFBSWl3QyxnQkFBZ0JOLEtBQUssQ0FBQzN2QyxFQUFFLElBQUlpd0MsZUFBZUwsTUFBTSxDQUFDNXZDLEVBQUUsRUFBRTtnQkFDdEQsT0FBT0E7WUFDWCxDQUFDO1FBQ0w7UUFDQSxPQUFPNE0sV0FBVyxlQUFlO0lBQ3JDO0lBQ0EscUdBQXFHO0lBQ3JHLGlEQUFpRDtJQUNqRHNpQyxjQUFjMXhDLFNBQVMsQ0FBQzB5QyxVQUFVLEdBQUcsU0FBVUMsV0FBVyxFQUFFO1FBQ3hELElBQUk3dUMsS0FBSyxJQUFJLEVBQUV3dUMsT0FBT3h1QyxHQUFHd3VDLElBQUksRUFBRUMsVUFBVXp1QyxHQUFHeXVDLE9BQU87UUFDbkQsSUFBSWhxQyxNQUFNK3BDLEtBQUs3dkMsTUFBTTtRQUNyQixJQUFJRDtRQUNKLElBQUtBLElBQUksR0FBR0EsSUFBSStGLEtBQUsvRixLQUFLLEVBQUc7WUFDekIsSUFBSW13QyxlQUFlTCxJQUFJLENBQUM5dkMsRUFBRSxJQUFJbXdDLGNBQWNKLE9BQU8sQ0FBQy92QyxFQUFFLEVBQUU7Z0JBQ3BELE9BQU9BO1lBQ1gsQ0FBQztRQUNMO1FBQ0EsT0FBTzRNLFdBQVcsZUFBZTtJQUNyQztJQUNBLG1EQUFtRDtJQUNuRHNpQyxjQUFjMXhDLFNBQVMsQ0FBQzR5QyxRQUFRLEdBQUcsU0FBVUMsU0FBUyxFQUFFO1FBQ3BELE9BQU8sSUFBSSxDQUFDVCxNQUFNLENBQUNTLFVBQVUsR0FBRyxJQUFJLENBQUNWLEtBQUssQ0FBQ1UsVUFBVTtJQUN6RDtJQUNBLG9EQUFvRDtJQUNwRG5CLGNBQWMxeEMsU0FBUyxDQUFDOHlDLFNBQVMsR0FBRyxTQUFVQyxRQUFRLEVBQUU7UUFDcEQsT0FBTyxJQUFJLENBQUNSLE9BQU8sQ0FBQ1EsU0FBUyxHQUFHLElBQUksQ0FBQ1QsSUFBSSxDQUFDUyxTQUFTO0lBQ3ZEO0lBQ0EsT0FBT3JCO0FBQ1g7QUFFQSxzQ0FBc0MsR0FDdEM7Ozs7QUFJQSxHQUNBLElBQUlzQixtQkFBbUIsV0FBVyxHQUFJLFdBQVk7SUFDOUMsU0FBU0EsbUJBQW1CLENBQzVCO0lBQ0FBLGlCQUFpQmh6QyxTQUFTLENBQUNpekMsZUFBZSxHQUFHLFdBQVk7UUFDckQsT0FBTyxJQUFJLENBQUNDLGVBQWUsS0FBSyxJQUFJLENBQUNDLGVBQWU7SUFDeEQ7SUFDQUgsaUJBQWlCaHpDLFNBQVMsQ0FBQ296QyxnQkFBZ0IsR0FBRyxXQUFZO1FBQ3RELE9BQU8sSUFBSSxDQUFDQyxjQUFjLEtBQUssSUFBSSxDQUFDQyxjQUFjO0lBQ3REO0lBQ0FOLGlCQUFpQmh6QyxTQUFTLENBQUN1ekMsbUJBQW1CLEdBQUcsV0FBWTtRQUN6RCxPQUFPLElBQUksQ0FBQ04sZUFBZSxLQUFLO0lBQ3BDO0lBQ0FELGlCQUFpQmh6QyxTQUFTLENBQUN3ekMscUJBQXFCLEdBQUcsV0FBWTtRQUMzRCxPQUFPLElBQUksQ0FBQ0osZ0JBQWdCLEtBQUs7SUFDckM7SUFDQUosaUJBQWlCaHpDLFNBQVMsQ0FBQ3l6QyxXQUFXLEdBQUcsV0FBWTtRQUNqRCxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLO0lBQ2pDO0lBQ0FWLGlCQUFpQmh6QyxTQUFTLENBQUMyekMsYUFBYSxHQUFHLFdBQVk7UUFDbkQsT0FBTyxJQUFJLENBQUNELFlBQVksS0FBSyxJQUFJLENBQUNULGVBQWU7SUFDckQ7SUFDQUQsaUJBQWlCaHpDLFNBQVMsQ0FBQzR6QyxhQUFhLEdBQUcsV0FBWTtRQUNuRCxPQUFPLElBQUksQ0FBQ0MsYUFBYSxLQUFLO0lBQ2xDO0lBQ0FiLGlCQUFpQmh6QyxTQUFTLENBQUM4ekMsY0FBYyxHQUFHLFdBQVk7UUFDcEQsT0FBTyxJQUFJLENBQUNELGFBQWEsS0FBSyxJQUFJLENBQUNULGdCQUFnQjtJQUN2RDtJQUNBLE9BQU9KO0FBQ1g7QUFDQSxJQUFJZSwwQkFBMEIsV0FBVyxHQUFJLFNBQVVDLE1BQU0sRUFBRTtJQUMzRDEwQyxnREFBU0EsQ0FBQ3kwQyx5QkFBeUJDO0lBQ25DLFNBQVNELHdCQUF3Qjd5QyxFQUFFLEVBQUU7UUFDakMsSUFBSTBXLFFBQVFvOEIsT0FBTzl4QyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUk7UUFDckMwVixNQUFNMVcsRUFBRSxHQUFHQTtRQUNYLE9BQU8wVztJQUNYO0lBQ0FtOEIsd0JBQXdCL3pDLFNBQVMsQ0FBQzB6QyxZQUFZLEdBQUcsV0FBWTtRQUN6RCxPQUFPLElBQUksQ0FBQ3h5QyxFQUFFLENBQUMreUMsU0FBUztJQUM1QjtJQUNBRix3QkFBd0IvekMsU0FBUyxDQUFDNnpDLGFBQWEsR0FBRyxXQUFZO1FBQzFELE9BQU8sSUFBSSxDQUFDM3lDLEVBQUUsQ0FBQ2d6QyxVQUFVO0lBQzdCO0lBQ0FILHdCQUF3Qi96QyxTQUFTLENBQUNtMEMsWUFBWSxHQUFHLFNBQVUzTSxHQUFHLEVBQUU7UUFDNUQsSUFBSSxDQUFDdG1DLEVBQUUsQ0FBQyt5QyxTQUFTLEdBQUd6TTtJQUN4QjtJQUNBdU0sd0JBQXdCL3pDLFNBQVMsQ0FBQ28wQyxhQUFhLEdBQUcsU0FBVTlNLElBQUksRUFBRTtRQUM5RCxJQUFJLENBQUNwbUMsRUFBRSxDQUFDZ3pDLFVBQVUsR0FBRzVNO0lBQ3pCO0lBQ0F5TSx3QkFBd0IvekMsU0FBUyxDQUFDcXpDLGNBQWMsR0FBRyxXQUFZO1FBQzNELE9BQU8sSUFBSSxDQUFDbnlDLEVBQUUsQ0FBQ216QyxXQUFXO0lBQzlCO0lBQ0FOLHdCQUF3Qi96QyxTQUFTLENBQUNrekMsZUFBZSxHQUFHLFdBQVk7UUFDNUQsT0FBTyxJQUFJLENBQUNoeUMsRUFBRSxDQUFDb3pDLFlBQVk7SUFDL0I7SUFDQVAsd0JBQXdCL3pDLFNBQVMsQ0FBQ216QyxlQUFlLEdBQUcsV0FBWTtRQUM1RCxPQUFPLElBQUksQ0FBQ2p5QyxFQUFFLENBQUMyc0MsWUFBWTtJQUMvQjtJQUNBa0csd0JBQXdCL3pDLFNBQVMsQ0FBQ3N6QyxjQUFjLEdBQUcsV0FBWTtRQUMzRCxPQUFPLElBQUksQ0FBQ3B5QyxFQUFFLENBQUM2c0MsV0FBVztJQUM5QjtJQUNBLE9BQU9nRztBQUNYLEVBQUVmO0FBQ0YsSUFBSXVCLHlCQUF5QixXQUFXLEdBQUksU0FBVVAsTUFBTSxFQUFFO0lBQzFEMTBDLGdEQUFTQSxDQUFDaTFDLHdCQUF3QlA7SUFDbEMsU0FBU08seUJBQXlCO1FBQzlCLE9BQU9QLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7SUFDbkU7SUFDQTY4Qix1QkFBdUJ2MEMsU0FBUyxDQUFDMHpDLFlBQVksR0FBRyxXQUFZO1FBQ3hELE9BQU92RixPQUFPMEIsV0FBVztJQUM3QjtJQUNBMEUsdUJBQXVCdjBDLFNBQVMsQ0FBQzZ6QyxhQUFhLEdBQUcsV0FBWTtRQUN6RCxPQUFPMUYsT0FBT3lCLFdBQVc7SUFDN0I7SUFDQTJFLHVCQUF1QnYwQyxTQUFTLENBQUNtMEMsWUFBWSxHQUFHLFNBQVU3cUMsQ0FBQyxFQUFFO1FBQ3pENmtDLE9BQU9xRyxNQUFNLENBQUNyRyxPQUFPeUIsV0FBVyxFQUFFdG1DO0lBQ3RDO0lBQ0FpckMsdUJBQXVCdjBDLFNBQVMsQ0FBQ28wQyxhQUFhLEdBQUcsU0FBVTlxQyxDQUFDLEVBQUU7UUFDMUQ2a0MsT0FBT3FHLE1BQU0sQ0FBQ2xyQyxHQUFHNmtDLE9BQU8wQixXQUFXO0lBQ3ZDO0lBQ0EwRSx1QkFBdUJ2MEMsU0FBUyxDQUFDcXpDLGNBQWMsR0FBRyxXQUFZO1FBQzFELE9BQU83eEMsU0FBU0MsZUFBZSxDQUFDNHlDLFdBQVc7SUFDL0M7SUFDQUUsdUJBQXVCdjBDLFNBQVMsQ0FBQ2t6QyxlQUFlLEdBQUcsV0FBWTtRQUMzRCxPQUFPMXhDLFNBQVNDLGVBQWUsQ0FBQzZ5QyxZQUFZO0lBQ2hEO0lBQ0FDLHVCQUF1QnYwQyxTQUFTLENBQUNtekMsZUFBZSxHQUFHLFdBQVk7UUFDM0QsT0FBTzN4QyxTQUFTQyxlQUFlLENBQUNvc0MsWUFBWTtJQUNoRDtJQUNBMEcsdUJBQXVCdjBDLFNBQVMsQ0FBQ3N6QyxjQUFjLEdBQUcsV0FBWTtRQUMxRCxPQUFPOXhDLFNBQVNDLGVBQWUsQ0FBQ3NzQyxXQUFXO0lBQy9DO0lBQ0EsT0FBT3dHO0FBQ1gsRUFBRXZCO0FBRUYsSUFBSXlCLFFBQVEsV0FBVyxHQUFJLFdBQVk7SUFDbkMsU0FBU0EsTUFBTWpXLGVBQWUsRUFBRTtRQUM1QixJQUFJLElBQUksQ0FBQ2tXLGtCQUFrQixFQUFFO1lBQ3pCLElBQUksQ0FBQ0MsZUFBZSxDQUFDblcsZUFBZSxDQUFDLElBQUksQ0FBQ2tXLGtCQUFrQixDQUFDO1FBQ2pFLENBQUM7SUFDTDtJQUNBRCxNQUFNejBDLFNBQVMsQ0FBQzIwQyxlQUFlLEdBQUcsU0FBVUMsZ0JBQWdCLEVBQUU7UUFDMUQsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUksT0FBT0YscUJBQXFCLFlBQVlBLGtCQUFrQjtZQUMxREMsa0JBQWtCejFDLCtDQUFRQSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMyMUMsV0FBVztZQUMvQyxJQUFLRCxjQUFjRixpQkFBa0I7Z0JBQ2pDQyxlQUFlLENBQUNDLFdBQVcsR0FBRyxJQUFJLENBQUNFLHVCQUF1QixDQUFDSixnQkFBZ0IsQ0FBQ0UsV0FBVztZQUMzRjtZQUNBLElBQUksQ0FBQ0MsV0FBVyxHQUFHRjtRQUN2QixPQUNLLElBQUlELHFCQUFxQixLQUFLLEVBQUU7WUFDakMsSUFBSSxDQUFDRyxXQUFXLEdBQUcsQ0FBQztRQUN4QixDQUFDO0lBQ0w7SUFDQU4sTUFBTXowQyxTQUFTLENBQUNnMUMsdUJBQXVCLEdBQUcsU0FBVW5uQixTQUFTLEVBQUU7UUFDM0QsSUFBSW9uQixTQUFTLElBQUksQ0FBQ0Msa0JBQWtCO1FBQ3BDLElBQUlELFVBQVVwbkIsVUFBVXZRLE9BQU8sQ0FBQzIzQixZQUFZLEdBQUc7WUFDM0NwbkIsWUFBWW9uQixTQUFTcG5CO1FBQ3pCLENBQUM7UUFDRCxPQUFPQTtJQUNYO0lBQ0E0bUIsTUFBTXowQyxTQUFTLENBQUNxc0MsUUFBUSxHQUFHLFNBQVVwbUMsR0FBRyxFQUFFO1FBQ3RDLE9BQU8sSUFBSSxDQUFDa3ZDLE9BQU8sQ0FBQ2x2QyxJQUFJLElBQUk7SUFDaEM7SUFDQXd1QyxNQUFNejBDLFNBQVMsQ0FBQ28xQyxZQUFZLEdBQUcsU0FBVU4sVUFBVSxFQUFFTyxLQUFLLEVBQUU7UUFDeEQsSUFBSXhuQjtRQUNKLElBQUl3bkIsU0FBUyxJQUFJLENBQUNDLGNBQWMsRUFBRTtZQUM5QnpuQixZQUFZLElBQUksQ0FBQ3luQixjQUFjLENBQUNSLFdBQVcsSUFBSSxJQUFJLENBQUNDLFdBQVcsQ0FBQ0QsV0FBVztRQUMvRSxPQUNLO1lBQ0RqbkIsWUFBWSxJQUFJLENBQUNrbkIsV0FBVyxDQUFDRCxXQUFXO1FBQzVDLENBQUM7UUFDRCxJQUFJam5CLFdBQVc7WUFDWCxPQUFPLElBQUksQ0FBQzBuQixhQUFhLEdBQUcsTUFBTTFuQjtRQUN0QyxDQUFDO1FBQ0QsT0FBTztJQUNYO0lBQ0E0bUIsTUFBTXowQyxTQUFTLENBQUN3MUMsd0JBQXdCLEdBQUcsU0FBVUMsaUJBQWlCLEVBQUU7UUFDcEUsSUFBSTVuQjtRQUNKLElBQUksSUFBSSxDQUFDNm5CLDhCQUE4QixFQUFFO1lBQ3JDN25CLFlBQVk0bkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDQyw4QkFBOEIsQ0FBQztZQUNsRSxJQUFJN25CLFdBQVc7Z0JBQ1gsT0FBTyxJQUFJLENBQUMwbkIsYUFBYSxHQUFHLE1BQU0sSUFBSSxDQUFDUCx1QkFBdUIsQ0FBQ25uQjtZQUNuRSxDQUFDO1FBQ0wsQ0FBQztRQUNELE9BQU87SUFDWDtJQUNBLE9BQU80bUI7QUFDWDtBQUNBQSxNQUFNejBDLFNBQVMsQ0FBQ20xQyxPQUFPLEdBQUcsQ0FBQztBQUMzQlYsTUFBTXowQyxTQUFTLENBQUMrMEMsV0FBVyxHQUFHLENBQUM7QUFDL0JOLE1BQU16MEMsU0FBUyxDQUFDdTFDLGFBQWEsR0FBRztBQUNoQ2QsTUFBTXowQyxTQUFTLENBQUNrMUMsa0JBQWtCLEdBQUc7QUFFckMsSUFBSVMsa0JBQWtCLFdBQVcsR0FBSSxXQUFZO0lBQzdDLFNBQVNBLGdCQUFnQkMsUUFBUSxFQUFFN2UsT0FBTyxFQUFFOVgsVUFBVSxFQUFFQyxlQUFlLEVBQUU7UUFDckUsSUFBSXRILFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNnK0IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUM3ZSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDOVgsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDMjJCLG1CQUFtQixHQUFHLFNBQVVDLE9BQU8sRUFBRTtZQUMxQ2wrQixNQUFNbStCLGFBQWEsR0FBRzMyQywrQ0FBUUEsQ0FBQyxDQUFDLEdBQUd3WSxNQUFNbStCLGFBQWEsSUFBSSxDQUFDLEdBQUdEO1lBQzlEbCtCLE1BQU1vK0IsS0FBSztRQUNmO1FBQ0FqZixRQUFRK0YsRUFBRSxDQUFDLGtCQUFrQixJQUFJLENBQUMrWSxtQkFBbUI7UUFDckQsSUFBSSxDQUFDSSxpQkFBaUI7SUFDMUI7SUFDQU4sZ0JBQWdCMzFDLFNBQVMsQ0FBQ2syQyxNQUFNLEdBQUcsV0FBWTtRQUMzQyxJQUFJLENBQUNuZixPQUFPLENBQUNvRyxHQUFHLENBQUMsa0JBQWtCLElBQUksQ0FBQzBZLG1CQUFtQjtJQUMvRDtJQUNBRixnQkFBZ0IzMUMsU0FBUyxDQUFDbTJDLE1BQU0sR0FBRyxTQUFVQyxVQUFVLEVBQUU7UUFDckQsSUFBSUEsY0FBYyxJQUFJLENBQUNsM0IsZUFBZSxFQUFFO1lBQ3BDLElBQUksQ0FBQysyQixpQkFBaUIsSUFBSSxhQUFhO1FBQzNDLE9BQ0s7WUFDRCxJQUFJLENBQUNELEtBQUs7UUFDZCxDQUFDO0lBQ0w7SUFDQUwsZ0JBQWdCMzFDLFNBQVMsQ0FBQ2kyQyxpQkFBaUIsR0FBRyxXQUFZO1FBQ3RELElBQUksQ0FBQ0osbUJBQW1CLENBQUM7WUFDckI3VSxNQUFNLElBQUksQ0FBQy9oQixVQUFVO1FBQ3pCO0lBQ0o7SUFDQTAyQixnQkFBZ0IzMUMsU0FBUyxDQUFDZzJDLEtBQUssR0FBRyxXQUFZO1FBQzFDLElBQUksSUFBSSxDQUFDRCxhQUFhLElBQUksSUFBSSxDQUFDSCxRQUFRLENBQUMsSUFBSSxDQUFDRyxhQUFhLEdBQUc7WUFDekQsSUFBSSxDQUFDQSxhQUFhLEdBQUcsSUFBSTtRQUM3QixDQUFDO0lBQ0w7SUFDQSxPQUFPSjtBQUNYO0FBRUEsSUFBSVUsa0JBQWtCOTJDLHVEQUFhQSxDQUFDLENBQUMsSUFBSSxpQkFBaUI7QUFDMUQsU0FBUysyQyxpQkFBaUJDLFFBQVEsRUFBRWpmLE9BQU8sRUFBRWtmLFdBQVcsRUFBRUMsb0JBQW9CLEVBQUVubEMsT0FBTyxFQUFFODZCLEtBQUssRUFBRWw2QixXQUFXLEVBQUVoUyxRQUFRLEVBQUVtNkIsY0FBYyxFQUFFdEQsT0FBTyxFQUFFaUMsV0FBVyxFQUFFMGQsNEJBQTRCLEVBQUVDLDhCQUE4QixFQUFFO0lBQ3ZOLE9BQU87UUFDSHJsQyxTQUFTQTtRQUNUYSxTQUFTcWtDO1FBQ1R0a0MsYUFBYUE7UUFDYjZrQixTQUFTQTtRQUNUNzJCLFVBQVVBO1FBQ1ZtNkIsZ0JBQWdCQTtRQUNoQnJCLGFBQWFBO1FBQ2J1ZCxVQUFVQTtRQUNWamYsU0FBU0E7UUFDVG1mLHNCQUFzQkE7UUFDdEJySyxPQUFPQTtRQUNQaUosT0FBT21CLFlBQVk3NUIsU0FBUyxLQUFLO1FBQ2pDaTZCLGtCQUFrQixTQUFVcHlDLE9BQU8sRUFBRTtZQUNqQ3V5QixRQUFRK0YsRUFBRSxDQUFDLFdBQVd0NEI7UUFDMUI7UUFDQXF5QyxxQkFBcUIsU0FBVXJ5QyxPQUFPLEVBQUU7WUFDcEN1eUIsUUFBUW9HLEdBQUcsQ0FBQyxXQUFXMzRCO1FBQzNCO1FBQ0FzeUMsdUJBQXVCLFNBQVVsQixRQUFRLEVBQUU7WUFDdkMsT0FBTyxJQUFJRCxnQkFBZ0JDLFVBQVU3ZSxTQUFTdmpCLGVBQWVnakMsWUFBWXYzQixVQUFVLEdBQUd1M0IsWUFBWXQzQixlQUFlO1FBQ3JIO1FBQ0F3M0IsOEJBQThCQTtRQUM5QkMsZ0NBQWdDQTtJQUNwQztBQUNKO0FBRUEsb0NBQW9DLEdBQ3BDLElBQUlJLGdCQUFnQixXQUFXLEdBQUksU0FBVS9DLE1BQU0sRUFBRTtJQUNqRDEwQyxnREFBU0EsQ0FBQ3kzQyxlQUFlL0M7SUFDekIsU0FBUytDLGdCQUFnQjtRQUNyQixPQUFPL0MsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtJQUNuRTtJQUNBcS9CLGNBQWMvMkMsU0FBUyxDQUFDZzNDLHFCQUFxQixHQUFHLFNBQVVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFO1FBQzVFLElBQUksSUFBSSxDQUFDQyxLQUFLLEVBQUU7WUFDWixzQ0FBc0M7WUFDdENsYSxRQUFRbWEsR0FBRyxDQUFDaG5DLGdCQUFnQjZtQyxXQUFXLElBQUksQ0FBQzV6QyxLQUFLLEdBQUcrTSxnQkFBZ0I4bUMsV0FBVyxJQUFJLENBQUMxWixLQUFLO1FBQzdGLENBQUM7UUFDRCxPQUFPLENBQUNsdEIsWUFBWSxJQUFJLENBQUNqTixLQUFLLEVBQUU0ekMsV0FBVyxJQUFJLENBQUNJLFlBQVksS0FDeEQsQ0FBQy9tQyxZQUFZLElBQUksQ0FBQ2t0QixLQUFLLEVBQUUwWixXQUFXLElBQUksQ0FBQ0ksYUFBYTtJQUM5RDtJQUNBLHFDQUFxQztJQUNyQ1AsY0FBYy8yQyxTQUFTLENBQUN1M0MsWUFBWSxHQUFHLFNBQVVDLFFBQVEsRUFBRTtRQUN2RCxJQUFJLENBQUNsbkMsWUFBWSxJQUFJLENBQUNrdEIsS0FBSyxFQUFFcCtCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDbytCLEtBQUssR0FBR2dhLFdBQVcsSUFBSSxDQUFDRixhQUFhLEdBQUc7WUFDNUYsSUFBSSxDQUFDRyxRQUFRLENBQUNEO1FBQ2xCLENBQUM7SUFDTDtJQUNBVCxjQUFjVyxnQkFBZ0IsR0FBR0E7SUFDakNYLGNBQWNZLGdCQUFnQixHQUFHQTtJQUNqQ1osY0FBY2EsV0FBVyxHQUFHdkI7SUFDNUIsT0FBT1U7QUFDWCxFQUFFdjNDLCtDQUFTQTtBQUNYdTNDLGNBQWMvMkMsU0FBUyxDQUFDcTNDLFlBQVksR0FBRyxDQUFDO0FBQ3hDTixjQUFjLzJDLFNBQVMsQ0FBQ3MzQyxhQUFhLEdBQUcsQ0FBQztBQUN6QyxJQUFJTyxnQkFBZ0IsV0FBVyxHQUFJLFNBQVU3RCxNQUFNLEVBQUU7SUFDakQxMEMsZ0RBQVNBLENBQUN1NEMsZUFBZTdEO0lBQ3pCLFNBQVM2RCxnQkFBZ0I7UUFDckIsT0FBTzdELFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7SUFDbkU7SUFDQW1nQyxjQUFjRCxXQUFXLEdBQUd2QjtJQUM1QixPQUFPd0I7QUFDWCxFQUFFZDtBQUNGLFNBQVNXLGlCQUFpQkwsWUFBWSxFQUFFO0lBQ3BDLElBQUk5bkMsT0FBTy9PLE9BQU9zM0MsTUFBTSxDQUFDLElBQUksQ0FBQzkzQyxTQUFTLENBQUNxM0MsWUFBWTtJQUNwRGo0QywrQ0FBUUEsQ0FBQ21RLE1BQU04bkM7SUFDZixJQUFJLENBQUNyM0MsU0FBUyxDQUFDcTNDLFlBQVksR0FBRzluQztBQUNsQztBQUNBLFNBQVNvb0MsaUJBQWlCTCxhQUFhLEVBQUU7SUFDckMsSUFBSS9uQyxPQUFPL08sT0FBT3MzQyxNQUFNLENBQUMsSUFBSSxDQUFDOTNDLFNBQVMsQ0FBQ3MzQyxhQUFhO0lBQ3JEbDRDLCtDQUFRQSxDQUFDbVEsTUFBTStuQztJQUNmLElBQUksQ0FBQ3QzQyxTQUFTLENBQUNzM0MsYUFBYSxHQUFHL25DO0FBQ25DO0FBQ0EsZ0JBQWdCO0FBQ2hCLFNBQVN3b0MsT0FBT0MsR0FBRyxFQUFFQyxPQUFPLEVBQUU7SUFDMUIsSUFBSSxPQUFPRCxRQUFRLFlBQVk7UUFDM0JBLElBQUlDO0lBQ1IsT0FDSyxJQUFJRCxLQUFLO1FBQ1YscURBQXFEO1FBQ3JEQSxJQUFJQyxPQUFPLEdBQUdBO0lBQ2xCLENBQUM7QUFDTDtBQUVBOzs7Ozs7QUFNQSxHQUNBLElBQUlDLGdCQUFnQixXQUFXLEdBQUksU0FBVWxFLE1BQU0sRUFBRTtJQUNqRDEwQyxnREFBU0EsQ0FBQzQ0QyxlQUFlbEU7SUFDekIsU0FBU2tFLGdCQUFnQjtRQUNyQixJQUFJdGdDLFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTXVnQyxHQUFHLEdBQUdoeUM7UUFDWixPQUFPeVI7SUFDWDtJQUNBLGFBQWE7SUFDYixvSEFBb0g7SUFDcEhzZ0MsY0FBY2w0QyxTQUFTLENBQUNvNEMsV0FBVyxHQUFHLFdBQVksQ0FDbEQ7SUFDQUYsY0FBY2w0QyxTQUFTLENBQUNxNEMsUUFBUSxHQUFHLFNBQVVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRTtRQUN2RixPQUFPLElBQUksRUFBRSwwQkFBMEI7SUFDM0M7SUFDQSw0QkFBNEI7SUFDNUIsb0hBQW9IO0lBQ3BIUCxjQUFjbDRDLFNBQVMsQ0FBQzA0QyxnQkFBZ0IsR0FBRyxTQUFVeDNDLEVBQUUsRUFBRTtRQUNyRCxPQUFPLENBQUMsSUFBSSxDQUFDbUMsS0FBSyxDQUFDK21DLFNBQVMsSUFBSSxPQUFPO1FBQ25DLENBQUMsSUFBSSxDQUFDL21DLEtBQUssQ0FBQ2luQyxXQUFXLElBQUksT0FBTztRQUNsQyxDQUFDanBDLGVBQWVILElBQUk7SUFDNUI7SUFDQWczQyxjQUFjbDRDLFNBQVMsQ0FBQzI0QyxpQkFBaUIsR0FBRyxTQUFVejNDLEVBQUUsRUFBRTtRQUN0RCxPQUFPLENBQUNHLGVBQWVILElBQUksa0NBQ3ZCLENBQUNHLGVBQWVILElBQUksb0JBQW9CLGtCQUFrQjtRQUMxRCxDQUFDRyxlQUFlSCxJQUFJLHNCQUFzQix1QkFBdUI7UUFDakUsQ0FBQ0csZUFBZUgsSUFBSSxnQkFBZ0IsT0FBTztJQUNuRDtJQUNBLE9BQU9nM0M7QUFDWCxFQUFFTDtBQUVGLHFFQUFxRTtBQUNyRSxTQUFTZSxhQUFhN3hDLEtBQUssRUFBRTtJQUN6QixPQUFPO1FBQ0g2bkIsSUFBSXpvQjtRQUNKMHlDLE1BQU05eEMsTUFBTTh4QyxJQUFJLElBQUksRUFBRTtRQUN0QkMsVUFBVS94QyxNQUFNK3hDLFFBQVEsSUFBSSxFQUFFO1FBQzlCQyxnQkFBZ0JoeUMsTUFBTWd5QyxjQUFjLElBQUksRUFBRTtRQUMxQ0MsYUFBYSxFQUFFLENBQUM5cUMsTUFBTSxDQUFDbkgsTUFBTWl5QyxXQUFXLElBQUksRUFBRTtRQUM5Q250QixlQUFlOWtCLE1BQU04a0IsYUFBYSxJQUFJLENBQUM7UUFDdkM2RCxzQkFBc0Izb0IsTUFBTTJvQixvQkFBb0IsSUFBSSxFQUFFO1FBQ3REOEwscUJBQXFCejBCLE1BQU15MEIsbUJBQW1CLElBQUksQ0FBQztRQUNuRDdHLHlCQUF5QjV0QixNQUFNNHRCLHVCQUF1QixJQUFJLEVBQUU7UUFDNURza0IsNEJBQTRCbHlDLE1BQU1reUMsMEJBQTBCLElBQUksRUFBRTtRQUNsRWxmLDBCQUEwQmh6QixNQUFNZ3pCLHdCQUF3QixJQUFJLEVBQUU7UUFDOURtZiwyQkFBMkJueUMsTUFBTW15Qyx5QkFBeUIsSUFBSSxFQUFFO1FBQ2hFQyxxQkFBcUJweUMsTUFBTW95QyxtQkFBbUIsSUFBSSxFQUFFO1FBQ3BEamdCLG9CQUFvQm55QixNQUFNbXlCLGtCQUFrQixJQUFJLEVBQUU7UUFDbEQvTyxPQUFPcGpCLE1BQU1vakIsS0FBSyxJQUFJLENBQUM7UUFDdkJpdkIsdUJBQXVCcnlDLE1BQU1xeUMscUJBQXFCLElBQUksRUFBRTtRQUN4REMsY0FBY3R5QyxNQUFNc3lDLFlBQVksSUFBSSxJQUFJO1FBQ3hDQyx1QkFBdUJ2eUMsTUFBTXV5QyxxQkFBcUIsSUFBSSxFQUFFO1FBQ3hEQyxzQkFBc0J4eUMsTUFBTXd5QyxvQkFBb0IsSUFBSSxFQUFFO1FBQ3REQyx1QkFBdUJ6eUMsTUFBTXl5QyxxQkFBcUIsSUFBSSxFQUFFO1FBQ3hEQyx1QkFBdUIxeUMsTUFBTTB5QyxxQkFBcUIsSUFBSSxFQUFFO1FBQ3hEQyxzQkFBc0IzeUMsTUFBTTJ5QyxvQkFBb0IsSUFBSSxFQUFFO1FBQ3REQyxjQUFjNXlDLE1BQU00eUMsWUFBWSxJQUFJLENBQUM7UUFDckNsZSxpQkFBaUIxMEIsTUFBTTAwQixlQUFlLElBQUksRUFBRTtRQUM1Q25kLGNBQWN2WCxNQUFNdVgsWUFBWTtRQUNoQy9NLGdCQUFnQnhLLE1BQU13SyxjQUFjLElBQUksRUFBRTtRQUMxQ3FvQyxvQkFBb0I3eUMsTUFBTTZ5QyxrQkFBa0I7UUFDNUNwNUIsYUFBYXpaLE1BQU15WixXQUFXLElBQUk7UUFDbENxNUIscUJBQXFCOXlDLE1BQU04eUMsbUJBQW1CO1FBQzlDQyxzQkFBc0IveUMsTUFBTSt5QyxvQkFBb0IsSUFBSSxDQUFDO1FBQ3JEQyxnQkFBZ0JoekMsTUFBTWd6QyxjQUFjLElBQUksSUFBSTtRQUM1Q0MscUJBQXFCanpDLE1BQU1pekMsbUJBQW1CLElBQUksQ0FBQztRQUNuREMsa0JBQWtCbHpDLE1BQU1rekMsZ0JBQWdCLElBQUksQ0FBQztRQUM3Q0MsZ0JBQWdCbnpDLE1BQU1tekMsY0FBYyxJQUFJLENBQUM7UUFDekNDLGlCQUFpQnB6QyxNQUFNb3pDLGVBQWUsSUFBSSxDQUFDO0lBQy9DO0FBQ0o7QUFDQSxTQUFTQyxpQkFBaUJDLFVBQVUsRUFBRUMsVUFBVSxFQUFFO0lBQzlDLElBQUlDLFVBQVUsQ0FBQztJQUNmLElBQUlDLFFBQVE7UUFDUjFCLFVBQVUsRUFBRTtRQUNaQyxnQkFBZ0IsRUFBRTtRQUNsQkMsYUFBYSxFQUFFO1FBQ2ZudEIsZUFBZSxDQUFDO1FBQ2hCNkQsc0JBQXNCLEVBQUU7UUFDeEI4TCxxQkFBcUIsQ0FBQztRQUN0QjdHLHlCQUF5QixFQUFFO1FBQzNCc2tCLDRCQUE0QixFQUFFO1FBQzlCbGYsMEJBQTBCLEVBQUU7UUFDNUJtZiwyQkFBMkIsRUFBRTtRQUM3QkMscUJBQXFCLEVBQUU7UUFDdkJqZ0Isb0JBQW9CLEVBQUU7UUFDdEIvTyxPQUFPLENBQUM7UUFDUml2Qix1QkFBdUIsRUFBRTtRQUN6QkMsY0FBYyxJQUFJO1FBQ2xCQyx1QkFBdUIsRUFBRTtRQUN6QkMsc0JBQXNCLEVBQUU7UUFDeEJDLHVCQUF1QixFQUFFO1FBQ3pCQyx1QkFBdUIsRUFBRTtRQUN6QkMsc0JBQXNCLEVBQUU7UUFDeEJDLGNBQWMsQ0FBQztRQUNmbGUsaUJBQWlCLEVBQUU7UUFDbkJuZCxjQUFjLElBQUk7UUFDbEIvTSxnQkFBZ0IsRUFBRTtRQUNsQnFvQyxvQkFBb0IsSUFBSTtRQUN4QnA1QixhQUFhO1FBQ2JxNUIscUJBQXFCLElBQUk7UUFDekJDLHNCQUFzQixDQUFDO1FBQ3ZCQyxnQkFBZ0IsSUFBSTtRQUNwQkMscUJBQXFCLENBQUM7UUFDdEJDLGtCQUFrQixDQUFDO1FBQ25CQyxnQkFBZ0IsQ0FBQztRQUNqQkMsaUJBQWlCLENBQUM7SUFDdEI7SUFDQSxTQUFTTSxRQUFRcm9DLElBQUksRUFBRTtRQUNuQixJQUFLLElBQUl4QyxLQUFLLEdBQUc4cUMsU0FBU3RvQyxNQUFNeEMsS0FBSzhxQyxPQUFPajRDLE1BQU0sRUFBRW1OLEtBQU07WUFDdEQsSUFBSTRDLE1BQU1rb0MsTUFBTSxDQUFDOXFDLEdBQUc7WUFDcEIsSUFBSSxDQUFDMnFDLE9BQU8sQ0FBQy9uQyxJQUFJb2MsRUFBRSxDQUFDLEVBQUU7Z0JBQ2xCMnJCLE9BQU8sQ0FBQy9uQyxJQUFJb2MsRUFBRSxDQUFDLEdBQUcsSUFBSTtnQkFDdEI2ckIsUUFBUWpvQyxJQUFJcW1DLElBQUk7Z0JBQ2hCMkIsUUFBUUcsYUFBYUgsT0FBT2hvQztZQUNoQyxDQUFDO1FBQ0w7SUFDSjtJQUNBLElBQUk2bkMsWUFBWTtRQUNaSSxRQUFRSjtJQUNaLENBQUM7SUFDREksUUFBUUg7SUFDUixPQUFPRTtBQUNYO0FBQ0EsU0FBU0ksd0JBQXdCO0lBQzdCLElBQUlDLHNCQUFzQixFQUFFO0lBQzVCLElBQUlDLG9CQUFvQixFQUFFO0lBQzFCLElBQUlDO0lBQ0osT0FBTyxTQUFVQyxZQUFZLEVBQUVWLFVBQVUsRUFBRTtRQUN2QyxJQUFJLENBQUNTLGdCQUFnQixDQUFDaGtDLGNBQWNpa0MsY0FBY0gsd0JBQXdCLENBQUM5akMsY0FBY3VqQyxZQUFZUSxvQkFBb0I7WUFDckhDLGVBQWVYLGlCQUFpQlksY0FBY1Y7UUFDbEQsQ0FBQztRQUNETyxzQkFBc0JHO1FBQ3RCRixvQkFBb0JSO1FBQ3BCLE9BQU9TO0lBQ1g7QUFDSjtBQUNBLFNBQVNKLGFBQWFNLE1BQU0sRUFBRUMsTUFBTSxFQUFFO0lBQ2xDLE9BQU87UUFDSHBDLFVBQVVtQyxPQUFPbkMsUUFBUSxDQUFDNXFDLE1BQU0sQ0FBQ2d0QyxPQUFPcEMsUUFBUTtRQUNoREMsZ0JBQWdCa0MsT0FBT2xDLGNBQWMsQ0FBQzdxQyxNQUFNLENBQUNndEMsT0FBT25DLGNBQWM7UUFDbEVDLGFBQWFpQyxPQUFPakMsV0FBVyxDQUFDOXFDLE1BQU0sQ0FBQ2d0QyxPQUFPbEMsV0FBVztRQUN6RG50QixlQUFlenNCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBT3B2QixhQUFhLEdBQUdxdkIsT0FBT3J2QixhQUFhO1FBQ2hGNkQsc0JBQXNCdXJCLE9BQU92ckIsb0JBQW9CLENBQUN4aEIsTUFBTSxDQUFDZ3RDLE9BQU94ckIsb0JBQW9CO1FBQ3BGOEwscUJBQXFCcDhCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBT3pmLG1CQUFtQixHQUFHMGYsT0FBTzFmLG1CQUFtQjtRQUNsRzdHLHlCQUF5QnNtQixPQUFPdG1CLHVCQUF1QixDQUFDem1CLE1BQU0sQ0FBQ2d0QyxPQUFPdm1CLHVCQUF1QjtRQUM3RnNrQiw0QkFBNEJnQyxPQUFPaEMsMEJBQTBCLENBQUMvcUMsTUFBTSxDQUFDZ3RDLE9BQU9qQywwQkFBMEI7UUFDdEdsZiwwQkFBMEJraEIsT0FBT2xoQix3QkFBd0IsQ0FBQzdyQixNQUFNLENBQUNndEMsT0FBT25oQix3QkFBd0I7UUFDaEdtZiwyQkFBMkIrQixPQUFPL0IseUJBQXlCLENBQUNockMsTUFBTSxDQUFDZ3RDLE9BQU9oQyx5QkFBeUI7UUFDbkdDLHFCQUFxQjhCLE9BQU85QixtQkFBbUIsQ0FBQ2pyQyxNQUFNLENBQUNndEMsT0FBTy9CLG1CQUFtQjtRQUNqRmpnQixvQkFBb0IraEIsT0FBTy9oQixrQkFBa0IsQ0FBQ2hyQixNQUFNLENBQUNndEMsT0FBT2hpQixrQkFBa0I7UUFDOUUvTyxPQUFPL3FCLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBTzl3QixLQUFLLEdBQUcrd0IsT0FBTy93QixLQUFLO1FBQ3hEaXZCLHVCQUF1QjZCLE9BQU83QixxQkFBcUIsQ0FBQ2xyQyxNQUFNLENBQUNndEMsT0FBTzlCLHFCQUFxQjtRQUN2RkMsY0FBYzZCLE9BQU83QixZQUFZLElBQUk0QixPQUFPNUIsWUFBWTtRQUN4REMsdUJBQXVCMkIsT0FBTzNCLHFCQUFxQixDQUFDcHJDLE1BQU0sQ0FBQ2d0QyxPQUFPNUIscUJBQXFCO1FBQ3ZGQyxzQkFBc0IwQixPQUFPMUIsb0JBQW9CLENBQUNyckMsTUFBTSxDQUFDZ3RDLE9BQU8zQixvQkFBb0I7UUFDcEZDLHVCQUF1QnlCLE9BQU96QixxQkFBcUIsQ0FBQ3RyQyxNQUFNLENBQUNndEMsT0FBTzFCLHFCQUFxQjtRQUN2RkUsc0JBQXNCdUIsT0FBT3ZCLG9CQUFvQixDQUFDeHJDLE1BQU0sQ0FBQ2d0QyxPQUFPeEIsb0JBQW9CO1FBQ3BGRCx1QkFBdUJ3QixPQUFPeEIscUJBQXFCLENBQUN2ckMsTUFBTSxDQUFDZ3RDLE9BQU96QixxQkFBcUI7UUFDdkZFLGNBQWN2NkMsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBRzY3QyxPQUFPdEIsWUFBWSxHQUFHdUIsT0FBT3ZCLFlBQVk7UUFDN0VsZSxpQkFBaUJ3ZixPQUFPeGYsZUFBZSxDQUFDdnRCLE1BQU0sQ0FBQ2d0QyxPQUFPemYsZUFBZTtRQUNyRW5kLGNBQWM0OEIsT0FBTzU4QixZQUFZLElBQUkyOEIsT0FBTzM4QixZQUFZO1FBQ3hEL00sZ0JBQWdCMHBDLE9BQU8xcEMsY0FBYyxDQUFDckQsTUFBTSxDQUFDZ3RDLE9BQU8zcEMsY0FBYztRQUNsRXFvQyxvQkFBb0JzQixPQUFPdEIsa0JBQWtCLElBQUlxQixPQUFPckIsa0JBQWtCO1FBQzFFcDVCLGFBQWF5NkIsT0FBT3o2QixXQUFXLElBQUkwNkIsT0FBTzE2QixXQUFXO1FBQ3JEcTVCLHFCQUFxQm9CLE9BQU9wQixtQkFBbUIsSUFBSXFCLE9BQU9yQixtQkFBbUI7UUFDN0VDLHNCQUFzQjE2QywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHNjdDLE9BQU9uQixvQkFBb0IsR0FBR29CLE9BQU9wQixvQkFBb0I7UUFDckdDLGdCQUFnQm1CLE9BQU9uQixjQUFjLElBQUlrQixPQUFPbEIsY0FBYztRQUM5REMscUJBQXFCNTZDLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBT2pCLG1CQUFtQixHQUFHa0IsT0FBT2xCLG1CQUFtQjtRQUNsR0Msa0JBQWtCNzZDLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBT2hCLGdCQUFnQixHQUFHaUIsT0FBT2pCLGdCQUFnQjtRQUN6RkMsZ0JBQWdCOTZDLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc2N0MsT0FBT2YsY0FBYyxHQUFHZ0IsT0FBT2hCLGNBQWM7UUFDbkZDLGlCQUFpQi82QywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHNjdDLE9BQU9kLGVBQWUsR0FBR2UsT0FBT2YsZUFBZTtJQUMxRjtBQUNKO0FBRUEsSUFBSWdCLGdCQUFnQixXQUFXLEdBQUksU0FBVW5ILE1BQU0sRUFBRTtJQUNqRDEwQyxnREFBU0EsQ0FBQzY3QyxlQUFlbkg7SUFDekIsU0FBU21ILGdCQUFnQjtRQUNyQixPQUFPbkgsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtJQUNuRTtJQUNBLE9BQU95akM7QUFDWCxFQUFFMUc7QUFDRjBHLGNBQWNuN0MsU0FBUyxDQUFDbTFDLE9BQU8sR0FBRztJQUM5QmlHLE1BQU07SUFDTkMsaUJBQWlCO0lBQ2pCQyxhQUFhO0lBQ2JDLFFBQVE7SUFDUkMsY0FBYztBQUNsQjtBQUNBTCxjQUFjbjdDLFNBQVMsQ0FBQ3UxQyxhQUFhLEdBQUc7QUFDeEM0RixjQUFjbjdDLFNBQVMsQ0FBQyswQyxXQUFXLEdBQUc7SUFDbEMwRyxPQUFPO0lBQ1B2ZCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsVUFBVTtJQUNWRSxVQUFVO0FBQ2Q7QUFDQTZjLGNBQWNuN0MsU0FBUyxDQUFDczFDLGNBQWMsR0FBRztJQUNyQ3BYLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZFLFVBQVU7QUFDZDtBQUNBNmMsY0FBY243QyxTQUFTLENBQUMwMEMsa0JBQWtCLEdBQUcsZUFBZSx5QkFBeUI7QUFDckZ5RyxjQUFjbjdDLFNBQVMsQ0FBQzAxQyw4QkFBOEIsR0FBRztBQUN6RHlGLGNBQWNuN0MsU0FBUyxDQUFDazFDLGtCQUFrQixHQUFHO0FBRTdDLFNBQVN3RyxnQkFBZ0JDLGNBQWMsRUFBRUMsZUFBZSxFQUFFO0lBQ3RELElBQUlyc0MsT0FBTyxDQUFDO0lBQ1osSUFBSTh0QjtJQUNKLElBQUtBLFlBQVlzZSxlQUFnQjtRQUM3QkUsY0FBY3hlLFVBQVU5dEIsTUFBTW9zQyxnQkFBZ0JDO0lBQ2xEO0lBQ0EsSUFBS3ZlLFlBQVl1ZSxnQkFBaUI7UUFDOUJDLGNBQWN4ZSxVQUFVOXRCLE1BQU1vc0MsZ0JBQWdCQztJQUNsRDtJQUNBLE9BQU9yc0M7QUFDWDtBQUNBLFNBQVNzc0MsY0FBY3hlLFFBQVEsRUFBRTl0QixJQUFJLEVBQUVvc0MsY0FBYyxFQUFFQyxlQUFlLEVBQUU7SUFDcEUsSUFBSXJzQyxJQUFJLENBQUM4dEIsU0FBUyxFQUFFO1FBQ2hCLE9BQU85dEIsSUFBSSxDQUFDOHRCLFNBQVM7SUFDekIsQ0FBQztJQUNELElBQUl5ZSxVQUFVQyxhQUFhMWUsVUFBVTl0QixNQUFNb3NDLGdCQUFnQkM7SUFDM0QsSUFBSUUsU0FBUztRQUNUdnNDLElBQUksQ0FBQzh0QixTQUFTLEdBQUd5ZTtJQUNyQixDQUFDO0lBQ0QsT0FBT0E7QUFDWDtBQUNBLFNBQVNDLGFBQWExZSxRQUFRLEVBQUU5dEIsSUFBSSxFQUFFb3NDLGNBQWMsRUFBRUMsZUFBZSxFQUFFO0lBQ25FLElBQUlJLGdCQUFnQkwsY0FBYyxDQUFDdGUsU0FBUztJQUM1QyxJQUFJNGUsaUJBQWlCTCxlQUFlLENBQUN2ZSxTQUFTO0lBQzlDLElBQUk2ZSxZQUFZLFNBQVUxNEMsSUFBSSxFQUFFO1FBQUUsT0FBUSxpQkFBa0J3NEMsYUFBYSxDQUFDeDRDLEtBQUssS0FBSyxJQUFJLEdBQUl3NEMsYUFBYSxDQUFDeDRDLEtBQUssR0FDMUcsa0JBQW1CeTRDLGNBQWMsQ0FBQ3o0QyxLQUFLLEtBQUssSUFBSSxHQUFJeTRDLGNBQWMsQ0FBQ3o0QyxLQUFLLEdBQUcsSUFBSTtJQUFJO0lBQ3hGLElBQUkyNEMsZUFBZUQsVUFBVTtJQUM3QixJQUFJRSxZQUFZRixVQUFVO0lBQzFCLElBQUlHLFdBQVcsSUFBSTtJQUNuQixJQUFJRCxXQUFXO1FBQ1gsSUFBSUEsY0FBYy9lLFVBQVU7WUFDeEIsTUFBTSxJQUFJenpCLE1BQU0sd0RBQXlEO1FBQzdFLENBQUM7UUFDRHl5QyxXQUFXUixjQUFjTyxXQUFXN3NDLE1BQU1vc0MsZ0JBQWdCQztJQUM5RCxDQUFDO0lBQ0QsSUFBSSxDQUFDTyxnQkFBZ0JFLFVBQVU7UUFDM0JGLGVBQWVFLFNBQVMzeEIsU0FBUztJQUNyQyxDQUFDO0lBQ0QsSUFBSSxDQUFDeXhCLGNBQWM7UUFDZixPQUFPLElBQUksRUFBRSxrRUFBa0U7SUFDbkYsQ0FBQztJQUNELE9BQU87UUFDSGg4QyxNQUFNazlCO1FBQ04zUyxXQUFXeXhCO1FBQ1hHLFVBQVVsOUMsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBSWk5QyxXQUFXQSxTQUFTQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUtOLGdCQUFnQkEsY0FBY08sVUFBVSxHQUFHLENBQUMsQ0FBQztRQUNwSEMsV0FBV3A5QywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFJaTlDLFdBQVdBLFNBQVNHLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBS1AsaUJBQWlCQSxlQUFlTSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQzVIO0FBQ0o7QUFFQSxvQ0FBb0MsR0FDcEMseUdBQXlHO0FBQ3pHLElBQUlFLGFBQWEsV0FBVyxHQUFJLFNBQVV6SSxNQUFNLEVBQUU7SUFDOUMxMEMsZ0RBQVNBLENBQUNtOUMsWUFBWXpJO0lBQ3RCLFNBQVN5SSxhQUFhO1FBQ2xCLElBQUk3a0MsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNOGtDLFNBQVMsR0FBR2o5QyxtREFBU0E7UUFDM0JtWSxNQUFNK2tDLFlBQVksR0FBRyxTQUFVejdDLEVBQUUsRUFBRTtZQUMvQjYyQyxPQUFPbmdDLE1BQU04a0MsU0FBUyxFQUFFeDdDO1lBQ3hCLElBQUkwVyxNQUFNdlUsS0FBSyxDQUFDdTVDLEtBQUssRUFBRTtnQkFDbkI3RSxPQUFPbmdDLE1BQU12VSxLQUFLLENBQUN1NUMsS0FBSyxFQUFFMTdDO1lBQzlCLENBQUM7UUFDTDtRQUNBLE9BQU8wVztJQUNYO0lBQ0E2a0MsV0FBV3o4QyxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDdEMsSUFBSWpsQyxRQUFRLElBQUk7UUFDaEIsSUFBSXZVLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUl5NUMsWUFBWXo1QyxNQUFNeTVDLFNBQVM7UUFDL0IsT0FBUXA5Qyx1REFBYUEsQ0FBQ3E5QyxXQUFXO1lBQUVELFdBQVdBO1lBQVc5eEIsVUFBVTNuQixNQUFNMm5CLFFBQVE7WUFBRUMsYUFBYTVuQixNQUFNNG5CLFdBQVc7WUFBRTJ4QixPQUFPLElBQUksQ0FBQ0QsWUFBWTtRQUFDLEdBQUcsU0FBVUQsU0FBUyxFQUFFO1lBQUUsT0FBUWg5Qyx1REFBYUEsQ0FBQ3M5QyxhQUFhO2dCQUFFRixXQUFXQTtnQkFBVy94QixTQUFTMW5CLE1BQU0wbkIsT0FBTztnQkFBRWt5QixnQkFBZ0I1NUMsTUFBTTQ1QyxjQUFjO2dCQUFFQyxhQUFhdGxDLE1BQU04a0MsU0FBUztZQUFDLEdBQUcsU0FBVVMsVUFBVSxFQUFFQyxZQUFZLEVBQUU7Z0JBQUUsT0FBTy81QyxNQUFNSixRQUFRLENBQUN5NUMsV0FBV1csb0JBQW9CaDZDLE1BQU15bkIsVUFBVSxFQUFFZ3lCLFlBQVlLLFlBQVlDO1lBQWU7UUFBSztJQUM1ZDtJQUNBLE9BQU9YO0FBQ1gsRUFBRTVFO0FBQ0Ysb0VBQW9FO0FBQ3BFLDhEQUE4RDtBQUM5RCxJQUFJeUYsNkJBQTZCLzlDLHVEQUFhQSxDQUFDO0FBQy9DLFNBQVN5OUMsWUFBWTM1QyxLQUFLLEVBQUU7SUFDeEIsT0FBUTNELHVEQUFhQSxDQUFDNDlDLDJCQUEyQkMsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFVQyxRQUFRLEVBQUU7UUFBRSxPQUFROTlDLHVEQUFhQSxDQUFDKzlDLGtCQUFrQnIrQywrQ0FBUUEsQ0FBQztZQUFFbytDLFVBQVVBO1FBQVMsR0FBR242QztJQUFVO0FBQzlLO0tBRlMyNUM7QUFHVCxJQUFJUyxtQkFBbUIsV0FBVyxHQUFJLFNBQVV6SixNQUFNLEVBQUU7SUFDcEQxMEMsZ0RBQVNBLENBQUNtK0Msa0JBQWtCeko7SUFDNUIsU0FBU3lKLG1CQUFtQjtRQUN4QixJQUFJN2xDLFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTXVsQyxVQUFVLEdBQUcxOUMsbURBQVNBO1FBQzVCLE9BQU9tWTtJQUNYO0lBQ0E2bEMsaUJBQWlCejlDLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUM1QyxPQUFPLElBQUksQ0FBQ3g1QyxLQUFLLENBQUNKLFFBQVEsQ0FBQyxJQUFJLENBQUNrNkMsVUFBVSxFQUFFLElBQUksQ0FBQ08sa0JBQWtCO0lBQ3ZFO0lBQ0FELGlCQUFpQno5QyxTQUFTLENBQUMyOUMsaUJBQWlCLEdBQUcsV0FBWTtRQUN2RCxJQUFJLENBQUNDLG1CQUFtQjtJQUM1QjtJQUNBSCxpQkFBaUJ6OUMsU0FBUyxDQUFDNjlDLGtCQUFrQixHQUFHLFdBQVk7UUFDeEQsSUFBSSxDQUFDRCxtQkFBbUI7SUFDNUI7SUFDQUgsaUJBQWlCejlDLFNBQVMsQ0FBQzg5QyxvQkFBb0IsR0FBRyxXQUFZO1FBQzFELElBQUksSUFBSSxDQUFDQyxpQkFBaUIsSUFBSSxJQUFJLENBQUNBLGlCQUFpQixDQUFDQyxPQUFPLEVBQUU7WUFDMUQsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQ0MsT0FBTztRQUNsQyxDQUFDO0lBQ0w7SUFDQVAsaUJBQWlCejlDLFNBQVMsQ0FBQzA5QyxrQkFBa0IsR0FBRyxXQUFZO1FBQ3hELElBQUlLLG9CQUFvQixJQUFJLENBQUNBLGlCQUFpQixFQUFFLCtDQUErQztRQUMvRixJQUFJWCxlQUFlLElBQUksQ0FBQ2EsZUFBZTtRQUN2QyxJQUFJbjlDLE9BQU8sSUFBSSxDQUFDbzlDLGNBQWMsQ0FBQ2Q7UUFDL0IseUVBQXlFO1FBQ3pFLElBQUksQ0FBQ1cscUJBQXFCQSxrQkFBa0JJLFVBQVUsS0FBS3I5QyxLQUFLcTlDLFVBQVUsRUFBRTtZQUN4RSxxQkFBcUI7WUFDckIsSUFBSUosbUJBQW1CO2dCQUNuQixJQUFJQSxrQkFBa0JDLE9BQU8sRUFBRTtvQkFDM0JELGtCQUFrQkMsT0FBTztnQkFDN0IsQ0FBQztnQkFDREQsb0JBQW9CLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUcsSUFBSTtZQUNyRCxDQUFDO1lBQ0Qsc0JBQXNCO1lBQ3RCLElBQUlqOUMsS0FBS3E5QyxVQUFVLEVBQUU7Z0JBQ2pCSixvQkFBb0IsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRzMrQywrQ0FBUUEsQ0FBQztvQkFBRSsrQyxZQUFZcjlDLEtBQUtxOUMsVUFBVTtvQkFBRUMsWUFBWWhCLFlBQVksQ0FBQ3Q4QyxLQUFLcTlDLFVBQVUsQ0FBQztnQkFBQyxHQUFHcjlDLEtBQUt1OUMsbUJBQW1CO1lBQzlKLENBQUM7UUFDRCxXQUFXO1FBQ2YsT0FDSyxJQUFJTixtQkFBbUI7WUFDeEJBLGtCQUFrQkssVUFBVSxHQUFHaEIsWUFBWSxDQUFDdDhDLEtBQUtxOUMsVUFBVSxDQUFDO1FBQ2hFLENBQUM7UUFDRCxPQUFPSixvQkFDRCxFQUFFLENBQUMsc0NBQXNDO1dBQ3pDWCxZQUFZLEVBQUUsc0NBQXNDO0lBQzlEO0lBQ0FLLGlCQUFpQno5QyxTQUFTLENBQUNpK0MsZUFBZSxHQUFHLFdBQVk7UUFDckQsSUFBSTU2QyxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJKzVDLGVBQWVrQixpQkFBaUJqN0MsTUFBTTBuQixPQUFPLEVBQUUxbkIsTUFBTXk1QyxTQUFTO1FBQ2xFLElBQUlNLGlCQUFpQmh1QyxXQUFXO1lBQzVCZ3VDLGVBQWVrQixpQkFBaUJqN0MsTUFBTTQ1QyxjQUFjLEVBQUU1NUMsTUFBTXk1QyxTQUFTO1FBQ3pFLENBQUM7UUFDRCxPQUFPTSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksR0FBR0EsWUFBWSxFQUFFLCtDQUErQztJQUN0RztJQUNBSyxpQkFBaUJ6OUMsU0FBUyxDQUFDaytDLGNBQWMsR0FBRyxTQUFVZCxZQUFZLEVBQUU7UUFDaEUsSUFBSXBELHNCQUFzQixJQUFJLENBQUNsNkMsT0FBTyxDQUFDb1MsV0FBVyxDQUFDOG5DLG1CQUFtQjtRQUN0RSxJQUFJbUUsYUFBYTtRQUNqQixJQUFJRSxzQkFBc0IsSUFBSTtRQUM5QixJQUFJakIsY0FBYztZQUNkLElBQUssSUFBSW1CLGFBQWF2RSxvQkFBcUI7Z0JBQ3ZDLElBQUlvRCxZQUFZLENBQUNtQixVQUFVLEtBQUtudkMsV0FBVztvQkFDdkMrdUMsYUFBYUk7b0JBQ2JGLHNCQUFzQnJFLG1CQUFtQixDQUFDdUUsVUFBVTtvQkFDcEQsS0FBTTtnQkFDVixDQUFDO1lBQ0w7UUFDSixDQUFDO1FBQ0QsT0FBTztZQUFFSixZQUFZQTtZQUFZRSxxQkFBcUJBO1FBQW9CO0lBQzlFO0lBQ0FaLGlCQUFpQno5QyxTQUFTLENBQUM0OUMsbUJBQW1CLEdBQUcsV0FBWTtRQUN6RCxJQUFJLElBQUksQ0FBQ0csaUJBQWlCLEVBQUU7WUFDeEIsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUNNLFVBQVUsQ0FBQ2xGLE9BQU8sSUFBSSxJQUFJLENBQUM1MEMsS0FBSyxDQUFDNjVDLFdBQVcsQ0FBQ2pGLE9BQU8sRUFDdkYsSUFBSSxDQUFDOEYsaUJBQWlCLENBQUNLLFVBQVU7UUFDckMsQ0FBQztJQUNMO0lBQ0EsT0FBT1g7QUFDWCxFQUFFNUY7QUFDRixJQUFJa0YsWUFBWSxXQUFXLEdBQUksU0FBVS9JLE1BQU0sRUFBRTtJQUM3QzEwQyxnREFBU0EsQ0FBQ3k5QyxXQUFXL0k7SUFDckIsU0FBUytJLFlBQVk7UUFDakIsSUFBSW5sQyxRQUFRbzhCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7UUFDcEVFLE1BQU0ra0MsWUFBWSxHQUFHLFNBQVU2QixNQUFNLEVBQUU7WUFDbkM1bUMsTUFBTTRtQyxNQUFNLEdBQUdBO1lBQ2YsSUFBSTVtQyxNQUFNdlUsS0FBSyxDQUFDdTVDLEtBQUssRUFBRTtnQkFDbkI3RSxPQUFPbmdDLE1BQU12VSxLQUFLLENBQUN1NUMsS0FBSyxFQUFFNEI7WUFDOUIsQ0FBQztRQUNMO1FBQ0EsT0FBTzVtQztJQUNYO0lBQ0FtbEMsVUFBVS84QyxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDckMsT0FBTyxJQUFJLENBQUN4NUMsS0FBSyxDQUFDSixRQUFRLENBQUMsSUFBSSxDQUFDMDVDLFlBQVk7SUFDaEQ7SUFDQUksVUFBVS84QyxTQUFTLENBQUMyOUMsaUJBQWlCLEdBQUcsV0FBWTtRQUNoRCxJQUFJbjRDLFdBQVcsSUFBSSxDQUFDbkMsS0FBSyxDQUFDMm5CLFFBQVE7UUFDbEMsSUFBSXhsQixVQUFVO1lBQ1ZBLFNBQVNwRywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ2lFLEtBQUssQ0FBQ3k1QyxTQUFTLEdBQUc7Z0JBQUU1N0MsSUFBSSxJQUFJLENBQUNzOUMsTUFBTTtZQUFDO1FBQzVFLENBQUM7SUFDTDtJQUNBekIsVUFBVS84QyxTQUFTLENBQUM4OUMsb0JBQW9CLEdBQUcsV0FBWTtRQUNuRCxJQUFJdDRDLFdBQVcsSUFBSSxDQUFDbkMsS0FBSyxDQUFDNG5CLFdBQVc7UUFDckMsSUFBSXpsQixVQUFVO1lBQ1ZBLFNBQVNwRywrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ2lFLEtBQUssQ0FBQ3k1QyxTQUFTLEdBQUc7Z0JBQUU1N0MsSUFBSSxJQUFJLENBQUNzOUMsTUFBTTtZQUFDO1FBQzVFLENBQUM7SUFDTDtJQUNBLE9BQU96QjtBQUNYLEVBQUVsRjtBQUNGLFNBQVM0RywyQkFBMkI7SUFDaEMsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDLG9CQUFvQixFQUFFO0lBQzFCLE9BQU8sU0FBVUMsU0FBUyxFQUFFL0IsU0FBUyxFQUFFO1FBQ25DLElBQUksQ0FBQzZCLG9CQUFvQixDQUFDeHVDLGFBQWF3dUMsa0JBQWtCN0IsY0FBYytCLGNBQWNILGtCQUFrQjtZQUNuR0EsbUJBQW1CRztZQUNuQkYsbUJBQW1CN0I7WUFDbkI4QixvQkFBb0J2QixvQkFBb0J3QixXQUFXL0I7UUFDdkQsQ0FBQztRQUNELE9BQU84QjtJQUNYO0FBQ0o7QUFDQSxTQUFTdkIsb0JBQW9CdnlCLFVBQVUsRUFBRWd5QixTQUFTLEVBQUU7SUFDaEQsSUFBSSxPQUFPaHlCLGVBQWUsWUFBWTtRQUNsQ0EsYUFBYUEsV0FBV2d5QjtJQUM1QixDQUFDO0lBQ0QsT0FBT3h2QixnQkFBZ0J4QztBQUMzQjtBQUNBLFNBQVN3ekIsaUJBQWlCdjNDLEtBQUssRUFBRSsxQyxTQUFTLEVBQUU7SUFDeEMsSUFBSSxPQUFPLzFDLFVBQVUsWUFBWTtRQUM3QixPQUFPQSxNQUFNKzFDLFdBQVdwOUMsbURBQWFBLEdBQUcsMkNBQTJDO0lBQ3ZGLENBQUM7SUFDRCxPQUFPcUg7QUFDWDtBQUVBLElBQUkrM0MsV0FBVyxXQUFXLEdBQUksU0FBVTlLLE1BQU0sRUFBRTtJQUM1QzEwQyxnREFBU0EsQ0FBQ3cvQyxVQUFVOUs7SUFDcEIsU0FBUzhLLFdBQVc7UUFDaEIsSUFBSWxuQyxRQUFRbzhCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7UUFDcEVFLE1BQU15bEMsbUJBQW1CLEdBQUdvQjtRQUM1QixPQUFPN21DO0lBQ1g7SUFDQWtuQyxTQUFTOStDLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUNwQyxJQUFJLzRDLEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87UUFDckQsSUFBSXFTLFVBQVVyUyxRQUFRcVMsT0FBTztRQUM3QixJQUFJMnFDLFlBQVk7WUFBRXpsQixNQUFNdjNCLFFBQVF3M0IsT0FBTztRQUFDO1FBQ3hDLElBQUl5bkIsbUJBQW1CLElBQUksQ0FBQzFCLG1CQUFtQixDQUFDbHJDLFFBQVFnUCxjQUFjLEVBQUUyN0I7UUFDeEUsT0FBUXA5Qyx1REFBYUEsQ0FBQ3E5QyxXQUFXO1lBQUVELFdBQVdBO1lBQVc5eEIsVUFBVTdZLFFBQVFpUCxZQUFZO1lBQUU2SixhQUFhOVksUUFBUWtQLGVBQWU7WUFBRXU3QixPQUFPdjVDLE1BQU11NUMsS0FBSztRQUFDLEdBQUcsU0FBVUYsU0FBUyxFQUFFO1lBQUUsT0FBT3I1QyxNQUFNSixRQUFRLENBQUN5NUMsV0FBVztnQkFBQyxRQUFRcjVDLE1BQU1rekMsUUFBUSxDQUFDcDJDLElBQUksR0FBRztnQkFBUzthQUFVLENBQUMrTixNQUFNLENBQUM2d0M7UUFBb0I7SUFDL1I7SUFDQSxPQUFPRDtBQUNYLEVBQUVqSDtBQUVGLFNBQVNtSCxpQkFBaUJDLE1BQU0sRUFBRTtJQUM5QixPQUFPeHZDLFFBQVF3dkMsUUFBUUM7QUFDM0I7QUFDQSxTQUFTQSxnQkFBZ0JuNEMsS0FBSyxFQUFFO0lBQzVCLElBQUl3MUMsYUFBYSxPQUFPeDFDLFVBQVUsYUFDOUI7UUFBRTJqQixXQUFXM2pCO0lBQU0sSUFDbkJBLEtBQUs7SUFDVCxJQUFJMmpCLFlBQVk2eEIsV0FBVzd4QixTQUFTO0lBQ3BDLElBQUk2eEIsV0FBV3h4QixPQUFPLEVBQUU7UUFDcEJMLFlBQVl5MEIsd0JBQXdCNUM7SUFDcEMsNkRBQTZEO0lBQ2pFLENBQUM7SUFDRCxPQUFPO1FBQ0hILFdBQVdHLFdBQVdwOEMsSUFBSTtRQUMxQnVxQixXQUFXQTtRQUNYNnhCLFlBQVlBO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTNEMsd0JBQXdCaHRDLE9BQU8sRUFBRTtJQUN0QyxPQUFPLFNBQVVpdEMsU0FBUyxFQUFFO1FBQUUsT0FBUTEvQyx1REFBYUEsQ0FBQzIyQyxnQkFBZ0JrSCxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVV6OUMsT0FBTyxFQUFFO1lBQUUsT0FBUUosdURBQWFBLENBQUNvL0MsVUFBVTtnQkFBRXZJLFVBQVV6MkMsUUFBUXkyQyxRQUFRO1lBQUMsR0FBRyxTQUFVOEksU0FBUyxFQUFFbCtCLGNBQWMsRUFBRTtnQkFDMU0sSUFBSTI3QixZQUFZMTlDLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdnZ0QsWUFBWTtvQkFBRXBnQyxrQkFBa0JsZixRQUFRcVMsT0FBTyxDQUFDNk0sZ0JBQWdCO2dCQUFDO2dCQUN2RyxPQUFRdGYsdURBQWFBLENBQUMrOEMsWUFBWTtvQkFBRUssV0FBV0E7b0JBQVdoeUIsWUFBWTNZLFFBQVEyWSxVQUFVO29CQUFFQyxTQUFTNVksUUFBUTRZLE9BQU87b0JBQUVDLFVBQVU3WSxRQUFRNlksUUFBUTtvQkFBRUMsYUFBYTlZLFFBQVE4WSxXQUFXO29CQUFFMnhCLE9BQU95QztnQkFBVSxHQUFHLFNBQVUzQyxTQUFTLEVBQUVxQyxnQkFBZ0IsRUFBRTVCLFVBQVUsRUFBRUMsWUFBWSxFQUFFO29CQUFFLE9BQVExOUMsdURBQWFBLENBQUMsT0FBTzt3QkFBRW11QixXQUFXMU0sZUFBZWpULE1BQU0sQ0FBQzZ3QyxrQkFBa0JsaUMsSUFBSSxDQUFDO3dCQUFNbTdCLEtBQUswRTtvQkFBVSxHQUFHVTtnQkFBZ0I7WUFDNVk7UUFBSztJQUFLO0FBQ2Q7QUFFQSxTQUFTa0MsZUFBZUMsYUFBYSxFQUFFQyxlQUFlLEVBQUVDLHNCQUFzQixFQUFFQyxjQUFjLEVBQUU7SUFDNUYsSUFBSS9ELGlCQUFpQnFELGlCQUFpQk87SUFDdEMsSUFBSTNELGtCQUFrQm9ELGlCQUFpQlEsZ0JBQWdCcjFCLEtBQUs7SUFDNUQsSUFBSXcxQixXQUFXakUsZ0JBQWdCQyxnQkFBZ0JDO0lBQy9DLE9BQU9uc0MsUUFBUWt3QyxVQUFVLFNBQVU3RCxPQUFPLEVBQUU7UUFBRSxPQUFPOEQsY0FBYzlELFNBQVNGLGlCQUFpQjRELGlCQUFpQkMsd0JBQXdCQztJQUFpQjtBQUMzSjtBQUNBLFNBQVNFLGNBQWM5RCxPQUFPLEVBQUVGLGVBQWUsRUFBRTRELGVBQWUsRUFBRUMsc0JBQXNCLEVBQUVDLGNBQWMsRUFBRTtJQUN0RyxJQUFJRyxnQkFBZ0IvRCxRQUFRVSxTQUFTLENBQUM1cUMsUUFBUSxJQUMxQ2txQyxRQUFRUSxRQUFRLENBQUMxcUMsUUFBUSxJQUN6QjZ0Qyx1QkFBdUI3dEMsUUFBUSxJQUMvQjR0QyxnQkFBZ0I1dEMsUUFBUTtJQUM1QixJQUFJQSxXQUFXLElBQUk7SUFDbkIsSUFBSWt1QyxlQUFlO0lBQ25CLElBQUk3aEIsYUFBYTtJQUNqQixJQUFJOGhCLHNCQUFzQixDQUFDO0lBQzNCLElBQUlGLGVBQWU7UUFDZmp1QyxXQUFXb3VDLHFCQUFxQkg7UUFDaEMsSUFBSWp1QyxVQUFVO1lBQ1YsSUFBSXF1QyxRQUFRbnFDLDRCQUE0QmxFO1lBQ3hDa3VDLGVBQWVHLE1BQU14c0MsSUFBSTtZQUN6QixJQUFJd3NDLE1BQU1scUMsS0FBSyxLQUFLLEdBQUc7Z0JBQ25Ca29CLGFBQWE2aEI7Z0JBQ2JDLHNCQUFzQm5FLGVBQWUsQ0FBQ2tFLGFBQWEsR0FBR2xFLGVBQWUsQ0FBQ2tFLGFBQWEsQ0FBQ3ZELFVBQVUsR0FBRyxDQUFDLENBQUM7WUFDdkcsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0QsSUFBSTJELGtCQUFrQixTQUFVQyxhQUFhLEVBQUU7UUFDM0MsSUFBSUMsZ0JBQWdCRCxjQUFjbDJCLFVBQVUsSUFBSSxDQUFDO1FBQ2pELElBQUlVLGdCQUFnQm14QixRQUFRUSxRQUFRLENBQUMzeEIsYUFBYTtRQUNsRCxJQUFJQSxpQkFBaUIsSUFBSSxJQUFJeTFCLGFBQWEsQ0FBQ3oxQixjQUFjLElBQUksSUFBSSxFQUFFO1lBQy9ELE9BQU95MUIsYUFBYSxDQUFDejFCLGNBQWM7UUFDdkMsQ0FBQztRQUNELElBQUl5MUIsYUFBYSxDQUFDdEUsUUFBUTM3QyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7WUFDckMsT0FBT2lnRCxhQUFhLENBQUN0RSxRQUFRMzdDLElBQUksQ0FBQztRQUN0QyxDQUFDO1FBQ0QsSUFBSWlnRCxhQUFhLENBQUNuaUIsV0FBVyxJQUFJLElBQUksRUFBRTtZQUNuQyxPQUFPbWlCLGFBQWEsQ0FBQ25pQixXQUFXO1FBQ3BDLENBQUM7UUFDRCxPQUFPLElBQUk7SUFDZjtJQUNBLElBQUlvaUIsbUJBQW1CLFNBQVVGLGFBQWEsRUFBRTtRQUM1QyxJQUFJajJCLGNBQWNpMkIsY0FBY2oyQixXQUFXLElBQUksQ0FBQztRQUNoRCxJQUFJbzJCLFlBQVl4RSxRQUFRUSxRQUFRLENBQUMzeEIsYUFBYSxFQUFFLHVCQUF1QjtRQUN2RSxJQUFJMjFCLGFBQWEsSUFBSSxJQUFJcDJCLFdBQVcsQ0FBQ28yQixVQUFVLElBQUksSUFBSSxFQUFFO1lBQ3JELE9BQU9wMkIsV0FBVyxDQUFDbzJCLFVBQVU7UUFDakMsQ0FBQztRQUNELElBQUlwMkIsV0FBVyxDQUFDNHhCLFFBQVEzN0MsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO1lBQ25DLE9BQU8rcEIsV0FBVyxDQUFDNHhCLFFBQVEzN0MsSUFBSSxDQUFDO1FBQ3BDLENBQUM7UUFDRCxJQUFJK3BCLFdBQVcsQ0FBQytULFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDakMsT0FBTy9ULFdBQVcsQ0FBQytULFdBQVc7UUFDbEMsQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0EsT0FBTztRQUNIOTlCLE1BQU0yN0MsUUFBUTM3QyxJQUFJO1FBQ2xCdXFCLFdBQVdveEIsUUFBUXB4QixTQUFTO1FBQzVCOVksVUFBVUE7UUFDVmt1QyxjQUFjQTtRQUNkN2hCLFlBQVlBO1FBQ1pzaUIsZ0JBQWdCekUsUUFBUVEsUUFBUTtRQUNoQ2tELGlCQUFpQnBnRCwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHMmdELHNCQUFzQmpFLFFBQVFVLFNBQVM7UUFDOUVnRSxvQkFBb0JOLGdCQUFnQlQsMkJBQ2hDUyxnQkFBZ0JWLG9CQUFvQixnRUFBZ0U7UUFDcEcxRCxRQUFRVSxTQUFTLENBQUN2eUIsVUFBVTtRQUNoQ3cyQixtQkFBbUJQLGdCQUFnQlIsbUJBQy9CNUQsUUFBUVEsUUFBUSxDQUFDcnlCLFVBQVUsSUFDM0JpMkIsZ0JBQWdCeDNCLHlCQUNoQm96QixRQUFRMzdDLElBQUk7UUFDaEIsVUFBVTtRQUNWdWdELHFCQUFxQkwsaUJBQWlCWiwyQkFDbENZLGlCQUFpQmIsb0JBQ2pCMUQsUUFBUVUsU0FBUyxDQUFDbUUsVUFBVTtRQUNoQ0Msb0JBQW9CUCxpQkFBaUJYLG1CQUNqQzVELFFBQVFRLFFBQVEsQ0FBQ3FFLFVBQVUsSUFDM0JOLGlCQUFpQjMzQjtJQUV6QjtBQUNKO0FBQ0Esa0NBQWtDO0FBQ2xDLElBQUltNEIsbUJBQW1CLENBQUM7QUFDeEIsU0FBU2IscUJBQXFCSCxhQUFhLEVBQUU7SUFDekMsSUFBSWlCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ25CO0lBQzFCLElBQUkzdUMsTUFBTTJ2QyxnQkFBZ0IsQ0FBQ0MsS0FBSztJQUNoQyxJQUFJNXZDLFFBQVE5QixXQUFXO1FBQ25COEIsTUFBTXNDLGVBQWVxc0M7UUFDckJnQixnQkFBZ0IsQ0FBQ0MsS0FBSyxHQUFHNXZDO0lBQzdCLENBQUM7SUFDRCxPQUFPQTtBQUNYO0FBRUEsSUFBSSt2Qyx1QkFBdUIsV0FBVyxHQUFJLFdBQVk7SUFDbEQsU0FBU0EscUJBQXFCNTlDLEtBQUssRUFBRTtRQUNqQyxJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMweUIsT0FBTyxHQUFHa0csT0FBTzU0QixNQUFNNjRCLFFBQVEsRUFBRTc0QixNQUFNaU8sT0FBTztRQUNuRCxJQUFJLENBQUM0dkMsY0FBYztJQUN2QjtJQUNBO3NIQUNrSCxHQUNsSCx3RkFBd0Y7SUFDeEZELHFCQUFxQmpoRCxTQUFTLENBQUNtaEQsU0FBUyxHQUFHLFNBQVVDLGtCQUFrQixFQUFFeGxCLFdBQVcsRUFBRXlsQixZQUFZLEVBQUU7UUFDaEcsSUFBSS92QyxVQUFVLElBQUksQ0FBQ2pPLEtBQUssQ0FBQ2lPLE9BQU87UUFDaEMsSUFBSWd3QyxXQUFXaHdDLFFBQVE4QixRQUFRLENBQUM5QixRQUFRNHlCLE9BQU8sQ0FBQ3RJLGFBQWF3bEIsbUJBQW1CRyxnQkFBZ0IsR0FDaEdILG1CQUFtQjc1QixhQUFhO1FBQ2hDLE9BQU8sSUFBSSxDQUFDaTZCLEtBQUssQ0FBQ0YsVUFBVSxDQUFDLEdBQUdEO0lBQ3BDO0lBQ0Esd0ZBQXdGO0lBQ3hGSixxQkFBcUJqaEQsU0FBUyxDQUFDeWhELFNBQVMsR0FBRyxTQUFVTCxrQkFBa0IsRUFBRXhsQixXQUFXLEVBQUV5bEIsWUFBWSxFQUFFO1FBQ2hHLElBQUkvdkMsVUFBVSxJQUFJLENBQUNqTyxLQUFLLENBQUNpTyxPQUFPO1FBQ2hDLElBQUlvd0MsV0FBV3B3QyxRQUFROUssR0FBRyxDQUFDOEssUUFBUTR5QixPQUFPLENBQUN0SSxhQUFhd2xCLG1CQUFtQkcsZ0JBQWdCLEdBQzNGSCxtQkFBbUI3NUIsYUFBYTtRQUNoQyxPQUFPLElBQUksQ0FBQ2k2QixLQUFLLENBQUNFLFVBQVUsR0FBR0w7SUFDbkM7SUFDQSwrRUFBK0U7SUFDL0UsdUZBQXVGO0lBQ3ZGLHdFQUF3RTtJQUN4RUoscUJBQXFCamhELFNBQVMsQ0FBQ3doRCxLQUFLLEdBQUcsU0FBVTVsQixXQUFXLEVBQUVqZixTQUFTLEVBQUUwa0MsWUFBWSxFQUFFO1FBQ25GLElBQUlBLGlCQUFpQixLQUFLLEdBQUc7WUFBRUEsZUFBZSxJQUFJO1FBQUUsQ0FBQztRQUNyRCxJQUFJaCtDLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlza0I7UUFDSixJQUFJZzZCO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlybkI7UUFDSixJQUFJc25CO1FBQ0puNkIsYUFBYSxJQUFJLENBQUNvNkIsZUFBZTtRQUNqQ3A2QixhQUFhLElBQUksQ0FBQ3E2QixjQUFjLENBQUNyNkI7UUFDakMsSUFBSTA1QixjQUFjO1lBQ2R6bEIsY0FBY3RKLHVCQUF1QnNKLGFBQWFqVTtRQUN0RCxDQUFDO1FBQ0RnNkIsY0FBYyxJQUFJLENBQUNNLHFCQUFxQixDQUFDcm1CLGFBQWFqZjtRQUN0RGlsQyxnQkFBZ0IsMEJBQTBCaitDLElBQUksQ0FBQ2crQyxZQUFZbHVDLElBQUk7UUFDL0RvdUMsY0FBYyxJQUFJLENBQUNLLGdCQUFnQixDQUFDLElBQUksQ0FBQ0YsY0FBYyxDQUFDTCxZQUFZbnpDLEtBQUssR0FBR216QyxZQUFZbHVDLElBQUksRUFBRW11QztRQUM5RkMsY0FBYyxJQUFJLENBQUNHLGNBQWMsQ0FBQ0g7UUFDbENybkIsY0FBY3FuQjtRQUNkLElBQUksQ0FBQ3grQyxNQUFNc2UsbUJBQW1CLEVBQUU7WUFDNUI2WSxjQUFjMUksZ0JBQWdCMEksYUFBYW1uQixZQUFZbnpDLEtBQUs7UUFDaEUsQ0FBQztRQUNEZ3NCLGNBQWMsSUFBSSxDQUFDMm5CLGlCQUFpQixDQUFDM25CO1FBQ3JDQSxjQUFjMUksZ0JBQWdCMEksYUFBYTdTLGFBQWEsb0JBQW9CO1FBQzVFLGtFQUFrRTtRQUNsRSw0REFBNEQ7UUFDNURtNkIsVUFBVTd2QixnQkFBZ0IwdkIsWUFBWW56QyxLQUFLLEVBQUVtWjtRQUM3QyxPQUFPO1lBQ0gsK0ZBQStGO1lBQy9GLG9EQUFvRDtZQUNwREEsWUFBWUE7WUFDWiw4Q0FBOEM7WUFDOUMsd0VBQXdFO1lBQ3hFOFMsY0FBY2tuQixZQUFZbnpDLEtBQUs7WUFDL0IsK0RBQStEO1lBQy9EK3lDLGtCQUFrQkksWUFBWWx1QyxJQUFJO1lBQ2xDbXVDLGVBQWVBO1lBQ2YsbURBQW1EO1lBQ25ELDJDQUEyQztZQUMzQ3BuQixhQUFhQTtZQUNiLHNDQUFzQztZQUN0QyxzREFBc0Q7WUFDdERxbkIsYUFBYUE7WUFDYix1RUFBdUU7WUFDdkV6aUMsYUFBYS9iLE1BQU0rYixXQUFXO1lBQzlCLCtFQUErRTtZQUMvRUMsYUFBYWhjLE1BQU1nYyxXQUFXO1lBQzlCeWlDLFNBQVNBO1lBQ1QsK0RBQStEO1lBQy9EdjZCLGVBQWUsSUFBSSxDQUFDNjZCLGtCQUFrQixDQUFDVCxZQUFZL3ZDLFFBQVE7UUFFL0Q7SUFDSjtJQUNBLHVEQUF1RDtJQUN2RCxrREFBa0Q7SUFDbEQsNENBQTRDO0lBQzVDcXZDLHFCQUFxQmpoRCxTQUFTLENBQUMraEQsZUFBZSxHQUFHLFdBQVk7UUFDekQsSUFBSWg3QyxRQUFRLElBQUksQ0FBQzFELEtBQUssQ0FBQ2cvQyxlQUFlO1FBQ3RDLElBQUlDLGNBQWMsT0FBT3Y3QyxVQUFVLGFBQzdCQSxNQUFNN0UsSUFBSSxDQUFDLElBQUksQ0FBQ21CLEtBQUssQ0FBQzIxQixXQUFXLEVBQUUsSUFBSSxDQUFDakQsT0FBTyxJQUMvQ2h2QixLQUFLO1FBQ1gsT0FBTyxJQUFJLENBQUN3N0MsV0FBVyxDQUFDRCxnQkFDcEI7WUFBRXh2QyxPQUFPLElBQUk7WUFBRUMsS0FBSyxJQUFJO1FBQUMsR0FBRyx3QkFBd0I7SUFDNUQ7SUFDQSw0RUFBNEU7SUFDNUUsc0RBQXNEO0lBQ3RELGdEQUFnRDtJQUNoRCw0RUFBNEU7SUFDNUVrdUMscUJBQXFCamhELFNBQVMsQ0FBQ2lpRCxxQkFBcUIsR0FBRyxTQUFVMTBDLElBQUksRUFBRW9QLFNBQVMsRUFBRTtRQUM5RSxJQUFJdFosUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSXVPLFdBQVcsSUFBSTtRQUNuQixJQUFJNkIsT0FBTyxJQUFJO1FBQ2YsSUFBSWpGLFFBQVEsSUFBSTtRQUNoQixJQUFJNlk7UUFDSixJQUFJaGtCLE1BQU11TyxRQUFRLEVBQUU7WUFDaEJBLFdBQVd2TyxNQUFNdU8sUUFBUTtZQUN6QjZCLE9BQU9wUSxNQUFNeThDLFlBQVk7WUFDekJ0eEMsUUFBUSxJQUFJLENBQUNnMEMsc0JBQXNCLENBQUNqMUMsTUFBTW9QLFdBQVcvSyxVQUFVNkI7UUFDbkUsT0FDSyxJQUFLNFQsV0FBVyxJQUFJLENBQUNoa0IsS0FBSyxDQUFDZ2tCLFFBQVEsRUFBRztZQUN2QzVULE9BQU87WUFDUGpGLFFBQVEsSUFBSSxDQUFDaTBDLHNCQUFzQixDQUFDbDFDLE1BQU1vUCxXQUFXMEs7UUFDekQsT0FDSyxJQUFLN1ksUUFBUSxJQUFJLENBQUNrMEMsdUJBQXVCLENBQUNuMUMsT0FBUTtZQUNuRGtHLE9BQU9wUSxNQUFNaU8sT0FBTyxDQUFDeXlCLGlCQUFpQixDQUFDdjFCLE1BQU1zRSxLQUFLLEVBQUV0RSxNQUFNdUUsR0FBRyxFQUFFVSxJQUFJO1FBQ3ZFLE9BQ0s7WUFDRDdCLFdBQVcsSUFBSSxDQUFDK3dDLG1CQUFtQjtZQUNuQ2x2QyxPQUFPcUMsNEJBQTRCbEUsVUFBVTZCLElBQUk7WUFDakRqRixRQUFRLElBQUksQ0FBQ2cwQyxzQkFBc0IsQ0FBQ2oxQyxNQUFNb1AsV0FBVy9LLFVBQVU2QjtRQUNuRSxDQUFDO1FBQ0QsT0FBTztZQUFFN0IsVUFBVUE7WUFBVTZCLE1BQU1BO1lBQU1qRixPQUFPQTtRQUFNO0lBQzFEO0lBQ0F5eUMscUJBQXFCamhELFNBQVMsQ0FBQzJpRCxtQkFBbUIsR0FBRyxXQUFZO1FBQzdELE9BQU9udkMsZUFBZTtZQUFFUSxLQUFLO1FBQUU7SUFDbkM7SUFDQSwrREFBK0Q7SUFDL0QseURBQXlEO0lBQ3pEaXRDLHFCQUFxQmpoRCxTQUFTLENBQUNtaUQsaUJBQWlCLEdBQUcsU0FBVTN6QyxLQUFLLEVBQUU7UUFDaEUsSUFBSTFLLEtBQUssSUFBSSxDQUFDVCxLQUFLLEVBQUVpTyxVQUFVeE4sR0FBR3dOLE9BQU8sRUFBRXVaLGlCQUFpQi9tQixHQUFHK21CLGNBQWMsRUFBRXpMLGNBQWN0YixHQUFHc2IsV0FBVyxFQUFFQyxjQUFjdmIsR0FBR3ViLFdBQVc7UUFDekksSUFBSXZNLFFBQVF0RSxNQUFNc0UsS0FBSyxFQUFFQyxNQUFNdkUsTUFBTXVFLEdBQUc7UUFDeEMsSUFBSThYLGdCQUFnQjtZQUNoQiwwRUFBMEU7WUFDMUUsSUFBSXhWLFlBQVkrSixlQUFlLEdBQUc7Z0JBQzlCdE0sUUFBUTlILFdBQVc4SCxRQUFRLGFBQWE7Z0JBQ3hDQSxRQUFReEIsUUFBUTlLLEdBQUcsQ0FBQ3NNLE9BQU9zTTtZQUMvQixDQUFDO1lBQ0QsZ0ZBQWdGO1lBQ2hGLElBQUkvSixZQUFZZ0ssZUFBZSxHQUFHO2dCQUM5QnRNLE1BQU0vSCxXQUFXK0gsTUFBTSxhQUFhO2dCQUNwQ0EsTUFBTTNJLFFBQVEySSxLQUFLLENBQUM7Z0JBQ3BCQSxNQUFNekIsUUFBUTlLLEdBQUcsQ0FBQ3VNLEtBQUtzTTtZQUMzQixDQUFDO1FBQ0wsQ0FBQztRQUNELE9BQU87WUFBRXZNLE9BQU9BO1lBQU9DLEtBQUtBO1FBQUk7SUFDcEM7SUFDQSwyRUFBMkU7SUFDM0UsK0VBQStFO0lBQy9Fa3VDLHFCQUFxQmpoRCxTQUFTLENBQUN3aUQsc0JBQXNCLEdBQUcsU0FBVWoxQyxJQUFJLEVBQUVvUCxTQUFTLEVBQUUvSyxRQUFRLEVBQUU2QixJQUFJLEVBQUU7UUFDL0YsSUFBSTNQLEtBQUssSUFBSSxDQUFDVCxLQUFLLEVBQUVpTyxVQUFVeE4sR0FBR3dOLE9BQU8sRUFBRWdXLGdCQUFnQnhqQixHQUFHd2pCLGFBQWE7UUFDM0UsSUFBSXhVO1FBQ0osSUFBSUM7UUFDSixJQUFJN0I7UUFDSix1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDb1csZUFBZTtZQUNoQixJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDbGtCLEtBQUssQ0FBQ2trQixhQUFhO1lBQzVDLElBQUlBLGVBQWU7Z0JBQ2YsbUNBQW1DO2dCQUNuQyxJQUFJaFMsVUFBVWdTLGlCQUFpQmhTLFVBQVUzRCxXQUFXO29CQUNoRDBWLGdCQUFnQnhSLDRCQUE0QnlSLGVBQWU5VCxJQUFJO2dCQUNuRSxPQUNLO29CQUNENlQsZ0JBQWdCN1Q7Z0JBQ3BCLENBQUM7WUFDTCxPQUNLO2dCQUNENlQsZ0JBQWdCN1Q7WUFDcEIsQ0FBQztRQUNMLENBQUM7UUFDRCwrQ0FBK0M7UUFDL0MsSUFBSTRCLFlBQVl6RCxhQUFhLEdBQUc7WUFDNUIsSUFBSSxJQUFJLENBQUNneEMsV0FBVyxDQUFDOXZDLFFBQVE7Z0JBQ3pCQSxRQUFRLElBQUksQ0FBQyt2QyxjQUFjLENBQUMvdkMsT0FBTzZKO2dCQUNuQzdKLFFBQVE5SCxXQUFXOEg7WUFDdkIsQ0FBQztRQUNMLENBQUM7UUFDRCxTQUFTZ3dDLGFBQWE7WUFDbEJod0MsUUFBUXhCLFFBQVE0eUIsT0FBTyxDQUFDMzJCLE1BQU0rWjtZQUM5QnZVLE1BQU16QixRQUFROUssR0FBRyxDQUFDc00sT0FBT2xCO1lBQ3pCVixNQUFNO2dCQUFFNEIsT0FBT0E7Z0JBQU9DLEtBQUtBO1lBQUk7UUFDbkM7UUFDQSt2QztRQUNBLDJFQUEyRTtRQUMzRSxJQUFJLENBQUMsSUFBSSxDQUFDZCxjQUFjLENBQUM5d0MsTUFBTTtZQUMzQjNELE9BQU8sSUFBSSxDQUFDczFDLGNBQWMsQ0FBQ3QxQyxNQUFNb1A7WUFDakNtbUM7UUFDSixDQUFDO1FBQ0QsT0FBTzV4QztJQUNYO0lBQ0EsMkRBQTJEO0lBQzNEK3ZDLHFCQUFxQmpoRCxTQUFTLENBQUN5aUQsc0JBQXNCLEdBQUcsU0FBVWwxQyxJQUFJLEVBQUVvUCxTQUFTLEVBQUUwSyxRQUFRLEVBQUU7UUFDekYsSUFBSXZqQixLQUFLLElBQUksQ0FBQ1QsS0FBSyxFQUFFaU8sVUFBVXhOLEdBQUd3TixPQUFPLEVBQUVnVyxnQkFBZ0J4akIsR0FBR3dqQixhQUFhO1FBQzNFLElBQUl5N0IsZUFBZTtRQUNuQixJQUFJandDLFFBQVF2RjtRQUNaLElBQUl3RjtRQUNKLElBQUl1VSxlQUFlO1lBQ2Z4VSxRQUFReEIsUUFBUTR5QixPQUFPLENBQUNweEIsT0FBT3dVO1FBQ25DLENBQUM7UUFDRHhVLFFBQVE5SCxXQUFXOEg7UUFDbkJBLFFBQVEsSUFBSSxDQUFDK3ZDLGNBQWMsQ0FBQy92QyxPQUFPNko7UUFDbkM1SixNQUFNRDtRQUNOLEdBQUc7WUFDQ0MsTUFBTTNJLFFBQVEySSxLQUFLO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUM2dkMsV0FBVyxDQUFDN3ZDLE1BQU07Z0JBQ3hCZ3dDLGdCQUFnQjtZQUNwQixDQUFDO1FBQ0wsUUFBU0EsZUFBZTE3QixVQUFVO1FBQ2xDLE9BQU87WUFBRXZVLE9BQU9BO1lBQU9DLEtBQUtBO1FBQUk7SUFDcEM7SUFDQSw0REFBNEQ7SUFDNUQsOEVBQThFO0lBQzlFa3VDLHFCQUFxQmpoRCxTQUFTLENBQUMwaUQsdUJBQXVCLEdBQUcsU0FBVW4xQyxJQUFJLEVBQUU7UUFDckUsSUFBSWxLLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUkwRCxRQUFRMUQsTUFBTTIvQyxpQkFBaUI7UUFDbkMsSUFBSVYsY0FBYyxPQUFPdjdDLFVBQVUsYUFDN0JBLE1BQU03RSxJQUFJLENBQUNtQixNQUFNMjFCLFdBQVcsRUFBRTMxQixNQUFNaU8sT0FBTyxDQUFDK21CLE1BQU0sQ0FBQzlxQixTQUNuRHhHLEtBQUs7UUFDWCxJQUFJeUgsUUFBUSxJQUFJLENBQUMrekMsV0FBVyxDQUFDRDtRQUM3QixJQUFJOXpDLFNBQVVBLENBQUFBLE1BQU1zRSxLQUFLLElBQUksSUFBSSxJQUFJdEUsTUFBTXVFLEdBQUcsSUFBSSxJQUFJLEdBQUc7WUFDckQsT0FBTyxJQUFJO1FBQ2YsQ0FBQztRQUNELE9BQU92RTtJQUNYO0lBQ0EsNEVBQTRFO0lBQzVFLHdDQUF3QztJQUN4Qyw0Q0FBNEM7SUFDNUN5eUMscUJBQXFCamhELFNBQVMsQ0FBQ2tpRCxnQkFBZ0IsR0FBRyxTQUFVem5CLFlBQVksRUFBRThtQixnQkFBZ0IsRUFBRUssYUFBYSxFQUFFO1FBQ3ZHLE9BQU9ubkI7SUFDWDtJQUNBLGtGQUFrRjtJQUNsRixzQ0FBc0M7SUFDdEN3bUIscUJBQXFCamhELFNBQVMsQ0FBQ29pRCxrQkFBa0IsR0FBRyxTQUFVYSxRQUFRLEVBQUU7UUFDcEUsSUFBSTE3QixnQkFBZ0IsSUFBSSxDQUFDbGtCLEtBQUssQ0FBQ2trQixhQUFhO1FBQzVDLElBQUkyN0I7UUFDSixJQUFJMzdCLGVBQWU7WUFDZixPQUFPQTtRQUNYLENBQUM7UUFDRCxJQUFLMjdCLGtCQUFrQixJQUFJLENBQUM3L0MsS0FBSyxDQUFDaWtCLGFBQWEsRUFBRztZQUM5QyxPQUFPOVQsZUFBZSxHQUFHMHZDO1FBQzdCLENBQUM7UUFDRCxJQUFJRCxVQUFVO1lBQ1YsT0FBT0E7UUFDWCxDQUFDO1FBQ0QsT0FBT3p2QyxlQUFlO1lBQUVwSSxNQUFNO1FBQUU7SUFDcEM7SUFDQTYxQyxxQkFBcUJqaEQsU0FBUyxDQUFDdWlELFdBQVcsR0FBRyxTQUFVWSxVQUFVLEVBQUU7UUFDL0QsSUFBSUEsWUFBWTtZQUNaLElBQUkzMEMsUUFBUTJpQixXQUFXZ3lCLFlBQVksSUFBSSxDQUFDOS9DLEtBQUssQ0FBQ2lPLE9BQU87WUFDckQsSUFBSTlDLE9BQU87Z0JBQ1BBLFFBQVFnaUIsdUJBQXVCaGlCO1lBQ25DLENBQUM7WUFDRCxPQUFPQTtRQUNYLENBQUM7UUFDRCxPQUFPLElBQUk7SUFDZjtJQUNBO3NIQUNrSCxHQUNsSCw0RUFBNEU7SUFDNUV5eUMscUJBQXFCamhELFNBQVMsQ0FBQ2toRCxjQUFjLEdBQUcsV0FBWTtRQUN4RCxJQUFJMTVCLGFBQWEsSUFBSSxDQUFDbmtCLEtBQUssQ0FBQ21rQixVQUFVLElBQUksRUFBRSxFQUFFLCtDQUErQztRQUM3RixJQUFJNDdCLGtCQUFrQixFQUFFLEVBQUUsbUVBQW1FO1FBQzdGLElBQUk3eUIsU0FBUztRQUNiLElBQUkvdEI7UUFDSixJQUFJLElBQUksQ0FBQ2EsS0FBSyxDQUFDc2QsUUFBUSxLQUFLLEtBQUssRUFBRTtZQUMvQjZHLFdBQVc1a0IsSUFBSSxDQUFDLEdBQUcsSUFBSSx1QkFBdUI7UUFDbEQsQ0FBQztRQUNELElBQUtKLElBQUksR0FBR0EsSUFBSSxHQUFHQSxLQUFLLEVBQUc7WUFDdkIsSUFBSSxDQUFFNGdELENBQUFBLGVBQWUsQ0FBQzVnRCxFQUFFLEdBQUdnbEIsV0FBV2xLLE9BQU8sQ0FBQzlhLE9BQU8sQ0FBQyxJQUFJO2dCQUN0RCt0QixVQUFVO1lBQ2QsQ0FBQztRQUNMO1FBQ0EsSUFBSSxDQUFDQSxRQUFRO1lBQ1QsTUFBTSxJQUFJM21CLE1BQU0sc0JBQXNCLENBQUMsNkJBQTZCO1FBQ3hFLENBQUM7UUFDRCxJQUFJLENBQUN3NUMsZUFBZSxHQUFHQTtJQUMzQjtJQUNBLG1GQUFtRjtJQUNuRixrREFBa0Q7SUFDbERuQyxxQkFBcUJqaEQsU0FBUyxDQUFDZ2lELGNBQWMsR0FBRyxTQUFVeHpDLEtBQUssRUFBRTtRQUM3RCxJQUFJc0UsUUFBUXRFLE1BQU1zRSxLQUFLLEVBQUVDLE1BQU12RSxNQUFNdUUsR0FBRztRQUN4QyxJQUFJRCxPQUFPO1lBQ1BBLFFBQVEsSUFBSSxDQUFDK3ZDLGNBQWMsQ0FBQy92QztRQUNoQyxDQUFDO1FBQ0QsSUFBSUMsS0FBSztZQUNMQSxNQUFNLElBQUksQ0FBQzh2QyxjQUFjLENBQUM5dkMsS0FBSyxDQUFDLEdBQUcsSUFBSTtRQUMzQyxDQUFDO1FBQ0QsSUFBSUQsU0FBUyxJQUFJLElBQUlDLE9BQU8sSUFBSSxJQUFJRCxRQUFRQyxLQUFLO1lBQzdDLE9BQU87Z0JBQUVELE9BQU9BO2dCQUFPQyxLQUFLQTtZQUFJO1FBQ3BDLENBQUM7UUFDRCxPQUFPLElBQUk7SUFDZjtJQUNBLDZCQUE2QjtJQUM3QiwrREFBK0Q7SUFDL0RrdUMscUJBQXFCamhELFNBQVMsQ0FBQzRpRCxXQUFXLEdBQUcsU0FBVTV1QyxHQUFHLEVBQUU7UUFDeEQsSUFBSUEsZUFBZWhHLE1BQU07WUFDckJnRyxNQUFNQSxJQUFJM0csU0FBUztRQUN2QixDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMrMUMsZUFBZSxDQUFDcHZDLElBQUk7SUFDcEM7SUFDQSxxRkFBcUY7SUFDckYsZ0NBQWdDO0lBQ2hDLHlFQUF5RTtJQUN6RSxvRUFBb0U7SUFDcEUsOERBQThEO0lBQzlEaXRDLHFCQUFxQmpoRCxTQUFTLENBQUM2aUQsY0FBYyxHQUFHLFNBQVV0MUMsSUFBSSxFQUFFODFDLEdBQUcsRUFBRUMsV0FBVyxFQUFFO1FBQzlFLElBQUlELFFBQVEsS0FBSyxHQUFHO1lBQUVBLE1BQU07UUFBRyxDQUFDO1FBQ2hDLElBQUlDLGdCQUFnQixLQUFLLEdBQUc7WUFBRUEsY0FBYyxLQUFLO1FBQUUsQ0FBQztRQUNwRCxNQUFPLElBQUksQ0FBQ0YsZUFBZSxDQUFDLENBQUM3MUMsS0FBS0YsU0FBUyxLQUFNaTJDLENBQUFBLGNBQWNELE1BQU0sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFFO1lBQy9FOTFDLE9BQU9uRCxRQUFRbUQsTUFBTTgxQztRQUN6QjtRQUNBLE9BQU85MUM7SUFDWDtJQUNBLE9BQU8wekM7QUFDWDtBQUVBLFNBQVNzQyxlQUFlbG1CLFFBQVEsRUFBRXhCLE1BQU0sRUFBRTtJQUN0QyxPQUFRQSxPQUFPMTdCLElBQUk7UUFDZixLQUFLO1lBQ0RrOUIsV0FBV3hCLE9BQU93QixRQUFRO0lBQ2xDO0lBQ0EsT0FBT0E7QUFDWDtBQUVBLFNBQVNtbUIsNkJBQTZCL0Qsc0JBQXNCLEVBQUU1akIsTUFBTSxFQUFFO0lBQ2xFLElBQUkvM0I7SUFDSixPQUFRKzNCLE9BQU8xN0IsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPZiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHcWdELHlCQUEwQjM3QyxDQUFBQSxLQUFLLENBQUMsR0FBR0EsRUFBRSxDQUFDKzNCLE9BQU9ZLFVBQVUsQ0FBQyxHQUFHWixPQUFPYSxjQUFjLEVBQUU1NEIsRUFBRTtRQUNySDtZQUNJLE9BQU8yN0M7SUFDZjtBQUNKO0FBRUEsU0FBU2dFLGtCQUFrQnJDLGtCQUFrQixFQUFFdmxCLE1BQU0sRUFBRUQsV0FBVyxFQUFFNmEsb0JBQW9CLEVBQUU7SUFDdEYsSUFBSWlOO0lBQ0osT0FBUTduQixPQUFPMTdCLElBQUk7UUFDZixLQUFLO1lBQ0QsT0FBT3MyQyxxQkFBcUIrSyxLQUFLLENBQUMzbEIsT0FBT0MsVUFBVSxJQUFJRjtRQUMzRCxLQUFLO1lBQ0QsT0FBTzZhLHFCQUFxQitLLEtBQUssQ0FBQzNsQixPQUFPQyxVQUFVO1FBQ3ZELEtBQUs7WUFDRDRuQixLQUFLak4scUJBQXFCMEssU0FBUyxDQUFDQyxvQkFBb0J4bEI7WUFDeEQsSUFBSThuQixHQUFHNUIsT0FBTyxFQUFFO2dCQUNaLE9BQU80QjtZQUNYLENBQUM7WUFDRCxLQUFNO1FBQ1YsS0FBSztZQUNEQSxLQUFLak4scUJBQXFCZ0wsU0FBUyxDQUFDTCxvQkFBb0J4bEI7WUFDeEQsSUFBSThuQixHQUFHNUIsT0FBTyxFQUFFO2dCQUNaLE9BQU80QjtZQUNYLENBQUM7WUFDRCxLQUFNO0lBQ2Q7SUFDQSxPQUFPdEM7QUFDWDtBQUVBLFNBQVN1QyxpQkFBaUJubEIsZUFBZSxFQUFFakUsV0FBVyxFQUFFejZCLE9BQU8sRUFBRTtJQUM3RCxJQUFJMDZCLGNBQWNELGNBQWNBLFlBQVlDLFdBQVcsR0FBRyxJQUFJO0lBQzlELE9BQU9vcEIsV0FBVyxDQUFDLEdBQUdDLG9CQUFvQnJsQixpQkFBaUIxK0IsVUFBVTA2QixhQUFhMTZCO0FBQ3RGO0FBQ0EsU0FBU2drRCxtQkFBbUJ4NUIsWUFBWSxFQUFFdVIsTUFBTSxFQUFFdEIsV0FBVyxFQUFFejZCLE9BQU8sRUFBRTtJQUNwRSxJQUFJMDZCLGNBQWNELGNBQWNBLFlBQVlDLFdBQVcsR0FBRyxJQUFJLEVBQUUsbUJBQW1CO0lBQ25GLE9BQVFxQixPQUFPMTdCLElBQUk7UUFDZixLQUFLO1lBQ0QsT0FBT3lqRCxXQUFXdDVCLGNBQWN1UixPQUFPOEUsT0FBTyxFQUFFbkcsYUFBYTE2QjtRQUNqRSxLQUFLO1lBQ0QsT0FBT2lrRCxhQUFhejVCLGNBQWN1UixPQUFPejdCLFFBQVE7UUFDckQsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELElBQUltNkIsYUFBYTtnQkFDYixPQUFPeXBCLGtCQUFrQjE1QixjQUFja1EsYUFBYTE2QjtZQUN4RCxDQUFDO1lBQ0QsT0FBT3dxQjtRQUNYLEtBQUs7WUFDRCxPQUFPMjVCLGtCQUFrQjM1QixjQUFjdVIsT0FBT3Y3QixTQUFTLEdBQ25EcVAsWUFBWWtzQixPQUFPdjdCLFNBQVMsSUFDNUI0akQscUJBQXFCNTVCLGNBQWN4cUIsUUFBUSxFQUFFMDZCLGFBQWFxQixPQUFPdDdCLFNBQVMsSUFBSSxLQUFLLEVBQUVUO1FBQzdGLEtBQUs7UUFDTCxLQUFLO1lBQ0QsT0FBT3FrRCxnQkFBZ0I3NUIsY0FBY3VSLE9BQU96N0IsUUFBUSxFQUFFeTdCLE9BQU91b0IsT0FBTyxFQUFFdm9CLE9BQU9QLFVBQVU7UUFDM0YsS0FBSztZQUNELE9BQU8sQ0FBQztRQUNaO1lBQ0ksT0FBT2hSO0lBQ2Y7QUFDSjtBQUNBLFNBQVMrNUIsOEJBQThCLzVCLFlBQVksRUFBRWlRLFdBQVcsRUFBRXo2QixPQUFPLEVBQUU7SUFDdkUsSUFBSTA2QixjQUFjRCxjQUFjQSxZQUFZQyxXQUFXLEdBQUcsSUFBSSxFQUFFLG1CQUFtQjtJQUNuRixPQUFPeXBCLGtCQUFrQjM1QixjQUFjNDVCLHFCQUFxQjU1QixjQUFjeHFCLFVBQVUwNkIsYUFBYSxJQUFJLEVBQUUxNkI7QUFDM0c7QUFDQSxTQUFTd2tELDJCQUEyQmg2QixZQUFZLEVBQUU7SUFDOUMsSUFBSyxJQUFJbHFCLFlBQVlrcUIsYUFBYztRQUMvQixJQUFJQSxZQUFZLENBQUNscUIsU0FBUyxDQUFDZzdCLFVBQVUsRUFBRTtZQUNuQyxPQUFPLElBQUk7UUFDZixDQUFDO0lBQ0w7SUFDQSxPQUFPLEtBQUs7QUFDaEI7QUFDQSxTQUFTd29CLFdBQVdXLGVBQWUsRUFBRTVqQixPQUFPLEVBQUVyRixVQUFVLEVBQUV4N0IsT0FBTyxFQUFFO0lBQy9ELElBQUl5UCxPQUFPLENBQUM7SUFDWixJQUFLLElBQUlLLEtBQUssR0FBRzQwQyxZQUFZN2pCLFNBQVMvd0IsS0FBSzQwQyxVQUFVL2hELE1BQU0sRUFBRW1OLEtBQU07UUFDL0QsSUFBSTYwQyxTQUFTRCxTQUFTLENBQUM1MEMsR0FBRztRQUMxQkwsSUFBSSxDQUFDazFDLE9BQU9ya0QsUUFBUSxDQUFDLEdBQUdxa0Q7SUFDNUI7SUFDQSxJQUFJbnBCLFlBQVk7UUFDWi9yQixPQUFPeTBDLGtCQUFrQnowQyxNQUFNK3JCLFlBQVl4N0I7SUFDL0MsQ0FBQztJQUNELE9BQU9WLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdtbEQsa0JBQWtCaDFDO0FBQ25EO0FBQ0EsU0FBU3cwQyxhQUFhUSxlQUFlLEVBQUVua0QsUUFBUSxFQUFFO0lBQzdDLE9BQU9rUCxXQUFXaTFDLGlCQUFpQixTQUFVNzRCLFdBQVcsRUFBRTtRQUFFLE9BQU9BLFlBQVl0ckIsUUFBUSxLQUFLQTtJQUFVO0FBQzFHO0FBQ0EsU0FBUzRqRCxrQkFBa0J6akIsVUFBVSxFQUFFakYsVUFBVSxFQUFFeDdCLE9BQU8sRUFBRTtJQUN4RCxPQUFPbWtELGtCQUFrQjFqQixZQUFZanhCLFdBQVdpeEIsWUFBWSxTQUFVN1UsV0FBVyxFQUFFO1FBQUUsT0FBT2c1QixjQUFjaDVCLGFBQWE0UCxZQUFZeDdCO0lBQVUsSUFBSXc3QixZQUFZLEtBQUssRUFBRXg3QjtBQUN4SztBQUNBLFNBQVM0a0QsY0FBY2g1QixXQUFXLEVBQUU0UCxVQUFVLEVBQUV4N0IsT0FBTyxFQUFFO0lBQ3JELElBQUksQ0FBQzZrRCxvQkFBb0JqNUIsYUFBYTVyQixVQUFVO1FBQzVDLE9BQU8sQ0FBQzRyQixZQUFZMlAsYUFBYTtJQUNyQyxDQUFDO0lBQ0QsT0FBTyxDQUFDdjdCLFFBQVFxUyxPQUFPLENBQUN5UCxZQUFZLElBQ2hDLENBQUM4SixZQUFZNFAsVUFBVSxJQUN2QjVQLFlBQVkwUCxVQUFVLElBQUksNkNBQTZDO0lBQ3ZFRSxXQUFXeG9CLEtBQUssR0FBRzRZLFlBQVk0UCxVQUFVLENBQUN4b0IsS0FBSyxJQUMvQ3dvQixXQUFXdm9CLEdBQUcsR0FBRzJZLFlBQVk0UCxVQUFVLENBQUN2b0IsR0FBRztBQUNuRDtBQUNBLFNBQVNreEMsa0JBQWtCVyxXQUFXLEVBQUVDLFlBQVksRUFBRXZwQixVQUFVLEVBQUUvNkIsU0FBUyxFQUFFVCxPQUFPLEVBQUU7SUFDbEYsSUFBSWdsRCxjQUFjLENBQUM7SUFDbkIsSUFBSyxJQUFJMWtELFlBQVl3a0QsWUFBYTtRQUM5QixJQUFJSCxTQUFTRyxXQUFXLENBQUN4a0QsU0FBUztRQUNsQyxJQUFJeWtELFlBQVksQ0FBQ3prRCxTQUFTLEVBQUU7WUFDeEIwa0QsV0FBVyxDQUFDMWtELFNBQVMsR0FBRzJrRCxZQUFZTixRQUFRbnBCLFlBQVkvNkIsV0FBV1Q7UUFDdkUsT0FDSztZQUNEZ2xELFdBQVcsQ0FBQzFrRCxTQUFTLEdBQUdxa0Q7UUFDNUIsQ0FBQztJQUNMO0lBQ0EsT0FBT0s7QUFDWDtBQUNBLFNBQVNDLFlBQVlyNUIsV0FBVyxFQUFFNFAsVUFBVSxFQUFFLzZCLFNBQVMsRUFBRVQsT0FBTyxFQUFFO0lBQzlELElBQUlxUyxVQUFVclMsUUFBUXFTLE9BQU8sRUFBRTZtQixjQUFjbDVCLFFBQVFrNUIsV0FBVztJQUNoRSxJQUFJZ3NCLFlBQVlsbEQsUUFBUW9TLFdBQVcsQ0FBQ3VwQixlQUFlLENBQUMvUCxZQUFZNlAsV0FBVyxDQUFDO0lBQzVFLElBQUk2b0IsVUFBVWorQztJQUNkNitDLFVBQVVDLEtBQUssQ0FBQztRQUNadjVCLGFBQWFBO1FBQ2JsZCxPQUFPOHNCO1FBQ1AvNkIsV0FBV0E7UUFDWFQsU0FBU0E7SUFDYixHQUFHLFNBQVVvUixHQUFHLEVBQUU7UUFDZCxJQUFJdWEsWUFBWXZhLElBQUl1YSxTQUFTO1FBQzdCLElBQUl0WixRQUFRMFIsa0JBQWtCLEVBQUU7WUFDNUI0SCxZQUFZdFosUUFBUTBSLGtCQUFrQixDQUFDM2hCLElBQUksQ0FBQzgyQixhQUFhdk4sV0FBV3ZhLElBQUlnMEMsR0FBRyxLQUFLejVCO1FBQ3BGLENBQUM7UUFDRCxJQUFJQyxZQUFZa1AsT0FBTyxFQUFFO1lBQ3JCblAsWUFBWUMsWUFBWWtQLE9BQU8sQ0FBQzE0QixJQUFJLENBQUM4MkIsYUFBYXZOLFdBQVd2YSxJQUFJZzBDLEdBQUcsS0FBS3o1QjtRQUM3RSxDQUFDO1FBQ0QzckIsUUFBUUksUUFBUSxDQUFDO1lBQ2JDLE1BQU07WUFDTkMsVUFBVXNyQixZQUFZdHJCLFFBQVE7WUFDOUJna0QsU0FBU0E7WUFDVDlvQixZQUFZQTtZQUNaN1AsV0FBV0E7UUFDZjtJQUNKLEdBQUcsU0FBVTA1QixLQUFLLEVBQUU7UUFDaEJsb0IsUUFBUUMsSUFBSSxDQUFDaW9CLE1BQU1DLE9BQU8sRUFBRUQ7UUFDNUIsSUFBSWh6QyxRQUFReVIsa0JBQWtCLEVBQUU7WUFDNUJ6UixRQUFReVIsa0JBQWtCLENBQUMxaEIsSUFBSSxDQUFDODJCLGFBQWFtc0I7UUFDakQsQ0FBQztRQUNELElBQUl6NUIsWUFBWW1QLE9BQU8sRUFBRTtZQUNyQm5QLFlBQVltUCxPQUFPLENBQUNzcUI7UUFDeEIsQ0FBQztRQUNEcmxELFFBQVFJLFFBQVEsQ0FBQztZQUNiQyxNQUFNO1lBQ05DLFVBQVVzckIsWUFBWXRyQixRQUFRO1lBQzlCZ2tELFNBQVNBO1lBQ1Q5b0IsWUFBWUE7WUFDWjZwQixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxPQUFPL2xELCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdzc0IsY0FBYztRQUFFMFAsWUFBWSxJQUFJO1FBQUVDLGVBQWUrb0I7SUFBUTtBQUMxRjtBQUNBLFNBQVNELGdCQUFnQjVqQixVQUFVLEVBQUVuZ0MsUUFBUSxFQUFFZ2tELE9BQU8sRUFBRTlvQixVQUFVLEVBQUU7SUFDaEUsSUFBSXgzQjtJQUNKLElBQUk0bkIsY0FBYzZVLFVBQVUsQ0FBQ25nQyxTQUFTO0lBQ3RDLElBQUlzckIsZUFBZSxzQkFBc0I7SUFDckMwNEIsWUFBWTE0QixZQUFZMlAsYUFBYSxFQUFFO1FBQ3ZDLE9BQU9qOEIsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR21oQyxhQUFjejhCLENBQUFBLEtBQUssQ0FBQyxHQUFHQSxFQUFFLENBQUMxRCxTQUFTLEdBQUdoQiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHc3NCLGNBQWM7WUFBRTBQLFlBQVksS0FBSztZQUFFRSxZQUFZQTtRQUFXLElBQUl4M0IsRUFBRTtJQUM3SixDQUFDO0lBQ0QsT0FBT3k4QjtBQUNYO0FBQ0EsU0FBUzJqQixxQkFBcUI1NUIsWUFBWSxFQUFFeHFCLE9BQU8sRUFBRTtJQUNqRCxPQUFPd1AsV0FBV2diLGNBQWMsU0FBVW9CLFdBQVcsRUFBRTtRQUFFLE9BQU9pNUIsb0JBQW9CajVCLGFBQWE1ckI7SUFBVTtBQUMvRztBQUNBLFNBQVMrakQsb0JBQW9CdEgsVUFBVSxFQUFFejhDLE9BQU8sRUFBRTtJQUM5QyxJQUFJdXJCLFdBQVcwUCx5QkFBeUJqN0I7SUFDeEMsSUFBSXVsRCxhQUFhLEVBQUUsQ0FBQ24zQyxNQUFNLENBQUNxdUMsV0FBV2p5QixZQUFZLElBQUksRUFBRTtJQUN4RCxJQUFJcVcsVUFBVSxFQUFFLEVBQUUsU0FBUztJQUMzQixJQUFJNGIsV0FBV255QixhQUFhLEVBQUU7UUFDMUJpN0IsV0FBV2wyQyxPQUFPLENBQUNvdEMsV0FBV255QixhQUFhO0lBQy9DLENBQUM7SUFDRCxJQUFJbXlCLFdBQVdseUIsTUFBTSxFQUFFO1FBQ25CZzdCLFdBQVdsMkMsT0FBTyxDQUFDb3RDLFdBQVdseUIsTUFBTTtJQUN4QyxDQUFDO0lBQ0QsSUFBSyxJQUFJemEsS0FBSyxHQUFHMDFDLGVBQWVELFlBQVl6MUMsS0FBSzAxQyxhQUFhN2lELE1BQU0sRUFBRW1OLEtBQU07UUFDeEUsSUFBSTIxQyxZQUFZRCxZQUFZLENBQUMxMUMsR0FBRztRQUNoQyxJQUFJNjBDLFNBQVMzcEIsaUJBQWlCeXFCLFdBQVd6bEQsU0FBU3VyQjtRQUNsRCxJQUFJbzVCLFFBQVE7WUFDUjlqQixRQUFRLzlCLElBQUksQ0FBQzZoRDtRQUNqQixDQUFDO0lBQ0w7SUFDQSxPQUFPOWpCO0FBQ1g7QUFDQSxTQUFTZ2tCLG9CQUFvQmo1QixXQUFXLEVBQUU1ckIsT0FBTyxFQUFFO0lBQy9DLElBQUlzUyxPQUFPdFMsUUFBUW9TLFdBQVcsQ0FBQ3VwQixlQUFlO0lBQzlDLE9BQU8sQ0FBQ3JwQixJQUFJLENBQUNzWixZQUFZNlAsV0FBVyxDQUFDLENBQUNpcUIsV0FBVztBQUNyRDtBQUVBLFNBQVNDLGlCQUFpQnp6QyxVQUFVLEVBQUU2cEIsTUFBTSxFQUFFdlIsWUFBWSxFQUFFaVEsV0FBVyxFQUFFejZCLE9BQU8sRUFBRTtJQUM5RSxPQUFRKzdCLE9BQU8xN0IsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPdWxELGlCQUFpQjF6QyxZQUFZc1ksWUFBWSxDQUFDdVIsT0FBT3o3QixRQUFRLENBQUMsRUFBRXk3QixPQUFPdW9CLE9BQU8sRUFBRXZvQixPQUFPUCxVQUFVLEVBQUVPLE9BQU9wUSxTQUFTLEVBQUUzckI7UUFDNUgsS0FBSztZQUNELE9BQU9zL0IsU0FBU3B0QixZQUFZNnBCLE9BQU83cEIsVUFBVSxFQUM3Q3VvQixjQUFjQSxZQUFZQyxXQUFXLEdBQUcsSUFBSSxFQUFFMTZCO1FBQ2xELEtBQUs7WUFDRCxPQUFPKzdCLE9BQU83cEIsVUFBVTtRQUM1QixLQUFLO1lBQ0QsT0FBTzRhLGlCQUFpQjVhLFlBQVk2cEIsT0FBTzdwQixVQUFVO1FBQ3pELEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7WUFDRCxJQUFJdW9CLGFBQWE7Z0JBQ2IsT0FBT3hvQixnQkFBZ0JDLFlBQVl1b0IsWUFBWUMsV0FBVyxFQUFFMTZCO1lBQ2hFLENBQUM7WUFDRCxPQUFPa1M7UUFDWCxLQUFLO1lBQ0QsT0FBT2diLHFCQUFxQmhiLFlBQVk2cEIsT0FBTzdwQixVQUFVO1FBQzdELEtBQUs7WUFDRCxPQUFPMnpDLHdCQUF3QjN6QyxZQUFZNnBCLE9BQU96N0IsUUFBUTtRQUM5RCxLQUFLO1lBQ0QsT0FBT2tzQixxQkFBcUJ0YSxZQUFZLFNBQVVnQixRQUFRLEVBQUU7Z0JBQUUsT0FBUSxDQUFDQSxTQUFTNVMsUUFBUSxDQUFDLHFDQUFxQzs7WUFDM0g7UUFDUCxLQUFLO1lBQ0QsT0FBT3dyQjtRQUNYO1lBQ0ksT0FBTzVaO0lBQ2Y7QUFDSjtBQUNBLFNBQVMwekMsaUJBQWlCMXpDLFVBQVUsRUFBRTBaLFdBQVcsRUFBRTA0QixPQUFPLEVBQUU5b0IsVUFBVSxFQUFFN1AsU0FBUyxFQUFFM3JCLE9BQU8sRUFBRTtJQUN4RixJQUFJNHJCLGVBQWUsc0JBQXNCO0lBQ3JDMDRCLFlBQVkxNEIsWUFBWTJQLGFBQWEsQ0FBQyxvREFBb0Q7TUFDNUY7UUFDRSxJQUFJdXFCLFNBQVNwNkIsWUFBWXE2QixtQkFBbUJwNkIsV0FBV0MsYUFBYTVyQixVQUFVNHJCLGFBQWE1ckI7UUFDM0YsSUFBSXc3QixZQUFZO1lBQ1pzcUIsU0FBUzd6QyxnQkFBZ0I2ekMsUUFBUXRxQixZQUFZeDdCO1FBQ2pELENBQUM7UUFDRCxPQUFPOHNCLGlCQUFpQis0Qix3QkFBd0IzekMsWUFBWTBaLFlBQVl0ckIsUUFBUSxHQUFHd2xEO0lBQ3ZGLENBQUM7SUFDRCxPQUFPNXpDO0FBQ1g7QUFDQSxTQUFTNnpDLG1CQUFtQnA2QixTQUFTLEVBQUVDLFdBQVcsRUFBRTVyQixPQUFPLEVBQUU7SUFDekQsSUFBSWdtRCxtQkFBbUJobUQsUUFBUXFTLE9BQU8sQ0FBQ3FSLGtCQUFrQjtJQUN6RCxJQUFJdWlDLHNCQUFzQnI2QixjQUFjQSxZQUFZbEksa0JBQWtCLEdBQUcsSUFBSTtJQUM3RSxJQUFJdWlDLHFCQUFxQjtRQUNyQnQ2QixZQUFZdTZCLHNCQUFzQnY2QixXQUFXczZCO0lBQ2pELENBQUM7SUFDRCxJQUFJRCxrQkFBa0I7UUFDbEJyNkIsWUFBWXU2QixzQkFBc0J2NkIsV0FBV3E2QjtJQUNqRCxDQUFDO0lBQ0QsT0FBT3I2QjtBQUNYO0FBQ0EsU0FBU3U2QixzQkFBc0J2NkIsU0FBUyxFQUFFL2pCLElBQUksRUFBRTtJQUM1QyxJQUFJdStDO0lBQ0osSUFBSSxDQUFDditDLE1BQU07UUFDUHUrQyxnQkFBZ0J4NkI7SUFDcEIsT0FDSztRQUNEdzZCLGdCQUFnQixFQUFFO1FBQ2xCLElBQUssSUFBSXIyQyxLQUFLLEdBQUdtYyxjQUFjTixXQUFXN2IsS0FBS21jLFlBQVl0cEIsTUFBTSxFQUFFbU4sS0FBTTtZQUNyRSxJQUFJb2MsV0FBV0QsV0FBVyxDQUFDbmMsR0FBRztZQUM5QixJQUFJczJDLGVBQWV4K0MsS0FBS3NrQjtZQUN4QixJQUFJazZCLGNBQWM7Z0JBQ2RELGNBQWNyakQsSUFBSSxDQUFDc2pEO1lBQ3ZCLE9BQ0ssSUFBSUEsZ0JBQWdCLElBQUksRUFBRTtnQkFDM0JELGNBQWNyakQsSUFBSSxDQUFDb3BCO1lBQ3ZCLENBQUMsQ0FBQyx5Q0FBeUM7UUFDL0M7SUFDSixDQUFDO0lBQ0QsT0FBT2k2QjtBQUNYO0FBQ0EsU0FBUzdtQixTQUFTcHRCLFVBQVUsRUFBRTR6QyxNQUFNLEVBQUVPLFdBQVcsRUFBRXJtRCxPQUFPLEVBQUU7SUFDeEQsSUFBSXFtRCxhQUFhO1FBQ2JQLFNBQVM3ekMsZ0JBQWdCNnpDLFFBQVFPLGFBQWFybUQ7SUFDbEQsQ0FBQztJQUNELE9BQU84c0IsaUJBQWlCNWEsWUFBWTR6QztBQUN4QztBQUNBLFNBQVNRLHNCQUFzQnAwQyxVQUFVLEVBQUVxMEMsVUFBVSxFQUFFQyxVQUFVLEVBQUU7SUFDL0QsSUFBSWwwQyxPQUFPSixXQUFXSSxJQUFJO0lBQzFCLElBQUlDLFlBQVk1QyxRQUFRdUMsV0FBV0ssU0FBUyxFQUFFLFNBQVVDLFFBQVEsRUFBRTtRQUM5RCxJQUFJRSxNQUFNSixJQUFJLENBQUNFLFNBQVMvRCxLQUFLLENBQUM7UUFDOUIsSUFBSWlFLElBQUlkLE1BQU0sSUFBSWMsSUFBSUQsWUFBWSxFQUFFO1lBQ2hDLE9BQU9ELFVBQVUsOEJBQThCO1FBQ25ELENBQUM7UUFDRCxPQUFPbFQsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR2tULFdBQVc7WUFBRTlELE9BQU87Z0JBQ3pDc0UsT0FBT3d6QyxXQUFXbDFCLFlBQVksQ0FBQ2kxQixXQUFXaHVCLE1BQU0sQ0FBQy9sQixTQUFTOUQsS0FBSyxDQUFDc0UsS0FBSyxFQUFFUixTQUFTN0QsY0FBYztnQkFDOUZzRSxLQUFLdXpDLFdBQVdsMUIsWUFBWSxDQUFDaTFCLFdBQVdodUIsTUFBTSxDQUFDL2xCLFNBQVM5RCxLQUFLLENBQUN1RSxHQUFHLEVBQUVULFNBQVM1RCxZQUFZO1lBQzVGO1lBQUdELGdCQUFnQjYzQyxXQUFXOWlCLGdCQUFnQixHQUFHLElBQUksR0FBR2x4QixTQUFTN0QsY0FBYztZQUFFQyxjQUFjNDNDLFdBQVc5aUIsZ0JBQWdCLEdBQUcsSUFBSSxHQUFHbHhCLFNBQVM1RCxZQUFZO1FBQUM7SUFDbEs7SUFDQSxPQUFPO1FBQUUwRCxNQUFNQTtRQUFNQyxXQUFXQTtJQUFVO0FBQzlDO0FBQ0EsU0FBU3N6Qyx3QkFBd0IzekMsVUFBVSxFQUFFNVIsUUFBUSxFQUFFO0lBQ25ELE9BQU9rc0IscUJBQXFCdGEsWUFBWSxTQUFVZ0IsUUFBUSxFQUFFO1FBQUUsT0FBT0EsU0FBUzVTLFFBQVEsS0FBS0E7SUFBVTtBQUN6RztBQUNBLHVGQUF1RjtBQUN2RixTQUFTbW1ELGlCQUFpQnYwQyxVQUFVLEVBQUV3MEMsUUFBUSxFQUFFO0lBQzVDLE9BQU87UUFDSHAwQyxNQUFNSixXQUFXSSxJQUFJO1FBQ3JCQyxXQUFXL0MsV0FBVzBDLFdBQVdLLFNBQVMsRUFBRSxTQUFVQyxRQUFRLEVBQUU7WUFBRSxPQUFPLENBQUNrMEMsUUFBUSxDQUFDbDBDLFNBQVMzRCxVQUFVLENBQUM7UUFBRTtJQUM3RztBQUNKO0FBRUEsU0FBUzgzQyxvQkFBb0JDLGdCQUFnQixFQUFFN3FCLE1BQU0sRUFBRTtJQUNuRCxPQUFRQSxPQUFPMTdCLElBQUk7UUFDZixLQUFLO1lBQ0QsT0FBTyxJQUFJO1FBQ2YsS0FBSztZQUNELE9BQU8wN0IsT0FBT2pELFNBQVM7UUFDM0I7WUFDSSxPQUFPOHRCO0lBQ2Y7QUFDSjtBQUVBLFNBQVNDLG9CQUFvQkMsaUJBQWlCLEVBQUUvcUIsTUFBTSxFQUFFO0lBQ3BELE9BQVFBLE9BQU8xN0IsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU8wN0IsT0FBT2dyQixlQUFlO1FBQ2pDO1lBQ0ksT0FBT0Q7SUFDZjtBQUNKO0FBRUEsU0FBU0UsZ0JBQWdCQyxXQUFXLEVBQUVsckIsTUFBTSxFQUFFO0lBQzFDLElBQUltckI7SUFDSixPQUFRbnJCLE9BQU8xN0IsSUFBSTtRQUNmLEtBQUs7WUFDRCxPQUFPLElBQUk7UUFDZixLQUFLO1lBQ0Q2bUQsVUFBVW5yQixPQUFPMkIsS0FBSztZQUN0QixPQUFPO2dCQUNIOE4sZ0JBQWdCMGIsUUFBUTFiLGNBQWM7Z0JBQ3RDRSxlQUFld2IsUUFBUXhiLGFBQWE7Z0JBQ3BDRyxTQUFTcWIsUUFBUXJiLE9BQU87WUFDNUI7UUFDSjtZQUNJLE9BQU9vYjtJQUNmO0FBQ0o7QUFFQSxTQUFTRSxrQkFBa0JDLGFBQWEsRUFBRXJyQixNQUFNLEVBQUU7SUFDOUMsSUFBSXNyQjtJQUNKLE9BQVF0ckIsT0FBTzE3QixJQUFJO1FBQ2YsS0FBSztZQUNELE9BQU8sSUFBSTtRQUNmLEtBQUs7WUFDRGduRCxZQUFZdHJCLE9BQU8yQixLQUFLO1lBQ3hCLE9BQU87Z0JBQ0g4TixnQkFBZ0I2YixVQUFVN2IsY0FBYztnQkFDeENFLGVBQWUyYixVQUFVM2IsYUFBYTtnQkFDdENHLFNBQVN3YixVQUFVeGIsT0FBTztZQUM5QjtRQUNKO1lBQ0ksT0FBT3ViO0lBQ2Y7QUFDSjtBQUVBLFNBQVNFLGNBQWM1b0IsZUFBZSxFQUFFNm9CLHVCQUF1QixFQUFFamIsS0FBSyxFQUFFMU8sU0FBUyxFQUFFMUUsV0FBVyxFQUFFO0lBQzVGLElBQUk4RSxTQUFTVSxnQkFBZ0IvZSxhQUFhLEdBQUc2bkMsYUFBYTlvQixnQkFBZ0IvZSxhQUFhLEVBQUUrZSxpQkFBaUI2b0IseUJBQXlCamIsT0FBTzFPLFdBQVcxRSxlQUFlLElBQUk7SUFDeEssSUFBSWdGLFNBQVNRLGdCQUFnQjllLGFBQWEsR0FBRzRuQyxhQUFhOW9CLGdCQUFnQjllLGFBQWEsRUFBRThlLGlCQUFpQjZvQix5QkFBeUJqYixPQUFPMU8sV0FBVzFFLGVBQWUsSUFBSTtJQUN4SyxPQUFPO1FBQUU4RSxRQUFRQTtRQUFRRSxRQUFRQTtJQUFPO0FBQzVDO0FBQ0EsU0FBU3NwQixhQUFhQyxjQUFjLEVBQUUvb0IsZUFBZSxFQUFFNm9CLHVCQUF1QixFQUFFamIsS0FBSyxFQUFFMU8sU0FBUyxFQUFFMUUsV0FBVyxFQUFFO0lBQzNHLElBQUl3dUIsaUJBQWlCLENBQUM7SUFDdEIsSUFBSXpwQixtQkFBbUIsRUFBRTtJQUN6QixJQUFJMHBCLFdBQVcsS0FBSztJQUNwQixJQUFLLElBQUlDLGVBQWVILGVBQWdCO1FBQ3BDLElBQUlJLGFBQWFKLGNBQWMsQ0FBQ0csWUFBWTtRQUM1QyxJQUFJRSxhQUFhQyxhQUFhRixZQUFZbnBCLGlCQUFpQjZvQix5QkFBeUJqYixPQUFPMU8sV0FBVzFFO1FBQ3RHd3VCLGNBQWMsQ0FBQ0UsWUFBWSxHQUFHRSxXQUFXRSxPQUFPO1FBQ2hEL3BCLGlCQUFpQm43QixJQUFJLENBQUNrRyxLQUFLLENBQUNpMUIsa0JBQWtCNnBCLFdBQVc3cEIsZ0JBQWdCO1FBQ3pFMHBCLFdBQVdBLFlBQVlHLFdBQVdILFFBQVE7SUFDOUM7SUFDQSxPQUFPO1FBQUVELGdCQUFnQkE7UUFBZ0J6cEIsa0JBQWtCQTtRQUFrQjBwQixVQUFVQTtJQUFTO0FBQ3BHO0FBQ0E7O0FBRUEsR0FDQSxTQUFTSSxhQUFhRixVQUFVLEVBQUVucEIsZUFBZSxFQUNqRDZvQix1QkFBdUIsRUFDdkJqYixLQUFLLEVBQUUxTyxTQUFTLEVBQUUxRSxXQUFXLEVBQUU7SUFDM0IsSUFBSXFjLFFBQVE3VyxnQkFBZ0I3aEIsU0FBUyxLQUFLO0lBQzFDLElBQUlvckMsd0JBQXdCdnBCLGdCQUFnQnpmLGFBQWEsSUFBSSxDQUFDO0lBQzlELElBQUlpcEMsOEJBQThCWCx3QkFBd0JwOUIsVUFBVSxJQUFJLENBQUM7SUFDekUsSUFBSWcrQixxQkFBcUJ6cEIsZ0JBQWdCdlUsVUFBVSxJQUFJLENBQUM7SUFDeEQsSUFBSWkrQiw4QkFBOEJiLHdCQUF3Qm45QixXQUFXLElBQUksQ0FBQztJQUMxRSxJQUFJaStCLHNCQUFzQjNwQixnQkFBZ0J0VSxXQUFXLElBQUksQ0FBQztJQUMxRCxJQUFJaytCLGlCQUFpQlQsYUFBYUEsV0FBV3hnRCxLQUFLLENBQUMsT0FBTyxFQUFFO0lBQzVELElBQUk0MkIsbUJBQW1CLEVBQUU7SUFDekIsSUFBSTBwQixXQUFXLEtBQUs7SUFDcEIsSUFBSUssVUFBVU0sZUFBZS8wQyxHQUFHLENBQUMsU0FBVWcxQyxjQUFjLEVBQUU7UUFBRSxPQUFRQSxlQUFlbGhELEtBQUssQ0FBQyxLQUFLa00sR0FBRyxDQUFDLFNBQVV5aEMsVUFBVSxFQUFFO1lBQ3JILElBQUlBLGVBQWUsU0FBUztnQkFDeEIyUyxXQUFXLElBQUk7Z0JBQ2YsT0FBTztvQkFBRTNTLFlBQVlBO2dCQUFXO1lBQ3BDLENBQUM7WUFDRCxJQUFJVztZQUNKLElBQUljO1lBQ0osSUFBSStSO1lBQ0osSUFBSUMsWUFBWSxnQ0FBZ0M7WUFDaEQsSUFBSXQrQixZQUFZLElBQUk7WUFDcEIsSUFBSTAyQjtZQUNKLGtEQUFrRDtZQUNsRCxJQUFLbEwsb0JBQW9Cc1MscUJBQXFCLENBQUNqVCxXQUFXLEVBQUc7Z0JBQ3pEd1QsY0FBYyxTQUFVemtELEVBQUUsRUFBRTtvQkFDeEIsSUFBSTR4QyxrQkFBa0IrUyxLQUFLLEVBQUU7d0JBQ3pCL1Msa0JBQWtCK1MsS0FBSyxDQUFDdG1ELElBQUksQ0FBQzJCLEdBQUdJLE1BQU0sRUFBRUosSUFBSUEsR0FBR0ksTUFBTSxHQUFHLG1DQUFtQztvQkFDL0YsQ0FBQztnQkFDTDtnQkFDQ3NrRCxDQUFBQSxhQUFhbmMsTUFBTW9KLHdCQUF3QixDQUFDQyxrQkFBaUIsS0FDekQ4UyxDQUFBQSxhQUFhbmMsTUFBTWdKLFlBQVksQ0FBQ04sWUFBWU8sTUFBSyxLQUNqRHByQixDQUFBQSxhQUFhd3JCLGtCQUFrQmdULElBQUk7Z0JBQ3hDOUgsYUFBYWxMLGtCQUFrQmlULElBQUksSUFBSWpULGtCQUFrQmdULElBQUk7WUFDakUsT0FDSyxJQUFLbFMsV0FBVzdZLFNBQVMsQ0FBQ29YLFdBQVcsRUFBRztnQkFDekMvVyxpQkFBaUJuN0IsSUFBSSxDQUFDa3lDO2dCQUN0QndULGNBQWMsV0FBWTtvQkFDdEJ0dkIsWUFBWW9FLFVBQVUsQ0FBQzBYO2dCQUMzQjtnQkFDQzdxQixDQUFBQSxhQUFhc3NCLFNBQVNpSyxrQkFBa0IsS0FDcEMrSCxDQUFBQSxhQUFhbmMsTUFBTWdKLFlBQVksQ0FBQ04sWUFBWU8sTUFBSyxLQUNqRHByQixDQUFBQSxhQUFhc3NCLFNBQVNrSyxpQkFBaUI7Z0JBQzVDLElBQUlrSSxlQUFlcFMsU0FBU2lLLGtCQUFrQixJQUMxQ2pLLFNBQVNrSyxpQkFBaUI7Z0JBQzlCRSxhQUFhajRDLG1CQUFtQjZ0QyxTQUFTbUssbUJBQW1CLElBQ3hEbkssU0FBU3FLLGtCQUFrQixJQUMzQnBpQixnQkFBZ0J4VyxRQUFRLEVBQUU7b0JBQUMyZ0M7b0JBQWM3VDtpQkFBVyxFQUN4RDZUO1lBQ0osT0FDSyxJQUFJM3ZCLFdBQVcsQ0FBQzhiLFdBQVcsRUFBRTtnQkFDOUJ3VCxjQUFjLFdBQVk7b0JBQ3RCdHZCLFdBQVcsQ0FBQzhiLFdBQVc7Z0JBQzNCO2dCQUNDN3FCLENBQUFBLGFBQWErOUIsMkJBQTJCLENBQUNsVCxXQUFXLEtBQ2hEeVQsQ0FBQUEsYUFBYW5jLE1BQU1nSixZQUFZLENBQUNOLFlBQVlPLE1BQUssS0FDakRwckIsQ0FBQUEsYUFBYWcrQixrQkFBa0IsQ0FBQ25ULFdBQVcsR0FBRyx3Q0FBd0M7Z0JBQzNGLElBQUlBLGVBQWUsY0FBY0EsZUFBZSxZQUFZO29CQUN4RCxJQUFJOFQsYUFBYTlULGVBQWUsYUFBYSxTQUFTLE1BQU07b0JBQzVENkwsYUFBYWo0QyxtQkFBbUJ3L0MsMkJBQTJCLENBQUNVLFdBQVcsSUFDbkVULG1CQUFtQixDQUFDUyxXQUFXLEVBQUU7d0JBQ2pDWCxtQkFBbUJuN0MsSUFBSSxJQUFJO3dCQUMzQjtxQkFDSCxFQUFFbTdDLGtCQUFrQixDQUFDblQsV0FBVztnQkFDckMsT0FDSztvQkFDRDZMLGFBQWEsU0FBVWtJLE9BQU8sRUFBRTt3QkFBRSxPQUFPbmdELG1CQUFtQncvQywyQkFBMkIsQ0FBQ3BULFdBQVcsSUFDL0ZxVCxtQkFBbUIsQ0FBQ3JULFdBQVcsRUFBRTs0QkFDakNtVCxrQkFBa0IsQ0FBQ1ksUUFBUSxJQUFJQTs0QkFDL0JBO3lCQUNILEVBQUVaLGtCQUFrQixDQUFDblQsV0FBVztvQkFBRztnQkFDeEMsQ0FBQztZQUNMLENBQUM7WUFDRCxPQUFPO2dCQUFFQSxZQUFZQTtnQkFBWXdULGFBQWFBO2dCQUFhQyxZQUFZQTtnQkFBWXQrQixZQUFZQTtnQkFBWTAyQixZQUFZQTtZQUFXO1FBQ3RJO0lBQUs7SUFDTCxPQUFPO1FBQUVtSCxTQUFTQTtRQUFTL3BCLGtCQUFrQkE7UUFBa0IwcEIsVUFBVUE7SUFBUztBQUN0RjtBQUVBLElBQUlxQixtQkFBbUI7SUFDbkJ0RCxhQUFhLElBQUk7SUFDakI5cEIsV0FBVyxTQUFVdHFCLE9BQU8sRUFBRTtRQUMxQixJQUFJaEssTUFBTUMsT0FBTyxDQUFDK0osUUFBUWlaLE1BQU0sR0FBRztZQUMvQixPQUFPalosUUFBUWlaLE1BQU07UUFDekIsQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0E0NkIsT0FBTyxTQUFVaDhDLEdBQUcsRUFBRTJ4QixPQUFPLEVBQUU7UUFDM0JBLFFBQVE7WUFDSm5QLFdBQVd4aUIsSUFBSXlpQixXQUFXLENBQUM1cUIsSUFBSTtRQUNuQztJQUNKO0FBQ0o7QUFDQSxJQUFJaW9ELHlCQUF5Qm5RLGFBQWE7SUFDdENuZCxpQkFBaUI7UUFBQ3F0QjtLQUFpQjtBQUN2QztBQUVBLElBQUlFLG1CQUFtQjtJQUNuQnR0QixXQUFXLFNBQVV0cUIsT0FBTyxFQUFFO1FBQzFCLElBQUksT0FBT0EsUUFBUWlaLE1BQU0sS0FBSyxZQUFZO1lBQ3RDLE9BQU9qWixRQUFRaVosTUFBTTtRQUN6QixDQUFDO1FBQ0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTQ2QixPQUFPLFNBQVVoOEMsR0FBRyxFQUFFMnhCLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ3BDLElBQUl2cEIsVUFBVXJJLElBQUluSixPQUFPLENBQUN3UixPQUFPO1FBQ2pDLElBQUk1SixPQUFPdUIsSUFBSXlpQixXQUFXLENBQUM1cUIsSUFBSTtRQUMvQjZ2QyxZQUFZanBDLEtBQUt1aEQsSUFBSSxDQUFDLElBQUksRUFBRTl3QiwwQkFBMEJsdkIsSUFBSXVGLEtBQUssRUFBRThDLFdBQVcsU0FBVW1hLFNBQVMsRUFBRTtZQUM3Rm1QLFFBQVE7Z0JBQUVuUCxXQUFXQTtZQUFVLElBQUksMkJBQTJCO1FBQ2xFLEdBQUdvUDtJQUNQO0FBQ0o7QUFDQSxJQUFJcXVCLHdCQUF3QnRRLGFBQWE7SUFDckNuZCxpQkFBaUI7UUFBQ3V0QjtLQUFpQjtBQUN2QztBQUVBLFNBQVNHLFlBQVlybkQsTUFBTSxFQUFFZixHQUFHLEVBQUVxb0QsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLGVBQWUsRUFBRTtJQUN4RXhuRCxTQUFTQSxPQUFPeW5ELFdBQVc7SUFDM0IsSUFBSWpqRCxPQUFPLElBQUk7SUFDZixJQUFJeEUsV0FBVyxPQUFPO1FBQ2xCZixNQUFNeW9ELHdCQUF3QnpvRCxLQUFLcW9EO0lBQ3ZDLE9BQ0s7UUFDRDlpRCxPQUFPbWpELGFBQWFMO0lBQ3hCLENBQUM7SUFDRCxJQUFJbEUsTUFBTSxJQUFJd0U7SUFDZHhFLElBQUl5RSxJQUFJLENBQUM3bkQsUUFBUWYsS0FBSyxJQUFJO0lBQzFCLElBQUllLFdBQVcsT0FBTztRQUNsQm9qRCxJQUFJMEUsZ0JBQWdCLENBQUMsZ0JBQWdCO0lBQ3pDLENBQUM7SUFDRDFFLElBQUkyRSxNQUFNLEdBQUcsV0FBWTtRQUNyQixJQUFJM0UsSUFBSTRFLE1BQU0sSUFBSSxPQUFPNUUsSUFBSTRFLE1BQU0sR0FBRyxLQUFLO1lBQ3ZDLElBQUl0NEMsU0FBUyxLQUFLO1lBQ2xCLElBQUlOLE1BQU0sS0FBSztZQUNmLElBQUk7Z0JBQ0FBLE1BQU02dkMsS0FBS3R2QyxLQUFLLENBQUN5ekMsSUFBSTZFLFlBQVk7Z0JBQ2pDdjRDLFNBQVMsSUFBSTtZQUNqQixFQUNBLE9BQU93NEMsS0FBSztZQUNSLDJCQUEyQjtZQUMvQjtZQUNBLElBQUl4NEMsUUFBUTtnQkFDUjYzQyxnQkFBZ0JuNEMsS0FBS2cwQztZQUN6QixPQUNLO2dCQUNEb0UsZ0JBQWdCLHdCQUF3QnBFO1lBQzVDLENBQUM7UUFDTCxPQUNLO1lBQ0RvRSxnQkFBZ0Isa0JBQWtCcEU7UUFDdEMsQ0FBQztJQUNMO0lBQ0FBLElBQUkrRSxPQUFPLEdBQUcsV0FBWTtRQUN0QlgsZ0JBQWdCLGtCQUFrQnBFO0lBQ3RDO0lBQ0FBLElBQUlnRixJQUFJLENBQUM1akQ7QUFDYjtBQUNBLFNBQVNrakQsd0JBQXdCem9ELEdBQUcsRUFBRXFvRCxNQUFNLEVBQUU7SUFDMUMsT0FBT3JvRCxNQUNGQSxDQUFBQSxJQUFJdWMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxJQUNwQ21zQyxhQUFhTDtBQUNyQjtBQUNBLFNBQVNLLGFBQWFMLE1BQU0sRUFBRTtJQUMxQixJQUFJM3NDLFFBQVEsRUFBRTtJQUNkLElBQUssSUFBSXhXLE9BQU9takQsT0FBUTtRQUNwQjNzQyxNQUFNN1osSUFBSSxDQUFDdW5ELG1CQUFtQmxrRCxPQUFPLE1BQU1ra0QsbUJBQW1CZixNQUFNLENBQUNuakQsSUFBSTtJQUM3RTtJQUNBLE9BQU93VyxNQUFNSSxJQUFJLENBQUM7QUFDdEI7QUFFQSxJQUFJdXRDLGtDQUFrQztJQUNsQ3RvRCxRQUFRc0U7SUFDUmlrRCxhQUFhMXJDO0lBQ2JrRCxZQUFZemI7SUFDWjBiLFVBQVUxYjtJQUNWMmIsZUFBZTNiO0FBQ25CO0FBRUEsSUFBSWtrRCxpQkFBaUI7SUFDakI1dUIsV0FBVyxTQUFVdHFCLE9BQU8sRUFBRTtRQUMxQixJQUFJQSxRQUFRclEsR0FBRyxJQUFLcVEsQ0FBQUEsUUFBUXBRLE1BQU0sS0FBSyxVQUFVLENBQUNvUSxRQUFRcFEsTUFBTSxHQUFHO1lBQy9ELE9BQU87Z0JBQ0hELEtBQUtxUSxRQUFRclEsR0FBRztnQkFDaEJDLFFBQVE7Z0JBQ1JjLFFBQVEsQ0FBQ3NQLFFBQVF0UCxNQUFNLElBQUksS0FBSSxFQUFHeW5ELFdBQVc7Z0JBQzdDYyxhQUFhajVDLFFBQVFpNUMsV0FBVztnQkFDaEN4b0MsWUFBWXpRLFFBQVF5USxVQUFVO2dCQUM5QkMsVUFBVTFRLFFBQVEwUSxRQUFRO2dCQUMxQkMsZUFBZTNRLFFBQVEyUSxhQUFhO1lBQ3hDO1FBQ0osQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0FrakMsT0FBTyxTQUFVaDhDLEdBQUcsRUFBRTJ4QixPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNwQyxJQUFJLzVCLE9BQU9tSSxJQUFJeWlCLFdBQVcsQ0FBQzVxQixJQUFJO1FBQy9CLElBQUl5cEQsZ0JBQWdCQyxtQkFBbUIxcEQsTUFBTW1JLElBQUl1RixLQUFLLEVBQUV2RixJQUFJbkosT0FBTztRQUNuRXFwRCxZQUFZcm9ELEtBQUtnQixNQUFNLEVBQUVoQixLQUFLQyxHQUFHLEVBQUV3cEQsZUFBZSxTQUFVOStCLFNBQVMsRUFBRXk1QixHQUFHLEVBQUU7WUFDeEV0cUIsUUFBUTtnQkFBRW5QLFdBQVdBO2dCQUFXeTVCLEtBQUtBO1lBQUk7UUFDN0MsR0FBRyxTQUFVdUYsWUFBWSxFQUFFdkYsR0FBRyxFQUFFO1lBQzVCcnFCLFFBQVE7Z0JBQUV1cUIsU0FBU3FGO2dCQUFjdkYsS0FBS0E7WUFBSTtRQUM5QztJQUNKO0FBQ0o7QUFDQSxJQUFJd0YsNEJBQTRCOVIsYUFBYTtJQUN6Q3BkLHFCQUFxQjR1QjtJQUNyQjN1QixpQkFBaUI7UUFBQzZ1QjtLQUFlO0FBQ3JDO0FBQ0EsU0FBU0UsbUJBQW1CMXBELElBQUksRUFBRTBOLEtBQUssRUFBRTFPLE9BQU8sRUFBRTtJQUM5QyxJQUFJd1IsVUFBVXhSLFFBQVF3UixPQUFPLEVBQUVhLFVBQVVyUyxRQUFRcVMsT0FBTztJQUN4RCxJQUFJMFA7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSTRvQztJQUNKLElBQUl2QixTQUFTLENBQUM7SUFDZHZuQyxhQUFhL2dCLEtBQUsrZ0IsVUFBVTtJQUM1QixJQUFJQSxjQUFjLElBQUksRUFBRTtRQUNwQkEsYUFBYTFQLFFBQVEwUCxVQUFVO0lBQ25DLENBQUM7SUFDREMsV0FBV2hoQixLQUFLZ2hCLFFBQVE7SUFDeEIsSUFBSUEsWUFBWSxJQUFJLEVBQUU7UUFDbEJBLFdBQVczUCxRQUFRMlAsUUFBUTtJQUMvQixDQUFDO0lBQ0RDLGdCQUFnQmpoQixLQUFLaWhCLGFBQWE7SUFDbEMsSUFBSUEsaUJBQWlCLElBQUksRUFBRTtRQUN2QkEsZ0JBQWdCNVAsUUFBUTRQLGFBQWE7SUFDekMsQ0FBQztJQUNELHVEQUF1RDtJQUN2RCxJQUFJLE9BQU9qaEIsS0FBS3VwRCxXQUFXLEtBQUssWUFBWTtRQUN4Qyx5REFBeUQ7UUFDekRNLHNCQUFzQjdwRCxLQUFLdXBELFdBQVc7SUFDMUMsT0FDSztRQUNELG1EQUFtRDtRQUNuRE0sc0JBQXNCN3BELEtBQUt1cEQsV0FBVyxJQUFJLENBQUM7SUFDL0MsQ0FBQztJQUNEanJELCtDQUFRQSxDQUFDZ3FELFFBQVF1QjtJQUNqQnZCLE1BQU0sQ0FBQ3ZuQyxXQUFXLEdBQUd2USxRQUFRaW5CLFNBQVMsQ0FBQy9wQixNQUFNc0UsS0FBSztJQUNsRHMyQyxNQUFNLENBQUN0bkMsU0FBUyxHQUFHeFEsUUFBUWluQixTQUFTLENBQUMvcEIsTUFBTXVFLEdBQUc7SUFDOUMsSUFBSXpCLFFBQVFvSyxRQUFRLEtBQUssU0FBUztRQUM5QjB0QyxNQUFNLENBQUNybkMsY0FBYyxHQUFHelEsUUFBUW9LLFFBQVE7SUFDNUMsQ0FBQztJQUNELE9BQU8wdEM7QUFDWDtBQUVBLElBQUl3Qiw0QkFBNEI7SUFDNUIvakIsWUFBWWxvQjtJQUNaZ29CLFdBQVduekI7SUFDWG96QixTQUFTcHpCO0lBQ1Q1QixVQUFVNEI7SUFDVnEzQyxZQUFZbHNDO0lBQ1ptc0MsVUFBVW5zQztBQUNkO0FBRUEsSUFBSW9zQyxZQUFZO0lBQ1p0NUMsT0FBTyxTQUFVTCxPQUFPLEVBQUVFLE9BQU8sRUFBRTtRQUMvQixJQUFJRixRQUFReTFCLFVBQVUsSUFBSXoxQixRQUFRdTFCLFNBQVMsSUFBSXYxQixRQUFRdzFCLE9BQU8sSUFBSXgxQixRQUFReTVDLFVBQVUsSUFBSXo1QyxRQUFRMDVDLFFBQVEsRUFBRTtZQUN0RyxJQUFJRSxnQkFBZ0I7Z0JBQ2hCbmtCLFlBQVl6MUIsUUFBUXkxQixVQUFVLElBQUksSUFBSTtnQkFDdENGLFdBQVd2MUIsUUFBUXUxQixTQUFTLElBQUksSUFBSTtnQkFDcENDLFNBQVN4MUIsUUFBUXcxQixPQUFPLElBQUksSUFBSTtnQkFDaENpa0IsWUFBWXo1QyxRQUFReTVDLFVBQVUsR0FBR3Y1QyxRQUFROGYsWUFBWSxDQUFDaGdCLFFBQVF5NUMsVUFBVSxJQUFJLElBQUk7Z0JBQ2hGQyxVQUFVMTVDLFFBQVEwNUMsUUFBUSxHQUFHeDVDLFFBQVE4ZixZQUFZLENBQUNoZ0IsUUFBUTA1QyxRQUFRLElBQUksSUFBSTtZQUM5RTtZQUNBLElBQUlsNUMsV0FBVyxLQUFLO1lBQ3BCLElBQUlSLFFBQVFRLFFBQVEsRUFBRTtnQkFDbEJBLFdBQVdSLFFBQVFRLFFBQVE7WUFDL0IsQ0FBQztZQUNELElBQUksQ0FBQ0EsWUFBWVIsUUFBUXUxQixTQUFTLElBQUl2MUIsUUFBUXcxQixPQUFPLEVBQUU7Z0JBQ25EaDFCLFdBQVdzRCxrQkFBa0I5RCxRQUFRdzFCLE9BQU8sRUFBRXgxQixRQUFRdTFCLFNBQVM7WUFDbkUsQ0FBQztZQUNELE9BQU87Z0JBQ0hoMUIsYUFBYXdOLFFBQVEsQ0FBQy9OLFFBQVF1MUIsU0FBUyxJQUFJLENBQUN2MUIsUUFBUXcxQixPQUFPO2dCQUMzRGgxQixVQUFVQTtnQkFDVkMsVUFBVW01QztZQUNkO1FBQ0osQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0E3M0MsUUFBUSxTQUFVdEIsUUFBUSxFQUFFSSxZQUFZLEVBQUVYLE9BQU8sRUFBRTtRQUMvQyxJQUFJMjVDLHNCQUFzQm41QixnQkFBZ0I3ZixjQUFjO1lBQUVhLE9BQU9qQixTQUFTZzVDLFVBQVU7WUFBRTkzQyxLQUFLbEIsU0FBU2k1QyxRQUFRO1FBQUM7UUFDN0csSUFBSUcscUJBQXFCO1lBQ3JCLE9BQU9DLGFBQWFyNUMsU0FBU2cxQixVQUFVLEVBQUVoMUIsU0FBUzgwQixTQUFTLEVBQUVza0IscUJBQXFCMzVDO1FBQ3RGLENBQUM7UUFDRCxPQUFPLEVBQUU7SUFDYjtBQUNKO0FBQ0EsSUFBSTY1Qyw4QkFBOEJ2UyxhQUFhO0lBQzNDcm5DLGdCQUFnQjtRQUFDdzVDO0tBQVU7SUFDM0JsL0IsZUFBZSsrQjtBQUNuQjtBQUNBLFNBQVNNLGFBQWFya0IsVUFBVSxFQUFFRixTQUFTLEVBQUUxMEIsWUFBWSxFQUFFWCxPQUFPLEVBQUU7SUFDaEUsSUFBSTg1QyxVQUFVdmtCLGFBQWFsM0IsWUFBWWszQixjQUFjLElBQUk7SUFDekQsSUFBSXdrQixZQUFZcmdELFdBQVdpSCxhQUFhYSxLQUFLO0lBQzdDLElBQUlrZCxZQUFZL2QsYUFBYWMsR0FBRztJQUNoQyxJQUFJdTRDLGlCQUFpQixFQUFFO0lBQ3ZCLE1BQU9ELFlBQVlyN0IsVUFBVztRQUMxQixJQUFJdTdCLGdCQUVGLEtBQUs7UUFDUCw4Q0FBOEM7UUFDOUMsSUFBSSxDQUFDSCxXQUFXQSxPQUFPLENBQUNDLFVBQVVoK0MsU0FBUyxHQUFHLEVBQUU7WUFDNUMsSUFBSXM1QixXQUFXO2dCQUNYNGtCLGdCQUFnQmo2QyxRQUFROUssR0FBRyxDQUFDNmtELFdBQVcxa0I7WUFDM0MsT0FDSztnQkFDRDRrQixnQkFBZ0JGO1lBQ3BCLENBQUM7WUFDREMsZUFBZTFvRCxJQUFJLENBQUMyb0Q7UUFDeEIsQ0FBQztRQUNERixZQUFZamhELFFBQVFpaEQsV0FBVztJQUNuQztJQUNBLE9BQU9DO0FBQ1g7QUFFQSxJQUFJRSxzQkFBc0I1UyxhQUFhO0lBQ25Da0Isc0JBQXNCO1FBQ2xCenZCLFFBQVEsU0FBVUEsTUFBTSxFQUFFdnFCLE9BQU8sRUFBRTtZQUMvQjJyRCxtQkFBbUI7Z0JBQUNwaEM7YUFBTyxFQUFFdnFCO1FBQ2pDO1FBQ0F3cUIsY0FBY21oQztJQUNsQjtBQUNKO0FBQ0E7O0FBRUEsR0FDQSxTQUFTQSxtQkFBbUJ4TSxNQUFNLEVBQUVuL0MsT0FBTyxFQUFFO0lBQ3pDLElBQUk0ckQsaUJBQWlCejdDLGtCQUFrQm5RLFFBQVF1NkIsY0FBYyxHQUFHL1AsWUFBWTtJQUM1RSxJQUFJcWhDLFlBQVksRUFBRTtJQUNsQixJQUFLLElBQUkvN0MsS0FBSyxHQUFHZzhDLFdBQVczTSxRQUFRcnZDLEtBQUtnOEMsU0FBU25wRCxNQUFNLEVBQUVtTixLQUFNO1FBQzVELElBQUk3SSxRQUFRNmtELFFBQVEsQ0FBQ2g4QyxHQUFHO1FBQ3hCLElBQUlpOEMsYUFBYSxLQUFLO1FBQ3RCLElBQUssSUFBSXJwRCxJQUFJLEdBQUdBLElBQUlrcEQsZUFBZWpwRCxNQUFNLEVBQUVELEtBQUssRUFBRztZQUMvQyxJQUFJa3BELGNBQWMsQ0FBQ2xwRCxFQUFFLENBQUMyNEIsSUFBSSxLQUFLcDBCLE9BQU87Z0JBQ2xDMmtELGVBQWU1MEMsTUFBTSxDQUFDdFUsR0FBRyxJQUFJLFNBQVM7Z0JBQ3RDcXBELGFBQWEsSUFBSTtnQkFDakIsS0FBTTtZQUNWLENBQUM7UUFDTDtRQUNBLElBQUksQ0FBQ0EsWUFBWTtZQUNiRixVQUFVL29ELElBQUksQ0FBQ21FO1FBQ25CLENBQUM7SUFDTDtJQUNBLElBQUssSUFBSWpELEtBQUssR0FBR2dvRCxtQkFBbUJKLGdCQUFnQjVuRCxLQUFLZ29ELGlCQUFpQnJwRCxNQUFNLEVBQUVxQixLQUFNO1FBQ3BGLElBQUlpb0QsZ0JBQWdCRCxnQkFBZ0IsQ0FBQ2hvRCxHQUFHO1FBQ3hDaEUsUUFBUUksUUFBUSxDQUFDO1lBQ2JDLE1BQU07WUFDTkMsVUFBVTJyRCxjQUFjM3JELFFBQVE7UUFDcEM7SUFDSjtJQUNBLElBQUssSUFBSTJELEtBQUssR0FBR2lvRCxjQUFjTCxXQUFXNW5ELEtBQUtpb0QsWUFBWXZwRCxNQUFNLEVBQUVzQixLQUFNO1FBQ3JFLElBQUlrb0QsV0FBV0QsV0FBVyxDQUFDam9ELEdBQUc7UUFDOUJqRSxRQUFRazVCLFdBQVcsQ0FBQzBILGNBQWMsQ0FBQ3VyQjtJQUN2QztBQUNKO0FBRUEsU0FBU0Msa0JBQWtCM3hCLFdBQVcsRUFBRXo2QixPQUFPLEVBQUU7SUFDN0NBLFFBQVFpM0IsT0FBTyxDQUFDRSxPQUFPLENBQUMsWUFBWTczQiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHKzRCLDBCQUEwQm9DLFlBQVlDLFdBQVcsRUFBRTE2QixRQUFRd1IsT0FBTyxJQUFJO1FBQUUrbEIsTUFBTXYzQixRQUFRdzNCLE9BQU87SUFBQztBQUM1SjtBQUVBLFNBQVM2MEIsaUJBQWlCbjZDLFVBQVUsRUFBRWxTLE9BQU8sRUFBRTtJQUMzQyxJQUFJaTNCLFVBQVVqM0IsUUFBUWkzQixPQUFPO0lBQzdCLElBQUlBLFFBQVFDLFdBQVcsQ0FBQyxjQUFjO1FBQ2xDRCxRQUFRRSxPQUFPLENBQUMsYUFBYW1KLGVBQWVwdUIsWUFBWWxTO0lBQzVELENBQUM7QUFDTDtBQUVBOzs7QUFHQSxHQUNBLElBQUlzc0QsZ0JBQWdCO0lBQ2hCckQ7SUFDQUc7SUFDQXdCO0lBQ0FTO0lBQ0FLO0lBQ0E1UyxhQUFhO1FBQ1RHLGdCQUFnQjtZQUNaLFNBQVV2YixLQUFLLEVBQUU7Z0JBQUUsT0FBTzhtQiwyQkFBMkI5bUIsTUFBTWxULFlBQVk7WUFBRztTQUM3RTtRQUNEMHZCLHFCQUFxQjtZQUNqQnFTLE1BQU1DO1lBQ05DLFVBQVVDO1FBQ2Q7UUFDQXJTLGlCQUFpQjtZQUNiNWYsYUFBYTJ4QjtZQUNibDZDLFlBQVltNkM7UUFDaEI7SUFDSjtDQUNIO0FBQ0QsU0FBU0csb0JBQW9CO0lBQ3pCLElBQUlHLFlBQVksSUFBSTtJQUNwQixJQUFJQyxjQUFjO0lBQ2xCLFNBQVM3UCxPQUFPMzdDLEVBQUUsRUFBRW1yRCxJQUFJLEVBQUU7UUFDdEIsSUFBSW5yRCxPQUFPdXJELGFBQWFKLFNBQVNLLGFBQWE7WUFDMUN4ckQsR0FBR3VuQyxTQUFTLEdBQUc0akI7UUFDbkIsQ0FBQztRQUNESSxZQUFZdnJEO1FBQ1p3ckQsY0FBY0w7SUFDbEI7SUFDQSxTQUFTck8sVUFBVTtRQUNmeU8sVUFBVWhrQixTQUFTLEdBQUc7UUFDdEJna0IsWUFBWSxJQUFJO1FBQ2hCQyxjQUFjO0lBQ2xCO0lBQ0EsT0FBTztRQUFFN1AsUUFBUUE7UUFBUW1CLFNBQVNBO0lBQVE7QUFDOUM7QUFDQSxTQUFTd08sdUJBQXVCO0lBQzVCLElBQUlDLFlBQVksSUFBSTtJQUNwQixJQUFJRSxrQkFBa0IsRUFBRTtJQUN4QixTQUFTOVAsT0FBTzM3QyxFQUFFLEVBQUVxckQsUUFBUSxFQUFFO1FBQzFCLElBQUlLLGNBQWN4bEQsTUFBTXBILFNBQVMsQ0FBQ29tQyxLQUFLLENBQUNsa0MsSUFBSSxDQUFDcXFEO1FBQzdDLElBQUlyckQsT0FBT3VyRCxhQUFhLENBQUMxMUMsY0FBYzQxQyxpQkFBaUJDLGNBQWM7WUFDbEUscURBQXFEO1lBQ3JELElBQUssSUFBSWg5QyxLQUFLLEdBQUdpOUMsZ0JBQWdCRCxhQUFhaDlDLEtBQUtpOUMsY0FBY3BxRCxNQUFNLEVBQUVtTixLQUFNO2dCQUMzRSxJQUFJazlDLFVBQVVELGFBQWEsQ0FBQ2o5QyxHQUFHO2dCQUMvQjFPLEdBQUd3bkMsV0FBVyxDQUFDb2tCO1lBQ25CO1lBQ0E5TztRQUNKLENBQUM7UUFDRHlPLFlBQVl2ckQ7UUFDWnlyRCxrQkFBa0JDO0lBQ3RCO0lBQ0EsU0FBUzVPLFVBQVU7UUFDZjJPLGdCQUFnQmpuRCxPQUFPLENBQUN6RTtRQUN4QjByRCxrQkFBa0IsRUFBRTtRQUNwQkYsWUFBWSxJQUFJO0lBQ3BCO0lBQ0EsT0FBTztRQUFFNVAsUUFBUUE7UUFBUW1CLFNBQVNBO0lBQVE7QUFDOUM7QUFFQSxJQUFJK08sZ0JBQWdCLFdBQVcsR0FBSSxXQUFZO0lBQzNDLFNBQVNBLGNBQWNDLGFBQWEsRUFBRTtRQUNsQyxJQUFJLENBQUNBLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsS0FBSztRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBRyxLQUFLO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDckI7SUFDQUwsY0FBYy9zRCxTQUFTLENBQUM4MUMsT0FBTyxHQUFHLFNBQVV1WCxLQUFLLEVBQUU7UUFDL0MsSUFBSSxDQUFDSCxPQUFPLEdBQUcsSUFBSTtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLElBQUk7WUFDbEIsSUFBSSxDQUFDQyxZQUFZO1lBQ2pCLElBQUlGLFNBQVMsSUFBSSxFQUFFO2dCQUNmLElBQUksQ0FBQ0csUUFBUTtZQUNqQixPQUNLO2dCQUNELElBQUksQ0FBQ0osU0FBUyxHQUFHSyxXQUNqQixJQUFJLENBQUNELFFBQVEsQ0FBQ3ZFLElBQUksQ0FBQyxJQUFJLEdBQUdvRTtZQUM5QixDQUFDO1FBQ0wsQ0FBQztJQUNMO0lBQ0FOLGNBQWMvc0QsU0FBUyxDQUFDMHRELEtBQUssR0FBRyxTQUFVQyxLQUFLLEVBQUU7UUFDN0MsSUFBSUEsVUFBVSxLQUFLLEdBQUc7WUFBRUEsUUFBUTtRQUFJLENBQUM7UUFDckMsSUFBSVIsY0FBYyxJQUFJLENBQUNBLFdBQVc7UUFDbENBLFdBQVcsQ0FBQ1EsTUFBTSxHQUFHLENBQUNSLFdBQVcsQ0FBQ1EsTUFBTSxJQUFJLEtBQUs7UUFDakQsSUFBSSxDQUFDSixZQUFZO0lBQ3JCO0lBQ0FSLGNBQWMvc0QsU0FBUyxDQUFDNHRELE1BQU0sR0FBRyxTQUFVRCxLQUFLLEVBQUVFLEtBQUssRUFBRTtRQUNyRCxJQUFJRixVQUFVLEtBQUssR0FBRztZQUFFQSxRQUFRO1FBQUksQ0FBQztRQUNyQyxJQUFJUixjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUNsQyxJQUFJUSxTQUFTUixhQUFhO1lBQ3RCLElBQUlVLE9BQU87Z0JBQ1AsT0FBT1YsV0FBVyxDQUFDUSxNQUFNO1lBQzdCLE9BQ0s7Z0JBQ0RSLFdBQVcsQ0FBQ1EsTUFBTSxJQUFJO2dCQUN0QixJQUFJRyxRQUFRWCxXQUFXLENBQUNRLE1BQU07Z0JBQzlCLElBQUlHLFNBQVMsR0FBRztvQkFDWixPQUFPWCxXQUFXLENBQUNRLE1BQU07Z0JBQzdCLENBQUM7WUFDTCxDQUFDO1lBQ0QsSUFBSSxDQUFDSCxRQUFRO1FBQ2pCLENBQUM7SUFDTDtJQUNBVCxjQUFjL3NELFNBQVMsQ0FBQ3N0RCxRQUFRLEdBQUcsV0FBWTtRQUMzQyxPQUFPOXNELE9BQU82UCxJQUFJLENBQUMsSUFBSSxDQUFDODhDLFdBQVcsRUFBRTFxRCxNQUFNO0lBQy9DO0lBQ0FzcUQsY0FBYy9zRCxTQUFTLENBQUN3dEQsUUFBUSxHQUFHLFdBQVk7UUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ1AsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDSyxRQUFRLElBQUk7WUFDckMsSUFBSSxDQUFDTCxTQUFTLEdBQUcsSUFBSTtZQUNyQixNQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFFO2dCQUNqQixJQUFJLENBQUNBLE9BQU8sR0FBRyxLQUFLO2dCQUNwQixJQUFJLENBQUNhLE9BQU8sSUFBSSxrQ0FBa0M7WUFDdEQ7WUFDQSxJQUFJLENBQUNkLFNBQVMsR0FBRyxLQUFLO1FBQzFCLENBQUM7SUFDTDtJQUNBRixjQUFjL3NELFNBQVMsQ0FBQ2d1RCxLQUFLLEdBQUcsV0FBWTtRQUN4QyxJQUFJLENBQUNULFlBQVk7UUFDakIsSUFBSSxDQUFDTCxPQUFPLEdBQUcsS0FBSztRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO0lBQ3hCO0lBQ0FKLGNBQWMvc0QsU0FBUyxDQUFDdXRELFlBQVksR0FBRyxXQUFZO1FBQy9DLElBQUksSUFBSSxDQUFDSCxTQUFTLEVBQUU7WUFDaEJHLGFBQWEsSUFBSSxDQUFDSCxTQUFTO1lBQzNCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ3JCLENBQUM7SUFDTDtJQUNBTCxjQUFjL3NELFNBQVMsQ0FBQyt0RCxPQUFPLEdBQUcsV0FBWTtRQUMxQyxJQUFJLElBQUksQ0FBQ2YsYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQ0EsYUFBYTtRQUN0QixDQUFDO0lBQ0w7SUFDQSxPQUFPRDtBQUNYO0FBRUEsSUFBSWtCLGFBQWEsV0FBVyxHQUFJLFdBQVk7SUFDeEMsU0FBU0EsV0FBV0MsYUFBYSxFQUFFbEIsYUFBYSxFQUFFO1FBQzlDLElBQUksQ0FBQ2tCLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDbEIsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUNtQixLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlyQixjQUFjLElBQUksQ0FBQy9XLEtBQUssQ0FBQ2lULElBQUksQ0FBQyxJQUFJO0lBQy9EO0lBQ0FnRixXQUFXanVELFNBQVMsQ0FBQzgxQyxPQUFPLEdBQUcsU0FBVXVZLElBQUksRUFBRWhCLEtBQUssRUFBRTtRQUNsRCxJQUFJLENBQUNjLEtBQUssQ0FBQ3ZyRCxJQUFJLENBQUN5ckQ7UUFDaEIsSUFBSSxDQUFDRCxhQUFhLENBQUN0WSxPQUFPLENBQUN1WDtJQUMvQjtJQUNBWSxXQUFXanVELFNBQVMsQ0FBQzB0RCxLQUFLLEdBQUcsU0FBVUMsS0FBSyxFQUFFO1FBQzFDLElBQUksQ0FBQ1MsYUFBYSxDQUFDVixLQUFLLENBQUNDO0lBQzdCO0lBQ0FNLFdBQVdqdUQsU0FBUyxDQUFDNHRELE1BQU0sR0FBRyxTQUFVRCxLQUFLLEVBQUVFLEtBQUssRUFBRTtRQUNsRCxJQUFJLENBQUNPLGFBQWEsQ0FBQ1IsTUFBTSxDQUFDRCxPQUFPRTtJQUNyQztJQUNBSSxXQUFXanVELFNBQVMsQ0FBQ2cyQyxLQUFLLEdBQUcsV0FBWTtRQUNyQyxJQUFJbVksUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsTUFBT0EsTUFBTTFyRCxNQUFNLENBQUU7WUFDakIsSUFBSTZyRCxpQkFBaUIsRUFBRTtZQUN2QixJQUFJRCxPQUFPLEtBQUs7WUFDaEIsTUFBUUEsT0FBT0YsTUFBTUksS0FBSyxHQUFLO2dCQUMzQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0g7Z0JBQ2JDLGVBQWUxckQsSUFBSSxDQUFDeXJEO1lBQ3hCO1lBQ0EsSUFBSSxDQUFDTixPQUFPLENBQUNPO1FBQ2pCLEVBQUUsa0VBQWtFO0lBQ3hFO0lBQ0FMLFdBQVdqdUQsU0FBUyxDQUFDd3VELE9BQU8sR0FBRyxTQUFVSCxJQUFJLEVBQUU7UUFDM0MsSUFBSSxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUNBLGFBQWEsQ0FBQ0c7UUFDdkIsQ0FBQztJQUNMO0lBQ0FKLFdBQVdqdUQsU0FBUyxDQUFDK3RELE9BQU8sR0FBRyxTQUFVTyxjQUFjLEVBQUU7UUFDckQsSUFBSSxJQUFJLENBQUN0QixhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDQSxhQUFhLENBQUNzQjtRQUN2QixDQUFDO0lBQ0w7SUFDQSxPQUFPTDtBQUNYO0FBRUEsZ0ZBQWdGO0FBQ2hGLFNBQVNRLFdBQVdsMEIsV0FBVyxFQUFFaWMsV0FBVyxFQUFFbGxDLE9BQU8sRUFBRTtJQUNuRCxJQUFJOUM7SUFDSiwyR0FBMkc7SUFDM0csSUFBSSxpQkFBaUI3SyxJQUFJLENBQUM0MkIsWUFBWWduQixnQkFBZ0IsR0FBRztRQUNyRC95QyxRQUFRK3JCLFlBQVlFLFlBQVk7SUFDcEMsT0FDSztRQUNEanNCLFFBQVErckIsWUFBWUMsV0FBVztJQUNuQyxDQUFDO0lBQ0QsT0FBT2xwQixRQUFReUksV0FBVyxDQUFDdkwsTUFBTXNFLEtBQUssRUFBRXRFLE1BQU11RSxHQUFHLEVBQUV5TCxnQkFBZ0JnNEIsWUFBWTN1QixXQUFXLElBQUk2bUMsaUJBQWlCbjBCLGVBQWU7UUFDMUhpSyxnQkFBZ0JqSyxZQUFZcW5CLGFBQWE7UUFDekM5bUMsa0JBQWtCMDdCLFlBQVk1MkIsbUJBQW1CO0lBQ3JEO0FBQ0o7QUFDQSxvR0FBb0c7QUFDcEcsa0dBQWtHO0FBQ2xHLFNBQVM4dUMsaUJBQWlCbjBCLFdBQVcsRUFBRTtJQUNuQyxJQUFJZ25CLG1CQUFtQmhuQixZQUFZZ25CLGdCQUFnQjtJQUNuRCxJQUFJQSxxQkFBcUIsUUFBUTtRQUM3QixPQUFPO1lBQUV6MEMsTUFBTTtRQUFVO0lBQzdCLENBQUM7SUFDRCxJQUFJeTBDLHFCQUFxQixTQUFTO1FBQzlCLE9BQU87WUFBRXowQyxNQUFNO1lBQVdpSCxPQUFPO1FBQU8sR0FBRyx3QkFBd0I7SUFDdkUsQ0FBQztJQUNELElBQUkzSSxPQUFPTSxjQUFjNnVCLFlBQVlFLFlBQVksQ0FBQzNuQixLQUFLLEVBQUV5bkIsWUFBWUUsWUFBWSxDQUFDMW5CLEdBQUc7SUFDckYsSUFBSTNILFNBQVMsSUFBSSxJQUFJQSxPQUFPLEdBQUc7UUFDM0IsbURBQW1EO1FBQ25ELE9BQU87WUFBRTBCLE1BQU07WUFBV2lILE9BQU87WUFBU0MsS0FBSztRQUFVO0lBQzdELENBQUM7SUFDRCwyQ0FBMkM7SUFDM0MsT0FBTztRQUFFbEgsTUFBTTtRQUFXaUgsT0FBTztRQUFRQyxLQUFLO0lBQVU7QUFDNUQ7QUFFQSxtRkFBbUY7QUFDbkYsaUZBQWlGO0FBQ2pGLElBQUkyNkMsc0JBQXNCLFdBQVcsR0FBSSxXQUFZO0lBQ2pELFNBQVNBLG9CQUFvQnRyRCxLQUFLLEVBQUU7UUFDaEMsSUFBSXVVLFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNnM0Msa0JBQWtCLEdBQUd6M0MsUUFBUSxJQUFJLENBQUMwM0MsbUJBQW1CO1FBQzFELElBQUksQ0FBQ0Msc0JBQXNCLEdBQUczM0MsUUFBUSxJQUFJLENBQUM0M0MsdUJBQXVCO1FBQ2xFLElBQUksQ0FBQzNwQixrQkFBa0IsR0FBR2p1QixRQUFRaXVCO1FBQ2xDLElBQUksQ0FBQ1EsV0FBVyxHQUFHenVCLFFBQVF5dUI7UUFDM0IsSUFBSSxDQUFDd1UsZ0JBQWdCLEdBQUdRO1FBQ3hCLElBQUksQ0FBQ29VLFlBQVksR0FBRzczQyxRQUFRNjNDO1FBQzVCLElBQUksQ0FBQ0MsVUFBVSxHQUFHOTNDLFFBQVE4M0M7UUFDMUIsSUFBSSxDQUFDN0gsYUFBYSxHQUFHandDLFFBQVFpd0M7UUFDN0IsSUFBSSxDQUFDOUgsY0FBYyxHQUFHbm9DLFFBQVFtb0M7UUFDOUIsSUFBSSxDQUFDNFAseUJBQXlCLEdBQUd2M0MsY0FBY3UzQztRQUMvQyxJQUFJLENBQUNDLFlBQVksR0FBR2g0QyxRQUFRZzRDO1FBQzVCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUd6M0MsY0FBY3kzQztRQUN0QyxJQUFJLENBQUNDLG9CQUFvQixHQUFHbDRDLFFBQVFrNEMsc0JBQXNCbC9DO1FBQzFELElBQUksQ0FBQ20vQyxpQkFBaUIsR0FBR240QyxRQUFRbTRDO1FBQ2pDLElBQUksQ0FBQ0MseUJBQXlCLEdBQUc1M0MsY0FBYzQzQztRQUMvQyxJQUFJLENBQUNkLFVBQVUsR0FBR3QzQyxRQUFRczNDO1FBQzFCLElBQUksQ0FBQzEzQixPQUFPLEdBQUcsSUFBSWlhO1FBQ25CLElBQUksQ0FBQ3dlLFlBQVksR0FBRyxJQUFJdkIsV0FBVyxJQUFJLENBQUN3QixhQUFhLENBQUN4RyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQ3lHLFVBQVUsQ0FBQ3pHLElBQUksQ0FBQyxJQUFJO1FBQzNGLElBQUksQ0FBQ3RzQiwyQkFBMkIsR0FBRyxDQUFDO1FBQ3BDLElBQUksQ0FBQ2d6Qiw2QkFBNkIsR0FBRyxDQUFDO1FBQ3RDLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUcsQ0FBQztRQUNoQyxJQUFJLENBQUNDLHlCQUF5QixHQUFHLENBQUM7UUFDbEMsSUFBSSxDQUFDN3lCLDhCQUE4QixHQUFHLENBQUM7UUFDdkMsSUFBSSxDQUFDM0MsY0FBYyxHQUFHLFdBQVk7WUFBRSxPQUFPemlCLE1BQU1rNEMsSUFBSTtRQUFFO1FBQ3ZELElBQUksQ0FBQzV2RCxRQUFRLEdBQUcsU0FBVTI3QixNQUFNLEVBQUU7WUFDOUJqa0IsTUFBTTQzQyxZQUFZLENBQUMxWixPQUFPLENBQUNqYSxTQUFTLG9EQUFvRDtRQUM1RjtRQUNBLElBQUksQ0FBQ3g0QixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDbXNELFlBQVksQ0FBQzlCLEtBQUs7UUFDdkIsSUFBSWpPLHlCQUF5QixDQUFDO1FBQzlCLElBQUlzUSxjQUFjLElBQUksQ0FBQ25CLGtCQUFrQixDQUFDdnJELE1BQU1tOEMsZUFBZSxFQUFFQyx3QkFBd0JwOEMsTUFBTTIxQixXQUFXO1FBQzFHLElBQUlnM0Isa0JBQWtCRCxZQUFZdnhCLGVBQWUsQ0FBQ2hlLFdBQVcsSUFBSXV2QyxZQUFZNzlDLFdBQVcsQ0FBQ3NPLFdBQVc7UUFDcEcsSUFBSXl2QyxrQkFBa0IsSUFBSSxDQUFDbkIsc0JBQXNCLENBQUNrQixpQkFBaUJELGFBQWExc0QsTUFBTW04QyxlQUFlLEVBQUVDO1FBQ3ZHLGlCQUFpQjtRQUNqQixnQkFBZ0I7UUFDaEJwOEMsTUFBTTIxQixXQUFXLENBQUNxRCxrQkFBa0IsR0FBRyxJQUFJO1FBQzNDLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQ29hLGNBQWMsQ0FBQzl0QyxNQUFNMjFCLFdBQVc7UUFDN0MsSUFBSSxDQUFDakMsT0FBTyxDQUFDcWEsVUFBVSxDQUFDNmUsZ0JBQWdCOTlDLE9BQU87UUFDL0MsSUFBSXlwQixjQUFjRyxlQUFlZzBCLFlBQVl2eEIsZUFBZSxFQUFFdXhCLFlBQVl6K0MsT0FBTztRQUNqRixJQUFJaXBCLGNBQWMwMUIsZ0JBQWdCeFosb0JBQW9CLENBQUMrSyxLQUFLLENBQUM1bEI7UUFDN0QsSUFBSSxDQUFDdkosb0JBQW9Ca0ksWUFBWUMsV0FBVyxFQUFFb0IsY0FBYztZQUM1REEsY0FBY3JCLFlBQVlFLFlBQVksQ0FBQzNuQixLQUFLO1FBQ2hELENBQUM7UUFDRCxJQUFJbzlDLGtCQUFrQjtZQUNsQjUrQyxTQUFTeStDLFlBQVl6K0MsT0FBTztZQUM1QmEsU0FBUzQ5QyxZQUFZdnhCLGVBQWU7WUFDcEN0c0IsYUFBYTY5QyxZQUFZNzlDLFdBQVc7WUFDcEM4bUIsYUFBYTMxQixNQUFNMjFCLFdBQVc7WUFDOUI5NEIsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkI2MkIsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJzRCxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1FBQ3ZDO1FBQ0EsbUNBQW1DO1FBQ25DLElBQUssSUFBSXpxQixLQUFLLEdBQUc5TCxLQUFLaXNELFlBQVk3OUMsV0FBVyxDQUFDOG1DLFdBQVcsRUFBRXBwQyxLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07WUFDN0UsSUFBSXBLLFdBQVcxQixFQUFFLENBQUM4TCxHQUFHO1lBQ3JCcEssU0FBUzBxRDtRQUNiO1FBQ0EsVUFBVTtRQUNWLElBQUk1bEMsZUFBZXE1QixpQkFBaUJvTSxZQUFZdnhCLGVBQWUsRUFBRWpFLGFBQWEyMUI7UUFDOUUsSUFBSUMsZUFBZTtZQUNmMVEsd0JBQXdCQTtZQUN4QnVRLGlCQUFpQkE7WUFDakJwMEIsYUFBYUE7WUFDYnJCLGFBQWFBO1lBQ2JsWCxlQUFlLElBQUksQ0FBQ2tzQyx5QkFBeUIsQ0FBQ1c7WUFDOUM1bEMsY0FBY0E7WUFDZGtJLGNBQWMsQ0FBQztZQUNmeGdCLFlBQVk0WjtZQUNad2tDLHNCQUFzQnhrQztZQUN0QnVULGVBQWUsSUFBSTtZQUNuQndMLGdCQUFnQjtZQUNoQlAsV0FBVyxJQUFJO1lBQ2ZFLGFBQWEsSUFBSTtZQUNqQitsQixpQkFBaUIsSUFBSSxDQUFDakIsZ0JBQWdCLENBQUNjLGlCQUFpQkcsZUFBZTtRQUMzRTtRQUNBLElBQUlDLGtCQUFrQmx4RCwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHOHdELGtCQUFrQkM7UUFDOUQsSUFBSyxJQUFJcHNELEtBQUssR0FBR2tuQyxLQUFLOGtCLFlBQVk3OUMsV0FBVyxDQUFDNG1DLFFBQVEsRUFBRS8wQyxLQUFLa25DLEdBQUd4b0MsTUFBTSxFQUFFc0IsS0FBTTtZQUMxRSxJQUFJd3NELFVBQVV0bEIsRUFBRSxDQUFDbG5DLEdBQUc7WUFDcEIzRSwrQ0FBUUEsQ0FBQyt3RCxjQUFjSSxRQUFRLElBQUksRUFBRSxJQUFJLEVBQUVEO1FBQy9DO1FBQ0EsSUFBSUUsaUJBQWlCTCxjQUFjRCxrQkFBa0I7WUFDakQsSUFBSSxDQUFDbjVCLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLFdBQVcsSUFBSSxHQUFHLFVBQVU7UUFDckQsQ0FBQztRQUNELElBQUksQ0FBQ3VHLEtBQUssR0FBRzJ5QjtRQUNiLElBQUksQ0FBQ1QsVUFBVTtRQUNmLElBQUksQ0FBQ0YsWUFBWSxDQUFDNUIsTUFBTTtJQUM1QjtJQUNBZSxvQkFBb0IzdUQsU0FBUyxDQUFDeXdELFlBQVksR0FBRyxTQUFValIsZUFBZSxFQUFFa1IsTUFBTSxFQUFFO1FBQzVFLElBQUlydEQsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEJBLE1BQU1tOEMsZUFBZSxHQUFHa1IsU0FDbEJ0eEQsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR2lFLE1BQU1tOEMsZUFBZSxHQUFHQSxtQkFBbUJBLGVBQWU7UUFDdEYsSUFBSSxDQUFDZ1EsWUFBWSxDQUFDMVosT0FBTyxDQUFDO1lBQ3RCMzFDLE1BQU07UUFDVjtJQUNKO0lBQ0F3dUQsb0JBQW9CM3VELFNBQVMsQ0FBQ3l2RCxhQUFhLEdBQUcsU0FBVTV6QixNQUFNLEVBQUU7UUFDNUQsSUFBSS8zQixLQUFLLElBQUksRUFBRVQsUUFBUVMsR0FBR1QsS0FBSyxFQUFFbTZCLFFBQVExNUIsR0FBRzA1QixLQUFLLEVBQUV6RyxVQUFVanpCLEdBQUdpekIsT0FBTztRQUN2RSxJQUFJMG9CLHlCQUF5QitELDZCQUE2QmhtQixNQUFNaWlCLHNCQUFzQixFQUFFNWpCO1FBQ3hGLElBQUlrMEIsY0FBYyxJQUFJLENBQUNuQixrQkFBa0IsQ0FBQ3ZyRCxNQUFNbThDLGVBQWUsRUFBRUMsd0JBQXdCcDhDLE1BQU0yMUIsV0FBVztRQUMxRyxJQUFJZzNCLGtCQUFrQnpNLGVBQWUvbEIsTUFBTXd5QixlQUFlLEVBQUVuMEI7UUFDNUQsSUFBSW8wQixrQkFBa0IsSUFBSSxDQUFDbkIsc0JBQXNCLENBQUNrQixpQkFBaUJELGFBQWExc0QsTUFBTW04QyxlQUFlLEVBQUVDO1FBQ3ZHLGlCQUFpQjtRQUNqQixnQkFBZ0I7UUFDaEJwOEMsTUFBTTIxQixXQUFXLENBQUNxRCxrQkFBa0IsR0FBRyxJQUFJO1FBQzNDdEYsUUFBUW9hLGNBQWMsQ0FBQzl0QyxNQUFNMjFCLFdBQVc7UUFDeENqQyxRQUFRcWEsVUFBVSxDQUFDNmUsZ0JBQWdCOTlDLE9BQU87UUFDMUMsSUFBSSs5QyxrQkFBa0I7WUFDbEI1K0MsU0FBU3krQyxZQUFZeitDLE9BQU87WUFDNUJhLFNBQVM0OUMsWUFBWXZ4QixlQUFlO1lBQ3BDdHNCLGFBQWE2OUMsWUFBWTc5QyxXQUFXO1lBQ3BDOG1CLGFBQWEzMUIsTUFBTTIxQixXQUFXO1lBQzlCOTRCLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCNjJCLFNBQVNBO1lBQ1RzRCxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1FBQ3ZDO1FBQ0EsSUFBSXVCLGNBQWM0QixNQUFNNUIsV0FBVyxFQUFFckIsY0FBY2lELE1BQU1qRCxXQUFXO1FBQ3BFLElBQUksSUFBSSxDQUFDdTFCLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ3JaLG9CQUFvQixLQUFLd1osZ0JBQWdCeFosb0JBQW9CLEVBQUU7WUFDdEZsYyxjQUFjMDFCLGdCQUFnQnhaLG9CQUFvQixDQUFDK0ssS0FBSyxDQUFDNWxCO1FBQzdELENBQUM7UUFDREEsY0FBY0Qsa0JBQWtCQyxhQUFhQztRQUM3Q3RCLGNBQWNrcEIsa0JBQWtCbHBCLGFBQWFzQixRQUFRRCxhQUFhcTBCLGdCQUFnQnhaLG9CQUFvQjtRQUN0RyxJQUFJNWEsT0FBTzE3QixJQUFJLEtBQUssVUFBVSxrREFBa0Q7UUFDNUUwN0IsT0FBTzE3QixJQUFJLEtBQUssVUFBVSxJQUFJO1FBQzlCLENBQUNreUIsb0JBQW9Ca0ksWUFBWUUsWUFBWSxFQUFFbUIsY0FBYztZQUM3REEsY0FBY3JCLFlBQVlFLFlBQVksQ0FBQzNuQixLQUFLO1FBQ2hELENBQUM7UUFDRCxJQUFJd1gsZUFBZXc1QixtQkFBbUJ0bUIsTUFBTWxULFlBQVksRUFBRXVSLFFBQVF0QixhQUFhMjFCO1FBQy9FLElBQUlsK0MsYUFBYXl6QyxpQkFBaUJqb0IsTUFBTXhyQixVQUFVLEVBQUU2cEIsUUFBUXZSLGNBQWNpUSxhQUFhMjFCO1FBQ3ZGLElBQUlTLGtCQUFrQnJNLDJCQUEyQmg2QixlQUFlLG9EQUFvRDtRQUNwSCxJQUFJOGxDLHVCQUF1QixtQkFBb0IsQ0FBQ0gsZ0JBQWdCOTlDLE9BQU8sQ0FBQ2lSLHlCQUF5QixHQUM1Rm9hLE1BQU00eUIsb0JBQW9CLElBQUlwK0MsYUFDL0JBLFVBQVU7UUFDZCxJQUFJak8sS0FBSyxJQUFJLENBQUNxckQsZ0JBQWdCLENBQUNjLGtCQUFrQlUsb0JBQW9CN3NELEdBQUc2c0QsaUJBQWlCLEVBQUVQLGtCQUFrQnRzRCxHQUFHc3NELGVBQWUsRUFBRSxtQkFBbUI7UUFDcEosSUFBSVEsa0JBQWtCLElBQUksQ0FBQ3hCLG9CQUFvQixDQUFDL2tDO1FBQ2hELElBQUlrSSxlQUFlLElBQUksQ0FBQzg4QixpQkFBaUIsQ0FBQ2MscUJBQXFCaCtDLElBQUksRUFBRXcrQyxtQkFBbUJDO1FBQ3hGLElBQUlyWixXQUFXO1lBQ1hpSSx3QkFBd0JBO1lBQ3hCdVEsaUJBQWlCQTtZQUNqQnAwQixhQUFhQTtZQUNickIsYUFBYUE7WUFDYmpRLGNBQWNBO1lBQ2R0WSxZQUFZQTtZQUNabytDLHNCQUFzQkE7WUFDdEJDLGlCQUFpQkE7WUFDakI3OUIsY0FBY0E7WUFDZG5QLGVBQWUsSUFBSSxDQUFDa3NDLHlCQUF5QixDQUFDVztZQUM5Qy93QixlQUFlc25CLG9CQUFvQmpwQixNQUFNMkIsYUFBYSxFQUFFdEQ7WUFDeEQ4TyxnQkFBZ0JnYyxvQkFBb0JucEIsTUFBTW1OLGNBQWMsRUFBRTlPO1lBQzFEdU8sV0FBVzBjLGdCQUFnQnRwQixNQUFNNE0sU0FBUyxFQUFFdk87WUFDNUN5TyxhQUFhMmMsa0JBQWtCenBCLE1BQU04TSxXQUFXLEVBQUV6TztRQUN0RDtRQUNBLElBQUl5MEIsa0JBQWtCbHhELCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUc4d0Qsa0JBQWtCMVk7UUFDOUQsSUFBSyxJQUFJNW5DLEtBQUssR0FBR3E3QixLQUFLOGtCLFlBQVk3OUMsV0FBVyxDQUFDNG1DLFFBQVEsRUFBRWxwQyxLQUFLcTdCLEdBQUd4b0MsTUFBTSxFQUFFbU4sS0FBTTtZQUMxRSxJQUFJMmdELFVBQVV0bEIsRUFBRSxDQUFDcjdCLEdBQUc7WUFDcEJ4USwrQ0FBUUEsQ0FBQ280QyxVQUFVK1ksUUFBUS95QixPQUFPM0IsUUFBUXkwQixtQkFBbUIsb0NBQW9DO1FBQ3JHO1FBQ0EsSUFBSVEsYUFBYU4saUJBQWlCaHpCLE9BQU8weUI7UUFDekMsSUFBSWEsWUFBWVAsaUJBQWlCaFosVUFBVTBZO1FBQzNDLDZDQUE2QztRQUM3QyxJQUFJLENBQUNZLGNBQWNDLFdBQVc7WUFDMUJoNkIsUUFBUUUsT0FBTyxDQUFDLFdBQVcsSUFBSTtRQUNuQyxPQUNLLElBQUk2NUIsY0FBYyxDQUFDQyxXQUFXO1lBQy9CaDZCLFFBQVFFLE9BQU8sQ0FBQyxXQUFXLEtBQUs7UUFDcEMsQ0FBQztRQUNELElBQUksQ0FBQ3VHLEtBQUssR0FBR2dhO1FBQ2IsSUFBSW4wQyxNQUFNMnRELFFBQVEsRUFBRTtZQUNoQjN0RCxNQUFNMnRELFFBQVEsQ0FBQ24xQjtRQUNuQixDQUFDO0lBQ0w7SUFDQTh5QixvQkFBb0IzdUQsU0FBUyxDQUFDMHZELFVBQVUsR0FBRyxXQUFZO1FBQ25ELElBQUk1ckQsS0FBSyxJQUFJLEVBQUVULFFBQVFTLEdBQUdULEtBQUssRUFBRW02QixRQUFRMTVCLEdBQUcwNUIsS0FBSztRQUNqRCxJQUFJeXpCLFVBQVUsSUFBSSxDQUFDbkIsSUFBSTtRQUN2QixJQUFJQyxjQUFjLElBQUksQ0FBQ25CLGtCQUFrQixDQUFDdnJELE1BQU1tOEMsZUFBZSxFQUFFaGlCLE1BQU1paUIsc0JBQXNCLEVBQUVwOEMsTUFBTTIxQixXQUFXO1FBQ2hILElBQUlpM0Isa0JBQWtCLElBQUksQ0FBQ25CLHNCQUFzQixDQUFDdHhCLE1BQU13eUIsZUFBZSxFQUFFRCxhQUFhMXNELE1BQU1tOEMsZUFBZSxFQUFFaGlCLE1BQU1paUIsc0JBQXNCO1FBQ3pJLElBQUlxUSxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHMXdELCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUM7WUFBRWs3QixXQUFXLElBQUksQ0FBQ20wQixVQUFVLENBQUNqeEIsTUFBTWpELFdBQVcsRUFBRTAxQixnQkFBZ0I5OUMsT0FBTyxFQUFFNDlDLFlBQVl6K0MsT0FBTztZQUFHMG5CLGFBQWEzMUIsTUFBTTIxQixXQUFXO1lBQUU5NEIsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFBRTYyQixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUFFc0QsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztRQUFDLEdBQUcwMUIsY0FBY0Usa0JBQWtCenlCO1FBQ3hTLElBQUkwekIsaUJBQWlCbkIsWUFBWTc5QyxXQUFXLENBQUM0bkMsb0JBQW9CO1FBQ2pFLElBQUlxWCxxQkFBcUJGLFdBQVdBLFFBQVF6eUIsZUFBZTtRQUMzRCxJQUFJNHlCLHFCQUFxQnJCLFlBQVl2eEIsZUFBZTtRQUNwRCxJQUFJMnlCLHNCQUFzQkEsdUJBQXVCQyxvQkFBb0I7WUFDakUsSUFBSUQsbUJBQW1CejFDLFFBQVEsS0FBSzAxQyxtQkFBbUIxMUMsUUFBUSxFQUFFO2dCQUM3RCxPQUFPO2dCQUNQOGhCLE1BQU1sVCxZQUFZLEdBQUd3bEMsS0FBS3hsQyxZQUFZLEdBQUcrNUIsOEJBQThCeUwsS0FBS3hsQyxZQUFZLEVBQUVrVCxNQUFNakQsV0FBVyxFQUFFdTFCO2dCQUM3R3R5QixNQUFNeHJCLFVBQVUsR0FBRzg5QyxLQUFLOTlDLFVBQVUsR0FBR28wQyxzQkFBc0IwSixLQUFLOTlDLFVBQVUsRUFBRWkvQyxRQUFRMy9DLE9BQU8sRUFBRXcrQyxLQUFLeCtDLE9BQU87WUFDN0csQ0FBQztZQUNELElBQUssSUFBSW1yQixjQUFjeTBCLGVBQWdCO2dCQUNuQyxJQUFJQyxrQkFBa0IsQ0FBQzEwQixXQUFXLEtBQUsyMEIsa0JBQWtCLENBQUMzMEIsV0FBVyxFQUFFO29CQUNuRXkwQixjQUFjLENBQUN6MEIsV0FBVyxDQUFDMjBCLGtCQUFrQixDQUFDMzBCLFdBQVcsRUFBRXF6QjtnQkFDL0QsQ0FBQztZQUNMO1FBQ0osQ0FBQztRQUNELElBQUl6c0QsTUFBTWd1RCxNQUFNLEVBQUU7WUFDZGh1RCxNQUFNZ3VELE1BQU0sQ0FBQ3ZCO1FBQ2pCLENBQUM7SUFDTDtJQUNBbkIsb0JBQW9CM3VELFNBQVMsQ0FBQzZ1RCxtQkFBbUIsR0FBRyxTQUFVclAsZUFBZSxFQUFFQyxzQkFBc0IsRUFBRXptQixXQUFXLEVBQUU7UUFDaEgsbUVBQW1FO1FBQ25FLElBQUlsMUIsS0FBSyxJQUFJLENBQUN3dEQseUJBQXlCLENBQUM5UixpQkFBaUJDLHlCQUF5QjhSLGlCQUFpQnp0RCxHQUFHeXRELGNBQWMsRUFBRXIvQyxjQUFjcE8sR0FBR29PLFdBQVcsRUFBRXd0QyxpQkFBaUI1N0MsR0FBRzQ3QyxjQUFjLEVBQUU4UixzQkFBc0IxdEQsR0FBRzB0RCxtQkFBbUIsRUFBRWxtQyxRQUFReG5CLEdBQUd3bkIsS0FBSztRQUN0UG1tQyxtQkFBbUJubUM7UUFDbkIsSUFBSWhhLFVBQVUsSUFBSSxDQUFDMDlDLFlBQVksQ0FBQ3VDLGVBQWU3MUMsUUFBUSxFQUFFNjFDLGVBQWVoMkMsTUFBTSxFQUFFZzJDLGVBQWUzd0MscUJBQXFCLEVBQUUyd0MsZUFBZW5xQyxRQUFRLEVBQUVtcUMsZUFBZWwyQyxRQUFRLEVBQUVuSixhQUFhcy9DLHFCQUFxQkQsZUFBZTV4QyxxQkFBcUI7UUFDOU8sSUFBSStkLFlBQVksSUFBSSxDQUFDNGhCLGNBQWMsQ0FBQ3B0QyxZQUFZaVksS0FBSyxFQUFFcTFCLGlCQUFpQkMsd0JBQXdCQztRQUNoRyxJQUFJdFQsUUFBUSxJQUFJLENBQUM2aUIsVUFBVSxDQUFDc0MsZ0JBQWdCci9DO1FBQzVDLElBQUkwckIsZ0JBQWdCLElBQUksQ0FBQ3dwQixhQUFhLENBQUNtSyxnQkFBZ0IvUixpQkFBaUJwVCxPQUFPMU8sV0FBVzFFO1FBQzFGLE9BQU87WUFDSHdGLGlCQUFpQit5QjtZQUNqQnIvQyxhQUFhQTtZQUNiWixTQUFTQTtZQUNUb3NCLFdBQVdBO1lBQ1gwTyxPQUFPQTtZQUNQeE8sZUFBZUE7WUFDZjhoQixnQkFBZ0JBO1lBQ2hCN2lCLHFCQUFxQjIwQixvQkFBb0JuK0MsR0FBRztRQUNoRDtJQUNKO0lBQ0EsdUNBQXVDO0lBQ3ZDczdDLG9CQUFvQjN1RCxTQUFTLENBQUNzeEQseUJBQXlCLEdBQUcsU0FBVTlSLGVBQWUsRUFBRUMsc0JBQXNCLEVBQUU7UUFDekcsSUFBSTM3QyxLQUFLb25CLGdCQUFnQjtZQUNyQnhDO1lBQ0E4MkI7WUFDQUM7U0FDSCxHQUFHejlCLFVBQVVsZSxHQUFHa2UsT0FBTyxFQUFFekcsU0FBU3pYLEdBQUd5WCxNQUFNO1FBQzVDLElBQUlpMkMsc0JBQXNCLElBQUksQ0FBQ3BzQixrQkFBa0IsQ0FBQ3BqQjtRQUNsRCxJQUFJNmEsc0JBQXNCMjBCLG9CQUFvQm4rQyxHQUFHO1FBQ2pELElBQUlxc0MsaUJBQWlCLElBQUksQ0FBQzlaLFdBQVcsQ0FBQ3JxQixVQUFVaTJDLG9CQUFvQmxzQixXQUFXLEVBQUV6SSxxQkFBcUIxcUIsT0FBTztRQUM3RyxJQUFJRCxjQUFjLElBQUksQ0FBQ2tvQyxnQkFBZ0IsQ0FBQ29GLGdCQUFnQnI0QixPQUFPLElBQUksRUFBRSxFQUFFaWxDO1FBQ3ZFLElBQUkvZ0MsV0FBVyxJQUFJLENBQUMyUiw4QkFBOEIsR0FBRzU5QiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUMsQ0FBQyxHQUFHcWYsdUJBQXVCbUssNkJBQTZCb0IsMkJBQTJCOVgsWUFBWStuQyxnQkFBZ0IsR0FBRy9uQyxZQUFZZ29DLGNBQWM7UUFDOU8sSUFBSTV1QixRQUFRLENBQUM7UUFDYixJQUFJQyxNQUFNTCxnQkFBZ0I7WUFDdEJ4QztZQUNBZzNCO1lBQ0FGO1lBQ0FDO1NBQ0g7UUFDRCxJQUFJcnVDLFVBQVUsQ0FBQztRQUNmLElBQUlzZ0QsYUFBYSxJQUFJLENBQUMvMEIsMkJBQTJCO1FBQ2pELElBQUlnMUIsaUJBQWlCLElBQUksQ0FBQ2hDLDZCQUE2QjtRQUN2RCxJQUFJaUMsYUFBYSxLQUFLO1FBQ3RCLElBQUssSUFBSW4xQixjQUFjbFIsSUFBSztZQUN4QixJQUFJa1IsZUFBZSxXQUFXO2dCQUMxQixJQUFJbFIsR0FBRyxDQUFDa1IsV0FBVyxLQUFLaTFCLFVBQVUsQ0FBQ2oxQixXQUFXLElBQ3pDbFMsMEJBQTBCLENBQUNrUyxXQUFXLElBQ2xDQSxjQUFjaTFCLGNBQ2ZubkMsMEJBQTBCLENBQUNrUyxXQUFXLENBQUNpMUIsVUFBVSxDQUFDajFCLFdBQVcsRUFBRWxSLEdBQUcsQ0FBQ2tSLFdBQVcsR0FBSTtvQkFDdEZyckIsT0FBTyxDQUFDcXJCLFdBQVcsR0FBR2sxQixjQUFjLENBQUNsMUIsV0FBVztnQkFDcEQsT0FDSyxJQUFJcFIsUUFBUSxDQUFDb1IsV0FBVyxFQUFFO29CQUMzQnJyQixPQUFPLENBQUNxckIsV0FBVyxHQUFHcFIsUUFBUSxDQUFDb1IsV0FBVyxDQUFDbFIsR0FBRyxDQUFDa1IsV0FBVztvQkFDMURtMUIsYUFBYSxJQUFJO2dCQUNyQixPQUNLO29CQUNEdG1DLEtBQUssQ0FBQ21SLFdBQVcsR0FBR2kxQixVQUFVLENBQUNqMUIsV0FBVztnQkFDOUMsQ0FBQztZQUNMLENBQUM7UUFDTDtRQUNBLElBQUltMUIsWUFBWTtZQUNaLElBQUksQ0FBQ2oxQiwyQkFBMkIsR0FBR3BSO1lBQ25DLElBQUksQ0FBQ29rQyw2QkFBNkIsR0FBR3YrQztRQUN6QyxDQUFDO1FBQ0QsT0FBTztZQUNIbXJDLFlBQVksSUFBSSxDQUFDNWYsMkJBQTJCO1lBQzVDNDBCLGdCQUFnQixJQUFJLENBQUM1Qiw2QkFBNkI7WUFDbER6OUMsYUFBYUE7WUFDYnMvQyxxQkFBcUJBO1lBQ3JCOVIsZ0JBQWdCQTtZQUNoQnAwQixPQUFPQTtRQUNYO0lBQ0o7SUFDQXFqQyxvQkFBb0IzdUQsU0FBUyxDQUFDK3VELHVCQUF1QixHQUFHLFNBQVUxeEIsUUFBUSxFQUFFMHlCLFdBQVcsRUFBRXZRLGVBQWUsRUFBRUMsc0JBQXNCLEVBQUU7UUFDOUgsSUFBSWxKLFdBQVd3WixZQUFZcnlCLFNBQVMsQ0FBQ0wsU0FBUztRQUM5QyxJQUFJLENBQUNrWixVQUFVO1lBQ1gsTUFBTSxJQUFJM3NDLE1BQU0sZUFBZ0J5ekIsV0FBVyw4RUFBOEU7UUFDN0gsQ0FBQztRQUNELElBQUl2NUIsS0FBSyxJQUFJLENBQUMrdEQscUJBQXFCLENBQUN0YixVQUFVd1osWUFBWTc5QyxXQUFXLEVBQUU2OUMsWUFBWXJRLGNBQWMsRUFBRUYsaUJBQWlCQyx5QkFBeUI4UixpQkFBaUJ6dEQsR0FBR3l0RCxjQUFjLEVBQUVqbUMsUUFBUXhuQixHQUFHd25CLEtBQUs7UUFDak1tbUMsbUJBQW1Cbm1DO1FBQ25CLElBQUltckIsdUJBQXVCLElBQUksQ0FBQ3lZLHlCQUF5QixDQUFDO1lBQ3REdGtDLDJCQUEyQjJyQixTQUFTZ0ssY0FBYyxDQUFDMzFCLHlCQUF5QjtZQUM1RWhaLFVBQVUya0MsU0FBUzNrQyxRQUFRO1lBQzNCa3VDLGNBQWN2SixTQUFTdUosWUFBWTtZQUNuQ2oxQixnQkFBZ0IwckIsU0FBU2dLLGNBQWMsQ0FBQzExQixjQUFjO1lBQ3REdlosU0FBU3krQyxZQUFZeitDLE9BQU87WUFDNUIwbkIsYUFBYSxJQUFJLENBQUMzMUIsS0FBSyxDQUFDMjFCLFdBQVc7WUFDbkM1WixhQUFhbXlDLGVBQWVueUMsV0FBVztZQUN2Q0MsYUFBYWt5QyxlQUFlbHlDLFdBQVc7WUFDdkNzQyxxQkFBcUI0dkMsZUFBZTV2QyxtQkFBbUI7WUFDdkQwRixVQUFVa3FDLGVBQWVscUMsUUFBUTtZQUNqQ0MsZUFBZWlxQyxlQUFlanFDLGFBQWE7WUFDM0NDLGVBQWVncUMsZUFBZWhxQyxhQUFhO1lBQzNDQyxZQUFZK3BDLGVBQWUvcEMsVUFBVTtZQUNyQzdHLFVBQVU0d0MsZUFBZTV3QyxRQUFRO1lBQ2pDdWIsVUFBVXExQixlQUFlaHVDLEdBQUc7WUFDNUI4K0IsaUJBQWlCa1AsZUFBZTVwQyxVQUFVO1lBQzFDcTdCLG1CQUFtQnVPLGVBQWUzcEMsWUFBWTtZQUM5Q0gsV0FBVzhwQyxlQUFlOXBDLFNBQVM7WUFDbkNDLGdCQUFnQjZwQyxlQUFlN3BDLGNBQWM7UUFDakQ7UUFDQSxJQUFJNFAsVUFBVSxJQUFJLENBQUM2M0IsWUFBWSxDQUFDOXhCLFVBQVUsSUFBSSxDQUFDaEQsY0FBYyxFQUFFMDFCLFlBQVl6K0MsT0FBTztRQUNsRixPQUFPO1lBQUVpbEMsVUFBVUE7WUFBVXBrQyxTQUFTby9DO1lBQWdCOWEsc0JBQXNCQTtZQUFzQm5mLFNBQVNBO1FBQVE7SUFDdkg7SUFDQXEzQixvQkFBb0IzdUQsU0FBUyxDQUFDNnhELHFCQUFxQixHQUFHLFNBQVV0YixRQUFRLEVBQUVya0MsV0FBVyxFQUFFd3RDLGNBQWMsRUFBRUYsZUFBZSxFQUFFQyxzQkFBc0IsRUFBRTtRQUM1SSxJQUFJbDBCLE1BQU1MLGdCQUFnQjtZQUN0QnhDO1lBQ0E2dEIsU0FBU2dLLGNBQWM7WUFDdkJiO1lBQ0FGO1lBQ0FqSixTQUFTaUosZUFBZTtZQUN4QkM7U0FDSDtRQUNELElBQUlwMEIsV0FBV2pzQiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR3FmLHVCQUF1Qm1LLDZCQUE2Qm9CLDJCQUEyQlMsdUJBQXVCdlksWUFBWStuQyxnQkFBZ0IsR0FBRy9uQyxZQUFZZ29DLGNBQWM7UUFDeE8sSUFBSTlvQyxVQUFVLENBQUM7UUFDZixJQUFJc2dELGFBQWEsSUFBSSxDQUFDOUIsdUJBQXVCO1FBQzdDLElBQUkrQixpQkFBaUIsSUFBSSxDQUFDOUIseUJBQXlCO1FBQ25ELElBQUkrQixhQUFhLEtBQUs7UUFDdEIsSUFBSXRtQyxRQUFRLENBQUM7UUFDYixJQUFLLElBQUltUixjQUFjbFIsSUFBSztZQUN4QixJQUFJQSxHQUFHLENBQUNrUixXQUFXLEtBQUtpMUIsVUFBVSxDQUFDajFCLFdBQVcsSUFDekNsUywwQkFBMEIsQ0FBQ2tTLFdBQVcsSUFDbkNsUywwQkFBMEIsQ0FBQ2tTLFdBQVcsQ0FBQ2xSLEdBQUcsQ0FBQ2tSLFdBQVcsRUFBRWkxQixVQUFVLENBQUNqMUIsV0FBVyxHQUFJO2dCQUN0RnJyQixPQUFPLENBQUNxckIsV0FBVyxHQUFHazFCLGNBQWMsQ0FBQ2wxQixXQUFXO1lBQ3BELE9BQ0s7Z0JBQ0QsSUFBSWxSLEdBQUcsQ0FBQ2tSLFdBQVcsS0FBSyxJQUFJLENBQUNFLDJCQUEyQixDQUFDRixXQUFXLElBQy9EbFMsMEJBQTBCLENBQUNrUyxXQUFXLElBQ25DbFMsMEJBQTBCLENBQUNrUyxXQUFXLENBQUNsUixHQUFHLENBQUNrUixXQUFXLEVBQUUsSUFBSSxDQUFDRSwyQkFBMkIsQ0FBQ0YsV0FBVyxHQUFJO29CQUM1RyxJQUFJQSxjQUFjLElBQUksQ0FBQ2t6Qiw2QkFBNkIsRUFBRTt3QkFDbER2K0MsT0FBTyxDQUFDcXJCLFdBQVcsR0FBRyxJQUFJLENBQUNrekIsNkJBQTZCLENBQUNsekIsV0FBVztvQkFDeEUsQ0FBQztnQkFDTCxPQUNLLElBQUlwUixRQUFRLENBQUNvUixXQUFXLEVBQUU7b0JBQzNCcnJCLE9BQU8sQ0FBQ3FyQixXQUFXLEdBQUdwUixRQUFRLENBQUNvUixXQUFXLENBQUNsUixHQUFHLENBQUNrUixXQUFXO2dCQUM5RCxPQUNLO29CQUNEblIsS0FBSyxDQUFDbVIsV0FBVyxHQUFHbFIsR0FBRyxDQUFDa1IsV0FBVztnQkFDdkMsQ0FBQztnQkFDRG0xQixhQUFhLElBQUk7WUFDckIsQ0FBQztRQUNMO1FBQ0EsSUFBSUEsWUFBWTtZQUNaLElBQUksQ0FBQ2hDLHVCQUF1QixHQUFHcmtDO1lBQy9CLElBQUksQ0FBQ3NrQyx5QkFBeUIsR0FBR3orQztRQUNyQyxDQUFDO1FBQ0QsT0FBTztZQUNIbXJDLFlBQVksSUFBSSxDQUFDcVQsdUJBQXVCO1lBQ3hDMkIsZ0JBQWdCLElBQUksQ0FBQzFCLHlCQUF5QjtZQUM5Q3ZrQyxPQUFPQTtRQUNYO0lBQ0o7SUFDQSxPQUFPcWpDO0FBQ1g7QUFDQSxTQUFTSyxhQUFhdHpDLFFBQVEsRUFBRW8yQyxjQUFjLEVBQUVseEMscUJBQXFCLEVBQUV3RyxRQUFRLEVBQUUvTCxRQUFRLEVBQUVuSixXQUFXLEVBQUVzL0MsbUJBQW1CLEVBQUUxMkMsZ0JBQWdCLEVBQUU7SUFDM0ksSUFBSVMsU0FBU3FxQixZQUFZa3NCLGtCQUFrQk4sb0JBQW9CbHNCLFdBQVcsRUFBRWtzQixvQkFBb0JuK0MsR0FBRztJQUNuRyxPQUFPLElBQUlnd0IsUUFBUTtRQUNmbHBCLGdCQUFnQjtRQUNoQnVCLFVBQVVBO1FBQ1Y2bkIsbUJBQW1CcnhCLFlBQVkwbkMsa0JBQWtCO1FBQ2pEcitCLFFBQVFBO1FBQ1JxRix1QkFBdUJBO1FBQ3ZCd0csVUFBVUE7UUFDVi9MLFVBQVVBO1FBQ1ZpRCxjQUFjcE0sWUFBWW9NLFlBQVk7UUFDdEN4RCxrQkFBa0JBO0lBQ3RCO0FBQ0o7QUFDQSxTQUFTbTBDLFdBQVc5OEMsT0FBTyxFQUFFRCxXQUFXLEVBQUU7SUFDdEMsSUFBSTYvQyxhQUFhNy9DLFlBQVl5bkMsWUFBWSxDQUFDeG5DLFFBQVE4UCxXQUFXLENBQUMsSUFBSWs1QjtJQUNsRSxPQUFPLElBQUk0VyxXQUFXNS9DO0FBQzFCO0FBQ0EsU0FBUys4QywwQkFBMEI3ckQsS0FBSyxFQUFFO0lBQ3RDLElBQUkydUQsNEJBQTRCM3VELE1BQU11bkIseUJBQXlCLElBQUlxMkI7SUFDbkUsT0FBTyxJQUFJK1EsMEJBQTBCM3VEO0FBQ3pDO0FBQ0EsU0FBUzhyRCxhQUFhaHZELElBQUksRUFBRWs2QixjQUFjLEVBQUUvb0IsT0FBTyxFQUFFO0lBQ2pELE9BQU8sSUFBSThvQixRQUFRajZCLE1BQU1rNkIsZ0JBQWdCL29CO0FBQzdDO0FBQ0EsU0FBUys5QyxxQkFBcUIva0MsWUFBWSxFQUFFO0lBQ3hDLE9BQU83YSxRQUFRNmEsY0FBYyxTQUFVb0IsV0FBVyxFQUFFO1FBQUUsT0FBT0EsWUFBWStELEVBQUU7SUFBRTtBQUNqRjtBQUNBLFNBQVM2L0Isa0JBQWtCdjdCLFNBQVMsRUFBRTY4QixpQkFBaUIsRUFBRUMsZUFBZSxFQUFFO0lBQ3RFLElBQUlyK0IsZUFBZTtRQUFFLElBQUlvK0I7SUFBa0I7SUFDM0MsSUFBSyxJQUFJcmlELFNBQVN3bEIsVUFBVztRQUN6QixJQUFJdmhCLE1BQU11aEIsU0FBUyxDQUFDeGxCLE1BQU07UUFDMUIsSUFBSWlFLElBQUlwUyxRQUFRLElBQUl5d0QsZUFBZSxDQUFDcitDLElBQUlwUyxRQUFRLENBQUMsRUFBRTtZQUMvQ295QixZQUFZLENBQUNqa0IsTUFBTSxHQUFHc2lELGVBQWUsQ0FBQ3IrQyxJQUFJcFMsUUFBUSxDQUFDO1FBQ3ZELENBQUM7SUFDTDtJQUNBLE9BQU9veUI7QUFDWDtBQUNBLFNBQVM0OEIsaUJBQWlCYyxlQUFlLEVBQUU7SUFDdkMsSUFBSS85QyxVQUFVKzlDLGdCQUFnQi85QyxPQUFPO0lBQ3JDLE9BQU87UUFDSHkrQyxtQkFBbUJ2aUMsY0FBYztZQUM3QjdSLFNBQVNySyxRQUFRMlIsWUFBWTtZQUM3QjVDLFVBQVUvTyxRQUFRK08sUUFBUTtZQUMxQnNNLGVBQWVyYixRQUFRNFIsa0JBQWtCO1lBQ3pDMEosa0JBQWtCdGIsUUFBUTZSLHFCQUFxQjtZQUMvQzBKLFlBQVl2YixRQUFRK1IsZUFBZTtZQUNuQ3lKLFNBQVMsT0FBT3hiLFFBQVE4UixZQUFZLEtBQUssWUFBWTlSLFFBQVE4UixZQUFZLEdBQUc3VSxTQUFTO1lBQ3JGd2UsT0FBT3piLFFBQVFnUyxVQUFVO1lBQ3pCNEosaUJBQWlCNWIsUUFBUWlTLG9CQUFvQjtZQUM3QzRKLGFBQWE3YixRQUFRa1MsZ0JBQWdCO1lBQ3JDNEosV0FBVzliLFFBQVFtUyxjQUFjO1lBQ2pDd0osT0FBTzNiLFFBQVFvUyxVQUFVO1FBRTdCLEdBQUcyckM7UUFDSEcsaUJBQWlCaGlDLGNBQWM7WUFDM0JYLFlBQVl2YixRQUFReVMsZ0JBQWdCO1lBQ3BDK0ksU0FBUyxPQUFPeGIsUUFBUTBTLGFBQWEsS0FBSyxZQUFZMVMsUUFBUTBTLGFBQWEsR0FBR3pWLFNBQVM7WUFDdkZ3ZSxPQUFPemIsUUFBUTJTLFdBQVc7UUFDOUIsR0FBR29yQztJQUNQO0FBQ0o7QUFDQSxTQUFTTSxpQkFBaUJoekIsS0FBSyxFQUFFMTlCLE9BQU8sRUFBRTtJQUN0QyxJQUFLLElBQUk4UCxLQUFLLEdBQUc5TCxLQUFLaEUsUUFBUW9TLFdBQVcsQ0FBQzZtQyxjQUFjLEVBQUVucEMsS0FBSzlMLEdBQUdyQixNQUFNLEVBQUVtTixLQUFNO1FBQzVFLElBQUlxaUQsZ0JBQWdCbnVELEVBQUUsQ0FBQzhMLEdBQUc7UUFDMUIsSUFBSXFpRCxjQUFjejBCLFFBQVE7WUFDdEIsT0FBTyxJQUFJO1FBQ2YsQ0FBQztJQUNMO0lBQ0EsT0FBTyxLQUFLO0FBQ2hCO0FBQ0EsU0FBUyt4QiwwQkFBMEJXLGVBQWUsRUFBRTtJQUNoRCxPQUFPcHBCLG1CQUFtQm9wQixnQkFBZ0IvOUMsT0FBTyxDQUFDa1IsYUFBYSxFQUFFNnNDO0FBQ3JFO0FBQ0EsU0FBU3VCLG1CQUFtQnQvQyxPQUFPLEVBQUUrL0MsUUFBUSxFQUFFO0lBQzNDLElBQUssSUFBSXoxQixjQUFjdHFCLFFBQVM7UUFDNUI4cUIsUUFBUUMsSUFBSSxDQUFDLHFCQUFxQlQsYUFBYSxNQUMxQ3kxQixDQUFBQSxXQUFXLGdCQUFnQkEsV0FBVyxNQUFNLEVBQUU7SUFDdkQ7QUFDSjtBQUVBLG1DQUFtQztBQUNuQyxJQUFJQyx1QkFBdUIsV0FBVyxHQUFJLFNBQVVuZSxNQUFNLEVBQUU7SUFDeEQxMEMsZ0RBQVNBLENBQUM2eUQsc0JBQXNCbmU7SUFDaEMsU0FBU21lLHFCQUFxQjl1RCxLQUFLLEVBQUU7UUFDakMsSUFBSXVVLFFBQVFvOEIsT0FBTzl4QyxJQUFJLENBQUMsSUFBSSxFQUFFbUIsVUFBVSxJQUFJO1FBQzVDdVUsTUFBTXc2QyxVQUFVLEdBQUcsU0FBVXRDLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUNsNEMsTUFBTXk2QyxXQUFXLEVBQUU7Z0JBQ3BCLDBEQUEwRDtnQkFDMUR6NkMsTUFBTTRsQixLQUFLLEdBQUdzeUIsTUFBTSx5QkFBeUI7WUFDakQsT0FDSztnQkFDRGw0QyxNQUFNNi9CLFFBQVEsQ0FBQ3FZO1lBQ25CLENBQUM7UUFDTDtRQUNBbDRDLE1BQU15NkMsV0FBVyxHQUFHLElBQUkxRCxvQkFBb0I7WUFDeENuUCxpQkFBaUJuOEMsTUFBTW04QyxlQUFlO1lBQ3RDeG1CLGFBQWEzMUIsTUFBTTIxQixXQUFXO1lBQzlCcTRCLFFBQVF6NUMsTUFBTXc2QyxVQUFVO1FBQzVCO1FBQ0EsT0FBT3g2QztJQUNYO0lBQ0F1NkMscUJBQXFCbnlELFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUNoRCxPQUFPLElBQUksQ0FBQ3g1QyxLQUFLLENBQUNKLFFBQVEsQ0FBQyxJQUFJLENBQUN1NkIsS0FBSztJQUN6QztJQUNBMjBCLHFCQUFxQm55RCxTQUFTLENBQUM2OUMsa0JBQWtCLEdBQUcsU0FBVXlVLFNBQVMsRUFBRTtRQUNyRSxJQUFJQyxxQkFBcUIsSUFBSSxDQUFDbHZELEtBQUssQ0FBQ204QyxlQUFlO1FBQ25ELElBQUkrUyx1QkFBdUJELFVBQVU5UyxlQUFlLEVBQUU7WUFDbEQsSUFBSSxDQUFDNlMsV0FBVyxDQUFDNUIsWUFBWSxDQUFDOEI7UUFDbEMsQ0FBQztJQUNMO0lBQ0EsT0FBT0o7QUFDWCxFQUFFM3lELCtDQUFTQTtBQUVYLFVBQVU7QUFDVjs7O0FBR0EsR0FDQSxTQUFTZ3pELFlBQVludkQsS0FBSyxFQUFFcU8sTUFBTSxFQUFFO0lBQ2hDLE9BQU82Z0IsZ0JBQWdCbHZCLE1BQU0yTyxVQUFVLEVBQUUzTyxNQUFNbXZCLFlBQVksRUFBRW52QixNQUFNazNCLFdBQVcsQ0FBQ0MsV0FBVyxFQUFFOW9CLFNBQVNyTyxNQUFNMmIsZ0JBQWdCLEdBQUcsSUFBSSxFQUFFeVUsRUFBRTtBQUMxSTtBQUVBLElBQUlnL0Isb0JBQW9CLFdBQVcsR0FBSSxXQUFZO0lBQy9DLFNBQVNBLGtCQUFrQno1QyxZQUFZLEVBQUU7UUFDckMsSUFBSSxDQUFDQSxZQUFZLEdBQUdBO0lBQ3hCO0lBQ0EsT0FBT3k1QztBQUNYO0FBRUEsSUFBSUMsZUFBZSxXQUFXLEdBQUksV0FBWTtJQUMxQyxTQUFTQSxlQUFlO1FBQ3BCLFdBQVc7UUFDWCxJQUFJLENBQUNDLFdBQVcsR0FBRyxLQUFLO1FBQ3hCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEtBQUs7UUFDM0IsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLGtCQUFrQjtRQUN0QyxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDLEdBQUcsa0JBQWtCO1FBQ3pDLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUUsRUFBRSxVQUFVO1FBQ2pDLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUUsRUFBRSw0QkFBNEI7UUFDdEQsSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUFHLCtCQUErQjtJQUN4RDtJQUNBUCxhQUFhMXlELFNBQVMsQ0FBQ2t6RCxPQUFPLEdBQUcsU0FBVWpVLE1BQU0sRUFBRTtRQUMvQyxJQUFJa1UsZ0JBQWdCLEVBQUU7UUFDdEIsSUFBSyxJQUFJdmpELEtBQUssR0FBR2c4QyxXQUFXM00sUUFBUXJ2QyxLQUFLZzhDLFNBQVNucEQsTUFBTSxFQUFFbU4sS0FBTTtZQUM1RCxJQUFJN0ksUUFBUTZrRCxRQUFRLENBQUNoOEMsR0FBRztZQUN4QixJQUFJLENBQUN3akQsV0FBVyxDQUFDcnNELE9BQU9vc0Q7UUFDNUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0FULGFBQWExeUQsU0FBUyxDQUFDb3pELFdBQVcsR0FBRyxTQUFVQyxLQUFLLEVBQUVGLGFBQWEsRUFBRTtRQUNqRSxJQUFJdjRDLFlBQVksSUFBSSxDQUFDMDRDLGFBQWEsQ0FBQ0Q7UUFDbkMsSUFBSSxJQUFJLENBQUNFLGdCQUFnQixDQUFDMzRDLFdBQVd5NEMsUUFBUTtZQUN6QyxJQUFJLENBQUNHLGFBQWEsQ0FBQ0gsT0FBT3o0QztZQUMxQixPQUFPO1FBQ1gsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDNjRDLHNCQUFzQixDQUFDNzRDLFdBQVd5NEMsT0FBT0Y7SUFDekQ7SUFDQVQsYUFBYTF5RCxTQUFTLENBQUN1ekQsZ0JBQWdCLEdBQUcsU0FBVTM0QyxTQUFTLEVBQUV5NEMsS0FBSyxFQUFFO1FBQ2xFLE9BQU8sQ0FBQyxJQUFJLENBQUNSLFFBQVEsS0FBSyxDQUFDLEtBQUtqNEMsVUFBVTg0QyxVQUFVLEdBQUdMLE1BQU1NLFNBQVMsSUFBSSxJQUFJLENBQUNkLFFBQVEsS0FDbEYsS0FBSSxDQUFDQyxXQUFXLEtBQUssQ0FBQyxLQUFLbDRDLFVBQVVnNUMsUUFBUSxHQUFHLElBQUksQ0FBQ2QsV0FBVztJQUN6RTtJQUNBLHlDQUF5QztJQUN6Q0osYUFBYTF5RCxTQUFTLENBQUN5ekQsc0JBQXNCLEdBQUcsU0FBVTc0QyxTQUFTLEVBQUV5NEMsS0FBSyxFQUFFRixhQUFhLEVBQUU7UUFDdkYsSUFBSSxJQUFJLENBQUNQLGNBQWMsSUFBSWg0QyxVQUFVaTVDLGFBQWEsRUFBRTtZQUNoRCxPQUFPLElBQUksQ0FBQ0MsVUFBVSxDQUFDVCxPQUFPejRDLFVBQVVpNUMsYUFBYSxFQUFFVjtRQUMzRCxDQUFDO1FBQ0RBLGNBQWN2d0QsSUFBSSxDQUFDeXdEO1FBQ25CLE9BQU87SUFDWDtJQUNBWCxhQUFhMXlELFNBQVMsQ0FBQzh6RCxVQUFVLEdBQUcsU0FBVVQsS0FBSyxFQUFFVSxPQUFPLEVBQUVaLGFBQWEsRUFBRTtRQUN6RSxJQUFJYSxVQUFVO1FBQ2QsSUFBSUMscUJBQXFCLEVBQUU7UUFDM0IsSUFBSUMsWUFBWWIsTUFBTTM3QixJQUFJO1FBQzFCLElBQUl5OEIsY0FBY0osUUFBUXI4QixJQUFJO1FBQzlCLElBQUl3OEIsVUFBVXBoRCxLQUFLLEdBQUdxaEQsWUFBWXJoRCxLQUFLLEVBQUU7WUFDckNraEQsV0FBVyxJQUFJLENBQUNaLFdBQVcsQ0FBQztnQkFDeEJscUQsT0FBT21xRCxNQUFNbnFELEtBQUs7Z0JBQ2xCeXFELFdBQVdOLE1BQU1NLFNBQVM7Z0JBQzFCajhCLE1BQU07b0JBQUU1a0IsT0FBT29oRCxVQUFVcGhELEtBQUs7b0JBQUVDLEtBQUtvaEQsWUFBWXJoRCxLQUFLO2dCQUFDO1lBQzNELEdBQUdtaEQ7UUFDUCxDQUFDO1FBQ0QsSUFBSUMsVUFBVW5oRCxHQUFHLEdBQUdvaEQsWUFBWXBoRCxHQUFHLEVBQUU7WUFDakNpaEQsV0FBVyxJQUFJLENBQUNaLFdBQVcsQ0FBQztnQkFDeEJscUQsT0FBT21xRCxNQUFNbnFELEtBQUs7Z0JBQ2xCeXFELFdBQVdOLE1BQU1NLFNBQVM7Z0JBQzFCajhCLE1BQU07b0JBQUU1a0IsT0FBT3FoRCxZQUFZcGhELEdBQUc7b0JBQUVBLEtBQUttaEQsVUFBVW5oRCxHQUFHO2dCQUFDO1lBQ3ZELEdBQUdraEQ7UUFDUCxDQUFDO1FBQ0QsSUFBSUQsU0FBUztZQUNUYixjQUFjdndELElBQUksQ0FBQ2tHLEtBQUssQ0FBQ3FxRCxlQUFlOXpELG9EQUFhQSxDQUFDO2dCQUFDO29CQUMvQzZKLE9BQU9tcUQsTUFBTW5xRCxLQUFLO29CQUNsQnlxRCxXQUFXTixNQUFNTSxTQUFTO29CQUMxQmo4QixNQUFNMDhCLGVBQWVELGFBQWFEO2dCQUN0QzthQUFFLEVBQUVEO1lBQ1IsT0FBT0Q7UUFDWCxDQUFDO1FBQ0RiLGNBQWN2d0QsSUFBSSxDQUFDeXdEO1FBQ25CLE9BQU87SUFDWDtJQUNBWCxhQUFhMXlELFNBQVMsQ0FBQ3d6RCxhQUFhLEdBQUcsU0FBVUgsS0FBSyxFQUFFejRDLFNBQVMsRUFBRTtRQUMvRCxJQUFJOVcsS0FBSyxJQUFJLEVBQUVrdkQsaUJBQWlCbHZELEdBQUdrdkQsY0FBYyxFQUFFRCxjQUFjanZELEdBQUdpdkQsV0FBVztRQUMvRSxJQUFJbjRDLFVBQVV5NUMsT0FBTyxLQUFLLENBQUMsR0FBRztZQUMxQixxQkFBcUI7WUFDckJDLFNBQVN2QixhQUFhbjRDLFVBQVUyNUMsS0FBSyxFQUFFMzVDLFVBQVU4NEMsVUFBVTtZQUMzRFksU0FBU3RCLGdCQUFnQnA0QyxVQUFVMjVDLEtBQUssRUFBRTtnQkFBQ2xCO2FBQU07UUFDckQsT0FDSztZQUNELDZCQUE2QjtZQUM3QmlCLFNBQVN0QixjQUFjLENBQUNwNEMsVUFBVTI1QyxLQUFLLENBQUMsRUFBRTM1QyxVQUFVeTVDLE9BQU8sRUFBRWhCO1FBQ2pFLENBQUM7UUFDRCxJQUFJLENBQUNKLFNBQVMsQ0FBQ3VCLGNBQWNuQixPQUFPLEdBQUd6NEMsVUFBVWc1QyxRQUFRO0lBQzdEO0lBQ0FsQixhQUFhMXlELFNBQVMsQ0FBQ3N6RCxhQUFhLEdBQUcsU0FBVW1CLFFBQVEsRUFBRTtRQUN2RCxJQUFJM3dELEtBQUssSUFBSSxFQUFFaXZELGNBQWNqdkQsR0FBR2l2RCxXQUFXLEVBQUVDLGlCQUFpQmx2RCxHQUFHa3ZELGNBQWMsRUFBRUwsY0FBYzd1RCxHQUFHNnVELFdBQVcsRUFBRU0sWUFBWW52RCxHQUFHbXZELFNBQVM7UUFDdkksSUFBSXlCLFdBQVczQixZQUFZdHdELE1BQU07UUFDakMsSUFBSWt5RCxpQkFBaUI7UUFDckIsSUFBSUMsZ0JBQWdCLENBQUM7UUFDckIsSUFBSUMsa0JBQWtCLENBQUM7UUFDdkIsSUFBSWhCLGdCQUFnQixJQUFJO1FBQ3hCLElBQUlELFdBQVc7UUFDZixJQUFLLElBQUlrQixnQkFBZ0IsR0FBR0EsZ0JBQWdCSixVQUFVSSxpQkFBaUIsRUFBRztZQUN0RSxJQUFJQyxnQkFBZ0JoQyxXQUFXLENBQUMrQixjQUFjO1lBQzlDLGdHQUFnRztZQUNoRywyREFBMkQ7WUFDM0QsSUFBSSxDQUFDbkMsZUFBZW9DLGlCQUFpQkosaUJBQWlCRixTQUFTZCxTQUFTLEVBQUU7Z0JBQ3RFLEtBQU07WUFDVixDQUFDO1lBQ0QsSUFBSXFCLGtCQUFrQmhDLGNBQWMsQ0FBQzhCLGNBQWM7WUFDbkQsSUFBSUcsZ0JBQWdCLEtBQUs7WUFDekIsSUFBSUMsWUFBWUMsYUFBYUgsaUJBQWlCUCxTQUFTLzhCLElBQUksQ0FBQzVrQixLQUFLLEVBQUVzaUQsa0JBQWtCLHdDQUF3QztZQUM3SCxJQUFJQyxlQUFlSCxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRSxFQUFFLHlEQUF5RDtZQUN6RyxNQUNBLENBQUNELGdCQUFnQkQsZUFBZSxDQUFDSyxhQUFhLEtBQUssb0NBQW9DO1lBQ25GSixjQUFjdjlCLElBQUksQ0FBQzVrQixLQUFLLEdBQUcyaEQsU0FBUy84QixJQUFJLENBQUMza0IsR0FBRyxDQUFDLGlDQUFpQzthQUNoRjtnQkFDRSxJQUFJdWlELHNCQUFzQlAsZ0JBQWdCRSxjQUFjdEIsU0FBUztnQkFDakUsNENBQTRDO2dCQUM1QyxJQUFJMkIsc0JBQXNCWCxnQkFBZ0I7b0JBQ3RDQSxpQkFBaUJXO29CQUNqQnpCLGdCQUFnQm9CO29CQUNoQkwsZ0JBQWdCRTtvQkFDaEJELGtCQUFrQlE7Z0JBQ3RCLENBQUM7Z0JBQ0QsK0VBQStFO2dCQUMvRSxJQUFJQyx3QkFBd0JYLGdCQUFnQjtvQkFDeEMsK0VBQStFO29CQUMvRWYsV0FBV3ZvRCxLQUFLd08sR0FBRyxDQUFDKzVDLFVBQVVYLFNBQVMsQ0FBQ3VCLGNBQWNTLGVBQWUsR0FBRztnQkFDNUUsQ0FBQztnQkFDREksZ0JBQWdCO1lBQ3BCO1FBQ0o7UUFDQSxxRUFBcUU7UUFDckUsSUFBSUUsWUFBWTtRQUNoQixJQUFJMUIsZUFBZTtZQUNmMEIsWUFBWVgsZ0JBQWdCO1lBQzVCLE1BQU9XLFlBQVliLFlBQVkzQixXQUFXLENBQUN3QyxVQUFVLEdBQUdaLGVBQWdCO2dCQUNwRVksYUFBYTtZQUNqQjtRQUNKLENBQUM7UUFDRCx1REFBdUQ7UUFDdkQsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUlELFlBQVliLFlBQVkzQixXQUFXLENBQUN3QyxVQUFVLEtBQUtaLGdCQUFnQjtZQUNuRWEsY0FBY0wsYUFBYW5DLGNBQWMsQ0FBQ3VDLFVBQVUsRUFBRWQsU0FBUy84QixJQUFJLENBQUMza0IsR0FBRyxFQUFFcWlELGdCQUFnQixDQUFDLEVBQUU7UUFDaEcsQ0FBQztRQUNELE9BQU87WUFDSFIsZUFBZUE7WUFDZkMsaUJBQWlCQTtZQUNqQmhCLGVBQWVBO1lBQ2ZELFVBQVVBO1lBQ1ZGLFlBQVlpQjtZQUNaSixPQUFPZ0I7WUFDUGxCLFNBQVNtQjtRQUNiO0lBQ0o7SUFDQSwyQ0FBMkM7SUFDM0M5QyxhQUFhMXlELFNBQVMsQ0FBQ3kxRCxPQUFPLEdBQUcsV0FBWTtRQUN6QyxJQUFJM3hELEtBQUssSUFBSSxFQUFFa3ZELGlCQUFpQmx2RCxHQUFHa3ZELGNBQWMsRUFBRUQsY0FBY2p2RCxHQUFHaXZELFdBQVc7UUFDL0UsSUFBSTJCLFdBQVcxQixlQUFldndELE1BQU07UUFDcEMsSUFBSWl6RCxRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUluQixRQUFRLEdBQUdBLFFBQVFHLFVBQVVILFNBQVMsRUFBRztZQUM5QyxJQUFJb0IsVUFBVTNDLGNBQWMsQ0FBQ3VCLE1BQU07WUFDbkMsSUFBSWIsYUFBYVgsV0FBVyxDQUFDd0IsTUFBTTtZQUNuQyxJQUFLLElBQUkza0QsS0FBSyxHQUFHZ21ELFlBQVlELFNBQVMvbEQsS0FBS2dtRCxVQUFVbnpELE1BQU0sRUFBRW1OLEtBQU07Z0JBQy9ELElBQUl5akQsUUFBUXVDLFNBQVMsQ0FBQ2htRCxHQUFHO2dCQUN6QjhsRCxNQUFNOXlELElBQUksQ0FBQ3hELCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdpMEQsUUFBUTtvQkFBRUssWUFBWUE7Z0JBQVc7WUFDdEU7UUFDSjtRQUNBLE9BQU9nQztJQUNYO0lBQ0EsT0FBT2hEO0FBQ1g7QUFDQSxTQUFTMEMsZ0JBQWdCL0IsS0FBSyxFQUFFO0lBQzVCLE9BQU9BLE1BQU0zN0IsSUFBSSxDQUFDM2tCLEdBQUc7QUFDekI7QUFDQSxTQUFTeWhELGNBQWNuQixLQUFLLEVBQUU7SUFDMUIsT0FBT0EsTUFBTW5xRCxLQUFLLEdBQUcsTUFBTW1xRCxNQUFNMzdCLElBQUksQ0FBQzVrQixLQUFLO0FBQy9DO0FBQ0Esb0RBQW9EO0FBQ3BELFNBQVMraUQseUJBQXlCRixPQUFPLEVBQUU7SUFDdkMsSUFBSUcsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJbG1ELEtBQUssR0FBR21tRCxZQUFZSixTQUFTL2xELEtBQUttbUQsVUFBVXR6RCxNQUFNLEVBQUVtTixLQUFNO1FBQy9ELElBQUl5akQsUUFBUTBDLFNBQVMsQ0FBQ25tRCxHQUFHO1FBQ3pCLElBQUlvbUQsaUJBQWlCLEVBQUU7UUFDdkIsSUFBSUMsY0FBYztZQUNkditCLE1BQU0yN0IsTUFBTTM3QixJQUFJO1lBQ2hCaStCLFNBQVM7Z0JBQUN0QzthQUFNO1FBQ3BCO1FBQ0EsSUFBSyxJQUFJdnZELEtBQUssR0FBR295RCxXQUFXSixRQUFRaHlELEtBQUtveUQsU0FBU3p6RCxNQUFNLEVBQUVxQixLQUFNO1lBQzVELElBQUlxeUQsUUFBUUQsUUFBUSxDQUFDcHlELEdBQUc7WUFDeEIsSUFBSXN3RCxlQUFlK0IsTUFBTXorQixJQUFJLEVBQUV1K0IsWUFBWXYrQixJQUFJLEdBQUc7Z0JBQzlDdStCLGNBQWM7b0JBQ1ZOLFNBQVNRLE1BQU1SLE9BQU8sQ0FBQ3puRCxNQUFNLENBQUMrbkQsWUFBWU4sT0FBTztvQkFDakRqK0IsTUFBTTArQixVQUFVRCxNQUFNeitCLElBQUksRUFBRXUrQixZQUFZditCLElBQUk7Z0JBQ2hEO1lBQ0osT0FDSztnQkFDRHMrQixlQUFlcHpELElBQUksQ0FBQ3V6RDtZQUN4QixDQUFDO1FBQ0w7UUFDQUgsZUFBZXB6RCxJQUFJLENBQUNxekQ7UUFDcEJILFNBQVNFO0lBQ2I7SUFDQSxPQUFPRjtBQUNYO0FBQ0EsU0FBU00sVUFBVXQrQixLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUM3QixPQUFPO1FBQ0hqbEIsT0FBT3pILEtBQUt3QixHQUFHLENBQUNpckIsTUFBTWhsQixLQUFLLEVBQUVpbEIsTUFBTWpsQixLQUFLO1FBQ3hDQyxLQUFLMUgsS0FBS3dPLEdBQUcsQ0FBQ2llLE1BQU0va0IsR0FBRyxFQUFFZ2xCLE1BQU1obEIsR0FBRztJQUN0QztBQUNKO0FBQ0EsU0FBU3FoRCxlQUFldDhCLEtBQUssRUFBRUMsS0FBSyxFQUFFO0lBQ2xDLElBQUlqbEIsUUFBUXpILEtBQUt3TyxHQUFHLENBQUNpZSxNQUFNaGxCLEtBQUssRUFBRWlsQixNQUFNamxCLEtBQUs7SUFDN0MsSUFBSUMsTUFBTTFILEtBQUt3QixHQUFHLENBQUNpckIsTUFBTS9rQixHQUFHLEVBQUVnbEIsTUFBTWhsQixHQUFHO0lBQ3ZDLElBQUlELFFBQVFDLEtBQUs7UUFDYixPQUFPO1lBQUVELE9BQU9BO1lBQU9DLEtBQUtBO1FBQUk7SUFDcEMsQ0FBQztJQUNELE9BQU8sSUFBSTtBQUNmO0FBQ0EsZUFBZTtBQUNmLHdIQUF3SDtBQUN4SCxTQUFTdWhELFNBQVNueEIsR0FBRyxFQUFFajZCLEtBQUssRUFBRTRHLElBQUksRUFBRTtJQUNoQ3F6QixJQUFJcnNCLE1BQU0sQ0FBQzVOLE9BQU8sR0FBRzRHO0FBQ3pCO0FBQ0EsU0FBU3FsRCxhQUFhaHRELENBQUMsRUFBRWt1RCxTQUFTLEVBQUVDLFVBQVUsRUFBRTtJQUM1QyxJQUFJdmxELGFBQWE7SUFDakIsSUFBSUMsV0FBVzdJLEVBQUUxRixNQUFNLEVBQUUsWUFBWTtJQUNyQyxJQUFJLENBQUN1TyxZQUFZcWxELFlBQVlDLFdBQVdudUQsQ0FBQyxDQUFDNEksV0FBVyxHQUFHO1FBQ3BELE9BQU87WUFBQztZQUFHO1NBQUU7SUFDakIsQ0FBQztJQUNELElBQUlzbEQsWUFBWUMsV0FBV251RCxDQUFDLENBQUM2SSxXQUFXLEVBQUUsR0FBRztRQUN6QyxPQUFPO1lBQUNBO1lBQVU7U0FBRTtJQUN4QixDQUFDO0lBQ0QsTUFBT0QsYUFBYUMsU0FBVTtRQUMxQixJQUFJdWxELGNBQWNsckQsS0FBSzZCLEtBQUssQ0FBQzZELGFBQWEsQ0FBQ0MsV0FBV0QsVUFBUyxJQUFLO1FBQ3BFLElBQUl5bEQsWUFBWUYsV0FBV251RCxDQUFDLENBQUNvdUQsWUFBWTtRQUN6QyxJQUFJRixZQUFZRyxXQUFXO1lBQ3ZCeGxELFdBQVd1bEQ7UUFDZixPQUNLLElBQUlGLFlBQVlHLFdBQVc7WUFDNUJ6bEQsYUFBYXdsRCxjQUFjO1FBQy9CLE9BQ0s7WUFDRCxPQUFPO2dCQUFDQTtnQkFBYTthQUFFO1FBQzNCLENBQUM7SUFDTDtJQUNBLE9BQU87UUFBQ3hsRDtRQUFZO0tBQUU7QUFDMUI7QUFFQSxJQUFJMGxELGNBQWMsV0FBVyxHQUFJLFdBQVk7SUFDekMsU0FBU0EsWUFBWTEzQixRQUFRLEVBQUU7UUFDM0IsSUFBSSxDQUFDclUsU0FBUyxHQUFHcVUsU0FBU3JVLFNBQVM7UUFDbkMsSUFBSSxDQUFDZ3NDLGlCQUFpQixHQUFHMzNCLFNBQVMyM0IsaUJBQWlCLElBQUksSUFBSTtJQUMvRDtJQUNBRCxZQUFZejJELFNBQVMsQ0FBQ2crQyxPQUFPLEdBQUcsV0FBWSxDQUM1QztJQUNBLE9BQU95WTtBQUNYO0FBQ0EsU0FBU0UseUJBQXlCanNDLFNBQVMsRUFBRTNqQixLQUFLLEVBQUU7SUFDaEQsT0FBTztRQUNIMmpCLFdBQVdBO1FBQ1h4cEIsSUFBSTZGLE1BQU03RixFQUFFO1FBQ1owMUQsZ0JBQWdCN3ZELE1BQU02dkQsY0FBYyxJQUFJLElBQUksR0FBRzd2RCxNQUFNNnZELGNBQWMsR0FBRyxJQUFJO1FBQzFFRixtQkFBbUIzdkQsTUFBTTJ2RCxpQkFBaUIsSUFBSSxJQUFJO0lBQ3REO0FBQ0o7QUFDQSxTQUFTRywyQkFBMkI5M0IsUUFBUSxFQUFFO0lBQzFDLElBQUlqN0I7SUFDSixPQUFPQSxLQUFLLENBQUMsR0FDVEEsRUFBRSxDQUFDaTdCLFNBQVNyVSxTQUFTLENBQUN5dEIsR0FBRyxDQUFDLEdBQUdwWixVQUM3Qmo3QixFQUFFO0FBQ1Y7QUFDQSxlQUFlO0FBQ2YsSUFBSWd6RCwyQkFBMkIsQ0FBQztBQUVoQzs7Ozs7Ozs7Ozs7O0FBWUEsR0FDQSxJQUFJQyxrQkFBa0IsV0FBVyxHQUFJLFdBQVk7SUFDN0MsU0FBU0EsZ0JBQWdCNzFELEVBQUUsRUFBRUksUUFBUSxFQUFFO1FBQ25DLElBQUksQ0FBQ3kxQixPQUFPLEdBQUcsSUFBSWlhO0lBQ3ZCO0lBQ0ErbEIsZ0JBQWdCLzJELFNBQVMsQ0FBQ2crQyxPQUFPLEdBQUcsV0FBWSxDQUNoRDtJQUNBK1ksZ0JBQWdCLzJELFNBQVMsQ0FBQ2czRCxrQkFBa0IsR0FBRyxTQUFVQyxJQUFJLEVBQUU7SUFDM0Qsd0RBQXdEO0lBQzVEO0lBQ0FGLGdCQUFnQi8yRCxTQUFTLENBQUNrM0Qsb0JBQW9CLEdBQUcsU0FBVUQsSUFBSSxFQUFFO0lBQzdELHdEQUF3RDtJQUM1RDtJQUNBRixnQkFBZ0IvMkQsU0FBUyxDQUFDbTNELG9CQUFvQixHQUFHLFNBQVVGLElBQUksRUFBRTtJQUM3RCxXQUFXO0lBQ2Y7SUFDQSxPQUFPRjtBQUNYO0FBRUEsb0RBQW9EO0FBQ3BELDhFQUE4RTtBQUM5RSxJQUFJSyxTQUFTLENBQUM7QUFFZDs7O0FBR0EsR0FDQSxJQUFJQyxxQkFBcUI7SUFDckIxd0IsV0FBV256QjtJQUNYNUIsVUFBVTRCO0lBQ1Zza0MsUUFBUTM0QjtJQUNSL2UsVUFBVWdHO0FBQ2Q7QUFDQSxTQUFTa3hELGNBQWMvckMsR0FBRyxFQUFFO0lBQ3hCLElBQUl6bkIsS0FBS3NuQixZQUFZRyxLQUFLOHJDLHFCQUFxQmptRCxVQUFVdE4sR0FBR3NOLE9BQU8sRUFBRWthLFFBQVF4bkIsR0FBR3duQixLQUFLO0lBQ3JGLE9BQU87UUFDSHFiLFdBQVd2MUIsUUFBUXUxQixTQUFTLElBQUksSUFBSTtRQUNwQy8wQixVQUFVUixRQUFRUSxRQUFRLElBQUksSUFBSTtRQUNsQ2ttQyxRQUFRMW1DLFFBQVEwbUMsTUFBTSxJQUFJLElBQUksR0FBRzFtQyxRQUFRMG1DLE1BQU0sR0FBRyxJQUFJO1FBQ3REMTNDLFVBQVVnUixRQUFRaFIsUUFBUTtRQUMxQm0zRCxlQUFlanNDO0lBQ25CO0FBQ0o7QUFFQSxJQUFJa3NDLGlCQUFpQixXQUFXLEdBQUksU0FBVXhqQixNQUFNLEVBQUU7SUFDbEQxMEMsZ0RBQVNBLENBQUNrNEQsZ0JBQWdCeGpCO0lBQzFCLFNBQVN3akIsaUJBQWlCO1FBQ3RCLE9BQU94akIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtJQUNuRTtJQUNBOC9DLGVBQWV4M0QsU0FBUyxDQUFDNjhDLE1BQU0sR0FBRyxXQUFZO1FBQzFDLElBQUlqbEMsUUFBUSxJQUFJO1FBQ2hCLElBQUkzVSxXQUFXLElBQUksQ0FBQ0ksS0FBSyxDQUFDbzBELFlBQVksQ0FBQ3BrRCxHQUFHLENBQUMsU0FBVXFrRCxXQUFXLEVBQUU7WUFBRSxPQUFPOS9DLE1BQU0rL0MsaUJBQWlCLENBQUNEO1FBQWM7UUFDakgsT0FBT2g0RCx5REFBbUIsQ0FBQyxLQUFLLEdBQUdMLG9EQUFhQSxDQUFDO1lBQUM7WUFBTztnQkFBRXd1QixXQUFXO1lBQW1CO1NBQUUsRUFBRTVxQjtJQUNqRztJQUNBdTBELGVBQWV4M0QsU0FBUyxDQUFDMjNELGlCQUFpQixHQUFHLFNBQVVELFdBQVcsRUFBRTtRQUNoRSxJQUFJcjBELFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUkrb0MsUUFBUSxJQUFJLENBQUN0c0MsT0FBTyxDQUFDc3NDLEtBQUs7UUFDOUIsSUFBSW5wQyxXQUFXLEVBQUU7UUFDakIsSUFBSTIwRCxnQkFBZ0IsSUFBSTtRQUN4QixJQUFLLElBQUlob0QsS0FBSyxHQUFHaW9ELGdCQUFnQkgsYUFBYTluRCxLQUFLaW9ELGNBQWNwMUQsTUFBTSxFQUFFbU4sS0FBTTtZQUMzRSxJQUFJa29ELFNBQVNELGFBQWEsQ0FBQ2pvRCxHQUFHO1lBQzlCLElBQUlrbEMsYUFBYWdqQixPQUFPaGpCLFVBQVUsRUFBRXdULGNBQWN3UCxPQUFPeFAsV0FBVyxFQUFFcitCLGFBQWE2dEMsT0FBTzd0QyxVQUFVLEVBQUVzK0IsYUFBYXVQLE9BQU92UCxVQUFVLEVBQUU1SCxhQUFhbVgsT0FBT25YLFVBQVU7WUFDcEssSUFBSTdMLGVBQWUsU0FBUztnQkFDeEI4aUIsZ0JBQWdCLEtBQUs7Z0JBQ3JCMzBELFNBQVNMLElBQUksQ0FBQ2xELHVEQUFhQSxDQUFDLE1BQU07b0JBQUVtdUIsV0FBVztvQkFBb0JlLElBQUl2ckIsTUFBTTAwRCxPQUFPO2dCQUFDLEdBQUcxMEQsTUFBTXdyQixLQUFLO1lBQ3ZHLE9BQ0s7Z0JBQ0QsSUFBSW1wQyxZQUFZbGpCLGVBQWV6eEMsTUFBTTQwRCxZQUFZO2dCQUNqRCxJQUFJaHNCLGFBQWEsQ0FBRTVvQyxNQUFNNjBELGNBQWMsSUFBSXBqQixlQUFlLFdBQ3JELENBQUN6eEMsTUFBTTgwRCxhQUFhLElBQUlyakIsZUFBZSxVQUN2QyxDQUFDenhDLE1BQU0rMEQsYUFBYSxJQUFJdGpCLGVBQWU7Z0JBQzVDLElBQUl1akIsZ0JBQWdCO29CQUFDLFFBQVF2akIsYUFBYTtvQkFBVzFJLE1BQU1DLFFBQVEsQ0FBQztpQkFBVTtnQkFDOUUsSUFBSTJyQixXQUFXO29CQUNYSyxjQUFjejFELElBQUksQ0FBQ3dwQyxNQUFNQyxRQUFRLENBQUM7Z0JBQ3RDLENBQUM7Z0JBQ0RwcEMsU0FBU0wsSUFBSSxDQUFDbEQsdURBQWFBLENBQUMsVUFBVTtvQkFBRVMsTUFBTTtvQkFBVTB1QixPQUFPLE9BQU84eEIsZUFBZSxhQUFhQSxXQUFXdDlDLE1BQU13bEQsT0FBTyxJQUFJbEksVUFBVTtvQkFBRTJYLFVBQVVyc0I7b0JBQVksZ0JBQWdCK3JCO29CQUFXbnFDLFdBQVd3cUMsY0FBY3g3QyxJQUFJLENBQUM7b0JBQU1oWCxTQUFTeWlEO2dCQUFZLEdBQUdyK0IsY0FBZXMrQixDQUFBQSxhQUFhN29ELHVEQUFhQSxDQUFDLFFBQVE7b0JBQUVtdUIsV0FBVzA2QjtnQkFBVyxLQUFLLEVBQUU7WUFDNVUsQ0FBQztRQUNMO1FBQ0EsSUFBSXRsRCxTQUFTUixNQUFNLEdBQUcsR0FBRztZQUNyQixJQUFJODFELGlCQUFpQixpQkFBa0Juc0IsTUFBTUMsUUFBUSxDQUFDLGtCQUFtQjtZQUN6RSxPQUFPM3NDLHlEQUFtQixDQUFDLEtBQUssR0FBR0wsb0RBQWFBLENBQUM7Z0JBQUM7Z0JBQU87b0JBQUV3dUIsV0FBVzBxQztnQkFBZTthQUFFLEVBQUV0MUQ7UUFDN0YsQ0FBQztRQUNELE9BQU9BLFFBQVEsQ0FBQyxFQUFFO0lBQ3RCO0lBQ0EsT0FBT3UwRDtBQUNYLEVBQUUzZjtBQUVGLElBQUkyZ0IsVUFBVSxXQUFXLEdBQUksU0FBVXhrQixNQUFNLEVBQUU7SUFDM0MxMEMsZ0RBQVNBLENBQUNrNUQsU0FBU3hrQjtJQUNuQixTQUFTd2tCLFVBQVU7UUFDZixPQUFPeGtCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7SUFDbkU7SUFDQThnRCxRQUFReDRELFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUNuQyxJQUFJLzRDLEtBQUssSUFBSSxDQUFDVCxLQUFLLEVBQUVvMUQsUUFBUTMwRCxHQUFHMjBELEtBQUssRUFBRUMsaUJBQWlCNTBELEdBQUc0MEQsY0FBYztRQUN6RSxJQUFJQyxXQUFXLEtBQUs7UUFDcEIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlyUixpQkFBaUJpUixNQUFNalIsY0FBYztRQUN6QyxJQUFJc1IsZ0JBQWdCdFIsZUFBZTcrQixNQUFNO1FBQ3pDLElBQUk2K0IsZUFBZWxnQixJQUFJLEVBQUU7WUFDckJxeEIsV0FBVyxJQUFJO1lBQ2ZDLGVBQWVwUixlQUFlbGdCLElBQUk7UUFDdEMsT0FDSztZQUNEc3hCLGVBQWVwUixlQUFlMTBDLEtBQUs7UUFDdkMsQ0FBQztRQUNELElBQUkwMEMsZUFBZWpnQixLQUFLLEVBQUU7WUFDdEJveEIsV0FBVyxJQUFJO1lBQ2ZFLGFBQWFyUixlQUFlamdCLEtBQUs7UUFDckMsT0FDSztZQUNEc3hCLGFBQWFyUixlQUFlejBDLEdBQUc7UUFDbkMsQ0FBQztRQUNELElBQUkrWCxhQUFhO1lBQ2I0dEMsa0JBQWtCO1lBQ2xCO1lBQ0FDLFdBQVcsbUJBQW1CLEVBQUU7U0FDbkM7UUFDRCxPQUFRajVELHVEQUFhQSxDQUFDLE9BQU87WUFBRW11QixXQUFXL0MsV0FBV2pPLElBQUksQ0FBQztRQUFLLEdBQzNELElBQUksQ0FBQ2s4QyxhQUFhLENBQUMsU0FBU0gsZ0JBQWdCLEVBQUUsR0FDOUMsSUFBSSxDQUFDRyxhQUFhLENBQUMsVUFBVUQsaUJBQWlCLEVBQUUsR0FDaEQsSUFBSSxDQUFDQyxhQUFhLENBQUMsT0FBT0YsY0FBYyxFQUFFO0lBQ2xEO0lBQ0FMLFFBQVF4NEQsU0FBUyxDQUFDKzRELGFBQWEsR0FBRyxTQUFVOXlELEdBQUcsRUFBRXd4RCxZQUFZLEVBQUU7UUFDM0QsSUFBSXAwRCxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixPQUFRM0QsdURBQWFBLENBQUM4M0QsZ0JBQWdCO1lBQUV2eEQsS0FBS0E7WUFBS3d4RCxjQUFjQTtZQUFjNW9DLE9BQU94ckIsTUFBTXdyQixLQUFLO1lBQUVnNkIsU0FBU3hsRCxNQUFNd2xELE9BQU87WUFBRW9QLGNBQWM1MEQsTUFBTTQwRCxZQUFZO1lBQUVDLGdCQUFnQjcwRCxNQUFNNjBELGNBQWM7WUFBRUMsZUFBZTkwRCxNQUFNODBELGFBQWE7WUFBRUMsZUFBZS8wRCxNQUFNKzBELGFBQWE7WUFBRUwsU0FBUzEwRCxNQUFNMDBELE9BQU87UUFBQztJQUNyUztJQUNBLE9BQU9TO0FBQ1gsRUFBRTNnQjtBQUVGLCtCQUErQjtBQUMvQixJQUFJbWhCLGdCQUFnQixXQUFXLEdBQUksU0FBVWhsQixNQUFNLEVBQUU7SUFDakQxMEMsZ0RBQVNBLENBQUMwNUQsZUFBZWhsQjtJQUN6QixTQUFTZ2xCLGdCQUFnQjtRQUNyQixJQUFJcGhELFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTTRsQixLQUFLLEdBQUc7WUFDVnk3QixnQkFBZ0IsSUFBSTtRQUN4QjtRQUNBcmhELE1BQU1zaEQsUUFBUSxHQUFHLFNBQVVoNEQsRUFBRSxFQUFFO1lBQzNCMFcsTUFBTTFXLEVBQUUsR0FBR0E7WUFDWDYyQyxPQUFPbmdDLE1BQU12VSxLQUFLLENBQUN1NUMsS0FBSyxFQUFFMTdDO1lBQzFCMFcsTUFBTXVoRCxvQkFBb0I7UUFDOUI7UUFDQXZoRCxNQUFNd2hELFlBQVksR0FBRyxXQUFZO1lBQzdCeGhELE1BQU11aEQsb0JBQW9CO1FBQzlCO1FBQ0EsT0FBT3ZoRDtJQUNYO0lBQ0FvaEQsY0FBY2g1RCxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDekMsSUFBSS80QyxLQUFLLElBQUksRUFBRVQsUUFBUVMsR0FBR1QsS0FBSyxFQUFFbTZCLFFBQVExNUIsR0FBRzA1QixLQUFLO1FBQ2pELElBQUkvYyxjQUFjcGQsTUFBTW9kLFdBQVc7UUFDbkMsSUFBSXFLLGFBQWE7WUFDYjtZQUNDckssZUFBZXBkLE1BQU1nMkQsTUFBTSxJQUFJaDJELE1BQU15ZixNQUFNLEdBQ3RDLHlCQUF5Qiw4QkFBOEI7ZUFDdkQseUJBQXlCO1NBQ2xDO1FBQ0QsSUFBSUEsU0FBUztRQUNiLElBQUl1c0IsZ0JBQWdCO1FBQ3BCLElBQUk1dUIsYUFBYTtZQUNiLElBQUkrYyxNQUFNeTdCLGNBQWMsS0FBSyxJQUFJLEVBQUU7Z0JBQy9CbjJDLFNBQVMwYSxNQUFNeTdCLGNBQWMsR0FBR3g0QztZQUNwQyxPQUNLO2dCQUNELHNFQUFzRTtnQkFDdEUsdUVBQXVFO2dCQUN2RSwyRUFBMkU7Z0JBQzNFLGlGQUFpRjtnQkFDakY0dUIsZ0JBQWdCLElBQUs1dUIsY0FBZSxNQUFNO1lBQzlDLENBQUM7UUFDTCxPQUNLO1lBQ0RxQyxTQUFTemYsTUFBTXlmLE1BQU0sSUFBSTtRQUM3QixDQUFDO1FBQ0QsT0FBUXBqQix1REFBYUEsQ0FBQyxPQUFPO1lBQUUsbUJBQW1CMkQsTUFBTWkyRCxXQUFXO1lBQUV0aEIsS0FBSyxJQUFJLENBQUNraEIsUUFBUTtZQUFFcnJDLFdBQVcvQyxXQUFXak8sSUFBSSxDQUFDO1lBQU1uWixPQUFPO2dCQUFFb2YsUUFBUUE7Z0JBQVF1c0IsZUFBZUE7WUFBYztRQUFFLEdBQUdoc0MsTUFBTUosUUFBUTtJQUN2TTtJQUNBKzFELGNBQWNoNUQsU0FBUyxDQUFDMjlDLGlCQUFpQixHQUFHLFdBQVk7UUFDcEQsSUFBSSxDQUFDNzlDLE9BQU8sQ0FBQzgyQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUN3aUIsWUFBWTtJQUNuRDtJQUNBSixjQUFjaDVELFNBQVMsQ0FBQzg5QyxvQkFBb0IsR0FBRyxXQUFZO1FBQ3ZELElBQUksQ0FBQ2grQyxPQUFPLENBQUMrMkMsbUJBQW1CLENBQUMsSUFBSSxDQUFDdWlCLFlBQVk7SUFDdEQ7SUFDQUosY0FBY2g1RCxTQUFTLENBQUNtNUQsb0JBQW9CLEdBQUcsV0FBWTtRQUN2RCxJQUFJLElBQUksQ0FBQ2o0RCxFQUFFLElBQUksbUJBQW1CO1FBQzlCLElBQUksQ0FBQ21DLEtBQUssQ0FBQ29kLFdBQVcsQ0FBQyxtRUFBbUU7VUFDNUY7WUFDRSxJQUFJLENBQUNnM0IsUUFBUSxDQUFDO2dCQUFFd2hCLGdCQUFnQixJQUFJLENBQUMvM0QsRUFBRSxDQUFDNHNDLFdBQVc7WUFBQztRQUN4RCxDQUFDO0lBQ0w7SUFDQSxPQUFPa3JCO0FBQ1gsRUFBRW5oQjtBQUVGOztBQUVBLEdBQ0EsSUFBSTBoQixnQkFBZ0IsV0FBVyxHQUFJLFNBQVV2bEIsTUFBTSxFQUFFO0lBQ2pEMTBDLGdEQUFTQSxDQUFDaTZELGVBQWV2bEI7SUFDekIsU0FBU3VsQixjQUFjeDZCLFFBQVEsRUFBRTtRQUM3QixJQUFJbm5CLFFBQVFvOEIsT0FBTzl4QyxJQUFJLENBQUMsSUFBSSxFQUFFNjhCLGFBQWEsSUFBSTtRQUMvQ25uQixNQUFNNGhELGNBQWMsR0FBRyxTQUFVMzFELEVBQUUsRUFBRTQxRCxLQUFLLEVBQUU7WUFDeEMsSUFBSS91QyxZQUFZOVMsTUFBTThTLFNBQVM7WUFDL0IsSUFBSTVxQixVQUFVNHFCLFVBQVU1cUIsT0FBTztZQUMvQixJQUFJOHpCLE1BQU1FLFNBQVMybEM7WUFDbkIsSUFBSTdsQyxPQUFPLCtDQUErQztZQUN0RGxKLFVBQVVndUIsZ0JBQWdCLENBQUM3MEMsR0FBR0ksTUFBTSxHQUFHO2dCQUN2Qyx1RUFBdUU7Z0JBQ3ZFLHlFQUF5RTtnQkFDekUsSUFBSXkxRCxrQkFBa0JyNEQsZUFBZXdDLEdBQUdJLE1BQU0sRUFBRTtnQkFDaEQsSUFBSWxELE1BQU0yNEQsa0JBQWtCQSxnQkFBZ0Jod0QsYUFBYSxDQUFDLFdBQVdvdEIsSUFBSSxHQUFHLEVBQUU7Z0JBQzlFaDNCLFFBQVFpM0IsT0FBTyxDQUFDRSxPQUFPLENBQUMsY0FBYztvQkFDbEMvMUIsSUFBSXU0RDtvQkFDSnZpQyxPQUFPLElBQUlDLFNBQVN6TSxVQUFVNXFCLE9BQU8sRUFBRTh6QixJQUFJWSxVQUFVLENBQUNoaUIsR0FBRyxFQUFFb2hCLElBQUlZLFVBQVUsQ0FBQ2xpQixRQUFRO29CQUNsRjhrQixTQUFTdnpCO29CQUNUd3pCLE1BQU12M0IsUUFBUXczQixPQUFPO2dCQUN6QjtnQkFDQSxJQUFJdjJCLE9BQU8sQ0FBQzhDLEdBQUc4MUQsZ0JBQWdCLEVBQUU7b0JBQzdCeHJCLE9BQU95ckIsUUFBUSxDQUFDOWlDLElBQUksR0FBRy8xQjtnQkFDM0IsQ0FBQztZQUNMLENBQUM7UUFDTDtRQUNBNlcsTUFBTW9tQyxPQUFPLEdBQUd0NUMsaUJBQWlCcTZCLFNBQVM3OUIsRUFBRSxFQUFFLFNBQVMsYUFDdkQwVyxNQUFNNGhELGNBQWM7UUFDcEIsT0FBTzVoRDtJQUNYO0lBQ0EsT0FBTzJoRDtBQUNYLEVBQUU5QztBQUVGOzs7QUFHQSxHQUNBLElBQUlvRCxnQkFBZ0IsV0FBVyxHQUFJLFNBQVU3bEIsTUFBTSxFQUFFO0lBQ2pEMTBDLGdEQUFTQSxDQUFDdTZELGVBQWU3bEI7SUFDekIsU0FBUzZsQixjQUFjOTZCLFFBQVEsRUFBRTtRQUM3QixJQUFJbm5CLFFBQVFvOEIsT0FBTzl4QyxJQUFJLENBQUMsSUFBSSxFQUFFNjhCLGFBQWEsSUFBSTtRQUMvQywwRkFBMEY7UUFDMUZubkIsTUFBTWtpRCxtQkFBbUIsR0FBRyxTQUFVNTRELEVBQUUsRUFBRTtZQUN0QyxJQUFJQSxPQUFPMFcsTUFBTW1pRCxZQUFZLEVBQUU7Z0JBQzNCbmlELE1BQU1vaUQsY0FBYyxDQUFDLElBQUksRUFBRXBpRCxNQUFNbWlELFlBQVk7WUFDakQsQ0FBQztRQUNMO1FBQ0FuaUQsTUFBTXFpRCxjQUFjLEdBQUcsU0FBVXAyRCxFQUFFLEVBQUU0MUQsS0FBSyxFQUFFO1lBQ3hDLElBQUkzbEMsU0FBUzJsQyxRQUFRO2dCQUNqQjdoRCxNQUFNbWlELFlBQVksR0FBR047Z0JBQ3JCN2hELE1BQU1zaUQsWUFBWSxDQUFDLG1CQUFtQnIyRCxJQUFJNDFEO1lBQzlDLENBQUM7UUFDTDtRQUNBN2hELE1BQU1vaUQsY0FBYyxHQUFHLFNBQVVuMkQsRUFBRSxFQUFFNDFELEtBQUssRUFBRTtZQUN4QyxJQUFJN2hELE1BQU1taUQsWUFBWSxFQUFFO2dCQUNwQm5pRCxNQUFNbWlELFlBQVksR0FBRyxJQUFJO2dCQUN6Qm5pRCxNQUFNc2lELFlBQVksQ0FBQyxtQkFBbUJyMkQsSUFBSTQxRDtZQUM5QyxDQUFDO1FBQ0w7UUFDQTdoRCxNQUFNdWlELG9CQUFvQixHQUFHcDFELHdCQUF3Qmc2QixTQUFTNzlCLEVBQUUsRUFBRSxhQUNsRTBXLE1BQU1xaUQsY0FBYyxFQUFFcmlELE1BQU1vaUQsY0FBYztRQUMxQyxPQUFPcGlEO0lBQ1g7SUFDQWlpRCxjQUFjNzVELFNBQVMsQ0FBQ2crQyxPQUFPLEdBQUcsV0FBWTtRQUMxQyxJQUFJLENBQUNtYyxvQkFBb0I7SUFDN0I7SUFDQU4sY0FBYzc1RCxTQUFTLENBQUNrNkQsWUFBWSxHQUFHLFNBQVVFLFlBQVksRUFBRXYyRCxFQUFFLEVBQUU0MUQsS0FBSyxFQUFFO1FBQ3RFLElBQUkvdUMsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDOUIsSUFBSTVxQixVQUFVNHFCLFVBQVU1cUIsT0FBTztRQUMvQixJQUFJOHpCLE1BQU1FLFNBQVMybEM7UUFDbkIsSUFBSSxDQUFDNTFELE1BQU02bUIsVUFBVWd1QixnQkFBZ0IsQ0FBQzcwQyxHQUFHSSxNQUFNLEdBQUc7WUFDOUNuRSxRQUFRaTNCLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDbWpDLGNBQWM7Z0JBQ2xDbDVELElBQUl1NEQ7Z0JBQ0p2aUMsT0FBTyxJQUFJQyxTQUFTcjNCLFNBQVM4ekIsSUFBSVksVUFBVSxDQUFDaGlCLEdBQUcsRUFBRW9oQixJQUFJWSxVQUFVLENBQUNsaUIsUUFBUTtnQkFDeEU4a0IsU0FBU3Z6QjtnQkFDVHd6QixNQUFNdjNCLFFBQVF3M0IsT0FBTztZQUN6QjtRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU91aUM7QUFDWCxFQUFFcEQ7QUFFRixJQUFJNEQsa0JBQWtCLFdBQVcsR0FBSSxTQUFVcm1CLE1BQU0sRUFBRTtJQUNuRDEwQyxnREFBU0EsQ0FBQys2RCxpQkFBaUJybUI7SUFDM0IsU0FBU3FtQixrQkFBa0I7UUFDdkIsSUFBSXppRCxRQUFRbzhCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7UUFDcEVFLE1BQU0wK0IsZ0JBQWdCLEdBQUduL0IsUUFBUW0vQjtRQUNqQzErQixNQUFNMGlELHlCQUF5QixHQUFHbmpELFFBQVFtakQ7UUFDMUMxaUQsTUFBTTJpRCxpQkFBaUIsR0FBR3BqRCxRQUFRb2pEO1FBQ2xDM2lELE1BQU00aUQsU0FBUyxHQUFHLzZELG1EQUFTQTtRQUMzQm1ZLE1BQU02aUQsU0FBUyxHQUFHaDdELG1EQUFTQTtRQUMzQm1ZLE1BQU04aUQsaUJBQWlCLEdBQUcsQ0FBQztRQUMzQiwyQkFBMkI7UUFDM0I5aUQsTUFBTTRsQixLQUFLLEdBQUc7WUFDVm05QixhQUFhdDJEO1FBQ2pCO1FBQ0EseUJBQXlCO1FBQ3pCLG9IQUFvSDtRQUNwSHVULE1BQU04K0IsNEJBQTRCLEdBQUcsU0FBVWhzQixTQUFTLEVBQUVrd0MsYUFBYSxFQUFFO1lBQ3JFLElBQUk3N0IsV0FBVzQzQix5QkFBeUJqc0MsV0FBV2t3QztZQUNuRCxJQUFJQyx1QkFBdUI7Z0JBQ3ZCdEI7Z0JBQ0FNO2FBQ0g7WUFDRCxJQUFJaUIscUJBQXFCRCxxQkFBcUIzc0QsTUFBTSxDQUFDMEosTUFBTXZVLEtBQUssQ0FBQzZPLFdBQVcsQ0FBQ3VuQyxxQkFBcUI7WUFDbEcsSUFBSXNoQixlQUFlRCxtQkFBbUJ6bkQsR0FBRyxDQUFDLFNBQVUybkQsbUJBQW1CLEVBQUU7Z0JBQUUsT0FBTyxJQUFJQSxvQkFBb0JqOEI7WUFBVztZQUNySG5uQixNQUFNOGlELGlCQUFpQixDQUFDaHdDLFVBQVV5dEIsR0FBRyxDQUFDLEdBQUc0aUI7WUFDekNqRSx3QkFBd0IsQ0FBQ3BzQyxVQUFVeXRCLEdBQUcsQ0FBQyxHQUFHcFo7UUFDOUM7UUFDQW5uQixNQUFNKytCLDhCQUE4QixHQUFHLFNBQVVqc0IsU0FBUyxFQUFFO1lBQ3hELElBQUl1d0MsWUFBWXJqRCxNQUFNOGlELGlCQUFpQixDQUFDaHdDLFVBQVV5dEIsR0FBRyxDQUFDO1lBQ3RELElBQUk4aUIsV0FBVztnQkFDWCxJQUFLLElBQUlyckQsS0FBSyxHQUFHc3JELGNBQWNELFdBQVdyckQsS0FBS3NyRCxZQUFZejRELE1BQU0sRUFBRW1OLEtBQU07b0JBQ3JFLElBQUl1ckQsV0FBV0QsV0FBVyxDQUFDdHJELEdBQUc7b0JBQzlCdXJELFNBQVNuZCxPQUFPO2dCQUNwQjtnQkFDQSxPQUFPcG1DLE1BQU04aUQsaUJBQWlCLENBQUNod0MsVUFBVXl0QixHQUFHLENBQUM7WUFDakQsQ0FBQztZQUNELE9BQU8yZSx3QkFBd0IsQ0FBQ3BzQyxVQUFVeXRCLEdBQUcsQ0FBQztRQUNsRDtRQUNBLFdBQVc7UUFDWCxvSEFBb0g7UUFDcEh2Z0MsTUFBTXdqRCxZQUFZLEdBQUcsSUFBSXJPLGNBQWMsV0FBWTtZQUMvQ24xQyxNQUFNdlUsS0FBSyxDQUFDMHpCLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDLFdBQVcsSUFBSSxHQUFHLGlEQUFpRDtZQUMvRnJmLE1BQU12VSxLQUFLLENBQUMwekIsT0FBTyxDQUFDRSxPQUFPLENBQUMsZ0JBQWdCO2dCQUFFSSxNQUFNemYsTUFBTXZVLEtBQUssQ0FBQ2kwQixPQUFPO1lBQUM7UUFDNUU7UUFDQTFmLE1BQU02SyxrQkFBa0IsR0FBRyxTQUFVNWUsRUFBRSxFQUFFO1lBQ3JDLElBQUlzTyxVQUFVeUYsTUFBTXZVLEtBQUssQ0FBQzhPLE9BQU87WUFDakMsSUFBSUEsUUFBUXNRLGtCQUFrQixJQUMxQjVlLEdBQUdJLE1BQU0sS0FBS2txQyxPQUFPLG9CQUFvQjtjQUMzQztnQkFDRXYyQixNQUFNd2pELFlBQVksQ0FBQ3RsQixPQUFPLENBQUMzakMsUUFBUXVRLGlCQUFpQjtZQUN4RCxDQUFDO1FBQ0w7UUFDQSxPQUFPOUs7SUFDWDtJQUNBOztJQUVBLEdBQ0F5aUQsZ0JBQWdCcjZELFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUMzQyxJQUFJeDVDLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUl1NkIsZ0JBQWdCdjZCLE1BQU11NkIsYUFBYSxFQUFFenJCLFVBQVU5TyxNQUFNOE8sT0FBTztRQUNoRSxJQUFJa3BELGVBQWUsSUFBSSxDQUFDZCxpQkFBaUIsQ0FBQ2wzRCxNQUFNa3pDLFFBQVEsRUFBRWx6QyxNQUFNazNCLFdBQVcsRUFBRWwzQixNQUFNb3pDLG9CQUFvQixFQUFFcHpDLE1BQU11NEIsV0FBVyxFQUFFSyxPQUFPNTRCLE1BQU04TyxPQUFPLENBQUNvUixHQUFHLEVBQUVsZ0IsTUFBTWlPLE9BQU8sR0FDbktqTyxNQUFNaTNCLFNBQVM7UUFDZixJQUFJZ2hDLFlBQVksS0FBSztRQUNyQixJQUFJMzNDLGFBQWE7UUFDakIsSUFBSTQzQztRQUNKLElBQUlsNEQsTUFBTW00RCxZQUFZLElBQUluNEQsTUFBTW80RCxRQUFRLEVBQUU7WUFDdEM5M0MsYUFBYTtRQUNqQixPQUNLLElBQUl4UixRQUFRMlEsTUFBTSxJQUFJLElBQUksRUFBRTtZQUM3Qnc0QyxZQUFZLElBQUk7UUFDcEIsT0FDSyxJQUFJbnBELFFBQVE0USxhQUFhLElBQUksSUFBSSxFQUFFO1lBQ3BDWSxhQUFheFIsUUFBUTRRLGFBQWE7UUFDdEMsT0FDSztZQUNEdzRDLGtCQUFrQmx3RCxLQUFLd08sR0FBRyxDQUFDMUgsUUFBUXNPLFdBQVcsRUFBRSxNQUFNLGdDQUFnQztRQUMxRixDQUFDO1FBQ0QsSUFBSWk3QyxjQUFjLElBQUksQ0FBQ3BsQixnQkFBZ0IsQ0FBQ2p6QyxNQUFNa3pDLFFBQVEsRUFBRWx6QyxNQUFNaTBCLE9BQU8sRUFBRWowQixNQUFNOE8sT0FBTyxFQUFFOU8sTUFBTW96QyxvQkFBb0IsRUFBRXB6QyxNQUFNaU8sT0FBTyxFQUFFak8sTUFBTStvQyxLQUFLLEVBQUUvb0MsTUFBTTZPLFdBQVcsRUFBRTdPLE1BQU1uRCxRQUFRLEVBQUVtRCxNQUFNZzNCLGNBQWMsRUFBRWgzQixNQUFNMHpCLE9BQU8sRUFBRTF6QixNQUFNMjFCLFdBQVcsRUFBRSxJQUFJLENBQUMwZCw0QkFBNEIsRUFBRSxJQUFJLENBQUNDLDhCQUE4QjtRQUMvUyxJQUFJZ2tCLGNBQWMsY0FBZTc4QixNQUFNLElBQUlGLGNBQWNFLE1BQU0sQ0FBQzJwQixRQUFRLEdBQ2xFLElBQUksQ0FBQ2pxQixLQUFLLENBQUNtOUIsV0FBVyxHQUN0QixFQUFFO1FBQ1IsT0FBUWo3RCx1REFBYUEsQ0FBQzIyQyxnQkFBZ0JzbEIsUUFBUSxFQUFFO1lBQUU1bEQsT0FBTzJsRDtRQUFZLEdBQ2pFOTlCLGNBQWNFLE1BQU0sSUFBS3ArQix1REFBYUEsQ0FBQzg0RCxTQUFTcDVELCtDQUFRQSxDQUFDO1lBQUU0NEMsS0FBSyxJQUFJLENBQUN3aUIsU0FBUztZQUFFOUIsZ0JBQWdCO1lBQXFCRCxPQUFPNzZCLGNBQWNFLE1BQU07WUFBRWk2QixTQUFTNEM7UUFBWSxHQUFHVSxnQkFDMUszN0QsdURBQWFBLENBQUNzNUQsZUFBZTtZQUFFSyxRQUFRaUM7WUFBV3g0QyxRQUFRYTtZQUFZbEQsYUFBYTg2QztZQUFpQmpDLGFBQWFxQjtRQUFZLEdBQ3pILElBQUksQ0FBQ2lCLFVBQVUsQ0FBQ3Y0RCxRQUNoQixJQUFJLENBQUN3NEQsa0JBQWtCLEtBQzNCaitCLGNBQWNJLE1BQU0sSUFBS3QrQix1REFBYUEsQ0FBQzg0RCxTQUFTcDVELCtDQUFRQSxDQUFDO1lBQUU0NEMsS0FBSyxJQUFJLENBQUN5aUIsU0FBUztZQUFFL0IsZ0JBQWdCO1lBQXFCRCxPQUFPNzZCLGNBQWNJLE1BQU07WUFBRSs1QixTQUFTO1FBQUcsR0FBR3NEO0lBQ3pLO0lBQ0FoQixnQkFBZ0JyNkQsU0FBUyxDQUFDMjlDLGlCQUFpQixHQUFHLFdBQVk7UUFDdEQsSUFBSXQ2QyxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJLENBQUNxMkMsb0JBQW9CLEdBQUdyMkMsTUFBTTZPLFdBQVcsQ0FBQ3duQyxvQkFBb0IsQ0FDN0RybUMsR0FBRyxDQUFDLFNBQVV5b0Qsd0JBQXdCLEVBQUU7WUFBRSxPQUFPLElBQUlBLHlCQUF5Qno0RDtRQUFRO1FBQzNGOHFDLE9BQU90cEMsZ0JBQWdCLENBQUMsVUFBVSxJQUFJLENBQUM0ZCxrQkFBa0I7UUFDekQsSUFBSTAzQixrQkFBa0I5MkMsTUFBTTZPLFdBQVcsQ0FBQ2lvQyxlQUFlO1FBQ3ZELElBQUssSUFBSTcyQyxZQUFZNjJDLGdCQUFpQjtZQUNsQ0EsZUFBZSxDQUFDNzJDLFNBQVMsQ0FBQ0QsS0FBSyxDQUFDQyxTQUFTLEVBQUVEO1FBQy9DO0lBQ0o7SUFDQWczRCxnQkFBZ0JyNkQsU0FBUyxDQUFDNjlDLGtCQUFrQixHQUFHLFNBQVV5VSxTQUFTLEVBQUU7UUFDaEUsSUFBSWp2RCxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJODJDLGtCQUFrQjkyQyxNQUFNNk8sV0FBVyxDQUFDaW9DLGVBQWU7UUFDdkQsSUFBSyxJQUFJNzJDLFlBQVk2MkMsZ0JBQWlCO1lBQ2xDLElBQUk5MkMsS0FBSyxDQUFDQyxTQUFTLEtBQUtndkQsU0FBUyxDQUFDaHZELFNBQVMsRUFBRTtnQkFDekM2MkMsZUFBZSxDQUFDNzJDLFNBQVMsQ0FBQ0QsS0FBSyxDQUFDQyxTQUFTLEVBQUVEO1lBQy9DLENBQUM7UUFDTDtJQUNKO0lBQ0FnM0QsZ0JBQWdCcjZELFNBQVMsQ0FBQzg5QyxvQkFBb0IsR0FBRyxXQUFZO1FBQ3pEM1AsT0FBT3JwQyxtQkFBbUIsQ0FBQyxVQUFVLElBQUksQ0FBQzJkLGtCQUFrQjtRQUM1RCxJQUFJLENBQUMyNEMsWUFBWSxDQUFDcE4sS0FBSztRQUN2QixJQUFLLElBQUlwK0MsS0FBSyxHQUFHOUwsS0FBSyxJQUFJLENBQUM0MUMsb0JBQW9CLEVBQUU5cEMsS0FBSzlMLEdBQUdyQixNQUFNLEVBQUVtTixLQUFNO1lBQ25FLElBQUl1N0IsY0FBY3JuQyxFQUFFLENBQUM4TCxHQUFHO1lBQ3hCdTdCLFlBQVk2UyxPQUFPO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDMzZDLEtBQUssQ0FBQzB6QixPQUFPLENBQUNFLE9BQU8sQ0FBQztJQUMvQjtJQUNBb2pDLGdCQUFnQnI2RCxTQUFTLENBQUM2N0Qsa0JBQWtCLEdBQUcsV0FBWTtRQUN2RCxJQUFJeDRELFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlKLFdBQVdJLE1BQU02TyxXQUFXLENBQUNxbkMsb0JBQW9CLENBQUNsbUMsR0FBRyxDQUFDLFNBQVV3b0Qsa0JBQWtCLEVBQUU7WUFBRSxPQUFPQSxtQkFBbUJ4NEQ7UUFBUTtRQUM1SCxPQUFPM0QseURBQW1CLENBQUMsS0FBSyxHQUFHTCxvREFBYUEsQ0FBQztZQUFDTSw4Q0FBUUE7WUFBRSxDQUFDO1NBQUUsRUFBRXNEO0lBQ3JFO0lBQ0FvM0QsZ0JBQWdCcjZELFNBQVMsQ0FBQzQ3RCxVQUFVLEdBQUcsU0FBVXY0RCxLQUFLLEVBQUU7UUFDcEQsSUFBSTZPLGNBQWM3TyxNQUFNNk8sV0FBVztRQUNuQyxJQUFJcWtDLFdBQVdsekMsTUFBTWt6QyxRQUFRO1FBQzdCLElBQUk2SSxZQUFZO1lBQ1o3a0IsYUFBYWwzQixNQUFNazNCLFdBQVc7WUFDOUJsWCxlQUFlaGdCLE1BQU1nZ0IsYUFBYTtZQUNsQ3JSLFlBQVkzTyxNQUFNK3NELG9CQUFvQjtZQUN0QzU5QixjQUFjbnZCLE1BQU1tdkIsWUFBWTtZQUNoQzJNLGVBQWU5N0IsTUFBTTg3QixhQUFhO1lBQ2xDd0wsZ0JBQWdCdG5DLE1BQU1zbkMsY0FBYztZQUNwQ1AsV0FBVy9tQyxNQUFNK21DLFNBQVM7WUFDMUJFLGFBQWFqbkMsTUFBTWluQyxXQUFXO1lBQzlCa3hCLGNBQWNuNEQsTUFBTW00RCxZQUFZO1lBQ2hDQyxVQUFVcDRELE1BQU1vNEQsUUFBUTtRQUM1QjtRQUNBLElBQUkvbUMsZUFBZSxJQUFJLENBQUM0bEMseUJBQXlCLENBQUNwb0QsWUFBWWtuQyxxQkFBcUI7UUFDbkYsSUFBSyxJQUFJeHBDLEtBQUssR0FBR2dsQixpQkFBaUJGLGNBQWM5a0IsS0FBS2dsQixlQUFlbnlCLE1BQU0sRUFBRW1OLEtBQU07WUFDOUUsSUFBSWlsQixjQUFjRCxjQUFjLENBQUNobEIsR0FBRztZQUNwQ3hRLCtDQUFRQSxDQUFDZ2dELFdBQVd2cUIsWUFBWXNFLFNBQVMsQ0FBQ2ltQixXQUFXLzdDO1FBQ3pEO1FBQ0EsSUFBSTA0RCxnQkFBZ0J4bEIsU0FBUzdyQixTQUFTO1FBQ3RDLE9BQVFockIsdURBQWFBLENBQUNxOEQsZUFBZTM4RCwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdnZ0Q7SUFDdEQ7SUFDQSxPQUFPaWI7QUFDWCxFQUFFdGpCO0FBQ0YsU0FBU3dqQixrQkFBa0Joa0IsUUFBUSxFQUFFaGMsV0FBVyxFQUFFa2Msb0JBQW9CLEVBQUU3YSxXQUFXLEVBQUVyWSxHQUFHLEVBQUVzTCxLQUFLLEVBQUU7SUFDN0YseUdBQXlHO0lBQ3pHLElBQUltdEMsWUFBWXZsQixxQkFBcUIrSyxLQUFLLENBQUNqK0IsS0FBS25VLFdBQVcsS0FBSyxHQUFHLCtEQUErRDtJQUNsSSxJQUFJNnNELFdBQVd4bEIscUJBQXFCMEssU0FBUyxDQUFDNW1CLGFBQWFxQixhQUFhLEtBQUs7SUFDN0UsSUFBSXNnQyxXQUFXemxCLHFCQUFxQmdMLFNBQVMsQ0FBQ2xuQixhQUFhcUIsYUFBYSxLQUFLO0lBQzdFLE9BQU87UUFDSC9NLE9BQU9BO1FBQ1BvcEMsY0FBYzFoQixTQUFTcDJDLElBQUk7UUFDM0Iwb0QsU0FBU3RTLFNBQVN0WSxVQUFVO1FBQzVCaTZCLGdCQUFnQjhELFVBQVVsYSxPQUFPLElBQUksQ0FBQ3p2QixvQkFBb0JrSSxZQUFZRSxZQUFZLEVBQUVsWDtRQUNwRjQwQyxlQUFlOEQsU0FBU25hLE9BQU87UUFDL0JzVyxlQUFlOEQsU0FBU3BhLE9BQU87SUFDbkM7QUFDSjtBQUNBLFNBQVM7QUFDVCxvSEFBb0g7QUFDcEgsU0FBU3dZLDBCQUEwQjZCLFVBQVUsRUFBRTtJQUMzQyxPQUFPQSxXQUFXOW9ELEdBQUcsQ0FBQyxTQUFVK29ELFFBQVEsRUFBRTtRQUFFLE9BQU8sSUFBSUE7SUFBWTtBQUN2RTtBQUVBLElBQUlDLGVBQWUsV0FBVyxHQUFJLFNBQVVyb0IsTUFBTSxFQUFFO0lBQ2hEMTBDLGdEQUFTQSxDQUFDKzhELGNBQWNyb0I7SUFDeEIsU0FBU3FvQixlQUFlO1FBQ3BCLElBQUl6a0QsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNNGxCLEtBQUssR0FBRztZQUNWaStCLFVBQVUsS0FBSztRQUNuQjtRQUNBN2pELE1BQU0wa0QsaUJBQWlCLEdBQUcsV0FBWTtZQUNsQzFrRCxNQUFNNi9CLFFBQVEsQ0FBQztnQkFBRWdrQixVQUFVLElBQUk7WUFBQztRQUNwQztRQUNBN2pELE1BQU0ya0QsZ0JBQWdCLEdBQUcsV0FBWTtZQUNqQzNrRCxNQUFNNi9CLFFBQVEsQ0FBQztnQkFBRWdrQixVQUFVLEtBQUs7WUFBQztRQUNyQztRQUNBLE9BQU83akQ7SUFDWDtJQUNBeWtELGFBQWFyOEQsU0FBUyxDQUFDNjhDLE1BQU0sR0FBRyxXQUFZO1FBQ3hDLElBQUl4NUMsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSThPLFVBQVU5TyxNQUFNOE8sT0FBTztRQUMzQixJQUFJc3BELFdBQVcsSUFBSSxDQUFDaitCLEtBQUssQ0FBQ2krQixRQUFRO1FBQ2xDLElBQUlELGVBQWVDLFlBQVl0cEQsUUFBUTJRLE1BQU0sS0FBSyxVQUFVM1EsUUFBUTRRLGFBQWEsS0FBSztRQUN0RixJQUFJRCxTQUFTLENBQUUwNEMsZ0JBQWdCcnBELFFBQVEyUSxNQUFNLElBQUksSUFBSSxHQUFJM1EsUUFBUTJRLE1BQU0sR0FBRyxFQUFFO1FBQzVFLElBQUlnSSxhQUFhO1lBQ2I7WUFDQTJ3QyxXQUFXLG1CQUFtQixpQkFBaUI7WUFDL0Msa0JBQWtCdHBELFFBQVF3SyxTQUFTO1lBQ25DdFosTUFBTStvQyxLQUFLLENBQUNDLFFBQVEsQ0FBQztTQUN4QjtRQUNELElBQUksQ0FBQy9ELHlCQUF5QjtZQUMxQnhkLFdBQVdsb0IsSUFBSSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxPQUFPUyxNQUFNSixRQUFRLENBQUM2bkIsWUFBWWhJLFFBQVEwNEMsY0FBY0M7SUFDNUQ7SUFDQVksYUFBYXI4RCxTQUFTLENBQUMyOUMsaUJBQWlCLEdBQUcsV0FBWTtRQUNuRCxJQUFJNW1CLFVBQVUsSUFBSSxDQUFDMXpCLEtBQUssQ0FBQzB6QixPQUFPO1FBQ2hDQSxRQUFRK0YsRUFBRSxDQUFDLGdCQUFnQixJQUFJLENBQUN3L0IsaUJBQWlCO1FBQ2pEdmxDLFFBQVErRixFQUFFLENBQUMsZUFBZSxJQUFJLENBQUN5L0IsZ0JBQWdCO0lBQ25EO0lBQ0FGLGFBQWFyOEQsU0FBUyxDQUFDODlDLG9CQUFvQixHQUFHLFdBQVk7UUFDdEQsSUFBSS9tQixVQUFVLElBQUksQ0FBQzF6QixLQUFLLENBQUMwekIsT0FBTztRQUNoQ0EsUUFBUW9HLEdBQUcsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDbS9CLGlCQUFpQjtRQUNsRHZsQyxRQUFRb0csR0FBRyxDQUFDLGVBQWUsSUFBSSxDQUFDby9CLGdCQUFnQjtJQUNwRDtJQUNBLE9BQU9GO0FBQ1gsRUFBRXhrQjtBQUVGLDhGQUE4RjtBQUM5RixTQUFTMmtCLDRCQUE0QkMsb0JBQW9CLEVBQUVsc0MsTUFBTSxFQUFFO0lBQy9ELG1GQUFtRjtJQUNuRixnREFBZ0Q7SUFDaEQsSUFBSSxDQUFDa3NDLHdCQUF3QmxzQyxTQUFTLElBQUk7UUFDdEMsT0FBTy9SLGdCQUFnQjtZQUFFdEYsU0FBUztRQUFRLElBQUksUUFBUTtJQUMxRCxDQUFDO0lBQ0QsSUFBSXFYLFNBQVMsR0FBRztRQUNaLE9BQU8vUixnQkFBZ0I7WUFBRXRGLFNBQVM7WUFBU25GLE9BQU87WUFBV0MsS0FBSztZQUFXOEUsWUFBWSxJQUFJO1FBQUMsSUFBSSxjQUFjO0lBQ3BILENBQUM7SUFDRCxPQUFPMEYsZ0JBQWdCO1FBQUV0RixTQUFTO0lBQU8sSUFBSSxhQUFhO0FBQzlEO0FBRUEsSUFBSXdqRCxhQUFhLHNCQUFzQix5QkFBeUI7QUFDaEUsU0FBU0MsY0FBYzdmLFNBQVMsRUFBRTtJQUM5QixPQUFPQSxVQUFVMkwsSUFBSTtBQUN6QjtBQUVBLElBQUltVSxnQkFBZ0IsV0FBVyxHQUFJLFNBQVU1b0IsTUFBTSxFQUFFO0lBQ2pEMTBDLGdEQUFTQSxDQUFDczlELGVBQWU1b0I7SUFDekIsU0FBUzRvQixnQkFBZ0I7UUFDckIsT0FBTzVvQixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO0lBQ25FO0lBQ0FrbEQsY0FBYzU4RCxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDekMsSUFBSS80QyxLQUFLLElBQUksQ0FBQ2hFLE9BQU8sRUFBRXdSLFVBQVV4TixHQUFHd04sT0FBTyxFQUFFYSxVQUFVck8sR0FBR3FPLE9BQU8sRUFBRWk2QixRQUFRdG9DLEdBQUdzb0MsS0FBSyxFQUFFOVUsVUFBVXh6QixHQUFHd3pCLE9BQU87UUFDekcsSUFBSWowQixRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJa0ssT0FBT2xLLE1BQU1rSyxJQUFJLEVBQUVndEIsY0FBY2wzQixNQUFNazNCLFdBQVc7UUFDdEQsSUFBSXNpQyxVQUFVN3dCLFlBQVl6K0IsTUFBTWxLLE1BQU15eUIsVUFBVSxFQUFFLElBQUksRUFBRXlFO1FBQ3hELElBQUl6UCxhQUFhO1lBQUM0eEM7U0FBVyxDQUFDeHVELE1BQU0sQ0FBQ2krQixpQkFBaUIwd0IsU0FBU3p3QjtRQUMvRCxJQUFJcWMsT0FBT24zQyxRQUFRdFEsTUFBTSxDQUFDdU0sTUFBTWxLLE1BQU0wYyxlQUFlO1FBQ3JELHdFQUF3RTtRQUN4RSxJQUFJKzhDLGVBQWUsQ0FBRUQsUUFBUTV3QixVQUFVLElBQUk1b0MsTUFBTTA1RCxNQUFNLEdBQUcsSUFDcER0d0Isa0JBQWtCLElBQUksQ0FBQzNzQyxPQUFPLEVBQUV5TixRQUNoQyxDQUFDLENBQUM7UUFDUixJQUFJdXZDLFlBQVkxOUMsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQztZQUFFbU8sTUFBTStELFFBQVErbUIsTUFBTSxDQUFDOXFCO1lBQU84cEIsTUFBTUM7UUFBUSxHQUFHajBCLE1BQU0yNUQsY0FBYyxHQUFHO1lBQUV2VSxNQUFNQTtRQUFLLElBQUlvVTtRQUNsSSxPQUFRbjlELHVEQUFhQSxDQUFDKzhDLFlBQVk7WUFBRUssV0FBV0E7WUFBV2h5QixZQUFZM1ksUUFBUTZOLG1CQUFtQjtZQUFFK0ssU0FBUzVZLFFBQVE4TixnQkFBZ0I7WUFBRWc5QixnQkFBZ0IwZjtZQUFlM3hDLFVBQVU3WSxRQUFRK04saUJBQWlCO1lBQUUrSyxhQUFhOVksUUFBUWdPLG9CQUFvQjtRQUFDLEdBQUcsU0FBVXU4QixTQUFTLEVBQUVxQyxnQkFBZ0IsRUFBRTVCLFVBQVUsRUFBRUMsWUFBWSxFQUFFO1lBQUUsT0FBUTE5Qyx1REFBYUEsQ0FBQyxNQUFNTiwrQ0FBUUEsQ0FBQztnQkFBRTQ0QyxLQUFLMEU7Z0JBQVd1Z0IsTUFBTTtnQkFBZ0JwdkMsV0FBVy9DLFdBQVc1YyxNQUFNLENBQUM2d0Msa0JBQWtCbGlDLElBQUksQ0FBQztnQkFBTSxhQUFhLENBQUNnZ0QsUUFBUTV3QixVQUFVLEdBQUc1MUIsZ0JBQWdCOUksUUFBUTZCLFNBQVM7Z0JBQUU4dEQsU0FBUzc1RCxNQUFNNjVELE9BQU87WUFBQyxHQUFHNzVELE1BQU04NUQsY0FBYyxHQUNqakJ6OUQsdURBQWFBLENBQUMsT0FBTztnQkFBRW11QixXQUFXO1lBQTJCLEdBQUcsQ0FBQ2d2QyxRQUFRNXdCLFVBQVUsSUFBS3ZzQyx1REFBYUEsQ0FBQyxLQUFLTiwrQ0FBUUEsQ0FBQztnQkFBRTQ0QyxLQUFLbUY7Z0JBQVl0dkIsV0FBVztvQkFDMUk7b0JBQ0F4cUIsTUFBTSs1RCxRQUFRLEdBQUcsY0FBYyxFQUFFO2lCQUNwQyxDQUFDdmdELElBQUksQ0FBQztZQUFLLEdBQUdpZ0QsZUFBZTFmO1FBQW1CO0lBQzdEO0lBQ0EsT0FBT3dmO0FBQ1gsRUFBRS9rQjtBQUVGLElBQUl3bEIsaUJBQWlCNytDLGdCQUFnQjtJQUFFdEYsU0FBUztBQUFPO0FBQ3ZELElBQUlva0QsZUFBZSxXQUFXLEdBQUksU0FBVXRwQixNQUFNLEVBQUU7SUFDaEQxMEMsZ0RBQVNBLENBQUNnK0QsY0FBY3RwQjtJQUN4QixTQUFTc3BCLGVBQWU7UUFDcEIsT0FBT3RwQixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO0lBQ25FO0lBQ0E0bEQsYUFBYXQ5RCxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDeEMsSUFBSXg1QyxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJUyxLQUFLLElBQUksQ0FBQ2hFLE9BQU8sRUFBRXdSLFVBQVV4TixHQUFHd04sT0FBTyxFQUFFODZCLFFBQVF0b0MsR0FBR3NvQyxLQUFLLEVBQUU5VSxVQUFVeHpCLEdBQUd3ekIsT0FBTyxFQUFFbmxCLFVBQVVyTyxHQUFHcU8sT0FBTztRQUN6RyxJQUFJNUUsT0FBT25ELFFBQVEsSUFBSTRELEtBQUssWUFBWTNLLE1BQU1rSixHQUFHLEdBQUcsMkNBQTJDO1FBQy9GLElBQUlrNkIsV0FBVztZQUNYbDZCLEtBQUtsSixNQUFNa0osR0FBRztZQUNkMC9CLFlBQVksS0FBSztZQUNqQi9WLFVBQVUsS0FBSztZQUNmRCxRQUFRLEtBQUs7WUFDYkUsU0FBUyxLQUFLO1lBQ2QrVixTQUFTLEtBQUs7UUFDbEI7UUFDQSxJQUFJcGhCLGFBQWE7WUFBQzR4QztTQUFXLENBQUN4dUQsTUFBTSxDQUFDaStCLGlCQUFpQjFGLFVBQVUyRixRQUFRL29DLE1BQU1rNkQsZUFBZSxJQUFJLEVBQUU7UUFDbkcsSUFBSTlVLE9BQU9uM0MsUUFBUXRRLE1BQU0sQ0FBQ3VNLE1BQU1sSyxNQUFNMGMsZUFBZTtRQUNyRCxJQUFJKzhCLFlBQVkxOUMsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUM7WUFDaERtTyxNQUFNQTtRQUFLLEdBQUdrNUIsV0FBVztZQUFFcFAsTUFBTUM7UUFBUSxJQUFJajBCLE1BQU0yNUQsY0FBYyxHQUFHO1lBQUV2VSxNQUFNQTtRQUFLO1FBQ3JGLE9BQVEvb0QsdURBQWFBLENBQUMrOEMsWUFBWTtZQUFFSyxXQUFXQTtZQUFXaHlCLFlBQVkzWSxRQUFRNk4sbUJBQW1CO1lBQUUrSyxTQUFTNVksUUFBUThOLGdCQUFnQjtZQUFFZzlCLGdCQUFnQjBmO1lBQWUzeEMsVUFBVTdZLFFBQVErTixpQkFBaUI7WUFBRStLLGFBQWE5WSxRQUFRZ08sb0JBQW9CO1FBQUMsR0FBRyxTQUFVdThCLFNBQVMsRUFBRXFDLGdCQUFnQixFQUFFNUIsVUFBVSxFQUFFQyxZQUFZLEVBQUU7WUFBRSxPQUFRMTlDLHVEQUFhQSxDQUFDLE1BQU1OLCtDQUFRQSxDQUFDO2dCQUFFNDRDLEtBQUswRTtnQkFBV3VnQixNQUFNO2dCQUFnQnB2QyxXQUFXL0MsV0FBVzVjLE1BQU0sQ0FBQzZ3QyxrQkFBa0JsaUMsSUFBSSxDQUFDO2dCQUFNcWdELFNBQVM3NUQsTUFBTTY1RCxPQUFPO1lBQUMsR0FBRzc1RCxNQUFNODVELGNBQWMsR0FDM2V6OUQsdURBQWFBLENBQUMsT0FBTztnQkFBRW11QixXQUFXO1lBQTJCLEdBQ3pEbnVCLHVEQUFhQSxDQUFDLEtBQUs7Z0JBQUUsY0FBYzRSLFFBQVF0USxNQUFNLENBQUN1TSxNQUFNOHZEO2dCQUFpQnh2QyxXQUFXO29CQUM1RTtvQkFDQXhxQixNQUFNKzVELFFBQVEsR0FBRyxjQUFjLEVBQUU7aUJBQ3BDLENBQUN2Z0QsSUFBSSxDQUFDO2dCQUFNbTdCLEtBQUttRjtZQUFXLEdBQUdDO1FBQWtCO0lBQ2xFO0lBQ0EsT0FBT2tnQjtBQUNYLEVBQUV6bEI7QUFFRixJQUFJMmxCLFdBQVcsV0FBVyxHQUFJLFNBQVV4cEIsTUFBTSxFQUFFO0lBQzVDMTBDLGdEQUFTQSxDQUFDaytELFVBQVV4cEI7SUFDcEIsU0FBU3dwQixTQUFTbjZELEtBQUssRUFBRXZELE9BQU8sRUFBRTtRQUM5QixJQUFJOFgsUUFBUW84QixPQUFPOXhDLElBQUksQ0FBQyxJQUFJLEVBQUVtQixPQUFPdkQsWUFBWSxJQUFJO1FBQ3JEOFgsTUFBTTZsRCxjQUFjLEdBQUd4aEMsT0FBT244QixRQUFRcVMsT0FBTyxDQUFDb1IsR0FBRyxFQUFFempCLFFBQVF3UixPQUFPO1FBQ2xFc0csTUFBTThsRCxtQkFBbUIsR0FBRyxJQUFJMXZELE9BQU90RCxPQUFPO1FBQzlDa04sTUFBTTRsQixLQUFLLEdBQUc1bEIsTUFBTStsRCxhQUFhLEdBQUdDLFlBQVk7UUFDaEQsT0FBT2htRDtJQUNYO0lBQ0E0bEQsU0FBU3g5RCxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDcEMsSUFBSS80QyxLQUFLLElBQUksRUFBRVQsUUFBUVMsR0FBR1QsS0FBSyxFQUFFbTZCLFFBQVExNUIsR0FBRzA1QixLQUFLO1FBQ2pELE9BQU9uNkIsTUFBTUosUUFBUSxDQUFDdTZCLE1BQU16SCxPQUFPLEVBQUV5SCxNQUFNMUgsVUFBVTtJQUN6RDtJQUNBMG5DLFNBQVN4OUQsU0FBUyxDQUFDMjlDLGlCQUFpQixHQUFHLFdBQVk7UUFDL0MsSUFBSSxDQUFDOFAsVUFBVTtJQUNuQjtJQUNBK1AsU0FBU3g5RCxTQUFTLENBQUM2OUMsa0JBQWtCLEdBQUcsU0FBVXlVLFNBQVMsRUFBRTtRQUN6RCxJQUFJQSxVQUFVNytDLElBQUksS0FBSyxJQUFJLENBQUNwUSxLQUFLLENBQUNvUSxJQUFJLEVBQUU7WUFDcEMsSUFBSSxDQUFDODVDLFlBQVk7WUFDakIsSUFBSSxDQUFDRSxVQUFVO1FBQ25CLENBQUM7SUFDTDtJQUNBK1AsU0FBU3g5RCxTQUFTLENBQUM4OUMsb0JBQW9CLEdBQUcsV0FBWTtRQUNsRCxJQUFJLENBQUN5UCxZQUFZO0lBQ3JCO0lBQ0FpUSxTQUFTeDlELFNBQVMsQ0FBQzI5RCxhQUFhLEdBQUcsV0FBWTtRQUMzQyxJQUFJNzVELEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87UUFDckQsSUFBSSs5RCxlQUFleHpELE1BQU0sSUFBSSxDQUFDb3pELGNBQWMsRUFBRSxJQUFJenZELE9BQU90RCxPQUFPLEtBQUssSUFBSSxDQUFDZ3pELG1CQUFtQjtRQUM3RixJQUFJSSxtQkFBbUJoK0QsUUFBUXdSLE9BQU8sQ0FBQzR5QixPQUFPLENBQUMyNUIsY0FBY3g2RCxNQUFNb1EsSUFBSTtRQUN2RSxJQUFJc3FELGdCQUFnQmorRCxRQUFRd1IsT0FBTyxDQUFDOUssR0FBRyxDQUFDczNELGtCQUFrQnRxRCxlQUFlLEdBQUduUSxNQUFNb1EsSUFBSTtRQUN0RixJQUFJdXFELFNBQVNELGNBQWNyekQsT0FBTyxLQUFLbXpELGFBQWFuekQsT0FBTztRQUMzRCxpRkFBaUY7UUFDakYsOEJBQThCO1FBQzlCc3pELFNBQVMzeUQsS0FBS3dCLEdBQUcsQ0FBQyxPQUFPLEtBQUssS0FBSyxJQUFJbXhEO1FBQ3ZDLE9BQU87WUFDSEosY0FBYztnQkFBRTduQyxTQUFTK25DO2dCQUFrQmhvQyxZQUFZbW9DLGNBQWNIO1lBQWtCO1lBQ3ZGNW1CLFdBQVc7Z0JBQUVuaEIsU0FBU2dvQztnQkFBZWpvQyxZQUFZbW9DLGNBQWNGO1lBQWU7WUFDOUVDLFFBQVFBO1FBQ1o7SUFDSjtJQUNBUixTQUFTeDlELFNBQVMsQ0FBQ3l0RCxVQUFVLEdBQUcsV0FBWTtRQUN4QyxJQUFJNzFDLFFBQVEsSUFBSTtRQUNoQixJQUFJOVQsS0FBSyxJQUFJLENBQUM2NUQsYUFBYSxJQUFJem1CLFlBQVlwekMsR0FBR296QyxTQUFTLEVBQUU4bUIsU0FBU2w2RCxHQUFHazZELE1BQU07UUFDM0UsSUFBSSxDQUFDNVEsU0FBUyxHQUFHSyxXQUFXLFdBQVk7WUFDcEM3MUMsTUFBTTYvQixRQUFRLENBQUNQLFdBQVcsV0FBWTtnQkFDbEN0L0IsTUFBTTYxQyxVQUFVO1lBQ3BCO1FBQ0osR0FBR3VRO0lBQ1A7SUFDQVIsU0FBU3g5RCxTQUFTLENBQUN1dEQsWUFBWSxHQUFHLFdBQVk7UUFDMUMsSUFBSSxJQUFJLENBQUNILFNBQVMsRUFBRTtZQUNoQkcsYUFBYSxJQUFJLENBQUNILFNBQVM7UUFDL0IsQ0FBQztJQUNMO0lBQ0FvUSxTQUFTNWxCLFdBQVcsR0FBR3ZCO0lBQ3ZCLE9BQU9tbkI7QUFDWCxFQUFFaCtELCtDQUFTQTtBQUNYLFNBQVN5K0QsY0FBYzF3RCxJQUFJLEVBQUU7SUFDekIsSUFBSXVGLFFBQVE5SCxXQUFXdUM7SUFDdkIsSUFBSXdGLE1BQU0zSSxRQUFRMEksT0FBTztJQUN6QixPQUFPO1FBQUVBLE9BQU9BO1FBQU9DLEtBQUtBO0lBQUk7QUFDcEM7QUFFQSxJQUFJbXJELFlBQVksV0FBVyxHQUFJLFNBQVVscUIsTUFBTSxFQUFFO0lBQzdDMTBDLGdEQUFTQSxDQUFDNCtELFdBQVdscUI7SUFDckIsU0FBU2txQixZQUFZO1FBQ2pCLElBQUl0bUQsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNdW1ELHdCQUF3QixHQUFHaG5ELFFBQVFnbkQ7UUFDekMsT0FBT3ZtRDtJQUNYO0lBQ0FzbUQsVUFBVWwrRCxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDckMsSUFBSS84QyxVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUMxQixJQUFJZ0UsS0FBSyxJQUFJLENBQUNULEtBQUssRUFBRSs2RCxRQUFRdDZELEdBQUdzNkQsS0FBSyxFQUFFN2pDLGNBQWN6MkIsR0FBR3kyQixXQUFXLEVBQUVraUMsdUJBQXVCMzRELEdBQUcyNEQsb0JBQW9CLEVBQUU0QixjQUFjdjZELEdBQUd1NkQsV0FBVztRQUNqSixJQUFJdCtDLGtCQUFrQixJQUFJLENBQUNvK0Msd0JBQXdCLENBQUNyK0QsUUFBUXFTLE9BQU8sQ0FBQzROLGVBQWUsRUFBRTA4QyxzQkFBc0IyQixNQUFNMzdELE1BQU07UUFDdkgsT0FBUS9DLHVEQUFhQSxDQUFDODlELFVBQVU7WUFBRS9wRCxNQUFNO1FBQU0sR0FBRyxTQUFVc2lCLE9BQU8sRUFBRUQsVUFBVSxFQUFFO1lBQUUsT0FBUXAyQix1REFBYUEsQ0FBQyxNQUFNO2dCQUFFdTlELE1BQU07WUFBTSxHQUN4SG9CLGVBQWVBLFlBQVksUUFDM0JELE1BQU0vcUQsR0FBRyxDQUFDLFNBQVU5RixJQUFJLEVBQUU7Z0JBQUUsT0FBUWt2RCx1QkFBd0IvOEQsdURBQWFBLENBQUNrOUQsZUFBZTtvQkFBRTMyRCxLQUFLc0gsS0FBSzRJLFdBQVc7b0JBQUk1SSxNQUFNQTtvQkFBTWd0QixhQUFhQTtvQkFBYXpFLFlBQVlBO29CQUFZaW5DLFFBQVFxQixNQUFNMzdELE1BQU07b0JBQUVzZCxpQkFBaUJBO2dCQUFnQixLQUFPcmdCLHVEQUFhQSxDQUFDNDlELGNBQWM7b0JBQUVyM0QsS0FBS3NILEtBQUtGLFNBQVM7b0JBQUlkLEtBQUtnQixLQUFLRixTQUFTO29CQUFJMFMsaUJBQWlCQTtnQkFBZ0IsRUFBRztZQUFHO1FBQU07SUFDalg7SUFDQSxPQUFPbStDO0FBQ1gsRUFBRXJtQjtBQUNGLFNBQVNzbUIseUJBQXlCRyxjQUFjLEVBQUU3QixvQkFBb0IsRUFBRThCLE9BQU8sRUFBRTtJQUM3RSxPQUFPRCxrQkFBa0I5Qiw0QkFBNEJDLHNCQUFzQjhCO0FBQy9FO0FBRUEsSUFBSUMsaUJBQWlCLFdBQVcsR0FBSSxXQUFZO0lBQzVDLFNBQVNBLGVBQWVod0QsS0FBSyxFQUFFaW9DLG9CQUFvQixFQUFFO1FBQ2pELElBQUlscEMsT0FBT2lCLE1BQU1zRSxLQUFLO1FBQ3RCLElBQUlDLE1BQU12RSxNQUFNdUUsR0FBRztRQUNuQixJQUFJMHJELFVBQVUsRUFBRTtRQUNoQixJQUFJTCxRQUFRLEVBQUU7UUFDZCxJQUFJTSxXQUFXLENBQUM7UUFDaEIsTUFBT254RCxPQUFPd0YsSUFBSztZQUNmLElBQUkwakMscUJBQXFCbU0sV0FBVyxDQUFDcjFDLE9BQU87Z0JBQ3hDa3hELFFBQVE3N0QsSUFBSSxDQUFDODdELFdBQVcsTUFBTSxpQ0FBaUM7WUFDbkUsT0FDSztnQkFDREEsWUFBWTtnQkFDWkQsUUFBUTc3RCxJQUFJLENBQUM4N0Q7Z0JBQ2JOLE1BQU14N0QsSUFBSSxDQUFDMks7WUFDZixDQUFDO1lBQ0RBLE9BQU9uRCxRQUFRbUQsTUFBTTtRQUN6QjtRQUNBLElBQUksQ0FBQzZ3RCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDSyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxHQUFHLEdBQUdQLE1BQU0zN0QsTUFBTTtJQUMzQjtJQUNBKzdELGVBQWV4K0QsU0FBUyxDQUFDNCtELFVBQVUsR0FBRyxTQUFVcHdELEtBQUssRUFBRTtRQUNuRCxJQUFJcXdELGFBQWEsSUFBSSxDQUFDQyxlQUFlLENBQUN0d0QsTUFBTXNFLEtBQUssR0FBRyx3QkFBd0I7UUFDNUUsSUFBSWlzRCxZQUFZLElBQUksQ0FBQ0QsZUFBZSxDQUFDMTBELFFBQVFvRSxNQUFNdUUsR0FBRyxFQUFFLENBQUMsS0FBSyx1QkFBdUI7UUFDckYsSUFBSWlzRCxvQkFBb0IzekQsS0FBS3dPLEdBQUcsQ0FBQyxHQUFHZ2xEO1FBQ3BDLElBQUlJLG1CQUFtQjV6RCxLQUFLd0IsR0FBRyxDQUFDLElBQUksQ0FBQzh4RCxHQUFHLEdBQUcsR0FBR0k7UUFDOUMsK0JBQStCO1FBQy9CQyxvQkFBb0IzekQsS0FBSzZ6RCxJQUFJLENBQUNGLG9CQUFvQix1Q0FBdUM7UUFDekZDLG1CQUFtQjV6RCxLQUFLNkIsS0FBSyxDQUFDK3hELG1CQUFtQixxQ0FBcUM7UUFDdEYsSUFBSUQscUJBQXFCQyxrQkFBa0I7WUFDdkMsT0FBTztnQkFDSEosWUFBWUc7Z0JBQ1pELFdBQVdFO2dCQUNYOXJDLFNBQVMwckMsZUFBZUc7Z0JBQ3hCNXJDLE9BQU8yckMsY0FBY0U7WUFDekI7UUFDSixDQUFDO1FBQ0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQSxxRkFBcUY7SUFDckYsMEdBQTBHO0lBQzFHLHlEQUF5RDtJQUN6RCx5RUFBeUU7SUFDekUsMEZBQTBGO0lBQzFGVCxlQUFleCtELFNBQVMsQ0FBQzgrRCxlQUFlLEdBQUcsU0FBVXZ4RCxJQUFJLEVBQUU7UUFDdkQsSUFBSWt4RCxVQUFVLElBQUksQ0FBQ0EsT0FBTztRQUMxQixJQUFJVSxZQUFZOXpELEtBQUs2QixLQUFLLENBQUN6QyxTQUFTLElBQUksQ0FBQzJ6RCxLQUFLLENBQUMsRUFBRSxFQUFFN3dEO1FBQ25ELElBQUk0eEQsWUFBWSxHQUFHO1lBQ2YsT0FBT1YsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN4QixDQUFDO1FBQ0QsSUFBSVUsYUFBYVYsUUFBUWg4RCxNQUFNLEVBQUU7WUFDN0IsT0FBT2c4RCxPQUFPLENBQUNBLFFBQVFoOEQsTUFBTSxHQUFHLEVBQUUsR0FBRztRQUN6QyxDQUFDO1FBQ0QsT0FBT2c4RCxPQUFPLENBQUNVLFVBQVU7SUFDN0I7SUFDQSxPQUFPWDtBQUNYO0FBRUEsSUFBSVksZ0JBQWdCLFdBQVcsR0FBSSxXQUFZO0lBQzNDLFNBQVNBLGNBQWNDLFNBQVMsRUFBRUMsWUFBWSxFQUFFO1FBQzVDLElBQUlsQixRQUFRaUIsVUFBVWpCLEtBQUs7UUFDM0IsSUFBSW1CO1FBQ0osSUFBSW40QztRQUNKLElBQUlvNEM7UUFDSixJQUFJRixjQUFjO1lBQ2QsOENBQThDO1lBQzlDbDRDLFdBQVdnM0MsS0FBSyxDQUFDLEVBQUUsQ0FBQy93RCxTQUFTO1lBQzdCLElBQUtreUQsYUFBYSxHQUFHQSxhQUFhbkIsTUFBTTM3RCxNQUFNLEVBQUU4OEQsY0FBYyxFQUFHO2dCQUM3RCxJQUFJbkIsS0FBSyxDQUFDbUIsV0FBVyxDQUFDbHlELFNBQVMsT0FBTytaLFVBQVU7b0JBQzVDLEtBQU07Z0JBQ1YsQ0FBQztZQUNMO1lBQ0FvNEMsU0FBU24wRCxLQUFLNnpELElBQUksQ0FBQ2QsTUFBTTM3RCxNQUFNLEdBQUc4OEQ7UUFDdEMsT0FDSztZQUNEQyxTQUFTO1lBQ1RELGFBQWFuQixNQUFNMzdELE1BQU07UUFDN0IsQ0FBQztRQUNELElBQUksQ0FBQys4RCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDekMsTUFBTSxHQUFHd0M7UUFDZCxJQUFJLENBQUNGLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxVQUFVO1FBQzVCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUksQ0FBQ0MsZ0JBQWdCO0lBQzVDO0lBQ0FSLGNBQWNwL0QsU0FBUyxDQUFDMC9ELFVBQVUsR0FBRyxXQUFZO1FBQzdDLElBQUlHLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSUMsTUFBTSxHQUFHQSxNQUFNLElBQUksQ0FBQ04sTUFBTSxFQUFFTSxPQUFPLEVBQUc7WUFDM0MsSUFBSUwsUUFBUSxFQUFFO1lBQ2QsSUFBSyxJQUFJTSxNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDaEQsTUFBTSxFQUFFZ0QsT0FBTyxFQUFHO2dCQUMzQ04sTUFBTTc4RCxJQUFJLENBQUMsSUFBSSxDQUFDbzlELFNBQVMsQ0FBQ0YsS0FBS0M7WUFDbkM7WUFDQUYsS0FBS2o5RCxJQUFJLENBQUM2OEQ7UUFDZDtRQUNBLE9BQU9JO0lBQ1g7SUFDQVQsY0FBY3AvRCxTQUFTLENBQUNnZ0UsU0FBUyxHQUFHLFNBQVVGLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQ3BELElBQUl4eUQsT0FBTyxJQUFJLENBQUM4eEQsU0FBUyxDQUFDakIsS0FBSyxDQUFDMEIsTUFBTSxJQUFJLENBQUMvQyxNQUFNLEdBQUdnRCxJQUFJO1FBQ3hELE9BQU87WUFDSDk1RCxLQUFLc0gsS0FBSzRJLFdBQVc7WUFDckI1SSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTZ4RCxjQUFjcC9ELFNBQVMsQ0FBQzQvRCxnQkFBZ0IsR0FBRyxXQUFZO1FBQ25ELElBQUl4QixRQUFRLEVBQUU7UUFDZCxJQUFLLElBQUkyQixNQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFDaEQsTUFBTSxFQUFFZ0QsT0FBTyxFQUFHO1lBQzNDM0IsTUFBTXg3RCxJQUFJLENBQUMsSUFBSSxDQUFDNjhELEtBQUssQ0FBQyxFQUFFLENBQUNNLElBQUksQ0FBQ3h5RCxJQUFJO1FBQ3RDO1FBQ0EsT0FBTzZ3RDtJQUNYO0lBQ0FnQixjQUFjcC9ELFNBQVMsQ0FBQzQrRCxVQUFVLEdBQUcsU0FBVXB3RCxLQUFLLEVBQUU7UUFDbEQsSUFBSXV1RCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixJQUFJa0QsWUFBWSxJQUFJLENBQUNaLFNBQVMsQ0FBQ1QsVUFBVSxDQUFDcHdEO1FBQzFDLElBQUkwbEIsT0FBTyxFQUFFO1FBQ2IsSUFBSStyQyxXQUFXO1lBQ1gsSUFBSXBCLGFBQWFvQixVQUFVcEIsVUFBVSxFQUFFRSxZQUFZa0IsVUFBVWxCLFNBQVM7WUFDdEUsSUFBSTcxRCxRQUFRMjFEO1lBQ1osTUFBTzMxRCxTQUFTNjFELFVBQVc7Z0JBQ3ZCLElBQUllLE1BQU16MEQsS0FBSzZCLEtBQUssQ0FBQ2hFLFFBQVE2ekQ7Z0JBQzdCLElBQUltRCxZQUFZNzBELEtBQUt3QixHQUFHLENBQUMsQ0FBQ2l6RCxNQUFNLEtBQUsvQyxRQUFRZ0MsWUFBWTtnQkFDekQ3cUMsS0FBS3R4QixJQUFJLENBQUM7b0JBQ05rOUQsS0FBS0E7b0JBQ0xLLFVBQVVqM0QsUUFBUTZ6RDtvQkFDbEJxRCxTQUFTLENBQUNGLFlBQVksS0FBS25EO29CQUMzQjVwQyxTQUFTOHNDLFVBQVU5c0MsT0FBTyxJQUFJanFCLFVBQVUyMUQ7b0JBQ3hDenJDLE9BQU82c0MsVUFBVTdzQyxLQUFLLElBQUksWUFBYSxNQUFPMnJDO2dCQUNsRDtnQkFDQTcxRCxRQUFRZzNEO1lBQ1o7UUFDSixDQUFDO1FBQ0QsT0FBT2hzQztJQUNYO0lBQ0EsT0FBT2tyQztBQUNYO0FBRUEsSUFBSWlCLFNBQVMsV0FBVyxHQUFJLFdBQVk7SUFDcEMsU0FBU0EsU0FBUztRQUNkLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUducEQsUUFBUSxJQUFJLENBQUNvcEQsbUJBQW1CO1FBQzFELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdycEQsUUFBUSxJQUFJLENBQUNzcEQsY0FBYztRQUNyRCxJQUFJLENBQUNsdUMsZUFBZSxHQUFHcGIsUUFBUSxJQUFJLENBQUN1cEQsZ0JBQWdCO1FBQ3BELElBQUksQ0FBQ0MsY0FBYyxHQUFHeHBELFFBQVEsSUFBSSxDQUFDeXBELGlCQUFpQjtRQUNwRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHMXBELFFBQVEsSUFBSSxDQUFDeXBELGlCQUFpQjtRQUN0RCxJQUFJLENBQUNFLGtCQUFrQixHQUFHLEtBQUssRUFBRSxPQUFPO0lBQzVDO0lBQ0FULE9BQU9yZ0UsU0FBUyxDQUFDK2dFLFVBQVUsR0FBRyxTQUFVMTlELEtBQUssRUFBRWszQixXQUFXLEVBQUV2YixnQkFBZ0IsRUFBRWxmLE9BQU8sRUFBRTtRQUNuRixJQUFJa2hFLFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlweEQsS0FBSyxHQUFHQSxLQUFLOEgsVUFBVWpWLE1BQU0sRUFBRW1OLEtBQU07WUFDMUNveEQsU0FBUyxDQUFDcHhELEtBQUssRUFBRSxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUNyQztRQUNBLElBQUk0aUIsZUFBZW52QixNQUFNbXZCLFlBQVk7UUFDckMsSUFBSXl1QyxZQUFZLElBQUksQ0FBQzF1QyxlQUFlLENBQUN6cEIsS0FBSyxDQUFDLElBQUksRUFBRXpKLG9EQUFhQSxDQUFDO1lBQUNnRSxNQUFNMk8sVUFBVTtZQUFFd2dCO1lBQWMrSDtZQUFhdmI7U0FBaUIsRUFBRWdpRDtRQUNoSSxPQUFPO1lBQ0hFLG1CQUFtQixJQUFJLENBQUNWLGtCQUFrQixDQUFDMTNELEtBQUssQ0FBQyxJQUFJLEVBQUV6SixvREFBYUEsQ0FBQztnQkFBQ2dFLE1BQU04N0IsYUFBYTtnQkFBRTNNO2dCQUFjMXlCO2FBQVEsRUFBRWtoRTtZQUNuSEcsa0JBQWtCLElBQUksQ0FBQ2Isa0JBQWtCLENBQUN4M0QsS0FBSyxDQUFDLElBQUksRUFBRXpKLG9EQUFhQSxDQUFDO2dCQUFDZ0UsTUFBTWdnQixhQUFhO2dCQUFFa1g7Z0JBQWF2YjtnQkFBa0JsZjthQUFRLEVBQUVraEU7WUFDbklJLGFBQWFILFVBQVV4dEMsRUFBRTtZQUN6QjR0QyxhQUFhSixVQUFVenRDLEVBQUU7WUFDekI0VyxXQUFXLElBQUksQ0FBQ3UyQixjQUFjLENBQUM3M0QsS0FBSyxDQUFDLElBQUksRUFBRXpKLG9EQUFhQSxDQUFDO2dCQUFDZ0UsTUFBTSttQyxTQUFTO2dCQUFFNVg7Z0JBQWMrSDtnQkFBYXZiO2FBQWlCLEVBQUVnaUQ7WUFDekgxMkIsYUFBYSxJQUFJLENBQUN1MkIsZ0JBQWdCLENBQUMvM0QsS0FBSyxDQUFDLElBQUksRUFBRXpKLG9EQUFhQSxDQUFDO2dCQUFDZ0UsTUFBTWluQyxXQUFXO2dCQUFFOVg7Z0JBQWMrSDtnQkFBYXZiO2FBQWlCLEVBQUVnaUQ7WUFDL0hyMkIsZ0JBQWdCdG5DLE1BQU1zbkMsY0FBYztRQUN4QyxHQUFHLDhCQUE4QjtJQUNyQztJQUNBMDFCLE9BQU9yZ0UsU0FBUyxDQUFDc2hFLFlBQVksR0FBRyxTQUNoQy96RCxJQUFJLEVBQUV6TixPQUFPLEVBQUU7UUFDWCxJQUFJa2hFLFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlweEQsS0FBSyxHQUFHQSxLQUFLOEgsVUFBVWpWLE1BQU0sRUFBRW1OLEtBQU07WUFDMUNveEQsU0FBUyxDQUFDcHhELEtBQUssRUFBRSxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUNyQztRQUNBLE9BQU8sSUFBSSxDQUFDNndELGNBQWMsQ0FBQzMzRCxLQUFLLENBQUMsSUFBSSxFQUFFekosb0RBQWFBLENBQUM7WUFBQztnQkFBRW1QLE9BQU87b0JBQUVzRSxPQUFPdkY7b0JBQU13RixLQUFLMUksTUFBTWtELE1BQU07Z0JBQUc7Z0JBQUdtRSxRQUFRLEtBQUs7WUFBQztZQUMvRyxDQUFDO1lBQ0Q1UjtTQUFRLEVBQUVraEU7SUFDbEI7SUFDQVgsT0FBT3JnRSxTQUFTLENBQUN1Z0UsbUJBQW1CLEdBQUcsU0FBVWw5QyxhQUFhLEVBQUVrWCxXQUFXLEVBQUV2YixnQkFBZ0IsRUFBRWxmLE9BQU8sRUFBRTtRQUNwRyxJQUFJa2hFLFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlweEQsS0FBSyxHQUFHQSxLQUFLOEgsVUFBVWpWLE1BQU0sRUFBRW1OLEtBQU07WUFDMUNveEQsU0FBUyxDQUFDcHhELEtBQUssRUFBRSxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUNyQztRQUNBLElBQUksQ0FBQ3lULGVBQWU7WUFDaEIsT0FBTyxFQUFFO1FBQ2IsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDcTlDLGdCQUFnQixDQUFDNTNELEtBQUssQ0FBQyxJQUFJLEVBQUV6SixvREFBYUEsQ0FBQztZQUFDMFMsZ0JBQWdCc1IsZUFBZWsrQyxtQkFBbUJobkMsYUFBYXBiLFFBQVFILG9CQUFvQmxmO1lBQy9JLENBQUM7WUFDRHk2QjtZQUNBdmI7U0FBaUIsRUFBRWdpRCxZQUFZeHRDLEVBQUU7SUFDekM7SUFDQTZzQyxPQUFPcmdFLFNBQVMsQ0FBQzBnRSxnQkFBZ0IsR0FBRyxTQUFVMXVELFVBQVUsRUFBRXdnQixZQUFZLEVBQUUrSCxXQUFXLEVBQUV2YixnQkFBZ0IsRUFBRTtRQUNuRyxJQUFJZ2lELFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlweEQsS0FBSyxHQUFHQSxLQUFLOEgsVUFBVWpWLE1BQU0sRUFBRW1OLEtBQU07WUFDMUNveEQsU0FBUyxDQUFDcHhELEtBQUssRUFBRSxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUNyQztRQUNBLElBQUlvQyxZQUFZO1lBQ1osSUFBSXd2RCxXQUFXanZDLGdCQUFnQnZnQixZQUFZd2dCLGNBQWMrdUMsbUJBQW1CaG5DLGFBQWFwYixRQUFRSCxvQkFBb0JBO1lBQ3JILE9BQU87Z0JBQ0h3VSxJQUFJLElBQUksQ0FBQ2l1QyxnQkFBZ0IsQ0FBQ0QsU0FBU2h1QyxFQUFFLEVBQUV3dEM7Z0JBQ3ZDdnRDLElBQUksSUFBSSxDQUFDZ3VDLGdCQUFnQixDQUFDRCxTQUFTL3RDLEVBQUUsRUFBRXV0QztZQUMzQztRQUNKLENBQUM7UUFDRCxPQUFPO1lBQUV4dEMsSUFBSSxFQUFFO1lBQUVDLElBQUksRUFBRTtRQUFDO0lBQzVCO0lBQ0E0c0MsT0FBT3JnRSxTQUFTLENBQUM0Z0UsaUJBQWlCLEdBQUcsU0FBVXoxQixXQUFXLEVBQUUzWSxZQUFZLEVBQUUrSCxXQUFXLEVBQUV2YixnQkFBZ0IsRUFBRTtRQUNyRyxJQUFJZ2lELFlBQVksRUFBRTtRQUNsQixJQUFLLElBQUlweEQsS0FBSyxHQUFHQSxLQUFLOEgsVUFBVWpWLE1BQU0sRUFBRW1OLEtBQU07WUFDMUNveEQsU0FBUyxDQUFDcHhELEtBQUssRUFBRSxHQUFHOEgsU0FBUyxDQUFDOUgsR0FBRztRQUNyQztRQUNBLElBQUksQ0FBQ3U3QixhQUFhO1lBQ2QsT0FBTyxJQUFJO1FBQ2YsQ0FBQztRQUNELElBQUlxMkIsV0FBV2p2QyxnQkFBZ0I0WSxZQUFZSyxhQUFhLEVBQUVoWixjQUFjK3VDLG1CQUFtQmhuQyxhQUFhcGIsUUFBUUgsb0JBQW9CQTtRQUNwSSxPQUFPO1lBQ0hrVixNQUFNLElBQUksQ0FBQ3V0QyxnQkFBZ0IsQ0FBQ0QsU0FBUy90QyxFQUFFLEVBQUV1dEM7WUFDekNVLG1CQUFtQnYyQixZQUFZRyxjQUFjLENBQUNqNUIsU0FBUztZQUN2RHM1QixTQUFTUixZQUFZUSxPQUFPO1FBQ2hDO0lBQ0o7SUFDQTAwQixPQUFPcmdFLFNBQVMsQ0FBQ3lnRSxjQUFjLEdBQUcsU0FBVS9uQyxRQUFRLEVBQUVsRyxZQUFZLEVBQUUxeUIsT0FBTyxFQUFFO1FBQ3pFLElBQUlraEUsWUFBWSxFQUFFO1FBQ2xCLElBQUssSUFBSXB4RCxLQUFLLEdBQUdBLEtBQUs4SCxVQUFValYsTUFBTSxFQUFFbU4sS0FBTTtZQUMxQ294RCxTQUFTLENBQUNweEQsS0FBSyxFQUFFLEdBQUc4SCxTQUFTLENBQUM5SCxHQUFHO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDOG9CLFVBQVU7WUFDWCxPQUFPLEVBQUU7UUFDYixDQUFDO1FBQ0QsSUFBSWxFLGFBQWFpRSxvQkFBb0JDLFVBQVVsRyxjQUFjMXlCO1FBQzdELElBQUlvMEIsT0FBTyxJQUFJLENBQUMwcUMsVUFBVSxDQUFDOTFELEtBQUssQ0FBQyxJQUFJLEVBQUV6SixvREFBYUEsQ0FBQztZQUFDcTVCLFNBQVNscUIsS0FBSztTQUFDLEVBQUV3eUQ7UUFDdkUsSUFBSyxJQUFJbDlELEtBQUssR0FBRzY5RCxTQUFTenRDLE1BQU1wd0IsS0FBSzY5RCxPQUFPbC9ELE1BQU0sRUFBRXFCLEtBQU07WUFDdEQsSUFBSTh2QixNQUFNK3RDLE1BQU0sQ0FBQzc5RCxHQUFHO1lBQ3BCOHZCLElBQUlZLFVBQVUsR0FBR0E7UUFDckI7UUFDQSxPQUFPTjtJQUNYO0lBQ0E7O0lBRUEsR0FDQW1zQyxPQUFPcmdFLFNBQVMsQ0FBQ3loRSxnQkFBZ0IsR0FBRyxTQUFVRyxXQUFXLEVBQUVaLFNBQVMsRUFBRTtRQUNsRSxJQUFJOXNDLE9BQU8sRUFBRTtRQUNiLElBQUssSUFBSXRrQixLQUFLLEdBQUdpeUQsZ0JBQWdCRCxhQUFhaHlELEtBQUtpeUQsY0FBY3AvRCxNQUFNLEVBQUVtTixLQUFNO1lBQzNFLElBQUk0a0IsYUFBYXF0QyxhQUFhLENBQUNqeUQsR0FBRztZQUNsQ3NrQixLQUFLdHhCLElBQUksQ0FBQ2tHLEtBQUssQ0FBQ29yQixNQUFNLElBQUksQ0FBQzR0QyxlQUFlLENBQUN0dEMsWUFBWXdzQztRQUMzRDtRQUNBLE9BQU85c0M7SUFDWDtJQUNBOztJQUVBLEdBQ0Ftc0MsT0FBT3JnRSxTQUFTLENBQUM4aEUsZUFBZSxHQUFHLFNBQVV0dEMsVUFBVSxFQUFFd3NDLFNBQVMsRUFBRTtRQUNoRSxJQUFJdnZDLFlBQVkrQyxXQUFXaG1CLEtBQUs7UUFDaEMscUdBQXFHO1FBQ3JHLElBQUksSUFBSSxDQUFDc3lELGtCQUFrQixJQUFJdHNDLFdBQVcvRSxFQUFFLENBQUNqVCxPQUFPLEtBQUssYUFBYTtZQUNsRWlWLFlBQVk7Z0JBQ1IzZSxPQUFPMmUsVUFBVTNlLEtBQUs7Z0JBQ3RCQyxLQUFLM0ksUUFBUXFuQixVQUFVM2UsS0FBSyxFQUFFO1lBQ2xDO1FBQ0osQ0FBQztRQUNELElBQUlvaEIsT0FBTyxJQUFJLENBQUMwcUMsVUFBVSxDQUFDOTFELEtBQUssQ0FBQyxJQUFJLEVBQUV6SixvREFBYUEsQ0FBQztZQUFDb3lCO1NBQVUsRUFBRXV2QztRQUNsRSxJQUFLLElBQUlweEQsS0FBSyxHQUFHbXlELFNBQVM3dEMsTUFBTXRrQixLQUFLbXlELE9BQU90L0QsTUFBTSxFQUFFbU4sS0FBTTtZQUN0RCxJQUFJZ2tCLE1BQU1tdUMsTUFBTSxDQUFDbnlELEdBQUc7WUFDcEJna0IsSUFBSVksVUFBVSxHQUFHQTtZQUNqQlosSUFBSVQsT0FBTyxHQUFHcUIsV0FBV3JCLE9BQU8sSUFBSVMsSUFBSVQsT0FBTztZQUMvQ1MsSUFBSVIsS0FBSyxHQUFHb0IsV0FBV3BCLEtBQUssSUFBSVEsSUFBSVIsS0FBSztRQUM3QztRQUNBLE9BQU9jO0lBQ1g7SUFDQSxPQUFPbXNDO0FBQ1g7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU2tCLG1CQUFtQmhuQyxXQUFXLEVBQUV5bkMsaUJBQWlCLEVBQUU7SUFDeEQsSUFBSXh6RCxRQUFRK3JCLFlBQVlDLFdBQVc7SUFDbkMsSUFBSXduQyxtQkFBbUI7UUFDbkIsT0FBT3h6RDtJQUNYLENBQUM7SUFDRCxPQUFPO1FBQ0hzRSxPQUFPekksTUFBTW1FLE1BQU1zRSxLQUFLLEVBQUV5bkIsWUFBWW5iLFdBQVcsQ0FBQzdULFlBQVk7UUFDOUR3SCxLQUFLMUksTUFBTW1FLE1BQU11RSxHQUFHLEVBQUV3bkIsWUFBWWxiLFdBQVcsQ0FBQzlULFlBQVksR0FBRztJQUNqRTtBQUNKO0FBRUEsK0NBQStDO0FBQy9DLDJIQUEySDtBQUMzSCxTQUFTMDJELG1CQUFtQjkyQixXQUFXLEVBQUU1USxXQUFXLEVBQUV6NkIsT0FBTyxFQUFFO0lBQzNELElBQUl1UyxZQUFZODRCLFlBQVlLLGFBQWEsQ0FBQ241QixTQUFTO0lBQ25ELElBQUssSUFBSTFELGNBQWMwRCxVQUFXO1FBQzlCLElBQUksQ0FBQzZmLG1CQUFtQnFJLFlBQVk1UyxVQUFVLEVBQUV0VixTQUFTLENBQUMxRCxXQUFXLENBQUNILEtBQUssR0FBRztZQUMxRSxPQUFPLEtBQUs7UUFDaEIsQ0FBQztJQUNMO0lBQ0EsT0FBTzB6RCxnQkFBZ0I7UUFBRTkzQixXQUFXZTtJQUFZLEdBQUdyckMsVUFBVSx5REFBeUQ7QUFDMUg7QUFDQSxTQUFTcWlFLHFCQUFxQmhqQyxhQUFhLEVBQUU1RSxXQUFXLEVBQUV6NkIsT0FBTyxFQUFFO0lBQy9ELElBQUksQ0FBQ295QixtQkFBbUJxSSxZQUFZNVMsVUFBVSxFQUFFd1gsY0FBYzN3QixLQUFLLEdBQUc7UUFDbEUsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxPQUFPMHpELGdCQUFnQjtRQUFFL2lDLGVBQWVBO0lBQWMsR0FBR3IvQjtBQUM3RDtBQUNBLFNBQVNvaUUsZ0JBQWdCMXhELFFBQVEsRUFBRTFRLE9BQU8sRUFBRTtJQUN4QyxJQUFJc2lFLGdCQUFnQnRpRSxRQUFRdTZCLGNBQWM7SUFDMUMsSUFBSWgzQixRQUFRakUsK0NBQVFBLENBQUM7UUFBRWlrQixlQUFlKytDLGNBQWMvK0MsYUFBYTtRQUFFOGIsZUFBZTtRQUFJbnRCLFlBQVlvd0QsY0FBY3B3RCxVQUFVO1FBQUV3Z0IsY0FBYzR2QyxjQUFjNXZDLFlBQVk7UUFBRW1ZLGdCQUFnQjtRQUFJUCxXQUFXLElBQUk7UUFBRUUsYUFBYSxJQUFJO0lBQUMsR0FBRzk1QjtJQUNoTyxPQUFPLENBQUMxUSxRQUFRb1MsV0FBVyxDQUFDbW5DLFlBQVksSUFBSUEsWUFBVyxFQUFHaDJDLE9BQU92RDtBQUNyRTtBQUNBLFNBQVN1NUMsYUFBYTdiLEtBQUssRUFBRTE5QixPQUFPLEVBQUV1aUUsWUFBWSxFQUFFQyxZQUFZLEVBQUU7SUFDOUQsSUFBSUQsaUJBQWlCLEtBQUssR0FBRztRQUFFQSxlQUFlLENBQUM7SUFBRyxDQUFDO0lBQ25ELElBQUk3a0MsTUFBTTRNLFNBQVMsSUFBSSxDQUFDbTRCLHdCQUF3Qi9rQyxPQUFPMTlCLFNBQVN1aUUsY0FBY0MsZUFBZTtRQUN6RixPQUFPLEtBQUs7SUFDaEIsQ0FBQztJQUNELElBQUk5a0MsTUFBTTJCLGFBQWEsSUFBSSxDQUFDcWpDLDBCQUEwQmhsQyxPQUFPMTlCLFNBQVN1aUUsY0FBY0MsZUFBZTtRQUMvRixPQUFPLEtBQUs7SUFDaEIsQ0FBQztJQUNELE9BQU8sSUFBSTtBQUNmO0FBQ0EsMEJBQTBCO0FBQzFCLDJIQUEySDtBQUMzSCxTQUFTQyx3QkFBd0Iva0MsS0FBSyxFQUFFMTlCLE9BQU8sRUFBRXVpRSxZQUFZLEVBQUVDLFlBQVksRUFBRTtJQUN6RSxJQUFJMUUsZUFBZTk5RCxRQUFRdTZCLGNBQWM7SUFDekMsSUFBSThRLGNBQWMzTixNQUFNNE0sU0FBUyxFQUFFLHlEQUF5RDtJQUM1RixJQUFJcTRCLG9CQUFvQnQzQixZQUFZSyxhQUFhO0lBQ2pELElBQUlrM0IsY0FBY0Qsa0JBQWtCcndELElBQUk7SUFDeEMsSUFBSXV3RCxtQkFBbUJGLGtCQUFrQnB3RCxTQUFTO0lBQ2xELElBQUl1d0QsaUJBQWlCN3ZDLGdCQUFnQjJ2QyxhQUFhdjNCLFlBQVlRLE9BQU8sR0FDakVuTyxNQUFNaEwsWUFBWSxHQUNsQjtRQUFFLElBQUlvckMsYUFBYXZOLGVBQWU7SUFBQyxDQUFDO0lBQ3hDLElBQUlpUyxjQUFjO1FBQ2RNLGlCQUFpQm56RCxRQUFRbXpELGdCQUFnQk47SUFDN0MsQ0FBQztJQUNELHNEQUFzRDtJQUN0RCxJQUFJTyxrQkFBa0J0YyxpQkFBaUIvb0IsTUFBTXhyQixVQUFVLEVBQUVtNUIsWUFBWUcsY0FBYyxDQUFDajVCLFNBQVM7SUFDN0YsSUFBSXl3RCxZQUFZRCxnQkFBZ0J6d0QsSUFBSTtJQUNwQyxJQUFJMndELGlCQUFpQkYsZ0JBQWdCeHdELFNBQVM7SUFDOUMsSUFBSTJ3RCxlQUFlandDLGdCQUFnQit2QyxXQUFXdGxDLE1BQU1oTCxZQUFZO0lBQ2hFLElBQUssSUFBSXl3QyxxQkFBcUJOLGlCQUFrQjtRQUM1QyxJQUFJTyxrQkFBa0JQLGdCQUFnQixDQUFDTSxrQkFBa0I7UUFDekQsSUFBSUUsZUFBZUQsZ0JBQWdCMTBELEtBQUs7UUFDeEMsSUFBSTQwRCxnQkFBZ0JSLGNBQWMsQ0FBQ00sZ0JBQWdCMzBELEtBQUssQ0FBQztRQUN6RCxJQUFJODBELGFBQWFYLFdBQVcsQ0FBQ1EsZ0JBQWdCMzBELEtBQUssQ0FBQztRQUNuRCxhQUFhO1FBQ2IsSUFBSSxDQUFDKzBELG1CQUFtQkYsY0FBY2oxQyxXQUFXLEVBQUVnMUMsY0FBY04saUJBQWlCcmxDLE1BQU1uYSxhQUFhLEVBQUV2akIsVUFBVTtZQUM3RyxPQUFPLEtBQUs7UUFDaEIsQ0FBQztRQUNELFVBQVU7UUFDVixJQUFJbWtCLGVBQWVua0IsUUFBUXFTLE9BQU8sQ0FBQzhSLFlBQVk7UUFDL0MsSUFBSXMvQyxtQkFBbUIsT0FBT3QvQyxpQkFBaUIsYUFBYUEsZUFBZSxJQUFJO1FBQy9FLElBQUssSUFBSXUvQyxtQkFBbUJULGVBQWdCO1lBQ3hDLElBQUlVLGdCQUFnQlYsY0FBYyxDQUFDUyxnQkFBZ0I7WUFDbkQsc0JBQXNCO1lBQ3RCLElBQUl2eEMsZ0JBQWdCa3hDLGNBQWNNLGNBQWNqMUQsS0FBSyxHQUFHO2dCQUNwRCxJQUFJazFELGVBQWVWLFlBQVksQ0FBQ1MsY0FBY2wxRCxLQUFLLENBQUMsQ0FBQ29mLE9BQU87Z0JBQzVELDBGQUEwRjtnQkFDMUYsSUFBSSsxQyxpQkFBaUIsS0FBSyxJQUFJdjRCLFlBQVlRLE9BQU8sRUFBRTtvQkFDL0MsT0FBTyxLQUFLO2dCQUNoQixDQUFDO2dCQUNELElBQUl5M0IsY0FBY3oxQyxPQUFPLEtBQUssS0FBSyxFQUFFO29CQUNqQyxPQUFPLEtBQUs7Z0JBQ2hCLENBQUM7Z0JBQ0QsSUFBSTQxQyxvQkFBb0IsQ0FBQ0EsaUJBQWlCLElBQUlwc0MsU0FBU3IzQixTQUFTZ2pFLFNBQVMsQ0FBQ1csY0FBY2wxRCxLQUFLLENBQUMsRUFBRWsxRCxnQkFDaEcsSUFBSXRzQyxTQUFTcjNCLFNBQVN1akUsWUFBWUgsbUJBQW1CO29CQUNqRCxPQUFPLEtBQUs7Z0JBQ2hCLENBQUM7WUFDTCxDQUFDO1FBQ0w7UUFDQSxxQkFBcUI7UUFDckIsSUFBSVMscUJBQXFCL0YsYUFBYTVyRCxVQUFVLEVBQUUsb0VBQW9FO1FBQ3RILElBQUssSUFBSXBDLEtBQUssR0FBRzlMLEtBQUtzL0QsY0FBY2gxQyxNQUFNLEVBQUV4ZSxLQUFLOUwsR0FBR3JCLE1BQU0sRUFBRW1OLEtBQU07WUFDOUQsSUFBSWcwRCxlQUFlOS9ELEVBQUUsQ0FBQzhMLEdBQUc7WUFDekIsSUFBSWkwRCxrQkFBa0J6a0UsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDLENBQUMsR0FBR2lqRSxlQUFlO2dCQUFFN3pELE9BQU8wMEQsZ0JBQWdCMTBELEtBQUs7Z0JBQUVrRCxRQUFRMnhELFdBQVczeEQsTUFBTTtZQUFDO1lBQ3JILElBQUlveUQsVUFBVUgsbUJBQW1CdnhELElBQUksQ0FBQ2l4RCxXQUFXOTBELEtBQUssQ0FBQztZQUN2RCxJQUFJdzFELGVBQWVKLG1CQUFtQnR4RCxTQUFTLENBQUM0d0Qsa0JBQWtCO1lBQ2xFLElBQUluakMsV0FBVyxLQUFLO1lBQ3BCLElBQUlna0MsU0FBUztnQkFDVGhrQyxXQUFXLElBQUkzSSxTQUFTcjNCLFNBQVNna0UsU0FBU0M7WUFDOUMsT0FDSztnQkFDRGprQyxXQUFXLElBQUkzSSxTQUFTcjNCLFNBQVN1akUsYUFBYSxvQ0FBb0M7WUFDdEYsQ0FBQztZQUNELElBQUksQ0FBQ08sYUFBYTlxQyw0QkFBNEIrcUMsaUJBQWlCL2pFLFVBQVVnZ0MsV0FBVztnQkFDaEYsT0FBTyxLQUFLO1lBQ2hCLENBQUM7UUFDTDtJQUNKO0lBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFDQSw0QkFBNEI7QUFDNUIsMkhBQTJIO0FBQzNILFNBQVMwaUMsMEJBQTBCaGxDLEtBQUssRUFBRTE5QixPQUFPLEVBQUV1aUUsWUFBWSxFQUFFQyxZQUFZLEVBQUU7SUFDM0UsSUFBSTBCLHFCQUFxQnhtQyxNQUFNeHJCLFVBQVU7SUFDekMsSUFBSWl5RCxlQUFlRCxtQkFBbUI1eEQsSUFBSTtJQUMxQyxJQUFJOHhELG9CQUFvQkYsbUJBQW1CM3hELFNBQVM7SUFDcEQsSUFBSXVtQixZQUFZNEUsTUFBTTJCLGFBQWE7SUFDbkMsSUFBSWdsQyxpQkFBaUJ2ckMsVUFBVXBxQixLQUFLO0lBQ3BDLElBQUk2aEQsa0JBQWtCdndELFFBQVF1NkIsY0FBYyxHQUFHZzJCLGVBQWU7SUFDOUQsSUFBSWlTLGNBQWM7UUFDZGpTLGtCQUFrQmlTLGFBQWFqUztJQUNuQyxDQUFDO0lBQ0QsYUFBYTtJQUNiLElBQUksQ0FBQ2lULG1CQUFtQmpULGdCQUFnQmxpQyxXQUFXLEVBQUVnMkMsZ0JBQWdCSCxvQkFBb0J4bUMsTUFBTW5hLGFBQWEsRUFBRXZqQixVQUFVO1FBQ3BILE9BQU8sS0FBSztJQUNoQixDQUFDO0lBQ0QsVUFBVTtJQUNWLElBQUkra0IsZ0JBQWdCL2tCLFFBQVFxUyxPQUFPLENBQUMwUyxhQUFhO0lBQ2pELElBQUl1L0Msb0JBQW9CLE9BQU92L0Msa0JBQWtCLGFBQWFBLGdCQUFnQixJQUFJO0lBQ2xGLElBQUssSUFBSXcvQyxzQkFBc0JILGtCQUFtQjtRQUM5QyxJQUFJSSxtQkFBbUJKLGlCQUFpQixDQUFDRyxtQkFBbUI7UUFDNUQsc0JBQXNCO1FBQ3RCLElBQUlweUMsZ0JBQWdCa3lDLGdCQUFnQkcsaUJBQWlCOTFELEtBQUssR0FBRztZQUN6RCxJQUFJNmhELGdCQUFnQjFpQyxPQUFPLEtBQUssS0FBSyxFQUFFO2dCQUNuQyxPQUFPLEtBQUs7WUFDaEIsQ0FBQztZQUNELElBQUl5MkMscUJBQXFCLENBQUNBLGtCQUFrQixJQUFJanRDLFNBQVNyM0IsU0FBU21rRSxZQUFZLENBQUNLLGlCQUFpQi8xRCxLQUFLLENBQUMsRUFBRSsxRCxtQkFBbUIsSUFBSSxHQUFHO2dCQUM5SCxPQUFPLEtBQUs7WUFDaEIsQ0FBQztRQUNMLENBQUM7SUFDTDtJQUNBLHFCQUFxQjtJQUNyQixJQUFLLElBQUkxMEQsS0FBSyxHQUFHOUwsS0FBS3VzRCxnQkFBZ0JqaUMsTUFBTSxFQUFFeGUsS0FBSzlMLEdBQUdyQixNQUFNLEVBQUVtTixLQUFNO1FBQ2hFLElBQUkyMEQsaUJBQWlCemdFLEVBQUUsQ0FBQzhMLEdBQUc7UUFDM0IsSUFBSTQwRCxlQUFlcGxFLCtDQUFRQSxDQUFDQSwrQ0FBUUEsQ0FBQyxDQUFDLEdBQUdpakUsZUFBZXpwQztRQUN4RCxJQUFJLENBQUMyckMsZUFBZXpyQyw0QkFBNEIwckMsY0FBYzFrRSxVQUFVLElBQUksR0FBRztZQUMzRSxPQUFPLEtBQUs7UUFDaEIsQ0FBQztJQUNMO0lBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFDQSxtQkFBbUI7QUFDbkIsMkhBQTJIO0FBQzNILFNBQVN3akUsbUJBQW1CbjFDLFdBQVcsRUFBRWcxQyxZQUFZLEVBQUVOLGVBQWUsRUFBRTRCLHVCQUF1QixFQUFFM2tFLE9BQU8sRUFBRTtJQUN0RyxJQUFLLElBQUk4UCxLQUFLLEdBQUc4MEQsZ0JBQWdCdjJDLGFBQWF2ZSxLQUFLODBELGNBQWNqaUUsTUFBTSxFQUFFbU4sS0FBTTtRQUMzRSxJQUFJOGQsYUFBYWczQyxhQUFhLENBQUM5MEQsR0FBRztRQUNsQyxJQUFJLENBQUMrMEQsc0JBQXNCQyxtQkFBbUJsM0MsWUFBWXkxQyxjQUFjTixpQkFBaUI0Qix5QkFBeUIza0UsVUFBVXFqRSxlQUFlO1lBQ3ZJLE9BQU8sS0FBSztRQUNoQixDQUFDO0lBQ0w7SUFDQSxPQUFPLElBQUk7QUFDZjtBQUNBLFNBQVN5QixtQkFBbUJsM0MsVUFBVSxFQUFFeTFDLFlBQVksRUFDcEROLGVBQWUsRUFDZjRCLHVCQUF1QixFQUN2QjNrRSxPQUFPLEVBQUU7SUFDTCxJQUFJNHRCLGVBQWUsaUJBQWlCO1FBQ2hDLE9BQU9tM0MsbUJBQW1COXlELGdCQUFnQjB5RCx5QkFBeUJ0QixjQUFjcmpFO0lBQ3JGLENBQUM7SUFDRCxJQUFJLE9BQU80dEIsZUFBZSxVQUFVO1FBQ2hDLE9BQU9tM0MsbUJBQW1CdjRDLHFCQUFxQnUyQyxpQkFBaUIsU0FBVTd2RCxRQUFRLEVBQUU7WUFBRSxPQUFPQSxTQUFTMlosT0FBTyxLQUFLZTtRQUFZO0lBQ2xJLENBQUM7SUFDRCxJQUFJLE9BQU9BLGVBQWUsWUFBWUEsWUFBWTtRQUM5QyxPQUFPbTNDLG1CQUFtQjl5RCxnQkFBZ0IyYixZQUFZeTFDLGNBQWNyakU7SUFDeEUsQ0FBQztJQUNELE9BQU8sRUFBRSxFQUFFLGdCQUFnQjtBQUMvQjtBQUNBLGtDQUFrQztBQUNsQyxTQUFTK2tFLG1CQUFtQjd5RCxVQUFVLEVBQUU7SUFDcEMsSUFBSUssWUFBWUwsV0FBV0ssU0FBUztJQUNwQyxJQUFJaWYsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJM2lCLGNBQWMwRCxVQUFXO1FBQzlCaWYsT0FBTzF1QixJQUFJLENBQUN5UCxTQUFTLENBQUMxRCxXQUFXLENBQUNILEtBQUs7SUFDM0M7SUFDQSxPQUFPOGlCO0FBQ1g7QUFDQSwyQkFBMkI7QUFDM0IsU0FBU3F6QyxzQkFBc0JHLFdBQVcsRUFBRTF5QyxVQUFVLEVBQUU7SUFDcEQsSUFBSyxJQUFJeGlCLEtBQUssR0FBR20xRCxnQkFBZ0JELGFBQWFsMUQsS0FBS20xRCxjQUFjdGlFLE1BQU0sRUFBRW1OLEtBQU07UUFDM0UsSUFBSXVpQixhQUFhNHlDLGFBQWEsQ0FBQ24xRCxHQUFHO1FBQ2xDLElBQUlzaUIsbUJBQW1CQyxZQUFZQyxhQUFhO1lBQzVDLE9BQU8sSUFBSTtRQUNmLENBQUM7SUFDTDtJQUNBLE9BQU8sS0FBSztBQUNoQjtBQUVBLElBQUk0eUMsb0JBQW9CO0FBQ3hCLElBQUlDLFdBQVcsV0FBVyxHQUFJLFNBQVVqeEIsTUFBTSxFQUFFO0lBQzVDMTBDLGdEQUFTQSxDQUFDMmxFLFVBQVVqeEI7SUFDcEIsU0FBU2l4QixXQUFXO1FBQ2hCLElBQUlydEQsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNc2hELFFBQVEsR0FBRyxTQUFVaDRELEVBQUUsRUFBRTtZQUMzQjBXLE1BQU0xVyxFQUFFLEdBQUdBO1lBQ1g2MkMsT0FBT25nQyxNQUFNdlUsS0FBSyxDQUFDdTVDLEtBQUssRUFBRTE3QztRQUM5QjtRQUNBLE9BQU8wVztJQUNYO0lBQ0FxdEQsU0FBU2psRSxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDcEMsSUFBSXg1QyxRQUFRLElBQUksQ0FBQ0EsS0FBSztRQUN0QixJQUFJZzJELFNBQVNoMkQsTUFBTWcyRCxNQUFNLEVBQUU2TCxtQkFBbUI3aEUsTUFBTTZoRSxnQkFBZ0I7UUFDcEUsSUFBSUMsYUFBYTlMLFVBQVU2TDtRQUMzQixJQUFJcjNDLFlBQVk7WUFBQztTQUFjO1FBQy9CLElBQUl3ckMsUUFBUTtZQUNSLElBQUk2TCxrQkFBa0I7Z0JBQ2xCcjNDLFVBQVVqckIsSUFBSSxDQUFDO1lBQ25CLE9BQ0s7Z0JBQ0RpckIsVUFBVWpyQixJQUFJLENBQUM7WUFDbkIsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFRbEQsdURBQWFBLENBQUMsT0FBTztZQUFFczRDLEtBQUssSUFBSSxDQUFDa2hCLFFBQVE7WUFBRXJyQyxXQUFXQSxVQUFVaFIsSUFBSSxDQUFDO1lBQU1uWixPQUFPO2dCQUNsRmd0QyxXQUFXcnRDLE1BQU1xdEMsU0FBUztnQkFDMUJELFdBQVdwdEMsTUFBTW90QyxTQUFTO2dCQUMxQm5KLE1BQU0sY0FBZSxDQUFFamtDLENBQUFBLE1BQU0raEUsWUFBWSxJQUFJLE1BQU87Z0JBQ3BENzlCLE9BQU8sY0FBZSxDQUFFbGtDLENBQUFBLE1BQU1naUUsYUFBYSxJQUFJLE1BQU87Z0JBQ3RENTlCLFFBQVEsY0FBZSxDQUFFcGtDLENBQUFBLE1BQU1paUUsY0FBYyxJQUFJLE1BQU87Z0JBQ3hEQyxZQUFZLENBQUVKLGNBQWMsQ0FBRTloRSxDQUFBQSxNQUFNK2hFLFlBQVksSUFBSSxNQUFPO2dCQUMzREksYUFBYSxDQUFFTCxjQUFjLENBQUU5aEUsQ0FBQUEsTUFBTWdpRSxhQUFhLElBQUksTUFBTztnQkFDN0Q3MEIsY0FBYyxDQUFFMjBCLGNBQWMsQ0FBRTloRSxDQUFBQSxNQUFNaWlFLGNBQWMsSUFBSSxNQUFPO2dCQUMvREcsV0FBV3BpRSxNQUFNb2lFLFNBQVMsSUFBSTtZQUNsQztRQUFFLEdBQUdwaUUsTUFBTUosUUFBUTtJQUMzQjtJQUNBZ2lFLFNBQVNqbEUsU0FBUyxDQUFDMGxFLGVBQWUsR0FBRyxXQUFZO1FBQzdDLElBQUlWLGtCQUFrQnJoRSxJQUFJLENBQUMsSUFBSSxDQUFDTixLQUFLLENBQUNxdEMsU0FBUyxHQUFHO1lBQzlDLE9BQU8sS0FBSztRQUNoQixDQUFDO1FBQ0Qsa0dBQWtHO1FBQ2xHLG1HQUFtRztRQUNuRywrQ0FBK0M7UUFDL0MsSUFBSXh2QyxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJeWtFLGtCQUFrQixJQUFJLENBQUN6a0UsRUFBRSxDQUFDMkkscUJBQXFCLEdBQUdDLEtBQUssR0FBRyxJQUFJLENBQUM4N0Qsa0JBQWtCO1FBQ3JGLElBQUkzaUUsV0FBVy9CLEdBQUcrQixRQUFRO1FBQzFCLElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJUyxTQUFTUixNQUFNLEVBQUVELEtBQUssRUFBRztZQUN6QyxJQUFJcWpFLFVBQVU1aUUsUUFBUSxDQUFDVCxFQUFFO1lBQ3pCLElBQUlxakUsUUFBUWg4RCxxQkFBcUIsR0FBR0MsS0FBSyxHQUFHNjdELGlCQUFpQjtnQkFDekQsT0FBTyxJQUFJO1lBQ2YsQ0FBQztRQUNMO1FBQ0EsT0FBTyxLQUFLO0lBQ2hCO0lBQ0FWLFNBQVNqbEUsU0FBUyxDQUFDOGxFLGVBQWUsR0FBRyxXQUFZO1FBQzdDLElBQUlkLGtCQUFrQnJoRSxJQUFJLENBQUMsSUFBSSxDQUFDTixLQUFLLENBQUNvdEMsU0FBUyxHQUFHO1lBQzlDLE9BQU8sS0FBSztRQUNoQixDQUFDO1FBQ0Qsb0dBQW9HO1FBQ3BHLG1HQUFtRztRQUNuRywrQ0FBK0M7UUFDL0MsSUFBSXZ2QyxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUNoQixJQUFJNmtFLG1CQUFtQixJQUFJLENBQUM3a0UsRUFBRSxDQUFDMkkscUJBQXFCLEdBQUdpWixNQUFNLEdBQUcsSUFBSSxDQUFDa2pELGtCQUFrQjtRQUN2RixJQUFJL2lFLFdBQVcvQixHQUFHK0IsUUFBUTtRQUMxQixJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSVMsU0FBU1IsTUFBTSxFQUFFRCxLQUFLLEVBQUc7WUFDekMsSUFBSXFqRSxVQUFVNWlFLFFBQVEsQ0FBQ1QsRUFBRTtZQUN6QixJQUFJcWpFLFFBQVFoOEQscUJBQXFCLEdBQUdpWixNQUFNLEdBQUdpakQsa0JBQWtCO2dCQUMzRCxPQUFPLElBQUk7WUFDZixDQUFDO1FBQ0w7UUFDQSxPQUFPLEtBQUs7SUFDaEI7SUFDQWQsU0FBU2psRSxTQUFTLENBQUNnbUUsa0JBQWtCLEdBQUcsV0FBWTtRQUNoRCxJQUFJaEIsa0JBQWtCcmhFLElBQUksQ0FBQyxJQUFJLENBQUNOLEtBQUssQ0FBQ3F0QyxTQUFTLEdBQUc7WUFDOUMsT0FBTztRQUNYLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQ3h2QyxFQUFFLENBQUMybkMsWUFBWSxHQUFHLElBQUksQ0FBQzNuQyxFQUFFLENBQUMyc0MsWUFBWSxFQUFFLCtFQUErRTtJQUN2STtJQUNBbzNCLFNBQVNqbEUsU0FBUyxDQUFDNGxFLGtCQUFrQixHQUFHLFdBQVk7UUFDaEQsSUFBSVosa0JBQWtCcmhFLElBQUksQ0FBQyxJQUFJLENBQUNOLEtBQUssQ0FBQ290QyxTQUFTLEdBQUc7WUFDOUMsT0FBTztRQUNYLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQ3Z2QyxFQUFFLENBQUM0c0MsV0FBVyxHQUFHLElBQUksQ0FBQzVzQyxFQUFFLENBQUM2c0MsV0FBVyxFQUFFLCtFQUErRTtJQUNySTtJQUNBLE9BQU9rM0I7QUFDWCxFQUFFcHRCO0FBRUY7OztBQUdBLEdBQ0EsSUFBSW91QixTQUFTLFdBQVcsR0FBSSxXQUFZO0lBQ3BDLFNBQVNBLE9BQU9DLGNBQWMsRUFBRTtRQUM1QixJQUFJdHVELFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNzdUQsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO1FBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7UUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLFNBQVU3aUUsR0FBRyxFQUFFd0MsR0FBRyxFQUFFO1lBQ25DLElBQUluQyxLQUFLOFQsT0FBT3d1RCxTQUFTdGlFLEdBQUdzaUUsTUFBTSxFQUFFRCxhQUFhcmlFLEdBQUdxaUUsVUFBVTtZQUM5RCxJQUFJSSxVQUFVLEtBQUs7WUFDbkIsSUFBSUMsUUFBUSxLQUFLO1lBQ2pCLElBQUkvaUUsUUFBUSxJQUFJLEVBQUU7Z0JBQ2QsMkdBQTJHO2dCQUMzRzhpRSxVQUFXdGdFLE9BQU9rZ0U7Z0JBQ2xCQSxVQUFVLENBQUNsZ0UsSUFBSSxHQUFHeEM7Z0JBQ2xCMmlFLE1BQU0sQ0FBQ25nRSxJQUFJLEdBQUcsQ0FBQ21nRSxNQUFNLENBQUNuZ0UsSUFBSSxJQUFJLEtBQUs7Z0JBQ25DdWdFLFFBQVEsSUFBSTtZQUNoQixPQUNLO2dCQUNESixNQUFNLENBQUNuZ0UsSUFBSSxJQUFJO2dCQUNmLElBQUksQ0FBQ21nRSxNQUFNLENBQUNuZ0UsSUFBSSxFQUFFO29CQUNkLE9BQU9rZ0UsVUFBVSxDQUFDbGdFLElBQUk7b0JBQ3RCLE9BQU8yUixNQUFNeXVELFdBQVcsQ0FBQ3BnRSxJQUFJO29CQUM3QnNnRSxVQUFVLElBQUk7Z0JBQ2xCLENBQUM7WUFDTCxDQUFDO1lBQ0QsSUFBSTN1RCxNQUFNc3VELGNBQWMsRUFBRTtnQkFDdEIsSUFBSUssU0FBUztvQkFDVDN1RCxNQUFNc3VELGNBQWMsQ0FBQyxJQUFJLEVBQUU5L0QsT0FBT0g7Z0JBQ3RDLENBQUM7Z0JBQ0QsSUFBSXVnRSxPQUFPO29CQUNQNXVELE1BQU1zdUQsY0FBYyxDQUFDemlFLEtBQUsyQyxPQUFPSDtnQkFDckMsQ0FBQztZQUNMLENBQUM7UUFDTDtJQUNKO0lBQ0FnZ0UsT0FBT2ptRSxTQUFTLENBQUNQLFNBQVMsR0FBRyxTQUFVd0csR0FBRyxFQUFFO1FBQ3hDLElBQUkyUixRQUFRLElBQUk7UUFDaEIsSUFBSTZ1RCxjQUFjLElBQUksQ0FBQ0osV0FBVyxDQUFDcGdFLElBQUk7UUFDdkMsSUFBSSxDQUFDd2dFLGFBQWE7WUFDZEEsY0FBYyxJQUFJLENBQUNKLFdBQVcsQ0FBQ3BnRSxJQUFJLEdBQUcsU0FBVXhDLEdBQUcsRUFBRTtnQkFDakRtVSxNQUFNMHVELFdBQVcsQ0FBQzdpRSxLQUFLMkMsT0FBT0g7WUFDbEM7UUFDSixDQUFDO1FBQ0QsT0FBT3dnRTtJQUNYO0lBQ0EsNkVBQTZFO0lBQzdFLHlHQUF5RztJQUN6RywrSEFBK0g7SUFDL0hSLE9BQU9qbUUsU0FBUyxDQUFDMG1FLE9BQU8sR0FBRyxTQUFVMzFELFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUU7UUFDN0QsT0FBT0gsZ0JBQWdCLElBQUksQ0FBQ3ExRCxVQUFVLEVBQUVwMUQsWUFBWUMsVUFBVUM7SUFDbEU7SUFDQWcxRCxPQUFPam1FLFNBQVMsQ0FBQzJtRSxNQUFNLEdBQUcsV0FBWTtRQUNsQyxPQUFPMTJELGtCQUFrQixJQUFJLENBQUNrMkQsVUFBVTtJQUM1QztJQUNBLE9BQU9GO0FBQ1g7QUFFQSxTQUFTVyxtQkFBbUJDLFFBQVEsRUFBRTtJQUNsQyxJQUFJQyxjQUFjM2tFLGFBQWEwa0UsVUFBVTtJQUN6QyxJQUFJRSxlQUFlO0lBQ25CLElBQUssSUFBSW4zRCxLQUFLLEdBQUdvM0QsZ0JBQWdCRixhQUFhbDNELEtBQUtvM0QsY0FBY3ZrRSxNQUFNLEVBQUVtTixLQUFNO1FBQzNFLElBQUlxM0QsYUFBYUQsYUFBYSxDQUFDcDNELEdBQUc7UUFDbENtM0QsZUFBZTE3RCxLQUFLd08sR0FBRyxDQUFDa3RELGNBQWN4OUQseUJBQXlCMDlEO0lBQ25FO0lBQ0EsT0FBTzU3RCxLQUFLNnpELElBQUksQ0FBQzZILGVBQWUsNkVBQTZFO0FBQ2pIO0FBQ0EsU0FBU0csMEJBQTBCN2pFLEtBQUssRUFBRThqRSxhQUFhLEVBQUU7SUFDckQsT0FBTzlqRSxNQUFNZzJELE1BQU0sSUFBSThOLGNBQWM5TixNQUFNLEVBQUUsMkZBQTJGO0FBQzVJO0FBQ0EsU0FBUytOLG1CQUFtQi9qRSxLQUFLLEVBQUU4akUsYUFBYSxFQUFFO0lBQzlDLE9BQU9BLGNBQWMxQixTQUFTLElBQUksSUFBSSxJQUFJLHNFQUFzRTtJQUM1R3lCLDBCQUEwQjdqRSxPQUFPOGpFLGdCQUFnQixrRkFBa0Y7QUFDM0k7QUFDQSxvRUFBb0U7QUFDcEUsU0FBU0UsbUJBQW1CRixhQUFhLEVBQUVHLFdBQVcsRUFBRXIrRCxHQUFHLEVBQUVzK0QsUUFBUSxFQUFFO0lBQ25FLElBQUkxa0QsYUFBYTVaLElBQUk0WixVQUFVO0lBQy9CLElBQUlrSSxVQUFVLE9BQU91OEMsWUFBWXY4QyxPQUFPLEtBQUssYUFDekN1OEMsWUFBWXY4QyxPQUFPLENBQUM5aEIsT0FDcEJ2Six1REFBYUEsQ0FBQyxTQUFTO1FBQ25CdTlELE1BQU07UUFDTnB2QyxXQUFXO1lBQ1B5NUMsWUFBWUUsY0FBYztZQUMxQkwsY0FBY00sY0FBYyxHQUFHLDZCQUE2QixFQUFFO1NBQ2pFLENBQUM1cUQsSUFBSSxDQUFDO1FBQ1BuWixPQUFPO1lBQ0hna0UsVUFBVXorRCxJQUFJMCtELGFBQWE7WUFDM0I3OUQsT0FBT2IsSUFBSThrQyxXQUFXO1lBQ3RCanJCLFFBQVFELGFBQWE1WixJQUFJNGtDLFlBQVksR0FBRyxFQUFFO1FBQzlDO0lBQ0osR0FBRzVrQyxJQUFJMitELGlCQUFpQixFQUFFbG9FLHVEQUFhQSxDQUFDNm5FLFdBQVcsVUFBVSxPQUFPLEVBQUU7UUFDbEV0SyxNQUFNO0lBQ1YsR0FBRyxPQUFPcUssWUFBWU8sVUFBVSxLQUFLLGFBQy9CUCxZQUFZTyxVQUFVLENBQUM1K0QsT0FDdkJxK0QsWUFBWU8sVUFBVSxFQUFFO0lBQ2xDLE9BQU85OEM7QUFDWDtBQUNBLFNBQVMrOEMsZ0JBQWdCQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtJQUNuQyxPQUFPanhELGNBQWNneEQsT0FBT0MsT0FBTzczRDtBQUN2QztBQUNBLFNBQVM4M0Qsb0JBQW9CQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtJQUM1QyxJQUFJQyxXQUFXLEVBQUU7SUFDakI7Ozs7SUFJQSxHQUNBLElBQUssSUFBSXg0RCxLQUFLLEdBQUd5NEQsU0FBU0gsTUFBTXQ0RCxLQUFLeTRELE9BQU81bEUsTUFBTSxFQUFFbU4sS0FBTTtRQUN0RCxJQUFJMDRELFdBQVdELE1BQU0sQ0FBQ3o0RCxHQUFHO1FBQ3pCLElBQUk4bkIsT0FBTzR3QyxTQUFTNXdDLElBQUksSUFBSTtRQUM1QixJQUFLLElBQUlsMUIsSUFBSSxHQUFHQSxJQUFJazFCLE1BQU1sMUIsS0FBSyxFQUFHO1lBQzlCNGxFLFNBQVN4bEUsSUFBSSxDQUFDbEQsdURBQWFBLENBQUMsT0FBTztnQkFBRWdFLE9BQU87b0JBQ3BDb0csT0FBT3crRCxTQUFTeCtELEtBQUssS0FBSyxXQUFXeStELG9CQUFvQkosZUFBZ0JHLFNBQVN4K0QsS0FBSyxJQUFJLEVBQUc7b0JBQzlGNDlELFVBQVVZLFNBQVNaLFFBQVEsSUFBSTtnQkFDbkM7WUFBRTtRQUNWO0lBQ0o7SUFDQSxPQUFPaG9FLHlEQUFtQixDQUFDLEtBQUssR0FBR0wsb0RBQWFBLENBQUM7UUFBQztRQUFZLENBQUM7S0FBRSxFQUFFK29FO0FBQ3ZFO0FBQ0EsU0FBU0csb0JBQW9CSixXQUFXLEVBQUU7SUFDdEM7NkRBQ3lELEdBQ3pELE9BQU9BLGVBQWUsSUFBSSxHQUFHLElBQUlBLFdBQVc7QUFDaEQ7QUFDQSxTQUFTSyxlQUFlTixJQUFJLEVBQUU7SUFDMUIsSUFBSyxJQUFJdDRELEtBQUssR0FBRzY0RCxTQUFTUCxNQUFNdDRELEtBQUs2NEQsT0FBT2htRSxNQUFNLEVBQUVtTixLQUFNO1FBQ3RELElBQUltd0QsTUFBTTBJLE1BQU0sQ0FBQzc0RCxHQUFHO1FBQ3BCLElBQUltd0QsSUFBSWoyRCxLQUFLLEtBQUssVUFBVTtZQUN4QixPQUFPLElBQUk7UUFDZixDQUFDO0lBQ0w7SUFDQSxPQUFPLEtBQUs7QUFDaEI7QUFDQSxTQUFTNCtELHdCQUF3QnJQLE1BQU0sRUFBRXY1RCxPQUFPLEVBQUU7SUFDOUMsSUFBSWdyQixhQUFhO1FBQ2I7UUFDQWhyQixRQUFRc3NDLEtBQUssQ0FBQ0MsUUFBUSxDQUFDO0tBQzFCO0lBQ0QsSUFBSWd0QixRQUFRO1FBQ1J2dUMsV0FBV2xvQixJQUFJLENBQUM7SUFDcEIsQ0FBQztJQUNELE9BQU9rb0I7QUFDWDtBQUNBLFNBQVM2OUMscUJBQXFCeEIsYUFBYSxFQUFFeUIsZUFBZSxFQUFFO0lBQzFELElBQUk5OUMsYUFBYTtRQUNiO1FBQ0EsMkJBQTJCcThDLGNBQWNobkUsSUFBSTtRQUM3Q2duRSxjQUFjdDVDLFNBQVM7S0FDMUI7SUFDRCxJQUFJKzZDLG1CQUFtQnpCLGNBQWM5TixNQUFNLElBQUk4TixjQUFjMUIsU0FBUyxJQUFJLElBQUksRUFBRTtRQUM1RTM2QyxXQUFXbG9CLElBQUksQ0FBQztJQUNwQixDQUFDO0lBQ0QsSUFBSXVrRSxjQUFjL0osUUFBUSxFQUFFO1FBQ3hCdHlDLFdBQVdsb0IsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFDRCxPQUFPa29CO0FBQ1g7QUFDQSxTQUFTKzlDLGlCQUFpQjUvRCxHQUFHLEVBQUU7SUFDM0IsT0FBUXZKLHVEQUFhQSxDQUFDLE9BQU87UUFBRW11QixXQUFXO1FBQTZCbnFCLE9BQU87WUFDdEVvRyxPQUFPYixJQUFJOGtDLFdBQVc7WUFDdEIyNUIsVUFBVXorRCxJQUFJMCtELGFBQWE7UUFDL0I7SUFBRTtBQUNWO0FBQ0EsU0FBU21CLHFCQUFxQjMyRCxPQUFPLEVBQUU7SUFDbkMsSUFBSXNSLG9CQUFvQnRSLFFBQVFzUixpQkFBaUI7SUFDakQsSUFBSUEscUJBQXFCLElBQUksSUFBSUEsc0JBQXNCLFFBQVE7UUFDM0RBLG9CQUFvQnRSLFFBQVEyUSxNQUFNLEtBQUssVUFBVTNRLFFBQVF3UixVQUFVLEtBQUs7SUFDNUUsQ0FBQztJQUNELE9BQU9GO0FBQ1g7QUFDQSxTQUFTc2xELHlCQUF5QjUyRCxPQUFPLEVBQUU7SUFDdkMsSUFBSXVSLHdCQUF3QnZSLFFBQVF1UixxQkFBcUI7SUFDekQsSUFBSUEseUJBQXlCLElBQUksSUFBSUEsMEJBQTBCLFFBQVE7UUFDbkVBLHdCQUF3QnZSLFFBQVEyUSxNQUFNLEtBQUssVUFBVTNRLFFBQVF3UixVQUFVLEtBQUs7SUFDaEYsQ0FBQztJQUNELE9BQU9EO0FBQ1g7QUFFQSxJQUFJc2xELG1CQUFtQixXQUFXLEdBQUksU0FBVWgxQixNQUFNLEVBQUU7SUFDcEQxMEMsZ0RBQVNBLENBQUMwcEUsa0JBQWtCaDFCO0lBQzVCLFNBQVNnMUIsbUJBQW1CO1FBQ3hCLElBQUlweEQsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNcXhELFdBQVcsR0FBRzl4RCxRQUFRLFNBQVVoUCxDQUFDLEVBQUU7WUFBRSxPQUFPQTtRQUFHLEdBQUcyL0Qsa0JBQWtCLHlDQUF5QztRQUNuSCxpRUFBaUU7UUFDakVsd0QsTUFBTXF3RCxtQkFBbUIsR0FBRzl3RCxRQUFROHdEO1FBQ3BDcndELE1BQU1zeEQsWUFBWSxHQUFHLElBQUlqRDtRQUN6QnJ1RCxNQUFNdXhELGNBQWMsR0FBRyxJQUFJbEQsT0FBT3J1RCxNQUFNd3hELGlCQUFpQixDQUFDbmdCLElBQUksQ0FBQ3J4QztRQUMvREEsTUFBTTRsQixLQUFLLEdBQUc7WUFDVjJxQyxhQUFhLElBQUk7WUFDakJrQixrQkFBa0IsS0FBSztZQUN2QkMsc0JBQXNCLENBQUM7WUFDdkJDLHVCQUF1QixDQUFDO1FBQzVCO1FBQ0Esa0VBQWtFO1FBQ2xFM3hELE1BQU00eEQsWUFBWSxHQUFHLFdBQVk7WUFDN0I1eEQsTUFBTTIvQixZQUFZLENBQUNuNEMsK0NBQVFBLENBQUM7Z0JBQUUrb0UsYUFBYXZ3RCxNQUFNZ3ZELGtCQUFrQjtZQUFHLEdBQUdodkQsTUFBTTZ4RCxtQkFBbUI7UUFDdEc7UUFDQSxPQUFPN3hEO0lBQ1g7SUFDQW94RCxpQkFBaUJocEUsU0FBUyxDQUFDNjhDLE1BQU0sR0FBRyxXQUFZO1FBQzVDLElBQUkvNEMsS0FBSyxJQUFJLEVBQUVULFFBQVFTLEdBQUdULEtBQUssRUFBRW02QixRQUFRMTVCLEdBQUcwNUIsS0FBSyxFQUFFMTlCLFVBQVVnRSxHQUFHaEUsT0FBTztRQUN2RSxJQUFJNHBFLGlCQUFpQnJtRSxNQUFNc21FLFFBQVEsSUFBSSxFQUFFO1FBQ3pDLElBQUl6QixPQUFPLElBQUksQ0FBQ2UsV0FBVyxDQUFDNWxFLE1BQU02a0UsSUFBSTtRQUN0QyxJQUFJMEIsb0JBQW9CLElBQUksQ0FBQzNCLG1CQUFtQixDQUFDQyxNQUFNMXFDLE1BQU0ycUMsV0FBVztRQUN4RSxJQUFJcjlDLGFBQWE0OUMsd0JBQXdCcmxFLE1BQU1nMkQsTUFBTSxFQUFFdjVEO1FBQ3ZELElBQUl1RCxNQUFNd21FLGdCQUFnQixFQUFFO1lBQ3hCLytDLFdBQVdsb0IsSUFBSSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxpQkFBaUI7UUFDakIsSUFBSWtuRSxZQUFZSixlQUFlam5FLE1BQU07UUFDckMsSUFBSXNuRSxVQUFVO1FBQ2QsSUFBSUM7UUFDSixJQUFJQyxtQkFBbUIsRUFBRTtRQUN6QixJQUFJQyxtQkFBbUIsRUFBRTtRQUN6QixJQUFJQyxtQkFBbUIsRUFBRTtRQUN6QixNQUFPSixVQUFVRCxhQUFhLENBQUNFLGdCQUFnQk4sY0FBYyxDQUFDSyxRQUFRLEVBQUU1cEUsSUFBSSxLQUFLLFNBQVU7WUFDdkY4cEUsaUJBQWlCcm5FLElBQUksQ0FBQyxJQUFJLENBQUNtMkQsYUFBYSxDQUFDaVIsZUFBZUosbUJBQW1CLElBQUk7WUFDL0VHLFdBQVc7UUFDZjtRQUNBLE1BQU9BLFVBQVVELGFBQWEsQ0FBQ0UsZ0JBQWdCTixjQUFjLENBQUNLLFFBQVEsRUFBRTVwRSxJQUFJLEtBQUssT0FBUTtZQUNyRitwRSxpQkFBaUJ0bkUsSUFBSSxDQUFDLElBQUksQ0FBQ20yRCxhQUFhLENBQUNpUixlQUFlSixtQkFBbUIsS0FBSztZQUNoRkcsV0FBVztRQUNmO1FBQ0EsTUFBT0EsVUFBVUQsYUFBYSxDQUFDRSxnQkFBZ0JOLGNBQWMsQ0FBQ0ssUUFBUSxFQUFFNXBFLElBQUksS0FBSyxTQUFVO1lBQ3ZGZ3FFLGlCQUFpQnZuRSxJQUFJLENBQUMsSUFBSSxDQUFDbTJELGFBQWEsQ0FBQ2lSLGVBQWVKLG1CQUFtQixJQUFJO1lBQy9FRyxXQUFXO1FBQ2Y7UUFDQSwyRUFBMkU7UUFDM0UsaUhBQWlIO1FBQ2pILHFFQUFxRTtRQUNyRSx3RUFBd0U7UUFDeEUsSUFBSUssVUFBVSxDQUFDOWhDO1FBQ2YsSUFBSStoQyxZQUFZO1lBQUVwTixNQUFNO1FBQVc7UUFDbkMsT0FBT3Y5RCx1REFBYUEsQ0FBQyxTQUFTO1lBQzFCdTlELE1BQU07WUFDTnB2QyxXQUFXL0MsV0FBV2pPLElBQUksQ0FBQztZQUMzQm5aLE9BQU87Z0JBQUVvZixRQUFRemYsTUFBTXlmLE1BQU07WUFBQztRQUNsQyxHQUFHM0QsUUFBUSxDQUFDaXJELFdBQVdILGlCQUFpQnhuRSxNQUFNLEtBQUsvQyx5REFBbUIsQ0FBQyxLQUFLLEdBQUdMLG9EQUFhQSxDQUFDO1lBQUM7WUFBU2dyRTtTQUFVLEVBQUVKLG9CQUFvQjlxRCxRQUFRLENBQUNpckQsV0FBV0YsaUJBQWlCem5FLE1BQU0sS0FBSy9DLHlEQUFtQixDQUFDLEtBQUssR0FBR0wsb0RBQWFBLENBQUM7WUFBQztZQUFTZ3JFO1NBQVUsRUFBRUgsb0JBQW9CL3FELFFBQVEsQ0FBQ2lyRCxXQUFXRCxpQkFBaUIxbkUsTUFBTSxLQUFLL0MseURBQW1CLENBQUMsS0FBSyxHQUFHTCxvREFBYUEsQ0FBQztZQUFDO1lBQVNnckU7U0FBVSxFQUFFRixvQkFBb0JDLFdBQVcxcUUseURBQW1CLENBQUMsS0FBSyxHQUFHTCxvREFBYUEsQ0FBQ0Esb0RBQWFBLENBQUNBLG9EQUFhQSxDQUFDO1lBQUM7WUFBU2dyRTtTQUFVLEVBQUVKLG1CQUFtQkMsbUJBQW1CQztJQUNoaUI7SUFDQW5CLGlCQUFpQmhwRSxTQUFTLENBQUMrNEQsYUFBYSxHQUFHLFNBQVVvTyxhQUFhLEVBQUV5QyxpQkFBaUIsRUFBRXJDLFFBQVEsRUFBRTtRQUM3RixJQUFJLGtCQUFrQkosZUFBZTtZQUNqQyxPQUFRem5FLHVEQUFhQSxDQUFDQyw4Q0FBUUEsRUFBRTtnQkFBRXNHLEtBQUtraEUsY0FBY2xoRSxHQUFHO1lBQUMsR0FBR2toRSxjQUFjbUQsWUFBWTtRQUMxRixDQUFDO1FBQ0QsT0FBUTVxRSx1REFBYUEsQ0FBQyxNQUFNO1lBQUV1RyxLQUFLa2hFLGNBQWNsaEUsR0FBRztZQUFFZzNELE1BQU07WUFBZ0JwdkMsV0FBVzg2QyxxQkFBcUJ4QixlQUFlLElBQUksQ0FBQzlqRSxLQUFLLENBQUNnMkQsTUFBTSxFQUFFeDhDLElBQUksQ0FBQztRQUFLLEdBQUcsSUFBSSxDQUFDMHRELGFBQWEsQ0FBQ3BELGVBQWV5QyxtQkFBbUJ6QyxjQUFjcUQsS0FBSyxFQUFFakQ7SUFDek87SUFDQXlCLGlCQUFpQmhwRSxTQUFTLENBQUN1cUUsYUFBYSxHQUFHLFNBQVVwRCxhQUFhLEVBQUV5QyxpQkFBaUIsRUFBRXRDLFdBQVcsRUFBRUMsUUFBUSxFQUFFO1FBQzFHLElBQUksa0JBQWtCRCxhQUFhO1lBQy9CLE9BQU9BLFlBQVlnRCxZQUFZO1FBQ25DLENBQUM7UUFDRCxJQUFJam5FLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3RCLElBQUlTLEtBQUssSUFBSSxDQUFDMDVCLEtBQUssRUFBRTZyQyxtQkFBbUJ2bEUsR0FBR3VsRSxnQkFBZ0IsRUFBRUMsdUJBQXVCeGxFLEdBQUd3bEUsb0JBQW9CLEVBQUVDLHdCQUF3QnpsRSxHQUFHeWxFLHFCQUFxQjtRQUM3SixJQUFJekQsa0JBQWtCc0IsbUJBQW1CL2pFLE9BQU84akUsZ0JBQWdCLHlDQUF5QztRQUN6RyxJQUFJc0QsV0FBV3ZELDBCQUEwQjdqRSxPQUFPOGpFO1FBQ2hELDREQUE0RDtRQUM1RCw4RkFBOEY7UUFDOUYsSUFBSTEyQixZQUFZLENBQUNwdEMsTUFBTWcyRCxNQUFNLEdBQUcsWUFDNUJnUSxtQkFBbUIsV0FDZixDQUFDdkQsa0JBQWtCLFdBQ2YsTUFBTTtRQUNsQixJQUFJNEUsYUFBYXZELGNBQWNsaEUsR0FBRztRQUNsQyxJQUFJOGtCLFVBQVVzOEMsbUJBQW1CRixlQUFlRyxhQUFhO1lBQ3pETSxtQkFBbUJnQztZQUNuQmpDLGVBQWU7WUFDZjU1QixhQUFhLENBQUUxcUMsTUFBTXdtRSxnQkFBZ0IsSUFBSVAsb0JBQW9CLENBQUNvQixXQUFXLEtBQUt0N0QsWUFBYWs2RCxvQkFBb0IsQ0FBQ29CLFdBQVcsR0FBRyxJQUFJO1lBQ2xJNzhCLGNBQWMwN0IscUJBQXFCLENBQUNtQixXQUFXLEtBQUt0N0QsWUFBWW02RCxxQkFBcUIsQ0FBQ21CLFdBQVcsR0FBRyxJQUFJO1lBQ3hHN25ELFlBQVlza0QsY0FBY3RrRCxVQUFVO1lBQ3BDNGtELGdCQUFnQixLQUFLO1lBQ3JCa0QsZ0JBQWdCLEVBQUU7WUFDbEJDLHVCQUF1QixXQUFZLENBQUU7UUFDekMsR0FBR3JEO1FBQ0gsT0FBTzduRSx1REFBYUEsQ0FBQzZuRSxXQUFXLE9BQU8sSUFBSSxFQUFFO1lBQ3pDdnZCLEtBQUtzdkIsWUFBWTFxQixLQUFLO1lBQ3RCcWdCLE1BQU07UUFDVixHQUFHdjlELHVEQUFhQSxDQUFDLE9BQU87WUFBRW11QixXQUFXLHdCQUF5QjQ4QyxDQUFBQSxXQUFXLGdDQUFnQyxFQUFFO1FBQUUsR0FDekcvcUUsdURBQWFBLENBQUN1bEUsVUFBVTtZQUFFanRCLEtBQUssSUFBSSxDQUFDa3hCLFlBQVksQ0FBQ3pwRSxTQUFTLENBQUNpckU7WUFBYTl0QixPQUFPLElBQUksQ0FBQ3VzQixjQUFjLENBQUMxcEUsU0FBUyxDQUFDaXJFO1lBQWFqNkIsV0FBV0E7WUFBV0MsV0FBVyxDQUFDcnRDLE1BQU1nMkQsTUFBTSxHQUFHLFlBQVksU0FBUyxtQkFBbUIsR0FBcEI7WUFBd0JvTSxXQUFXMEIsY0FBYzFCLFNBQVM7WUFBRXBNLFFBQVFvUjtZQUFVdkYsa0JBQ3ZRLElBQUk7UUFBQyxHQUFHbjZDO0lBQ3RCO0lBQ0FpK0MsaUJBQWlCaHBFLFNBQVMsQ0FBQ29wRSxpQkFBaUIsR0FBRyxTQUFVeUIsVUFBVSxFQUFFNWtFLEdBQUcsRUFBRTtRQUN0RSxJQUFJNmtFLFVBQVVDLGdCQUFnQixJQUFJLENBQUMxbkUsS0FBSyxDQUFDc21FLFFBQVEsRUFBRTFqRTtRQUNuRCxJQUFJNmtFLFNBQVM7WUFDVC95QixPQUFPK3lCLFFBQVFOLEtBQUssQ0FBQ1EsYUFBYSxFQUFFSDtRQUN4QyxDQUFDO0lBQ0w7SUFDQTdCLGlCQUFpQmhwRSxTQUFTLENBQUMyOUMsaUJBQWlCLEdBQUcsV0FBWTtRQUN2RCxJQUFJLENBQUM2ckIsWUFBWTtRQUNqQixJQUFJLENBQUMxcEUsT0FBTyxDQUFDODJDLGdCQUFnQixDQUFDLElBQUksQ0FBQzR5QixZQUFZO0lBQ25EO0lBQ0FSLGlCQUFpQmhwRSxTQUFTLENBQUM2OUMsa0JBQWtCLEdBQUcsV0FBWTtRQUN4RCxtRUFBbUU7UUFDbkUsSUFBSSxDQUFDMnJCLFlBQVk7SUFDckI7SUFDQVIsaUJBQWlCaHBFLFNBQVMsQ0FBQzg5QyxvQkFBb0IsR0FBRyxXQUFZO1FBQzFELElBQUksQ0FBQ2grQyxPQUFPLENBQUMrMkMsbUJBQW1CLENBQUMsSUFBSSxDQUFDMnlCLFlBQVk7SUFDdEQ7SUFDQVIsaUJBQWlCaHBFLFNBQVMsQ0FBQzRtRSxrQkFBa0IsR0FBRyxXQUFZO1FBQ3hELE9BQU80QixlQUFlLElBQUksQ0FBQ25sRSxLQUFLLENBQUM2a0UsSUFBSSxJQUMvQnRCLG1CQUFtQixJQUFJLENBQUN1QyxjQUFjLENBQUN4QyxNQUFNLE1BQzdDLENBQUM7SUFDWDtJQUNBcUMsaUJBQWlCaHBFLFNBQVMsQ0FBQ3lwRSxtQkFBbUIsR0FBRyxXQUFZO1FBQ3pELElBQUl3QixpQkFBaUJ4OUI7UUFDckIsSUFBSTNwQyxLQUFLLElBQUksRUFBRW9sRSxlQUFlcGxFLEdBQUdvbEUsWUFBWSxFQUFFQyxpQkFBaUJybEUsR0FBR3FsRSxjQUFjO1FBQ2pGLElBQUlFLG1CQUFtQixLQUFLO1FBQzVCLElBQUlDLHVCQUF1QixDQUFDO1FBQzVCLElBQUlDLHdCQUF3QixDQUFDO1FBQzdCLElBQUssSUFBSW1CLGNBQWN4QixhQUFhL0MsVUFBVSxDQUFFO1lBQzVDLElBQUkrRSxXQUFXaEMsYUFBYS9DLFVBQVUsQ0FBQ3VFLFdBQVc7WUFDbEQsSUFBSVEsWUFBWUEsU0FBU3BGLGVBQWUsSUFBSTtnQkFDeEN1RCxtQkFBbUIsSUFBSTtnQkFDdkIsS0FBTTtZQUNWLENBQUM7UUFDTDtRQUNBLElBQUssSUFBSXo1RCxLQUFLLEdBQUc3TCxLQUFLLElBQUksQ0FBQ1YsS0FBSyxDQUFDc21FLFFBQVEsRUFBRS81RCxLQUFLN0wsR0FBR3RCLE1BQU0sRUFBRW1OLEtBQU07WUFDN0QsSUFBSWs3RCxVQUFVL21FLEVBQUUsQ0FBQzZMLEdBQUc7WUFDcEIsSUFBSTg2RCxhQUFhSSxRQUFRN2tFLEdBQUc7WUFDNUIsSUFBSTRrRSxhQUFhMUIsZUFBZWhELFVBQVUsQ0FBQ3VFLFdBQVc7WUFDdEQsSUFBSUcsWUFBWTtnQkFDWixJQUFJTSxZQUFZTixXQUFXMXBFLFVBQVUsRUFBRSw4RUFBOEU7Z0JBQ3JIbW9FLG9CQUFvQixDQUFDb0IsV0FBVyxHQUFHci9ELEtBQUs2QixLQUFLLENBQUNpK0QsVUFBVXRoRSxxQkFBcUIsR0FBR0MsS0FBSyxHQUFJdS9ELENBQUFBLG1CQUNuRjRCLGVBQWV4K0QsQ0FBQyxDQUFDLHlGQUF5RjttQkFDMUcsQ0FBQztnQkFDUDg4RCxxQkFBcUIsQ0FBQ21CLFdBQVcsR0FBR3IvRCxLQUFLNkIsS0FBSyxDQUFDaStELFVBQVV0aEUscUJBQXFCLEdBQUdpWixNQUFNO1lBQzNGLENBQUM7UUFDTDtRQUNBLE9BQU87WUFBRXVtRCxrQkFBa0JBO1lBQWtCQyxzQkFBc0JBO1lBQXNCQyx1QkFBdUJBO1FBQXNCO0lBQzFJO0lBQ0EsT0FBT1A7QUFDWCxFQUFFbnhCO0FBQ0ZteEIsaUJBQWlCcnhCLGdCQUFnQixDQUFDO0lBQzlCMnhCLHNCQUFzQm41RDtJQUN0Qm81RCx1QkFBdUJwNUQ7QUFDM0I7QUFDQSxTQUFTNDZELGdCQUFnQnBCLFFBQVEsRUFBRTFqRSxHQUFHLEVBQUU7SUFDcEMsSUFBSyxJQUFJMkosS0FBSyxHQUFHdzdELGFBQWF6QixVQUFVLzVELEtBQUt3N0QsV0FBVzNvRSxNQUFNLEVBQUVtTixLQUFNO1FBQ2xFLElBQUlrN0QsVUFBVU0sVUFBVSxDQUFDeDdELEdBQUc7UUFDNUIsSUFBSWs3RCxRQUFRN2tFLEdBQUcsS0FBS0EsS0FBSztZQUNyQixPQUFPNmtFO1FBQ1gsQ0FBQztJQUNMO0lBQ0EsT0FBTyxJQUFJO0FBQ2Y7QUFFQSxJQUFJTyxZQUFZLFdBQVcsR0FBSSxTQUFVcjNCLE1BQU0sRUFBRTtJQUM3QzEwQyxnREFBU0EsQ0FBQytyRSxXQUFXcjNCO0lBQ3JCLFNBQVNxM0IsWUFBWTtRQUNqQixJQUFJenpELFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTWdsQyxLQUFLLEdBQUduOUMsbURBQVNBO1FBQ3ZCLE9BQU9tWTtJQUNYO0lBQ0F5ekQsVUFBVXJyRSxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDckMsSUFBSS80QyxLQUFLLElBQUksRUFBRVQsUUFBUVMsR0FBR1QsS0FBSyxFQUFFdkQsVUFBVWdFLEdBQUdoRSxPQUFPO1FBQ3JELElBQUlxUyxVQUFVclMsUUFBUXFTLE9BQU87UUFDN0IsSUFBSXloQixNQUFNdndCLE1BQU11d0IsR0FBRztRQUNuQixJQUFJWSxhQUFhWixJQUFJWSxVQUFVO1FBQy9CLElBQUkvRSxLQUFLK0UsV0FBVy9FLEVBQUU7UUFDdEIsSUFBSXF0QixZQUFZO1lBQ1o1bEIsT0FBTyxJQUFJQyxTQUFTcjNCLFNBQVMwMEIsV0FBV2hpQixHQUFHLEVBQUVnaUIsV0FBV2xpQixRQUFRO1lBQ2hFK2tCLE1BQU12M0IsUUFBUXczQixPQUFPO1lBQ3JCZzBDLFVBQVVqb0UsTUFBTWlvRSxRQUFRO1lBQ3hCcjlDLFdBQVd3QixHQUFHeEIsU0FBUztZQUN2QkYsaUJBQWlCMEIsR0FBRzFCLGVBQWU7WUFDbkNDLGFBQWF5QixHQUFHekIsV0FBVztZQUMzQnNJLGFBQWEsQ0FBQ2p6QixNQUFNa29FLGVBQWUsSUFBSTkyQyxvQkFBb0JiLEtBQUs5ekI7WUFDaEV5MkIsa0JBQWtCLENBQUNsekIsTUFBTW1vRSxlQUFlLElBQUkxMkMseUJBQXlCbEIsS0FBSzl6QjtZQUMxRTAyQixnQkFBZ0IsQ0FBQ256QixNQUFNbW9FLGVBQWUsSUFBSXoyQyx1QkFBdUJuQjtZQUNqRXlDLFVBQVVsWCxRQUFROWIsTUFBTW96QixVQUFVLElBQUlwekIsTUFBTXF6QixVQUFVLElBQUlyekIsTUFBTW9vRSxlQUFlO1lBQy9FdDRDLFNBQVNoVSxRQUFReVUsSUFBSVQsT0FBTztZQUM1QkMsT0FBT2pVLFFBQVF5VSxJQUFJUixLQUFLO1lBQ3hCNkMsUUFBUTlXLFFBQVE5YixNQUFNNHlCLE1BQU07WUFDNUJDLFVBQVUvVyxRQUFROWIsTUFBTTZ5QixRQUFRO1lBQ2hDQyxTQUFTaFgsUUFBUTliLE1BQU04eUIsT0FBTztZQUM5QlEsWUFBWXhYLFFBQVE5YixNQUFNc3pCLFVBQVU7WUFDcENGLFlBQVl0WCxRQUFROWIsTUFBTW96QixVQUFVO1lBQ3BDQyxZQUFZdlgsUUFBUTliLE1BQU1xekIsVUFBVTtRQUN4QztRQUNBLElBQUlnMUMscUJBQXFCdDFDLG1CQUFtQjBtQixXQUFXNXVDLE1BQU0sQ0FBQ3VoQixHQUFHM0UsVUFBVTtRQUMzRSxPQUFRcHJCLHVEQUFhQSxDQUFDKzhDLFlBQVk7WUFBRUssV0FBV0E7WUFBV2h5QixZQUFZM1ksUUFBUXFTLGVBQWU7WUFBRXVHLFNBQVM1WSxRQUFRc1MsWUFBWTtZQUFFdzRCLGdCQUFnQjU1QyxNQUFNNDVDLGNBQWM7WUFBRWp5QixVQUFVN1ksUUFBUXVTLGFBQWE7WUFBRXVHLGFBQWE5WSxRQUFRd1MsZ0JBQWdCO1lBQUVpNEIsT0FBTyxJQUFJLENBQUNBLEtBQUs7UUFBQyxHQUFHLFNBQVVGLFNBQVMsRUFBRXFDLGdCQUFnQixFQUFFNUIsVUFBVSxFQUFFQyxZQUFZLEVBQUU7WUFBRSxPQUFPLzVDLE1BQU1KLFFBQVEsQ0FBQ3k1QyxXQUFXZ3ZCLG1CQUFtQng5RCxNQUFNLENBQUM2d0MsbUJBQW1CNUIsWUFBWUMsY0FBY047UUFBWTtJQUM1YjtJQUNBdXVCLFVBQVVyckUsU0FBUyxDQUFDMjlDLGlCQUFpQixHQUFHLFdBQVk7UUFDaERocUIsU0FBUyxJQUFJLENBQUNpcEIsS0FBSyxDQUFDM0UsT0FBTyxFQUFFLElBQUksQ0FBQzUwQyxLQUFLLENBQUN1d0IsR0FBRztJQUMvQztJQUNBOztJQUVBLEdBQ0F5M0MsVUFBVXJyRSxTQUFTLENBQUM2OUMsa0JBQWtCLEdBQUcsU0FBVXlVLFNBQVMsRUFBRTtRQUMxRCxJQUFJMStCLE1BQU0sSUFBSSxDQUFDdndCLEtBQUssQ0FBQ3V3QixHQUFHO1FBQ3hCLElBQUlBLFFBQVEwK0IsVUFBVTErQixHQUFHLEVBQUU7WUFDdkJELFNBQVMsSUFBSSxDQUFDaXBCLEtBQUssQ0FBQzNFLE9BQU8sRUFBRXJrQjtRQUNqQyxDQUFDO0lBQ0w7SUFDQSxPQUFPeTNDO0FBQ1gsRUFBRXh6QjtBQUVGLGdDQUFnQztBQUNoQyxJQUFJOHpCLGdCQUFnQixXQUFXLEdBQUksU0FBVTMzQixNQUFNLEVBQUU7SUFDakQxMEMsZ0RBQVNBLENBQUNxc0UsZUFBZTMzQjtJQUN6QixTQUFTMjNCLGdCQUFnQjtRQUNyQixPQUFPMzNCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7SUFDbkU7SUFDQWkwRCxjQUFjM3JFLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUN6QyxJQUFJLzRDLEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87UUFDckQsSUFBSTh6QixNQUFNdndCLE1BQU11d0IsR0FBRztRQUNuQixJQUFJcUIsYUFBYW4xQixRQUFRcVMsT0FBTyxDQUFDa1UsZUFBZSxJQUFJaGpCLE1BQU11b0UsaUJBQWlCO1FBQzNFLElBQUlOLFdBQVd0MkMsaUJBQWlCcEIsS0FBS3FCLFlBQVluMUIsU0FBU3VELE1BQU02eEIsdUJBQXVCLEVBQUU3eEIsTUFBTTh4QixzQkFBc0I7UUFDckgsT0FBUXoxQix1REFBYUEsQ0FBQzJyRSxXQUFXO1lBQUV6M0MsS0FBS0E7WUFBSzAzQyxVQUFVQTtZQUFVQyxpQkFBaUJsb0UsTUFBTWtvRSxlQUFlO1lBQUVDLGlCQUFpQm5vRSxNQUFNbW9FLGVBQWU7WUFBRXZ1QixnQkFBZ0I1NUMsTUFBTTQ1QyxjQUFjLElBQUk0dUI7WUFBc0JwMUMsWUFBWXB6QixNQUFNb3pCLFVBQVU7WUFBRUMsWUFBWXJ6QixNQUFNcXpCLFVBQVU7WUFBRSswQyxpQkFBaUJwb0UsTUFBTW9vRSxlQUFlO1lBQUU5MEMsWUFBWXR6QixNQUFNc3pCLFVBQVU7WUFBRVYsUUFBUTV5QixNQUFNNHlCLE1BQU07WUFBRUMsVUFBVTd5QixNQUFNNnlCLFFBQVE7WUFBRUMsU0FBUzl5QixNQUFNOHlCLE9BQU87UUFBQyxHQUFHLFNBQVV1bUIsU0FBUyxFQUFFNXhCLFVBQVUsRUFBRXF5QixVQUFVLEVBQUVDLFlBQVksRUFBRU4sU0FBUyxFQUFFO1lBQUUsT0FBUXA5Qyx1REFBYUEsQ0FBQyxLQUFLTiwrQ0FBUUEsQ0FBQztnQkFBRXl1QixXQUFXeHFCLE1BQU1rNkQsZUFBZSxDQUFDcnZELE1BQU0sQ0FBQzRjLFlBQVlqTyxJQUFJLENBQUM7Z0JBQU1uWixPQUFPO29CQUN2a0JzcUIsYUFBYTh1QixVQUFVOXVCLFdBQVc7b0JBQ2xDRCxpQkFBaUIrdUIsVUFBVS91QixlQUFlO2dCQUM5QztnQkFBR2lxQixLQUFLMEU7WUFBVSxHQUFHN2xCLGtCQUFrQmpELEtBQUs5ekIsV0FDNUNKLHVEQUFhQSxDQUFDLE9BQU87Z0JBQUVtdUIsV0FBVztnQkFBaUJtcUIsS0FBS21GO2dCQUFZejVDLE9BQU87b0JBQUVvcUIsT0FBT2d2QixVQUFVN3VCLFNBQVM7Z0JBQUM7WUFBRSxHQUFHbXZCLGVBQzdHTixVQUFVdm1CLGdCQUFnQixJQUN0QjcyQix1REFBYUEsQ0FBQyxPQUFPO2dCQUFFbXVCLFdBQVc7WUFBMEMsSUFDaEZpdkIsVUFBVXRtQixjQUFjLElBQ3BCOTJCLHVEQUFhQSxDQUFDLE9BQU87Z0JBQUVtdUIsV0FBVztZQUF3QztRQUFNO0lBQzVGO0lBQ0EsT0FBTzg5QztBQUNYLEVBQUU5ekI7QUFDRixTQUFTZzBCLHFCQUFxQkMsVUFBVSxFQUFFO0lBQ3RDLE9BQVFwc0UsdURBQWFBLENBQUMsT0FBTztRQUFFbXVCLFdBQVc7SUFBc0IsR0FDNURpK0MsV0FBV1IsUUFBUSxJQUFLNXJFLHVEQUFhQSxDQUFDLE9BQU87UUFBRW11QixXQUFXO0lBQWdCLEdBQUdpK0MsV0FBV1IsUUFBUSxHQUNoRzVyRSx1REFBYUEsQ0FBQyxPQUFPO1FBQUVtdUIsV0FBVztJQUEyQixHQUN6RG51Qix1REFBYUEsQ0FBQyxPQUFPO1FBQUVtdUIsV0FBVztJQUEyQixHQUFHaStDLFdBQVc1MEMsS0FBSyxDQUFDckksS0FBSyxJQUFJbnZCLHVEQUFhQSxDQUFDQyw4Q0FBUUEsRUFBRSxJQUFJLEVBQUU7QUFDcEk7QUFFQSxJQUFJb3NFLG1CQUFtQixTQUFVMW9FLEtBQUssRUFBRTtJQUFFLE9BQVEzRCx1REFBYUEsQ0FBQzIyQyxnQkFBZ0JrSCxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVV6OUMsT0FBTyxFQUFFO1FBQy9HLElBQUlxUyxVQUFVclMsUUFBUXFTLE9BQU87UUFDN0IsSUFBSTJxQyxZQUFZO1lBQ1prdkIsUUFBUTNvRSxNQUFNMm9FLE1BQU07WUFDcEJ6K0QsTUFBTXpOLFFBQVF3UixPQUFPLENBQUMrbUIsTUFBTSxDQUFDaDFCLE1BQU1rSyxJQUFJO1lBQ3ZDOHBCLE1BQU12M0IsUUFBUXczQixPQUFPO1FBQ3pCO1FBQ0EsT0FBUTUzQix1REFBYUEsQ0FBQys4QyxZQUFZO1lBQUVLLFdBQVdBO1lBQVdoeUIsWUFBWTNZLFFBQVFvUCxzQkFBc0I7WUFBRXdKLFNBQVM1WSxRQUFRcVAsbUJBQW1CO1lBQUV3SixVQUFVN1ksUUFBUXNQLG9CQUFvQjtZQUFFd0osYUFBYTlZLFFBQVF1UCx1QkFBdUI7UUFBQyxHQUFHcmUsTUFBTUosUUFBUTtJQUN0UDtBQUFLO01BUkQ4b0U7QUFVSixJQUFJRSxpQkFBaUJ6dEQsZ0JBQWdCO0lBQUV4SyxLQUFLO0FBQVU7QUFDdEQsSUFBSWs0RCxpQkFBaUIsV0FBVyxHQUFJLFNBQVVsNEIsTUFBTSxFQUFFO0lBQ2xEMTBDLGdEQUFTQSxDQUFDNHNFLGdCQUFnQmw0QjtJQUMxQixTQUFTazRCLGlCQUFpQjtRQUN0QixPQUFPbDRCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7SUFDbkU7SUFDQXcwRCxlQUFlbHNFLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUMxQyxJQUFJLzRDLEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87UUFDckQsSUFBSXFTLFVBQVVyUyxRQUFRcVMsT0FBTztRQUM3QixJQUFJMnFDLFlBQVlxdkIsdUJBQXVCO1lBQ25DNStELE1BQU1sSyxNQUFNa0ssSUFBSTtZQUNoQmd0QixhQUFhbDNCLE1BQU1rM0IsV0FBVztZQUM5QnpFLFlBQVl6eUIsTUFBTXl5QixVQUFVO1lBQzVCczJDLGVBQWUvb0UsTUFBTStvRSxhQUFhO1lBQ2xDQyxZQUFZaHBFLE1BQU0yNUQsY0FBYztZQUNoQzFsQyxTQUFTeDNCLFFBQVF3M0IsT0FBTztZQUN4QmhtQixTQUFTeFIsUUFBUXdSLE9BQU87UUFDNUI7UUFDQSxPQUFRNVIsdURBQWFBLENBQUNzOUMsYUFBYTtZQUFFRixXQUFXQTtZQUFXL3hCLFNBQVM1WSxRQUFRa08sY0FBYztZQUFFNDhCLGdCQUFnQjU1QyxNQUFNNDVDLGNBQWM7UUFBQyxHQUFHNTVDLE1BQU1KLFFBQVE7SUFDdEo7SUFDQSxPQUFPaXBFO0FBQ1gsRUFBRXIwQjtBQUNGLFNBQVNzMEIsdUJBQXVCNWdELEdBQUcsRUFBRTtJQUNqQyxJQUFJaGUsT0FBT2dlLElBQUloZSxJQUFJLEVBQUUrRCxVQUFVaWEsSUFBSWphLE9BQU87SUFDMUMsSUFBSXVyRCxVQUFVN3dCLFlBQVl6K0IsTUFBTWdlLElBQUl1SyxVQUFVLEVBQUUsSUFBSSxFQUFFdkssSUFBSWdQLFdBQVc7SUFDckUsT0FBT243QiwrQ0FBUUEsQ0FBQ0EsK0NBQVFBLENBQUNBLCtDQUFRQSxDQUFDO1FBQUVtTyxNQUFNK0QsUUFBUSttQixNQUFNLENBQUM5cUI7UUFBTzhwQixNQUFNOUwsSUFBSStMLE9BQU87SUFBQyxHQUFHdWxDLFVBQVU7UUFBRXlQLGVBQWUvZ0QsSUFBSTZnRCxhQUFhLEdBQUc5NkQsUUFBUXRRLE1BQU0sQ0FBQ3VNLE1BQU0wK0Qsa0JBQWtCLEVBQUU7SUFBQyxJQUFJMWdELElBQUk4Z0QsVUFBVTtBQUNwTTtBQUVBLElBQUlFLGNBQWMsV0FBVyxHQUFJLFNBQVV2NEIsTUFBTSxFQUFFO0lBQy9DMTBDLGdEQUFTQSxDQUFDaXRFLGFBQWF2NEI7SUFDdkIsU0FBU3U0QixjQUFjO1FBQ25CLElBQUkzMEQsUUFBUW84QixXQUFXLElBQUksSUFBSUEsT0FBT2xyQyxLQUFLLENBQUMsSUFBSSxFQUFFNE8sY0FBYyxJQUFJO1FBQ3BFRSxNQUFNNDBELGVBQWUsR0FBRzcwRCxjQUFjdzBEO1FBQ3RDdjBELE1BQU15bEMsbUJBQW1CLEdBQUdvQjtRQUM1QixPQUFPN21DO0lBQ1g7SUFDQTIwRCxZQUFZdnNFLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUN2QyxJQUFJLzRDLEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87UUFDckQsSUFBSXFTLFVBQVVyUyxRQUFRcVMsT0FBTztRQUM3QixJQUFJMnFDLFlBQVksSUFBSSxDQUFDMHZCLGVBQWUsQ0FBQztZQUNqQ2ovRCxNQUFNbEssTUFBTWtLLElBQUk7WUFDaEJndEIsYUFBYWwzQixNQUFNazNCLFdBQVc7WUFDOUJ6RSxZQUFZenlCLE1BQU15eUIsVUFBVTtZQUM1QnMyQyxlQUFlL29FLE1BQU0rb0UsYUFBYTtZQUNsQ0MsWUFBWWhwRSxNQUFNMjVELGNBQWM7WUFDaEMxbEMsU0FBU3gzQixRQUFRdzNCLE9BQU87WUFDeEJobUIsU0FBU3hSLFFBQVF3UixPQUFPO1FBQzVCO1FBQ0EsSUFBSXdaLGFBQWFxaEIsaUJBQWlCMlEsV0FBV2g5QyxRQUFRc3NDLEtBQUssRUFBRWwrQixNQUFNLENBQUM0dUMsVUFBVTdRLFVBQVUsR0FDakYsRUFBRSxDQUFDLDBDQUEwQztXQUM3QyxJQUFJLENBQUNvUixtQkFBbUIsQ0FBQ2xyQyxRQUFRaU8saUJBQWlCLEVBQUUwOEIsVUFBVTtRQUNwRSxJQUFJMnZCLFlBQVkzdkIsVUFBVTdRLFVBQVUsR0FBRyxDQUFDLElBQUk7WUFDeEMsYUFBYTUxQixnQkFBZ0JoVCxNQUFNa0ssSUFBSTtRQUMzQyxDQUFDO1FBQ0QsT0FBUTdOLHVEQUFhQSxDQUFDcTlDLFdBQVc7WUFBRUQsV0FBV0E7WUFBVzl4QixVQUFVN1ksUUFBUW1PLGVBQWU7WUFBRTJLLGFBQWE5WSxRQUFRb08sa0JBQWtCO1lBQUVxOEIsT0FBT3Y1QyxNQUFNdTVDLEtBQUs7UUFBQyxHQUFHLFNBQVVGLFNBQVMsRUFBRTtZQUFFLE9BQU9yNUMsTUFBTUosUUFBUSxDQUFDeTVDLFdBQVc1eEIsWUFBWTJoRCxXQUFXM3ZCLFVBQVU3USxVQUFVO1FBQUc7SUFDclE7SUFDQSxPQUFPc2dDO0FBQ1gsRUFBRTEwQjtBQUVGLFNBQVM2MEIsV0FBV0MsUUFBUSxFQUFFO0lBQzFCLE9BQVFqdEUsdURBQWFBLENBQUMsT0FBTztRQUFFbXVCLFdBQVcsUUFBUTgrQztJQUFTO0FBQy9EO0FBQ0EsSUFBSUMsVUFBVSxTQUFVdnBFLEtBQUssRUFBRTtJQUFFLE9BQVEzRCx1REFBYUEsQ0FBQzJyRSxXQUFXO1FBQUVwdUIsZ0JBQWdCUztRQUFvQjlwQixLQUFLdndCLE1BQU11d0IsR0FBRyxDQUFDLG9CQUFvQjtRQUFJMDNDLFVBQVU7UUFBSUMsaUJBQWlCLElBQUk7UUFBRUMsaUJBQWlCLElBQUk7UUFBRS8wQyxZQUFZLEtBQUs7UUFBRUMsWUFBWSxLQUFLO1FBQUUrMEMsaUJBQWlCLEtBQUs7UUFBRTkwQyxZQUFZLEtBQUs7UUFBRVYsUUFBUTV5QixNQUFNNHlCLE1BQU07UUFBRUMsVUFBVTd5QixNQUFNNnlCLFFBQVE7UUFBRUMsU0FBUzl5QixNQUFNOHlCLE9BQU87SUFBQyxHQUFHLFNBQVV1bUIsU0FBUyxFQUFFNXhCLFVBQVUsRUFBRXF5QixVQUFVLEVBQUVDLFlBQVksRUFBRU4sU0FBUyxFQUFFO1FBQUUsT0FBUXA5Qyx1REFBYUEsQ0FBQyxPQUFPO1lBQUVzNEMsS0FBSzBFO1lBQVc3dUIsV0FBVztnQkFBQzthQUFjLENBQUMzZixNQUFNLENBQUM0YyxZQUFZak8sSUFBSSxDQUFDO1lBQU1uWixPQUFPO2dCQUNyaEJxcUIsaUJBQWlCK3VCLFVBQVUvdUIsZUFBZTtZQUM5QztRQUFFLEdBQUdxdkI7SUFBZ0I7QUFBSztNQUYxQnd2QjtBQUdKLFNBQVNsdkIsbUJBQW1CcjZDLEtBQUssRUFBRTtJQUMvQixJQUFJd3JCLFFBQVF4ckIsTUFBTTZ6QixLQUFLLENBQUNySSxLQUFLO0lBQzdCLE9BQU9BLFNBQVVudkIsdURBQWFBLENBQUMsT0FBTztRQUFFbXVCLFdBQVc7SUFBaUIsR0FBR3hxQixNQUFNNnpCLEtBQUssQ0FBQ3JJLEtBQUs7QUFDNUY7QUFFQSxJQUFJZytDLGlCQUFpQixTQUFVeHBFLEtBQUssRUFBRTtJQUFFLE9BQVEzRCx1REFBYUEsQ0FBQzIyQyxnQkFBZ0JrSCxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVV6OUMsT0FBTyxFQUFFO1FBQzdHLElBQUl3UixVQUFVeFIsUUFBUXdSLE9BQU8sRUFBRWEsVUFBVXJTLFFBQVFxUyxPQUFPO1FBQ3hELElBQUk1RSxPQUFPbEssTUFBTWtLLElBQUk7UUFDckIsSUFBSXZNLFNBQVNtUixRQUFRNlEsZ0JBQWdCLElBQUkzZixNQUFNeXBFLGFBQWE7UUFDNUQsSUFBSXZ3RCxNQUFNakwsUUFBUThKLGlCQUFpQixDQUFDN04sT0FBTyw0Q0FBNEM7UUFDdkYsSUFBSWs3QyxPQUFPbjNDLFFBQVF0USxNQUFNLENBQUN1TSxNQUFNdk07UUFDaEMsSUFBSTg3QyxZQUFZO1lBQUV2Z0MsS0FBS0E7WUFBS2tzQyxNQUFNQTtZQUFNbDdDLE1BQU1BO1FBQUs7UUFDbkQsT0FBUTdOLHVEQUFhQSxDQUFDKzhDLFlBQVk7WUFBRUssV0FBV0E7WUFBV2h5QixZQUFZM1ksUUFBUTJPLG9CQUFvQjtZQUFFaUssU0FBUzVZLFFBQVE0TyxpQkFBaUI7WUFBRWs4QixnQkFBZ0I4dkI7WUFBYS9oRCxVQUFVN1ksUUFBUTZPLGtCQUFrQjtZQUFFaUssYUFBYTlZLFFBQVE4TyxxQkFBcUI7UUFBQyxHQUFHNWQsTUFBTUosUUFBUTtJQUMzUTtBQUFLO01BUkQ0cEU7QUFTSixTQUFTRSxZQUFZakIsVUFBVSxFQUFFO0lBQzdCLE9BQU9BLFdBQVdyakIsSUFBSTtBQUMxQjtBQUVBLElBQUl1a0Isd0JBQXdCO0FBQzVCLElBQUlDLFVBQVUsV0FBVyxHQUFJLFNBQVVqNUIsTUFBTSxFQUFFO0lBQzNDMTBDLGdEQUFTQSxDQUFDMnRFLFNBQVNqNUI7SUFDbkIsU0FBU2k1QixVQUFVO1FBQ2YsSUFBSXIxRCxRQUFRbzhCLFdBQVcsSUFBSSxJQUFJQSxPQUFPbHJDLEtBQUssQ0FBQyxJQUFJLEVBQUU0TyxjQUFjLElBQUk7UUFDcEVFLE1BQU00bEIsS0FBSyxHQUFHO1lBQ1Z1NkIsU0FBUzF6RDtRQUNiO1FBQ0F1VCxNQUFNK2tDLFlBQVksR0FBRyxTQUFVejdDLEVBQUUsRUFBRTtZQUMvQjBXLE1BQU00bUMsTUFBTSxHQUFHdDlDO1lBQ2YsSUFBSTBXLE1BQU12VSxLQUFLLENBQUN1NUMsS0FBSyxFQUFFO2dCQUNuQjdFLE9BQU9uZ0MsTUFBTXZVLEtBQUssQ0FBQ3U1QyxLQUFLLEVBQUUxN0M7WUFDOUIsQ0FBQztRQUNMO1FBQ0Esc0ZBQXNGO1FBQ3RGMFcsTUFBTXMxRCx1QkFBdUIsR0FBRyxTQUFVcnBFLEVBQUUsRUFBRTtZQUMxQyxrRUFBa0U7WUFDbEUsSUFBSUksU0FBU0wsc0JBQXNCQztZQUNuQyxJQUFJLENBQUMrVCxNQUFNNG1DLE1BQU0sQ0FBQzk4QyxRQUFRLENBQUN1QyxTQUFTO2dCQUNoQzJULE1BQU11MUQsZ0JBQWdCO1lBQzFCLENBQUM7UUFDTDtRQUNBdjFELE1BQU13MUQscUJBQXFCLEdBQUcsU0FBVXZwRSxFQUFFLEVBQUU7WUFDeEMsSUFBSUEsR0FBR29DLEdBQUcsS0FBSyxVQUFVO2dCQUNyQjJSLE1BQU11MUQsZ0JBQWdCO1lBQzFCLENBQUM7UUFDTDtRQUNBdjFELE1BQU11MUQsZ0JBQWdCLEdBQUcsV0FBWTtZQUNqQyxJQUFJRSxVQUFVejFELE1BQU12VSxLQUFLLENBQUNncUUsT0FBTztZQUNqQyxJQUFJQSxTQUFTO2dCQUNUQTtZQUNKLENBQUM7UUFDTDtRQUNBLE9BQU96MUQ7SUFDWDtJQUNBcTFELFFBQVFqdEUsU0FBUyxDQUFDNjhDLE1BQU0sR0FBRyxXQUFZO1FBQ25DLElBQUkvNEMsS0FBSyxJQUFJLENBQUNoRSxPQUFPLEVBQUVzc0MsUUFBUXRvQyxHQUFHc29DLEtBQUssRUFBRWo2QixVQUFVck8sR0FBR3FPLE9BQU87UUFDN0QsSUFBSXBPLEtBQUssSUFBSSxFQUFFVixRQUFRVSxHQUFHVixLQUFLLEVBQUVtNkIsUUFBUXo1QixHQUFHeTVCLEtBQUs7UUFDakQsSUFBSTFTLGFBQWE7WUFDYjtZQUNBc2hCLE1BQU1DLFFBQVEsQ0FBQztTQUNsQixDQUFDbitCLE1BQU0sQ0FBQzdLLE1BQU1rNkQsZUFBZSxJQUFJLEVBQUU7UUFDcEMsT0FBTzM5RCxzREFBWUEsQ0FBQ0YsdURBQWFBLENBQUMsT0FBT04sK0NBQVFBLENBQUM7WUFBRXd2QixJQUFJdnJCLE1BQU11ckIsRUFBRTtZQUFFZixXQUFXL0MsV0FBV2pPLElBQUksQ0FBQztZQUFNLG1CQUFtQjJnQixNQUFNdTZCLE9BQU87UUFBQyxHQUFHMTBELE1BQU1pcUUsVUFBVSxFQUFFO1lBQUV0MUIsS0FBSyxJQUFJLENBQUMyRSxZQUFZO1FBQUMsSUFDOUtqOUMsdURBQWFBLENBQUMsT0FBTztZQUFFbXVCLFdBQVcsdUJBQXVCdWUsTUFBTUMsUUFBUSxDQUFDO1FBQWlCLEdBQ3JGM3NDLHVEQUFhQSxDQUFDLFFBQVE7WUFBRW11QixXQUFXO1lBQW9CZSxJQUFJNE8sTUFBTXU2QixPQUFPO1FBQUMsR0FBRzEwRCxNQUFNd3JCLEtBQUssR0FDdkZudkIsdURBQWFBLENBQUMsUUFBUTtZQUFFbXVCLFdBQVcsc0JBQXNCdWUsTUFBTWdKLFlBQVksQ0FBQztZQUFVdm1CLE9BQU8xYyxRQUFRK1YsU0FBUztZQUFFcmlCLFNBQVMsSUFBSSxDQUFDc25FLGdCQUFnQjtRQUFDLEtBQ25KenRFLHVEQUFhQSxDQUFDLE9BQU87WUFBRW11QixXQUFXLHFCQUFxQnVlLE1BQU1DLFFBQVEsQ0FBQztRQUFrQixHQUFHaHBDLE1BQU1KLFFBQVEsSUFBSUksTUFBTWtxRSxRQUFRO0lBQ25JO0lBQ0FOLFFBQVFqdEUsU0FBUyxDQUFDMjlDLGlCQUFpQixHQUFHLFdBQVk7UUFDOUNuOEMsU0FBU3FELGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDcW9FLHVCQUF1QjtRQUNuRTFyRSxTQUFTcUQsZ0JBQWdCLENBQUMsV0FBVyxJQUFJLENBQUN1b0UscUJBQXFCO1FBQy9ELElBQUksQ0FBQzd3QyxVQUFVO0lBQ25CO0lBQ0Ewd0MsUUFBUWp0RSxTQUFTLENBQUM4OUMsb0JBQW9CLEdBQUcsV0FBWTtRQUNqRHQ4QyxTQUFTc0QsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUNvb0UsdUJBQXVCO1FBQ3RFMXJFLFNBQVNzRCxtQkFBbUIsQ0FBQyxXQUFXLElBQUksQ0FBQ3NvRSxxQkFBcUI7SUFDdEU7SUFDQUgsUUFBUWp0RSxTQUFTLENBQUN1OEIsVUFBVSxHQUFHLFdBQVk7UUFDdkMsSUFBSThZLFFBQVEsSUFBSSxDQUFDdjFDLE9BQU8sQ0FBQ3UxQyxLQUFLO1FBQzlCLElBQUl2eEMsS0FBSyxJQUFJLENBQUNULEtBQUssRUFBRW1xRSxjQUFjMXBFLEdBQUcwcEUsV0FBVyxFQUFFQyxlQUFlM3BFLEdBQUcycEUsWUFBWTtRQUNqRixJQUFJanZCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLElBQUlrdkIsZ0JBQWdCNTlCLHlCQUF5QjA5QjtRQUM3QyxJQUFJRSxlQUFlO1lBQ2YsSUFBSUMsY0FBY252QixPQUFPMzBDLHFCQUFxQjtZQUM5QyxnQ0FBZ0M7WUFDaEMsSUFBSStqRSxhQUFhSCxlQUNYcHNFLGVBQWVtc0UsYUFBYSxrQkFBa0IzakUscUJBQXFCLEdBQUcyOUIsR0FBRyxHQUN6RWttQyxjQUFjbG1DLEdBQUc7WUFDdkIsSUFBSXFtQyxjQUFjeDRCLFFBQVFxNEIsY0FBY25tQyxLQUFLLEdBQUdvbUMsWUFBWTdqRSxLQUFLLEdBQUc0akUsY0FBY3BtQyxJQUFJO1lBQ3RGLFlBQVk7WUFDWnNtQyxhQUFhdmlFLEtBQUt3TyxHQUFHLENBQUMrekQsWUFBWVo7WUFDbENhLGNBQWN4aUUsS0FBS3dCLEdBQUcsQ0FBQ2doRSxhQUFhcnNFLFNBQVNDLGVBQWUsQ0FBQ3NzQyxXQUFXLEdBQUdpL0Isd0JBQXdCVyxZQUFZN2pFLEtBQUs7WUFDcEgrakUsY0FBY3hpRSxLQUFLd08sR0FBRyxDQUFDZzBELGFBQWFiO1lBQ3BDLElBQUljLFdBQVd0dkIsT0FBT3V2QixZQUFZLENBQUNsa0UscUJBQXFCO1lBQ3hEekcsV0FBV283QyxRQUFRO2dCQUNmaFgsS0FBS29tQyxhQUFhRSxTQUFTdG1DLEdBQUc7Z0JBQzlCRixNQUFNdW1DLGNBQWNDLFNBQVN4bUMsSUFBSTtZQUNyQztRQUNKLENBQUM7SUFDTDtJQUNBLE9BQU8ybEM7QUFDWCxFQUFFcDFCO0FBRUYsSUFBSW0yQixjQUFjLFdBQVcsR0FBSSxTQUFVaDZCLE1BQU0sRUFBRTtJQUMvQzEwQyxnREFBU0EsQ0FBQzB1RSxhQUFhaDZCO0lBQ3ZCLFNBQVNnNkIsY0FBYztRQUNuQixJQUFJcDJELFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTStrQyxZQUFZLEdBQUcsU0FBVTZCLE1BQU0sRUFBRTtZQUNuQzVtQyxNQUFNNG1DLE1BQU0sR0FBR0E7WUFDZixJQUFJQSxRQUFRO2dCQUNSNW1DLE1BQU05WCxPQUFPLENBQUM0MkMsNEJBQTRCLENBQUM5K0IsT0FBTztvQkFDOUMxVyxJQUFJczlDO29CQUNKb1ksZ0JBQWdCLEtBQUs7Z0JBQ3pCO1lBQ0osT0FDSztnQkFDRGgvQyxNQUFNOVgsT0FBTyxDQUFDNjJDLDhCQUE4QixDQUFDLytCO1lBQ2pELENBQUM7UUFDTDtRQUNBLE9BQU9BO0lBQ1g7SUFDQW8yRCxZQUFZaHVFLFNBQVMsQ0FBQzY4QyxNQUFNLEdBQUcsV0FBWTtRQUN2QyxJQUFJLzRDLEtBQUssSUFBSSxDQUFDaEUsT0FBTyxFQUFFcVMsVUFBVXJPLEdBQUdxTyxPQUFPLEVBQUViLFVBQVV4TixHQUFHd04sT0FBTztRQUNqRSxJQUFJak8sUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSTRxRSxZQUFZNXFFLE1BQU00cUUsU0FBUyxFQUFFbjRDLGFBQWF6eUIsTUFBTXl5QixVQUFVLEVBQUV5RSxjQUFjbDNCLE1BQU1rM0IsV0FBVztRQUMvRixJQUFJMUwsUUFBUXZkLFFBQVF0USxNQUFNLENBQUNpdEUsV0FBVzk3RCxRQUFRbU4sZ0JBQWdCO1FBQzlELE9BQVE1Zix1REFBYUEsQ0FBQzZzRSxhQUFhO1lBQUVoL0QsTUFBTTBnRTtZQUFXMXpDLGFBQWFBO1lBQWF6RSxZQUFZQTtZQUFZOG1CLE9BQU8sSUFBSSxDQUFDRCxZQUFZO1FBQUMsR0FBRyxTQUFVRCxTQUFTLEVBQUV3eEIsYUFBYSxFQUFFekIsU0FBUyxFQUFFO1lBQUUsT0FBUS9zRSx1REFBYUEsQ0FBQ3V0RSxTQUFTO2dCQUFFcndCLE9BQU9GO2dCQUFXOXRCLElBQUl2ckIsTUFBTXVyQixFQUFFO2dCQUFFQyxPQUFPQTtnQkFBTzB1QyxpQkFBaUI7b0JBQUM7aUJBQWtCLENBQUNydkQsTUFBTSxDQUFDZ2dFO2dCQUFnQlosWUFBWWIsVUFBVSxtREFBbUQ7Z0JBQUljLFVBQVVscUUsTUFBTWtxRSxRQUFRO2dCQUFFQyxhQUFhbnFFLE1BQU1tcUUsV0FBVztnQkFBRUMsY0FBY3BxRSxNQUFNb3FFLFlBQVk7Z0JBQUVKLFNBQVNocUUsTUFBTWdxRSxPQUFPO1lBQUMsR0FDNWYzdEUsdURBQWFBLENBQUN3c0UsZ0JBQWdCO2dCQUFFMytELE1BQU0wZ0U7Z0JBQVcxekMsYUFBYUE7Z0JBQWF6RSxZQUFZQTtZQUFXLEdBQUcsU0FBVXFuQixVQUFVLEVBQUVDLFlBQVksRUFBRTtnQkFBRSxPQUFRQSxnQkFDL0kxOUMsdURBQWFBLENBQUMsT0FBTztvQkFBRW11QixXQUFXO29CQUF3Qm1xQixLQUFLbUY7Z0JBQVcsR0FBR0M7WUFBZ0IsSUFDakcvNUMsTUFBTUosUUFBUTtRQUFJO0lBQzFCO0lBQ0ErcUUsWUFBWWh1RSxTQUFTLENBQUNxNEMsUUFBUSxHQUFHLFNBQVVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRTtRQUNyRixJQUFJMzBDLEtBQUssSUFBSSxFQUFFMDZDLFNBQVMxNkMsR0FBRzA2QyxNQUFNLEVBQUVuN0MsUUFBUVMsR0FBR1QsS0FBSztRQUNuRCxJQUFJaTFDLGdCQUFnQixLQUFLQSxlQUFlRSxXQUNwQ0QsZUFBZSxLQUFLQSxjQUFjRSxVQUFVO1lBQzVDLE9BQU87Z0JBQ0hsZSxhQUFhbDNCLE1BQU1rM0IsV0FBVztnQkFDOUI3QixVQUFVdDVCLCtDQUFRQSxDQUFDO29CQUFFc1MsUUFBUSxJQUFJO29CQUFFbEQsT0FBTzt3QkFDbENzRSxPQUFPelAsTUFBTTRxRSxTQUFTO3dCQUN0Qmw3RCxLQUFLMVAsTUFBTTQ3QixPQUFPO29CQUN0QjtnQkFBRSxHQUFHNTdCLE1BQU04cUUsYUFBYTtnQkFDNUJDLE9BQU81dkI7Z0JBQ1BuWCxNQUFNO29CQUNGQyxNQUFNO29CQUNORSxLQUFLO29CQUNMRCxPQUFPaVI7b0JBQ1AvUSxRQUFRZ1I7Z0JBQ1o7Z0JBQ0E0MUIsT0FBTztZQUNYO1FBQ0osQ0FBQztRQUNELE9BQU8sSUFBSTtJQUNmO0lBQ0EsT0FBT0w7QUFDWCxFQUFFOTFCO0FBRUYsSUFBSW8yQixlQUFlLFdBQVcsR0FBSSxTQUFVdDZCLE1BQU0sRUFBRTtJQUNoRDEwQyxnREFBU0EsQ0FBQ2d2RSxjQUFjdDZCO0lBQ3hCLFNBQVNzNkIsZUFBZTtRQUNwQixJQUFJMTJELFFBQVFvOEIsV0FBVyxJQUFJLElBQUlBLE9BQU9sckMsS0FBSyxDQUFDLElBQUksRUFBRTRPLGNBQWMsSUFBSTtRQUNwRUUsTUFBTTIyRCxTQUFTLEdBQUc5dUUsbURBQVNBO1FBQzNCbVksTUFBTTRsQixLQUFLLEdBQUc7WUFDVmd4QyxlQUFlLEtBQUs7WUFDcEJDLFdBQVdwcUU7UUFDZjtRQUNBdVQsTUFBTTgyRCxXQUFXLEdBQUcsU0FBVTdxRSxFQUFFLEVBQUU7WUFDOUIsSUFBSUMsS0FBSzhULE9BQU92VSxRQUFRUyxHQUFHVCxLQUFLLEVBQUV2RCxVQUFVZ0UsR0FBR2hFLE9BQU87WUFDdEQsSUFBSXVvQixnQkFBZ0J2b0IsUUFBUXFTLE9BQU8sQ0FBQ2tXLGFBQWE7WUFDakQsSUFBSTlhLE9BQU9vaEUsYUFBYXRyRSxPQUFPeVAsS0FBSztZQUNwQyxTQUFTODdELGVBQWVoN0MsR0FBRyxFQUFFO2dCQUN6QixJQUFJOXZCLEtBQUs4dkIsSUFBSVksVUFBVSxFQUFFaGlCLE1BQU0xTyxHQUFHME8sR0FBRyxFQUFFRixXQUFXeE8sR0FBR3dPLFFBQVEsRUFBRTlELFFBQVExSyxHQUFHMEssS0FBSztnQkFDL0UsT0FBTztvQkFDSDBvQixPQUFPLElBQUlDLFNBQVNyM0IsU0FBUzBTLEtBQUtGO29CQUNsQ1EsT0FBT2hULFFBQVF3UixPQUFPLENBQUMrbUIsTUFBTSxDQUFDN3BCLE1BQU1zRSxLQUFLO29CQUN6Q0MsS0FBS2pULFFBQVF3UixPQUFPLENBQUMrbUIsTUFBTSxDQUFDN3BCLE1BQU11RSxHQUFHO29CQUNyQ29nQixTQUFTUyxJQUFJVCxPQUFPO29CQUNwQkMsT0FBT1EsSUFBSVIsS0FBSztnQkFDcEI7WUFDSjtZQUNBLElBQUksT0FBTy9LLGtCQUFrQixZQUFZO2dCQUNyQ0EsZ0JBQWdCQSxjQUFjO29CQUMxQjlhLE1BQU1BO29CQUNObUUsUUFBUXlOLFFBQVE5YixNQUFNd3JFLFVBQVU7b0JBQ2hDQyxTQUFTenJFLE1BQU15ckUsT0FBTyxDQUFDejdELEdBQUcsQ0FBQ3U3RDtvQkFDM0JHLFlBQVkxckUsTUFBTTByRSxVQUFVLENBQUMxN0QsR0FBRyxDQUFDdTdEO29CQUNqQ3gzQyxTQUFTdnpCO29CQUNUd3pCLE1BQU12M0IsUUFBUXczQixPQUFPO2dCQUN6QjtZQUNKLENBQUM7WUFDRCxJQUFJLENBQUNqUCxpQkFBaUJBLGtCQUFrQixXQUFXO2dCQUMvQ3pRLE1BQU02L0IsUUFBUSxDQUFDO29CQUFFKzJCLGVBQWUsSUFBSTtnQkFBQztZQUN6QyxPQUNLLElBQUksT0FBT25tRCxrQkFBa0IsVUFBVTtnQkFDeEN2b0IsUUFBUWs1QixXQUFXLENBQUN1RSxNQUFNLENBQUNod0IsTUFBTThhO1lBQ3JDLENBQUM7UUFDTDtRQUNBelEsTUFBTW8zRCxrQkFBa0IsR0FBRyxXQUFZO1lBQ25DcDNELE1BQU02L0IsUUFBUSxDQUFDO2dCQUFFKzJCLGVBQWUsS0FBSztZQUFDO1FBQzFDO1FBQ0EsT0FBTzUyRDtJQUNYO0lBQ0EwMkQsYUFBYXR1RSxTQUFTLENBQUM2OEMsTUFBTSxHQUFHLFdBQVk7UUFDeEMsSUFBSWpsQyxRQUFRLElBQUk7UUFDaEIsSUFBSTlULEtBQUssSUFBSSxFQUFFVCxRQUFRUyxHQUFHVCxLQUFLLEVBQUVtNkIsUUFBUTE1QixHQUFHMDVCLEtBQUs7UUFDakQsT0FBUTk5Qix1REFBYUEsQ0FBQzIyQyxnQkFBZ0JrSCxRQUFRLEVBQUUsSUFBSSxFQUFFLFNBQVV6OUMsT0FBTyxFQUFFO1lBQ3JFLElBQUl3M0IsVUFBVXgzQixRQUFRdzNCLE9BQU8sRUFBRW5sQixVQUFVclMsUUFBUXFTLE9BQU8sRUFBRTZtQixjQUFjbDVCLFFBQVFrNUIsV0FBVztZQUMzRixJQUFJelMsZUFBZXBVLFFBQVFvVSxZQUFZO1lBQ3ZDLElBQUkwb0QsVUFBVTVyRSxNQUFNNHJFLE9BQU87WUFDM0IsSUFBSXpnRSxRQUFRbWdFLGFBQWF0ckU7WUFDekIsSUFBSW9sRCxPQUFPLE9BQU9saUMsaUJBQWlCLFdBQVcsMENBQTBDO2VBQ2xGQSxhQUFhcmtCLElBQUksQ0FBQzgyQixhQUFhaTJDLFdBQy9CLE1BQU1BLFVBQVUsTUFBTTFvRCxZQUFZO1lBQ3hDLElBQUlzSSxRQUFRbm1CLG1CQUFtQnlKLFFBQVFxVSxZQUFZLEVBQUU7Z0JBQUN5b0Q7YUFBUSxFQUFFeG1CO1lBQ2hFLElBQUkzTCxZQUFZO2dCQUNadmdDLEtBQUsweUQ7Z0JBQ0xDLFdBQVcsTUFBTUQ7Z0JBQ2pCeG1CLE1BQU1BO2dCQUNOcHhCLE1BQU1DO1lBQ1Y7WUFDQSxPQUFRNTNCLHVEQUFhQSxDQUFDQyw4Q0FBUUEsRUFBRSxJQUFJLEVBQ2hDd2YsUUFBUTliLE1BQU00ckUsT0FBTyxLQUFNdnZFLHVEQUFhQSxDQUFDKzhDLFlBQVk7Z0JBQUVHLE9BQU9obEMsTUFBTTIyRCxTQUFTO2dCQUFFenhCLFdBQVdBO2dCQUFXaHlCLFlBQVkzWSxRQUFRbVcsa0JBQWtCO2dCQUFFeUMsU0FBUzVZLFFBQVFvVyxlQUFlO2dCQUFFMDBCLGdCQUFnQjU1QyxNQUFNNDVDLGNBQWMsSUFBSWt5QjtnQkFBcUJua0QsVUFBVTdZLFFBQVFxVyxnQkFBZ0I7Z0JBQUV5QyxhQUFhOVksUUFBUXNXLG1CQUFtQjtZQUFDLEdBQUcsU0FBVWkwQixTQUFTLEVBQUVxQyxnQkFBZ0IsRUFBRTVCLFVBQVUsRUFBRUMsWUFBWSxFQUFFO2dCQUFFLE9BQU8vNUMsTUFBTUosUUFBUSxDQUFDeTVDLFdBQVc7b0JBQUM7aUJBQWUsQ0FBQ3h1QyxNQUFNLENBQUM2d0MsbUJBQW1CNUIsWUFBWUMsY0FBY3hsQyxNQUFNODJELFdBQVcsRUFBRTcvQyxPQUFPMk8sTUFBTWd4QyxhQUFhLEVBQUVoeEMsTUFBTWd4QyxhQUFhLEdBQUdoeEMsTUFBTWl4QyxTQUFTLEdBQUcsRUFBRTtZQUFHLElBQ2prQmp4QyxNQUFNZ3hDLGFBQWEsSUFBSzl1RSx1REFBYUEsQ0FBQ3N1RSxhQUFhO2dCQUFFcC9DLElBQUk0TyxNQUFNaXhDLFNBQVM7Z0JBQUVSLFdBQVd6L0QsTUFBTXNFLEtBQUs7Z0JBQUVtc0IsU0FBU3p3QixNQUFNdUUsR0FBRztnQkFBRXduQixhQUFhbDNCLE1BQU1rM0IsV0FBVztnQkFBRXpFLFlBQVl6eUIsTUFBTXl5QixVQUFVO2dCQUFFcTRDLGVBQWU5cUUsTUFBTThxRSxhQUFhO2dCQUFFWixVQUFVMzFELE1BQU0yMUQsUUFBUTtnQkFBRUMsYUFBYW5xRSxNQUFNK3JFLGNBQWMsQ0FBQ24zQixPQUFPO2dCQUFFdzFCLGNBQWNwcUUsTUFBTW9xRSxZQUFZO2dCQUFFSixTQUFTejFELE1BQU1vM0Qsa0JBQWtCO1lBQUMsR0FBRzNyRSxNQUFNZ3NFLGNBQWM7UUFDaFk7SUFDSjtJQUNBZixhQUFhdHVFLFNBQVMsQ0FBQzI5QyxpQkFBaUIsR0FBRyxXQUFZO1FBQ25ELElBQUksQ0FBQzJ4QixjQUFjO0lBQ3ZCO0lBQ0FoQixhQUFhdHVFLFNBQVMsQ0FBQzY5QyxrQkFBa0IsR0FBRyxXQUFZO1FBQ3BELElBQUksQ0FBQ3l4QixjQUFjO0lBQ3ZCO0lBQ0FoQixhQUFhdHVFLFNBQVMsQ0FBQ3N2RSxjQUFjLEdBQUcsV0FBWTtRQUNoRCxJQUFJLElBQUksQ0FBQ2YsU0FBUyxDQUFDdDJCLE9BQU8sRUFBRTtZQUN4QixJQUFJLENBQUNzMUIsUUFBUSxHQUFHbHNFLGVBQWUsSUFBSSxDQUFDa3RFLFNBQVMsQ0FBQ3QyQixPQUFPLEVBQUU7UUFDM0QsQ0FBQztJQUNMO0lBQ0EsT0FBT3EyQjtBQUNYLEVBQUV6MkI7QUFDRixTQUFTczNCLG9CQUFvQjlyRSxLQUFLLEVBQUU7SUFDaEMsT0FBT0EsTUFBTW9sRCxJQUFJO0FBQ3JCO0FBQ0EsU0FBU2ttQixhQUFhdHJFLEtBQUssRUFBRTtJQUN6QixJQUFJQSxNQUFNd3JFLFVBQVUsRUFBRTtRQUNsQixPQUFPO1lBQ0gvN0QsT0FBT3pQLE1BQU13ckUsVUFBVTtZQUN2Qjk3RCxLQUFLM0ksUUFBUS9HLE1BQU13ckUsVUFBVSxFQUFFO1FBQ25DO0lBQ0osQ0FBQztJQUNELElBQUlFLGFBQWExckUsTUFBTTByRSxVQUFVO0lBQ2pDLE9BQU87UUFDSGo4RCxPQUFPeThELHdCQUF3QlI7UUFDL0JoOEQsS0FBS3k4RCxvQkFBb0JUO0lBQzdCO0FBQ0o7QUFDQSxTQUFTUSx3QkFBd0JyN0MsSUFBSSxFQUFFO0lBQ25DLE9BQU9BLEtBQUtuckIsTUFBTSxDQUFDMG1FLG1CQUFtQmo3QyxVQUFVLENBQUNobUIsS0FBSyxDQUFDc0UsS0FBSztBQUNoRTtBQUNBLFNBQVMyOEQsa0JBQWtCQyxJQUFJLEVBQUVDLElBQUksRUFBRTtJQUNuQyxPQUFPRCxLQUFLbDdDLFVBQVUsQ0FBQ2htQixLQUFLLENBQUNzRSxLQUFLLEdBQUc2OEQsS0FBS243QyxVQUFVLENBQUNobUIsS0FBSyxDQUFDc0UsS0FBSyxHQUFHNDhELE9BQU9DLElBQUk7QUFDbEY7QUFDQSxTQUFTSCxvQkFBb0J0N0MsSUFBSSxFQUFFO0lBQy9CLE9BQU9BLEtBQUtuckIsTUFBTSxDQUFDNm1FLGVBQWVwN0MsVUFBVSxDQUFDaG1CLEtBQUssQ0FBQ3VFLEdBQUc7QUFDMUQ7QUFDQSxTQUFTNjhELGNBQWNGLElBQUksRUFBRUMsSUFBSSxFQUFFO0lBQy9CLE9BQU9ELEtBQUtsN0MsVUFBVSxDQUFDaG1CLEtBQUssQ0FBQ3VFLEdBQUcsR0FBRzQ4RCxLQUFLbjdDLFVBQVUsQ0FBQ2htQixLQUFLLENBQUN1RSxHQUFHLEdBQUcyOEQsT0FBT0MsSUFBSTtBQUM5RTtBQUVBLFVBQVU7QUFDVixxR0FBcUc7QUFDckcsSUFBSUUsVUFBVSxVQUFVLG9EQUFvRDtBQUUyNkcsQ0FDdi9HLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcz81NWM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjExLjNcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIyIEFkYW0gU2hhd1xuKi9cbmltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBDb21wb25lbnQsIGNyZWF0ZVJlZiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGNyZWF0ZVBvcnRhbCB9IGZyb20gJy4vdmRvbS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Zkb20uanMnO1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIEV2ZW50U291cmNlQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlQXBpKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICB9XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxuICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRXZlbnRTb3VyY2VBcGk7XG59KCkpO1xuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxufVxuLy8gUXVlcnlpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgLy8gcmVhbGx5IGJhZCBmYWxsYmFjayBmb3IgSUVcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSk7XG4gICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG1ldGhvZCA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBtZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4vLyBUT0RPOiBhY2NlcHQgdGhlIGRvY3VtZW50XG5mdW5jdGlvbiBmaW5kRWxlbWVudHMoY29udGFpbmVyLCBzZWxlY3Rvcikge1xuICAgIHZhciBjb250YWluZXJzID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbY29udGFpbmVyXSA6IGNvbnRhaW5lcjtcbiAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRhaW5lcnNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKG1hdGNoZXNbal0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gb25seSBxdWVyaWVzIGRpcmVjdCBjaGlsZCBlbGVtZW50cyAvLyBUT0RPOiByZW5hbWUgdG8gZmluZERpcmVjdENoaWxkcmVuIVxuZnVuY3Rpb24gZmluZERpcmVjdENoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnQ7XG4gICAgdmFyIGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuOyAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsO1xuICAgIH1cbn1cbi8vIEV2ZW50IEhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpZiBpbnRlcmNlcHRpbmcgYnViYmxlZCBldmVudHMgYXQgdGhlIGRvY3VtZW50L3dpbmRvdy9ib2R5IGxldmVsLFxuLy8gYW5kIHdhbnQgdG8gc2VlIG9yaWdpbmF0aW5nIGVsZW1lbnQgKHRoZSAndGFyZ2V0JyksIHVzZSB0aGlzIHV0aWwgaW5zdGVhZFxuLy8gb2YgYGV2LnRhcmdldGAgYmVjYXVzZSBpdCBnb2VzIHdpdGhpbiB3ZWItY29tcG9uZW50IGJvdW5kYXJpZXMuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBldi5jb21wb3NlZFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGV2KVswXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXYudGFyZ2V0O1xufVxuLy8gU2hhZG93IERPTSBjb25zdWRlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0RWxSb290KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xufVxuLy8gVW5pcXVlIElEIGZvciBET00gYXR0cmlidXRlXG52YXIgZ3VpZCQxID0gMDtcbmZ1bmN0aW9uIGdldFVuaXF1ZURvbUlkKCkge1xuICAgIGd1aWQkMSArPSAxO1xuICAgIHJldHVybiAnZmMtZG9tLScgKyBndWlkJDE7XG59XG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xufVxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG1hdGNoZWRDaGlsZCA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgc2VsZWN0b3IpO1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHZhciBhdHRhY2hlZEhhbmRsZXIgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb250YWluZXIsIHNlbGVjdG9yLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSkge1xuICAgIHZhciBjdXJyZW50TWF0Y2hlZENoaWxkO1xuICAgIHJldHVybiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHNlbGVjdG9yLCBmdW5jdGlvbiAobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkICE9PSBjdXJyZW50TWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbWF0Y2hlZENoaWxkO1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgdmFyIHJlYWxPbk1vdXNlTGVhdmVfMSA9IGZ1bmN0aW9uIChtb3VzZUxlYXZlRXYpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiBfX2Fzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxudmFyIGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy11bnNlbGVjdGFibGUnKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIHZhciBzcGVjcyA9IFtdO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIHZhciBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgYXJnLCBpbmRleCkgeyByZXR1cm4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKTsgfSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbi8qIE51bWJlciBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XG59XG4vKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcbiAgICB2YXIgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcbiAgICB2YXIgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcbiAgICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XG4gICAgfVxuICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXG4gICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xufVxuXG52YXIgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgdmFyIG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgdmFyIG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICB2YXIgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIHZhciB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgdmFyIG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgdmFyIGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIHZhciBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICB2YXIgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgdmFyIGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZDogZGVmSWQsXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICAgIH07XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XG4gICAgdmFyIGRlc3QgPSB7fTtcbiAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHByb3BPYmpzW2ldW25hbWVfMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVfMV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXzFdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAodmFyIGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lXzIgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV8yXSA9IHByb3BzW25hbWVfMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgdmFyIG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFfMVtfaV07XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGJ1aWxkSGFzaEZyb21BcnJheShhLCBmdW5jKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHR1cGxlID0gZnVuYyhhW2ldLCBpKTtcbiAgICAgICAgaGFzaFt0dXBsZVswXV0gPSB0dXBsZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGlmIChvYmowID09PSBvYmoxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzKSB7XG4gICAgaWYgKGVxdWFsaXR5RnVuY3MgPT09IHZvaWQgMCkgeyBlcXVhbGl0eUZ1bmNzID0ge307IH1cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yICh2YXIga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cbiAgICB2YXIgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICB2YXIgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXk7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3MsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZjsgfSk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBkZWYucmVjdXJyaW5nRGVmLmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdGFydHNfMSA9IHN0YXJ0czsgX2kgPCBzdGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICB2YXIgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIHZhciBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG52YXIgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xudmFyIFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoKF9hID0ge30sIF9hW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddID0gaW5wdXQsIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIHZhciBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgdmFyIHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICB2YXIgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXG5mdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lKSB7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cbiAgICB2YXIgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xuICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XG4vLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcbi8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXG5mdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XG59XG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvKSB7XG4gICAgaWYgKGRvSXNvID09PSB2b2lkIDApIHsgZG9Jc28gPSBmYWxzZTsgfVxuICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW5zLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiR01UXCIgKyBzaWduICsgaG91cnMgKyAobWlucyA/IFwiOlwiICsgcGFkU3RhcnQobWlucywgMikgOiAnJyk7XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGEwLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgY3VycmVudEFyZ3M7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBcmdzKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJncywgbmV3QXJncykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPYmpBcmcod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmc7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmcpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKF90aGlzLCBuZXdBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1Byb3BzRXF1YWwoY3VycmVudEFyZywgbmV3QXJnKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmNhbGwoX3RoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnU2V0cyA9IFtdO1xuICAgIHZhciBjdXJyZW50UmVzdWx0cyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnU2V0cykge1xuICAgICAgICB2YXIgY3VycmVudExlbiA9IGN1cnJlbnRBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdTZXRzW2ldLCBuZXdBcmdTZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmdIYXNoID0ge307XG4gICAgdmFyIGN1cnJlbnRSZXNIYXNoID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmdIYXNoKSB7XG4gICAgICAgIHZhciBuZXdSZXNIYXNoID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KF90aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnSGFzaFtrZXldKTtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSAocmVzRXF1YWxpdHkgJiYgcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzSGFzaFtrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50UmVzSGFzaFtrZXldXG4gICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gY3VycmVudFJlc0hhc2hba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnSGFzaCA9IG5ld0FyZ0hhc2g7XG4gICAgICAgIGN1cnJlbnRSZXNIYXNoID0gbmV3UmVzSGFzaDtcbiAgICAgICAgcmV0dXJuIG5ld1Jlc0hhc2g7XG4gICAgfTtcbn1cblxudmFyIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgIHdlZWs6IDMsXG4gICAgc2VwYXJhdG9yOiAwLFxuICAgIG9taXRaZXJvTWludXRlOiAwLFxuICAgIG1lcmlkaWVtOiAwLFxuICAgIG9taXRDb21tYXM6IDAsXG59O1xudmFyIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xudmFyIE1FUklESUVNX1JFID0gL1xccyooW2FwXSlcXC4/bVxcLj8vaTsgLy8gZWF0cyB1cCBsZWFkaW5nIHNwYWNlcyB0b29cbnZhciBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbnZhciBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG52YXIgTFRSX1JFID0gL1xcdTIwMGUvZzsgLy8gY29udHJvbCBjaGFyYWN0ZXJcbnZhciBVVENfUkUgPSAvVVRDfEdNVC87XG52YXIgTmF0aXZlRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdGl2ZUZvcm1hdHRlcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICB2YXIgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgdmFyIGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAobmFtZV8xIGluIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRTZXR0aW5nc1tuYW1lXzFdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVfMV0sIHNldmVyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzW25hbWVfMV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lXzEgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHsgLy8gVE9ETzogd2hhdCBhYm91dCBob3VyMTI/IG5vIHNldmVyaXR5XG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XG4gICAgfTtcbiAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhbmRhcmREYXRlUHJvcHMgPSBfYS5zdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyA9IF9hLmV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHZhciBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XG4gICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xuICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVsbDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xuICAgICAgICB2YXIgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XG4gICAgfTtcbiAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmdldExhcmdlc3RVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOYXRpdmVGb3JtYXR0ZXI7XG59KCkpO1xuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHZhciBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpOyB9O1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTsgLy8gY29weVxuICAgIGV4dGVuZGVkU2V0dGluZ3MgPSBfX2Fzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcbiAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcbiAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcbiAgICB2YXIgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICB2YXIgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHZhciB6ZXJvUHJvcHMgPSBfX2Fzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgbWFya2VyID0gZGF0ZS5tYXJrZXI7XG4gICAgICAgIHZhciBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHsgcmV0dXJuIG0xLnRvTG9jYWxlTG93ZXJDYXNlKCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHsgcmV0dXJuIG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkgKyBcIm1cIjsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24gKG0wKSB7IHJldHVybiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcbiAgICBzID0gcy50cmltKCk7XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XG4gICAgdmFyIHJlcGxhY2VkID0gZmFsc2U7XG4gICAgcyA9IHMucmVwbGFjZShVVENfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHpvU3RyO1xuICAgIH0pO1xuICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICAgIGlmICghcmVwbGFjZWQpIHtcbiAgICAgICAgcyArPSBcIiBcIiArIHR6b1N0cjtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyKG51bSwgd2Vla1RleHQsIHdlZWtUZXh0TG9uZywgbG9jYWxlLCBkaXNwbGF5KSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0TG9uZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc3BsYXkgPT09ICdzaG9ydCcgfHwgZGlzcGxheSA9PT0gJ25hcnJvdycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dCk7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycgfHwgZGlzcGxheSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKCcgJyk7XG4gICAgfVxuICAgIHBhcnRzLnB1c2gobG9jYWxlLnNpbXBsZU51bWJlckZvcm1hdC5mb3JtYXQobnVtKSk7XG4gICAgaWYgKGxvY2FsZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gVE9ETzogdXNlIGNvbnRyb2wgY2hhcmFjdGVycyBpbnN0ZWFkP1xuICAgICAgICBwYXJ0cy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cbi8vIFJhbmdlIEZvcm1hdHRpbmcgVXRpbHNcbi8vIDAgPSBleGFjdGx5IHRoZSBzYW1lXG4vLyAxID0gZGlmZmVyZW50IGJ5IHRpbWVcbi8vIGFuZCBiaWdnZXJcbmZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoZDAsIGQxLCBjYSkge1xuICAgIGlmIChjYS5nZXRNYXJrZXJZZWFyKGQwKSAhPT0gY2EuZ2V0TWFya2VyWWVhcihkMSkpIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJNb250aChkMCkgIT09IGNhLmdldE1hcmtlck1vbnRoKGQxKSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlckRheShkMCkgIT09IGNhLmdldE1hcmtlckRheShkMSkpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGlmICh0aW1lQXNNcyhkMCkgIT09IHRpbWVBc01zKGQxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMsIGJpZ2dlc3RVbml0KSB7XG4gICAgdmFyIHBhcnRpYWxPcHRpb25zID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8yIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZV8yIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVfMl0gPD0gYmlnZ2VzdFVuaXQpIHtcbiAgICAgICAgICAgIHBhcnRpYWxPcHRpb25zW25hbWVfMl0gPSBvcHRpb25zW25hbWVfMl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xufVxuZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xuICAgIHZhciBpMCA9IDA7XG4gICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XG4gICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xuICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcbiAgICAgICAgdmFyIGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XG4gICAgICAgIHZhciBpMSA9IDA7XG4gICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcbiAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xuICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFpvbmVkTWFya2VyKGRhdGVJbmZvLCBjYWxlbmRhclN5c3RlbSkge1xuICAgIHZhciBhID0gY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShkYXRlSW5mby5tYXJrZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcjogZGF0ZUluZm8ubWFya2VyLFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZUluZm8udGltZVpvbmVPZmZzZXQsXG4gICAgICAgIGFycmF5OiBhLFxuICAgICAgICB5ZWFyOiBhWzBdLFxuICAgICAgICBtb250aDogYVsxXSxcbiAgICAgICAgZGF5OiBhWzJdLFxuICAgICAgICBob3VyOiBhWzNdLFxuICAgICAgICBtaW51dGU6IGFbNF0sXG4gICAgICAgIHNlY29uZDogYVs1XSxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFbNl0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgIHZhciBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgdmFyIGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgICAgIGVuZDogZW5kSW5mbyxcbiAgICAgICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfTtcbn1cblxuLypcblRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXG4qL1xuLypcbkF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxuSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXG4qL1xudmFyIENtZEZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbWRGb3JtYXR0ZXIoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBDbWRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgQ21kRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIENtZEZvcm1hdHRlcjtcbn0oKSk7XG5cbnZhciBGdW5jRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bmNGb3JtYXR0ZXIoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIH1cbiAgICBGdW5jRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIEZ1bmNGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY0Zvcm1hdHRlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gYmFzZSBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS1cbnZhciBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgbW9udGhNb2RlOiBCb29sZWFuLFxuICAgIGZpeGVkV2Vla0NvdW50OiBCb29sZWFuLFxuICAgIHZhbGlkUmFuZ2U6IGlkZW50aXR5LFxuICAgIHZpc2libGVSYW5nZTogaWRlbnRpdHksXG4gICAgdGl0bGVGb3JtYXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50SW50ZXJhY3RpdmU6IEJvb2xlYW4sXG4gICAgLy8gb25seSB1c2VkIGJ5IGxpc3QtdmlldywgYnV0IGxhbmd1YWdlcyBkZWZpbmUgdGhlIHZhbHVlLCBzbyB3ZSBuZWVkIGl0IGluIGJhc2Ugb3B0aW9uc1xuICAgIG5vRXZlbnRzVGV4dDogU3RyaW5nLFxuICAgIHZpZXdIaW50OiBpZGVudGl0eSxcbiAgICBuYXZMaW5rSGludDogaWRlbnRpdHksXG4gICAgY2xvc2VIaW50OiBTdHJpbmcsXG4gICAgdGltZUhpbnQ6IFN0cmluZyxcbiAgICBldmVudEhpbnQ6IFN0cmluZyxcbiAgICBtb3JlTGlua0NsaWNrOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ29udGVudDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtXaWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gZG8gTk9UIGdpdmUgYSB0eXBlIGhlcmUuIG5lZWQgYHR5cGVvZiBCQVNFX09QVElPTl9ERUZBVUxUU2AgdG8gZ2l2ZSByZWFsIHJlc3VsdHMuXG4vLyByYXcgdmFsdWVzLlxudmFyIEJBU0VfT1BUSU9OX0RFRkFVTFRTID0ge1xuICAgIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXG4gICAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgICBpbml0aWFsVmlldzogJycsXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXG4gICAgaGVhZGVyVG9vbGJhcjoge1xuICAgICAgICBzdGFydDogJ3RpdGxlJyxcbiAgICAgICAgY2VudGVyOiAnJyxcbiAgICAgICAgZW5kOiAndG9kYXkgcHJldixuZXh0JyxcbiAgICB9LFxuICAgIHdlZWtlbmRzOiB0cnVlLFxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG4gICAgZWRpdGFibGU6IGZhbHNlLFxuICAgIG5vd0luZGljYXRvcjogZmFsc2UsXG4gICAgc2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IHRydWUsXG4gICAgc2xvdE1pblRpbWU6ICcwMDowMDowMCcsXG4gICAgc2xvdE1heFRpbWU6ICcyNDowMDowMCcsXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcbiAgICBlbmRQYXJhbTogJ2VuZCcsXG4gICAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcbiAgICB0aW1lWm9uZTogJ2xvY2FsJyxcbiAgICBsb2NhbGVzOiBbXSxcbiAgICBsb2NhbGU6ICcnLFxuICAgIHRoZW1lU3lzdGVtOiAnc3RhbmRhcmQnLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuICAgIGRyYWdTY3JvbGw6IHRydWUsXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXG4gICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxuICAgIGRyb3BBY2NlcHQ6ICcqJyxcbiAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDAsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsXG4gICAgZXhwYW5kUm93czogZmFsc2UsXG4gICAgbmF2TGlua3M6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIGV2ZW50TWluSGVpZ2h0OiAxNSxcbiAgICBldmVudE1pbldpZHRoOiAzMCxcbiAgICBldmVudFNob3J0SGVpZ2h0OiAzMCxcbn07XG4vLyBjYWxlbmRhciBsaXN0ZW5lcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudHNTZXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWRkOiBpZGVudGl0eSxcbiAgICBldmVudENoYW5nZTogaWRlbnRpdHksXG4gICAgZXZlbnRSZW1vdmU6IGlkZW50aXR5LFxuICAgIHdpbmRvd1Jlc2l6ZTogaWRlbnRpdHksXG4gICAgZXZlbnRDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUVudGVyOiBpZGVudGl0eSxcbiAgICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5LFxuICAgIHNlbGVjdDogaWRlbnRpdHksXG4gICAgdW5zZWxlY3Q6IGlkZW50aXR5LFxuICAgIGxvYWRpbmc6IGlkZW50aXR5LFxuICAgIC8vIGludGVybmFsXG4gICAgX3VubW91bnQ6IGlkZW50aXR5LFxuICAgIF9iZWZvcmVwcmludDogaWRlbnRpdHksXG4gICAgX2FmdGVycHJpbnQ6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgX25vRXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIF9yZXNpemU6IGlkZW50aXR5LFxuICAgIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSxcbn07XG4vLyBjYWxlbmRhci1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbnZhciBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyA9IHtcbiAgICBoZWFkZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGZvb3RlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uVGV4dDogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25IaW50czogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25JY29uczogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBkYXRlSW5jcmVtZW50OiBpc01heWJlT2JqZWN0c0VxdWFsLFxufTtcbmZ1bmN0aW9uIGlzTWF5YmVPYmplY3RzRXF1YWwoYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGlzUHJvcHNFcXVhbChhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG4vLyB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFZJRVdfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb21wb25lbnQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvblRleHQ6IFN0cmluZyxcbiAgICBidXR0b25UZXh0S2V5OiBTdHJpbmcsXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogaWRlbnRpdHksXG4gICAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sXG4gICAgY2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgY29udGVudDogaWRlbnRpdHksXG4gICAgZGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdpbGxVbm1vdW50OiBpZGVudGl0eSxcbn07XG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBtZXJnZVJhd09wdGlvbnMob3B0aW9uU2V0cykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG9wdGlvblNldHMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVByb3BzKGlucHV0LCByZWZpbmVycykge1xuICAgIHZhciByZWZpbmVkID0ge307XG4gICAgdmFyIGV4dHJhID0ge307XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcmVmaW5lcnMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgICAgICByZWZpbmVkW3Byb3BOYW1lXSA9IHJlZmluZXJzW3Byb3BOYW1lXShpbnB1dFtwcm9wTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHJlZmluZXJzKSkge1xuICAgICAgICAgICAgZXh0cmFbcHJvcE5hbWVdID0gaW5wdXRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZmluZWQ6IHJlZmluZWQsIGV4dHJhOiBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICB2YXIgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgIHZhciBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmF3RXZlbnRzXzEgPSByYXdFdmVudHM7IF9pIDwgcmF3RXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgdmFyIHR1cGxlID0gcGFyc2VFdmVudChyYXdFdmVudCwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBldmVudFJlZmluZXJzKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSkge1xuICAgIGlmIChldmVudFN0b3JlID09PSB2b2lkIDApIHsgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyB9XG4gICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XG4gICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XG4gICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxuLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxuLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuZnVuY3Rpb24gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgZGVmXzEgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgdmFyIG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGxvb2tEZWYpIHsgcmV0dXJuIGlzRXZlbnREZWZzR3JvdXBlZChkZWZfMSwgbG9va0RlZik7IH0pO1xuICAgICAgICAvLyBhZGQgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgICAgIG5ld1N0b3JlLmRlZnNbZGVmXzEuZGVmSWRdID0gZGVmXzE7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdG9yZTAuZGVmcyksIHN0b3JlMS5kZWZzKSxcbiAgICAgICAgaW5zdGFuY2VzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RvcmUwLmluc3RhbmNlcyksIHN0b3JlMS5pbnN0YW5jZXMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XG4gICAgdmFyIGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XG4gICAgdmFyIGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gKGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cbiAgICApOyB9KTtcbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICB2YXIgZGVmcyA9IG1hc3Rlci5kZWZzLCBpbnN0YW5jZXMgPSBtYXN0ZXIuaW5zdGFuY2VzO1xuICAgIHZhciBmaWx0ZXJlZERlZnMgPSB7fTtcbiAgICB2YXIgZmlsdGVyZWRJbnN0YW5jZXMgPSB7fTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGlmICghc3ViLmRlZnNbZGVmSWRdKSB7IC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuaW5zdGFuY2VzW2luc3RhbmNlSWRdICYmIC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbaW5zdGFuY2VzW2luc3RhbmNlSWRdLmRlZklkXSAvLyBkZWYgd2Fzbid0IGZpbHRlcmVkIGF3YXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBmaWx0ZXJlZERlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVyZWRJbnN0YW5jZXMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoW2lucHV0XSwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbi8vIFRPRE86IGJldHRlciBjYWxsZWQgXCJFdmVudFNldHRpbmdzXCIgb3IgXCJFdmVudENvbmZpZ1wiXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZmlsZSBpbnRvIHN0cnVjdHNcbi8vIFRPRE86IHNlcGFyYXRlIGNvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvdywgYmVjYXVzZSBzZWxlY3Rpb24gdXNlcyBvbmx5IHRoYXQsIG5vdCBvdGhlciBwcm9wc1xudmFyIEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xudmFyIEVNUFRZX0VWRU5UX1VJID0ge1xuICAgIGRpc3BsYXk6IG51bGwsXG4gICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICBvdmVybGFwOiBudWxsLFxuICAgIGFsbG93czogW10sXG4gICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBib3JkZXJDb2xvcjogJycsXG4gICAgdGV4dENvbG9yOiAnJyxcbiAgICBjbGFzc05hbWVzOiBbXSxcbn07XG5mdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpIHtcbiAgICB2YXIgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiByZWZpbmVkLmRpc3BsYXkgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcbiAgICAgICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxuICAgICAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXG4gICAgICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSksIC8vIGpvaW4gc2luZ3VsYXIgYW5kIHBsdXJhbFxuICAgIH07XG59XG4vLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuZnVuY3Rpb24gY29tYmluZUV2ZW50VWlzKHVpcykge1xuICAgIHJldHVybiB1aXMucmVkdWNlKGNvbWJpbmVUd29FdmVudFVpcywgRU1QVFlfRVZFTlRfVUkpO1xufVxuZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wLCBpdGVtMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxuICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxuICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXG4gICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcbiAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxuICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcbiAgICB9O1xufVxuXG52YXIgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG52YXIgRVZFTlRfREFURV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBkYXRlOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xudmFyIEVWRU5UX1JFRklORVJTID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSwgRVZFTlRfREFURV9SRUZJTkVSUyksIHsgZXh0ZW5kZWRQcm9wczogaWRlbnRpdHkgfSk7XG5mdW5jdGlvbiBwYXJzZUV2ZW50KHJhdywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCByZWZpbmVycykge1xuICAgIGlmIChyZWZpbmVycyA9PT0gdm9pZCAwKSB7IHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpOyB9XG4gICAgdmFyIF9hID0gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgIHZhciBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgdmFyIHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQpO1xuICAgICAgICBkZWYucmVjdXJyaW5nRGVmID0ge1xuICAgICAgICAgICAgdHlwZUlkOiByZWN1cnJpbmdSZXMudHlwZUlkLFxuICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ1Jlcy50eXBlRGF0YSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRlZjogZGVmLCBpbnN0YW5jZTogbnVsbCB9O1xuICAgIH1cbiAgICB2YXIgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpO1xuICAgIGlmIChzaW5nbGVSZXMpIHtcbiAgICAgICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIHJldHVybiB7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKSB7XG4gICAgaWYgKHJlZmluZXJzID09PSB2b2lkIDApIHsgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7IH1cbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCkge1xuICAgIHZhciBkZWYgPSB7XG4gICAgICAgIHRpdGxlOiByZWZpbmVkLnRpdGxlIHx8ICcnLFxuICAgICAgICBncm91cElkOiByZWZpbmVkLmdyb3VwSWQgfHwgJycsXG4gICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICB1cmw6IHJlZmluZWQudXJsIHx8ICcnLFxuICAgICAgICByZWN1cnJpbmdEZWY6IG51bGwsXG4gICAgICAgIGRlZklkOiBndWlkKCksXG4gICAgICAgIHNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICAgIGhhc0VuZDogaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSksIGV4dHJhKSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWVtYmVyQWRkZXIgPSBfYVtfaV07XG4gICAgICAgIF9fYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBoZWxwIG91dCBFdmVudEFwaSBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIHZhciBhbGxEYXkgPSByZWZpbmVkLmFsbERheTtcbiAgICB2YXIgc3RhcnRNZXRhO1xuICAgIHZhciBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgdmFyIGhhc0VuZCA9IGZhbHNlO1xuICAgIHZhciBlbmRNZXRhO1xuICAgIHZhciBlbmRNYXJrZXIgPSBudWxsO1xuICAgIHZhciBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgaGFzRW5kOiBoYXNFbmQsXG4gICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBpZiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgcmVzID0gZXZlbnRTb3VyY2UuZGVmYXVsdEFsbERheTtcbiAgICB9XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICB2YXIgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgIGlmIChuZXh0RGF5VGhyZXNob2xkID09PSB2b2lkIDApIHsgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApOyB9XG4gICAgdmFyIHN0YXJ0RGF5ID0gbnVsbDtcbiAgICB2YXIgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIHZhciBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIHZhciB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcGFyc2VSYW5nZShpbnB1dCwgZGF0ZUVudikge1xuICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgdmFyIGVuZCA9IG51bGw7XG4gICAgaWYgKGlucHV0LnN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuZW5kKSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LmVuZCk7XG4gICAgfVxuICAgIGlmICghc3RhcnQgJiYgIWVuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQgPCBzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xufVxuLy8gU0lERS1FRkZFQ1Q6IHdpbGwgbXV0YXRlIHJhbmdlcy5cbi8vIFdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHJlc3VsdC5cbmZ1bmN0aW9uIGludmVydFJhbmdlcyhyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xuICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IFtdO1xuICAgIHZhciBzdGFydCA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydDsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGRhdGVSYW5nZS5zdGFydCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVSYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICBpZiAoc3RhcnQgPCBjb25zdHJhaW50UmFuZ2UuZW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlMC5zdGFydCwgZW5kID0gcmFuZ2UwLmVuZDtcbiAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xuICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIG5ld1JhbmdlID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdSYW5nZTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcbiAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XG4gICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXG4gICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcbiAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XG59XG4vLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXG4vLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cbmZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8qXG5TcGVjaWZ5aW5nIG5leHREYXlUaHJlc2hvbGQgc2lnbmFscyB0aGF0IGFsbC1kYXkgcmFuZ2VzIHNob3VsZCBiZSBzbGljZWQuXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZnJhbWluZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgdmFyIGludmVyc2VCZ0J5R3JvdXBJZCA9IHt9O1xuICAgIHZhciBpbnZlcnNlQmdCeURlZklkID0ge307XG4gICAgdmFyIGRlZkJ5R3JvdXBJZCA9IHt9O1xuICAgIHZhciBiZ1JhbmdlcyA9IFtdO1xuICAgIHZhciBmZ1JhbmdlcyA9IFtdO1xuICAgIHZhciBldmVudFVpcyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50VWlCYXNlcyk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICB2YXIgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSA9IGRlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2RlZklkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICB2YXIgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gaW5zdGFuY2UucmFuZ2U7XG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICAgICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlKG9yaWdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkgOlxuICAgICAgICAgICAgb3JpZ1JhbmdlO1xuICAgICAgICB2YXIgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2luc3RhbmNlLmRlZklkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1aS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAodWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnID8gYmdSYW5nZXMgOiBmZ1JhbmdlcykucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aTogdWksXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMSA9IGludmVydGVkUmFuZ2VzOyBfaSA8IGludmVydGVkUmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZSA9IGludmVydGVkUmFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlZkJ5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgICAgICAgICB1aTogdWksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gaW52ZXJzZUJnQnlEZWZJZCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF07XG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMiA9IGludmVydGVkUmFuZ2VzOyBfYSA8IGludmVydGVkUmFuZ2VzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZSA9IGludmVydGVkUmFuZ2VzXzJbX2FdO1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpOyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICB2YXIgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICB2YXIgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KGZ1bmN0aW9uIChvYmowLCBvYmoxKSB7IHJldHVybiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcyk7IH0pO1xuICAgIHJldHVybiBvYmpzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5fc2VnOyB9KTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICB2YXIgZXZlbnREZWYgPSBldmVudFJhbmdlLmRlZjtcbiAgICB2YXIgcmFuZ2UgPSBldmVudFJhbmdlLmluc3RhbmNlID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZSA6IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQgPyByYW5nZS5zdGFydC52YWx1ZU9mKCkgOiAwOyAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igb3Blbi1yYW5nZSBldmVudHNcbiAgICB2YXIgZW5kID0gcmFuZ2UuZW5kID8gcmFuZ2UuZW5kLnZhbHVlT2YoKSA6IDA7IC8vIFwiXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudERlZi5leHRlbmRlZFByb3BzKSwgZXZlbnREZWYpLCB7IGlkOiBldmVudERlZi5wdWJsaWNJZCwgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCwgZHVyYXRpb246IGVuZCAtIHN0YXJ0LCBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLCBfc2VnOiBzZWcgfSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCkge1xuICAgIHZhciBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3M7XG4gICAgdmFyIHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIHVpID0gX2EudWk7XG4gICAgdmFyIHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XG4gICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXJzXzFbX2ldO1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkaXNwbGF5RXZlbnRUaW1lID0gb3B0aW9ucy5kaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgPSBvcHRpb25zLmRpc3BsYXlFdmVudEVuZDtcbiAgICB2YXIgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWY7XG4gICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICBpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSBkZWZhdWx0RGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSBkZWZhdWx0RGlzcGxheUV2ZW50RW5kICE9PSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHdob2xlRXZlbnRTdGFydCA9IGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHdob2xlRXZlbnRFbmQgPSBldmVudEluc3RhbmNlLnJhbmdlLmVuZDtcbiAgICB2YXIgc2VnU3RhcnQgPSBzdGFydE92ZXJyaWRlIHx8IHNlZy5zdGFydCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbiAgICB2YXIgc2VnRW5kID0gZW5kT3ZlcnJpZGUgfHwgc2VnLmVuZCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG4gICAgdmFyIGlzU3RhcnREYXkgPSBzdGFydE9mRGF5KHdob2xlRXZlbnRTdGFydCkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KHNlZ1N0YXJ0KS52YWx1ZU9mKCk7XG4gICAgdmFyIGlzRW5kRGF5ID0gc3RhcnRPZkRheShhZGRNcyh3aG9sZUV2ZW50RW5kLCAtMSkpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShhZGRNcyhzZWdFbmQsIC0xKSkudmFsdWVPZigpO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lICYmICFldmVudERlZi5hbGxEYXkgJiYgKGlzU3RhcnREYXkgfHwgaXNFbmREYXkpKSB7XG4gICAgICAgIHNlZ1N0YXJ0ID0gaXNTdGFydERheSA/IHdob2xlRXZlbnRTdGFydCA6IHNlZ1N0YXJ0O1xuICAgICAgICBzZWdFbmQgPSBpc0VuZERheSA/IHdob2xlRXZlbnRFbmQgOiBzZWdFbmQ7XG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgJiYgZXZlbnREZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzZWdTdGFydCwgc2VnRW5kLCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHNlZ1N0YXJ0LCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgLy8gbm9vb29vLCBzYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkge1xuICAgIHZhciBzZWdSYW5nZSA9IHNlZy5ldmVudFJhbmdlLnJhbmdlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzUGFzdDogc2VnUmFuZ2UuZW5kIDwgKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIHZhciBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogZXZlbnRSYW5nZS5kZWYuZGVmSWQgKyBcIjpcIiArIGV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKTtcbiAgICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkge1xuICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgdmFyIHVybCA9IGRlZi51cmw7XG4gICAgaWYgKHVybCkge1xuICAgICAgICByZXR1cm4geyBocmVmOiB1cmwgfTtcbiAgICB9XG4gICAgdmFyIGVtaXR0ZXIgPSBjb250ZXh0LmVtaXR0ZXIsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGV2ZW50SW50ZXJhY3RpdmUgPSBvcHRpb25zLmV2ZW50SW50ZXJhY3RpdmU7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG52YXIgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICB2YXIgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgdmFyIHJhbmdlID0gc3Bhbi5yYW5nZTtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlLmVuZCkge1xuICAgICAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3Bhbjtcbn1cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5mdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpIHtcbiAgICB2YXIgX2EgPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTKSwgc3RhbmRhcmRQcm9wcyA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgdmFyIHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgIHZhciBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbDtcbiAgICB2YXIgYWxsRGF5ID0gc3RhbmRhcmRQcm9wcy5hbGxEYXk7XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXk6IGFsbERheSB9LCBleHRyYSk7XG59XG5mdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbn1cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHNwYW4xKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHNwYW4xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHNwYW4ucmFuZ2UsIGRhdGVFbnYsIHNwYW4uYWxsRGF5KSksIHsgYWxsRGF5OiBzcGFuLmFsbERheSB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZTogb21pdFRpbWUgfSksXG4gICAgICAgIGVuZFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kLCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlcyA9IHJlZmluZUV2ZW50RGVmKHsgZWRpdGFibGU6IGZhbHNlIH0sIGNvbnRleHQpO1xuICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlcy5yZWZpbmVkLCByZXMuZXh0cmEsICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgIHVpOiBjb21waWxlRXZlbnRVaShkZWYsIGV2ZW50VWlCYXNlcyksXG4gICAgICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgICAgICByYW5nZTogZGF0ZVNwYW4ucmFuZ2UsXG4gICAgICAgIGlzU3RhcnQ6IHRydWUsXG4gICAgICAgIGlzRW5kOiB0cnVlLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc2VsZWN0aW9uLCBjb250ZXh0KSksIHsganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSkpO1xufVxuZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gX2FbX2ldO1xuICAgICAgICBfX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIF9fYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG4vLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG4vLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50RW5kKGFsbERheSwgbWFya2VyLCBjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIHZhciBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIHZhciBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIHZhciBjb3B5ID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xuICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XG4gICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb3B5LmV4dGVuZGVkUHJvcHMpLCBtdXRhdGlvbi5leHRlbmRlZFByb3BzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgYXBwbGllciA9IF9hW19pXTtcbiAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xuICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxuZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnY7XG4gICAgdmFyIGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICB2YXIgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICB2YXIgY29weSA9IF9fYXNzaWduKHt9LCBldmVudEluc3RhbmNlKTtcbiAgICBpZiAoZm9yY2VBbGxEYXkpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoY29weS5yYW5nZSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5kYXRlc0RlbHRhICYmIGV2ZW50Q29uZmlnLnN0YXJ0RWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uc3RhcnREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uc3RhcnREZWx0YSksXG4gICAgICAgICAgICBlbmQ6IGNvcHkucmFuZ2UuZW5kLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uZW5kRGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5lbmREZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjbGVhckVuZCkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIGV2ZW50IHdhcyBhbGwtZGF5IGJ1dCB0aGUgc3VwcGxpZWQgZGVsdGFzIHdlcmUgbm90XG4gICAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5lbmQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgICBpZiAoY29weS5yYW5nZS5lbmQgPCBjb3B5LnJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIGNvcHkucmFuZ2UuZW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIFZpZXdBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gZ2V0Q3VycmVudERhdGE7XG4gICAgICAgIHRoaXMuZGF0ZUVudiA9IGRhdGVFbnY7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJjYWxlbmRhclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5jYWxlbmRhckFwaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiYWN0aXZlU3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiYWN0aXZlRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJjdXJyZW50U3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImN1cnJlbnRFbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZpZXdBcGkucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXTsgLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBWaWV3QXBpO1xufSgpKTtcblxudmFyIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMpIHtcbiAgICBpZiAocmVmaW5lcnMgPT09IHZvaWQgMCkgeyByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTsgfVxuICAgIHZhciByYXdPYmo7XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmF3T2JqID0geyBldmVudHM6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnb2JqZWN0JyAmJiByYXcpIHsgLy8gbm90IG51bGxcbiAgICAgICAgcmF3T2JqID0gcmF3O1xuICAgIH1cbiAgICBpZiAocmF3T2JqKSB7XG4gICAgICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhd09iaiwgcmVmaW5lcnMpLCByZWZpbmVkID0gX2EucmVmaW5lZCwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgdmFyIG1ldGFSZXMgPSBidWlsZEV2ZW50U291cmNlTWV0YShyZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG1ldGFSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3JhdzogcmF3LFxuICAgICAgICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhdGVzdEZldGNoSWQ6ICcnLFxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFsbERheTogcmVmaW5lZC5kZWZhdWx0QWxsRGF5LFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogcmVmaW5lZC5ldmVudERhdGFUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVmaW5lZC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlZmluZWQuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZ3VpZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZURlZklkOiBtZXRhUmVzLnNvdXJjZURlZklkLFxuICAgICAgICAgICAgICAgIG1ldGE6IG1ldGFSZXMubWV0YSxcbiAgICAgICAgICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFByb3BzOiBleHRyYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlUmVmaW5lcnMpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZU1ldGEocmF3LCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICBmb3IgKHZhciBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgdmFyIG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2VEZWZJZDogaSwgbWV0YTogbWV0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRhdGVNYXJrZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9ucywgZGF0ZUVudikge1xuICAgIHZhciBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZTtcbiAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcbiAgICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbml0aWFsRGF0ZUlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vdyhvcHRpb25zLm5vdywgZGF0ZUVudik7IC8vIGdldE5vdyBhbHJlYWR5IHJldHVybnMgdW56b25lZFxufVxuZnVuY3Rpb24gZ2V0Tm93KG5vd0lucHV0LCBkYXRlRW52KSB7XG4gICAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3dJbnB1dCA9IG5vd0lucHV0KCk7XG4gICAgfVxuICAgIGlmIChub3dJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU5vd01hcmtlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93SW5wdXQpO1xufVxuXG52YXIgQ2FsZW5kYXJBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJBcGkoKSB7XG4gICAgfVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbGVuZGFyQXBpLnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld0FwaTsgfSAvLyBmb3IgcHVibGljIEFQSVxuICAgICAgICAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYmF0Y2hSZW5kZXJpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgb3B0aW9uTmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiB2YWwsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XG4gICAgfTtcbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoaGFuZGxlck5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXMuY3VycmVudERhdGFNYW5hZ2VyO1xuICAgICAgICBpZiAoY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVyc1toYW5kbGVyTmFtZV0pIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbGlzdGVuZXIgbmFtZSAnXCIgKyBoYW5kbGVyTmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvLyBub3QgbWVhbnQgZm9yIHB1YmxpYyB1c2VcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIpLnRyaWdnZXIuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXJOYW1lXSwgYXJncykpO1xuICAgIH07XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiAodmlld1R5cGUsIGRhdGVPclJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ZUVudiA9IF90aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZUVudjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnpvb21UbyA9IGZ1bmN0aW9uIChkYXRlTWFya2VyLCB2aWV3VHlwZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBzcGVjO1xuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXG4gICAgICAgIHNwZWMgPSBzdGF0ZS52aWV3U3BlY3Nbdmlld1R5cGVdIHx8IHRoaXMuZ2V0VW5pdFZpZXdTcGVjKHZpZXdUeXBlKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiBzcGVjLnR5cGUsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZU1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cbiAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldFVuaXRWaWV3U3BlYyA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKSwgdmlld1NwZWNzID0gX2Eudmlld1NwZWNzLCB0b29sYmFyQ29uZmlnID0gX2EudG9vbGJhckNvbmZpZztcbiAgICAgICAgdmFyIHZpZXdUeXBlcyA9IFtdLmNvbmNhdCh0b29sYmFyQ29uZmlnLmhlYWRlciA/IHRvb2xiYXJDb25maWcuaGVhZGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSwgdG9vbGJhckNvbmZpZy5mb290ZXIgPyB0b29sYmFyQ29uZmlnLmZvb3Rlci52aWV3c1dpdGhCdXR0b25zIDogW10pO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIGZvciAodmFyIHZpZXdUeXBlIGluIHZpZXdTcGVjcykge1xuICAgICAgICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNwZWMgPSB2aWV3U3BlY3Nbdmlld1R5cGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBDdXJyZW50IERhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnByZXZZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgLTEpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5uZXh0WWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ290b0RhdGUgPSBmdW5jdGlvbiAoem9uZWREYXRlSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuY3JlYXRlTWFya2VyKHpvbmVkRGF0ZUlucHV0KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZm9yIGV4dGVybmFsIEFQSVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfTtcbiAgICAvLyBEYXRlIEZvcm1hdHRpbmcgVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24gKGQsIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9O1xuICAgIC8vIGBzZXR0aW5nc2AgaXMgZm9yIGZvcm1hdHRlciBBTkQgaXNFbmRFeGNsdXNpdmVcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZDAsIGQxLCBzZXR0aW5ncykge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmZvcm1hdElzbyA9IGZ1bmN0aW9uIChkLCBvbWl0VGltZSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWU6IG9taXRUaW1lIH0pO1xuICAgIH07XG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxuICAgIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGVPck9iaiwgZW5kRGF0ZSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5wdXQ7XG4gICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgbnVsbCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEFwaSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBldmVudFNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0KSB7IC8vIHRydWUuIHBhcnQgb2YgdGhlIGZpcnN0IGV2ZW50IHNvdXJjZVxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xuICAgICAgICAgICAgdmFyIHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFxcXCJcIiArIHNvdXJjZUlucHV0ICsgXCJcXFwiXCIpOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgdmFyIG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50QXBpKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnRyaWdnZXJFdmVudEFkZCA9IGZ1bmN0aW9uIChldmVudEFwaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW1pdHRlciA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gVE9ETzogb3B0aW1pemVcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIF9hID0gc3RhdGUuZXZlbnRTdG9yZSwgZGVmcyA9IF9hLmRlZnMsIGluc3RhbmNlcyA9IF9hLmluc3RhbmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XG4gICAgfTtcbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgIHZhciBzb3VyY2VBcGlzID0gW107XG4gICAgICAgIGZvciAodmFyIGludGVybmFsSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgICAgICAgc291cmNlQXBpcy5wdXNoKG5ldyBFdmVudFNvdXJjZUFwaShzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW3NvdXJjZUlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBldmVudFNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVmZXRjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xuICAgIH07XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuc2Nyb2xsVG9UaW1lID0gZnVuY3Rpb24gKHRpbWVJbnB1dCkge1xuICAgICAgICB2YXIgdGltZSA9IGNyZWF0ZUR1cmF0aW9uKHRpbWVJbnB1dCk7XG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ19zY3JvbGxSZXF1ZXN0JywgeyB0aW1lOiB0aW1lIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJBcGk7XG59KCkpO1xuXG52YXIgRXZlbnRBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgZnVuY3Rpb24gRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChuYW1lIGluIEVWRU5UX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHNldCBkYXRlLXJlbGF0ZWQgcHJvcCBcXCduYW1lXFwnLiBVc2Ugb25lIG9mIHRoZSBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBwcm9wZXIgYWxpYXNpbmcgc3lzdGVtP1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBwdWJsaWNJZDogdmFsIH0sIC8vIGhhcmRjb2RlZCBpbnRlcm5hbCBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IChfYSA9IHt9LCBfYVtuYW1lXSA9IHZhbCwgX2EpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgdmFyIHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IChfYiA9IHt9LCBfYltuYW1lXSA9IHZhbCwgX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgdWk6IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBzZXQgcHJvcCAnXCIgKyBuYW1lICsgXCInLiBVc2Ugc2V0RXh0ZW5kZWRQcm9wIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0RXh0ZW5kZWRQcm9wID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IChfYSA9IHt9LCBfYVtuYW1lXSA9IHZhbCwgX2EpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRTdGFydCA9IGZ1bmN0aW9uIChzdGFydElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHRoaXMuX2luc3RhbmNlKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdmFyIGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIHZhciBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTsgLy8gd2hhdCBpZiBwYXJzZWQgYmFkIT9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1haW50YWluRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFbmQgPSBmdW5jdGlvbiAoZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXREYXRlcyA9IGZ1bmN0aW9uIChzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogb3B0aW9ucy5hbGxEYXkgfTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICAvLyB3aGVuIGNvbXB1dGluZyB0aGUgZGlmZiBmb3IgYW4gZXZlbnQgYmVpbmcgY29udmVydGVkIHRvIGFsbC1kYXksXG4gICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgb2ZmIG9mIHRoZSBhbGwtZGF5IHZhbHVlcyB0aGUgd2F5IGV2ZW50LW11dGF0aW9uIGRvZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShpbnN0YW5jZVJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uc0VxdWFsKHN0YXJ0RGVsdGEsIGVuZERlbHRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IHN0YXJ0RGVsdGEsIGVuZERlbHRhOiBlbmREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLm1vdmVTdGFydCA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZUVuZCA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLm1vdmVEYXRlcyA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0QWxsRGF5ID0gZnVuY3Rpb24gKGFsbERheSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBhbGxEYXkgfTtcbiAgICAgICAgdmFyIG1haW50YWluRHVyYXRpb24gPSBvcHRpb25zLm1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChtYWludGFpbkR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKGZvcm1hdElucHV0KSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihmb3JtYXRJbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UucmFuZ2UuZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgICAgICB2YXIgY29udGV4dF8xID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIHZhciBldmVudFN0b3JlXzEgPSBjb250ZXh0XzEuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlO1xuICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZV8xLCBpbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIHZhciBldmVudENvbmZpZ0Jhc2UgPSB7XG4gICAgICAgICAgICAgICAgJyc6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dF8xKTtcbiAgICAgICAgICAgIHZhciBvbGRFdmVudCA9IG5ldyBFdmVudEFwaShjb250ZXh0XzEsIGRlZiwgaW5zdGFuY2UpOyAvLyBzbmFwc2hvdFxuICAgICAgICAgICAgdGhpcy5fZGVmID0gcmVsZXZhbnRFdmVudHMuZGVmc1tkZWYuZGVmSWRdO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSByZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBjb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBvbGRFdmVudDogb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHRfMSwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlXzEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICB2YXIgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VJZCA9IHRoaXMuX2RlZi5zb3VyY2VJZDtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkodGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlc1tzb3VyY2VJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInN0YXJ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJlbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRTdHJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgb21pdFRpbWU6IHRoaXMuX2RlZi5hbGxEYXksXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImVuZFN0clwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLy8gY29tcHV0YWJsZSBwcm9wcyB0aGF0IGFsbCBhY2Nlc3MgdGhlIGRlZlxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJncm91cElkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuZ3JvdXBJZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYWxsRGF5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuYWxsRGF5OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51cmw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImRpc3BsYXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kaXNwbGF5IHx8ICdhdXRvJzsgfSAvLyBiYWQuIGp1c3Qgbm9ybWFsaXplIHRoZSB0eXBlIGVhcmxpZXJcbiAgICAgICAgLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydEVkaXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZHVyYXRpb25FZGl0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImNvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJvdmVybGFwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYWxsb3dcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJib3JkZXJDb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImNsYXNzTmFtZXNcIiwge1xuICAgICAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jbGFzc05hbWVzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJleHRlbmRlZFByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuZXh0ZW5kZWRQcm9wczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS50b1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cbiAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgdmFyIHVpID0gZGVmLnVpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGFydFN0ciA9IF9hLnN0YXJ0U3RyLCBlbmRTdHIgPSBfYS5lbmRTdHI7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgaWYgKGRlZi50aXRsZSkge1xuICAgICAgICAgICAgcmVzLnRpdGxlID0gZGVmLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFN0cikge1xuICAgICAgICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0cikge1xuICAgICAgICAgICAgcmVzLmVuZCA9IGVuZFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnB1YmxpY0lkKSB7XG4gICAgICAgICAgICByZXMuaWQgPSBkZWYucHVibGljSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYudXJsKSB7XG4gICAgICAgICAgICByZXMudXJsID0gZGVmLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuZGlzcGxheSAmJiB1aS5kaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJlcy5kaXNwbGF5ID0gdWkuZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc3RhcnRFZGl0YWJsZS9kdXJhdGlvbkVkaXRhYmxlL2NvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvd1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5iYWNrZ3JvdW5kQ29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYm9yZGVyQ29sb3IgPSB1aS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICAgICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5jbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLmNsYXNzTmFtZXMgPSB1aS5jbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWYuZXh0ZW5kZWRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VFeHRlbmRlZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgX19hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BsYWluT2JqZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRBcGk7XG59KCkpO1xuZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgZGVmID0gZXZlbnRBcGkuX2RlZjtcbiAgICB2YXIgaW5zdGFuY2UgPSBldmVudEFwaS5faW5zdGFuY2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogKF9hID0ge30sIF9hW2RlZi5kZWZJZF0gPSBkZWYsIF9hKSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyAoX2IgPSB7fSwgX2JbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZSwgX2IpIDoge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQsIGV4Y2x1ZGVJbnN0YW5jZSkge1xuICAgIHZhciBkZWZzID0gZXZlbnRTdG9yZS5kZWZzLCBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgZXZlbnRBcGlzID0gW107XG4gICAgdmFyIGV4Y2x1ZGVJbnN0YW5jZUlkID0gZXhjbHVkZUluc3RhbmNlID8gZXhjbHVkZUluc3RhbmNlLmluc3RhbmNlSWQgOiAnJztcbiAgICBmb3IgKHZhciBpZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgdmFyIGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBpZiAoaW5zdGFuY2UuaW5zdGFuY2VJZCAhPT0gZXhjbHVkZUluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIGV2ZW50QXBpcy5wdXNoKG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxudmFyIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0obmFtZSwgdGhlQ2xhc3MpIHtcbiAgICBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdID0gdGhlQ2xhc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxlbmRhclN5c3RlbShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdKCk7XG59XG52YXIgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0oKSB7XG4gICAgfVxuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJZZWFyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9O1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJNb250aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmFycmF5VG9NYXJrZXIgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLm1hcmtlclRvQXJyYXkgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiBkYXRlVG9VdGNBcnJheShtYXJrZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtO1xufSgpKTtcbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XG5cbnZhciBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICB2YXIgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKFwiMC5cIiArIG1bMTJdKSAqIDEwMDAgOiAwKSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1bMTNdKSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgICAgICBpc1RpbWVVbnNwZWNpZmllZDogIW1bNl0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IHRpbWVab25lT2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxudmFyIERhdGVFbnYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZUVudihzZXR0aW5ncykge1xuICAgICAgICB2YXIgdGltZVpvbmUgPSB0aGlzLnRpbWVab25lID0gc2V0dGluZ3MudGltZVpvbmU7XG4gICAgICAgIHZhciBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQyc7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbSA9IGNyZWF0ZUNhbGVuZGFyU3lzdGVtKHNldHRpbmdzLmNhbGVuZGFyU3lzdGVtKTtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGU7XG4gICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcbiAgICAgICAgdGhpcy53ZWVrRG95ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG95O1xuICAgICAgICBpZiAoc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcbiAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy53ZWVrVGV4dExvbmcgPSAoc2V0dGluZ3Mud2Vla1RleHRMb25nICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dExvbmcgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dExvbmcpIHx8IHRoaXMud2Vla1RleHQ7XG4gICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xuICAgICAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yO1xuICAgIH1cbiAgICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpO1xuICAgICAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGEubWFya2VyO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTm93TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSB0aGUgY3VycmVudCBkYXRlIHZhbCBmb3IgYSB0aW1lem9uZSxcbiAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKCkpKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlck1ldGEgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyOiBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBmYWxzZSwgZm9yY2VkVHpvOiBudWxsIH07XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBwYXJ0cy5tYXJrZXI7XG4gICAgICAgIHZhciBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem86IGZvcmNlZFR6byB9O1xuICAgIH07XG4gICAgLy8gQWNjZXNzb3JzXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfTtcbiAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSArPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdICs9IGR1ci5kYXlzO1xuICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdIC09IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdIC09IGR1ci5kYXlzO1xuICAgICAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRZZWFycyA9IGZ1bmN0aW9uIChtYXJrZXIsIG4pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkTW9udGhzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzFdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlWWVhcnMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlTW9udGhzID0gZnVuY3Rpb24gKG0wLCBtMSkge1xuICAgICAgICB2YXIgY2FsZW5kYXJTeXN0ZW0gPSB0aGlzLmNhbGVuZGFyU3lzdGVtO1xuICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXG4gICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBSYW5nZSAvIER1cmF0aW9uXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ3JlYXRlc3RXaG9sZVVuaXQgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH07XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jb3VudER1cmF0aW9uc0JldHdlZW4gPSBmdW5jdGlvbiAobTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgdmFyIGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfTtcbiAgICAvLyBTdGFydC1PZlxuICAgIC8vIHRoZXNlIERPTidUIHJldHVybiB6b25lZC1kYXRlcy4gb25seSBVVEMgc3RhcnQtb2YgZGF0ZXNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mID0gZnVuY3Rpb24gKG0sIHVuaXQpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZlllYXIobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mRGF5KG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mSG91cihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZTZWNvbmQobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mWWVhciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZNb250aCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mV2VlayA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpIC0gKChtLmdldFVUQ0RheSgpIC0gdGhpcy53ZWVrRG93ICsgNykgJSA3KSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvLyBXZWVrIE51bWJlclxuICAgIERhdGVFbnYucHJvdG90eXBlLmNvbXB1dGVXZWVrTnVtYmVyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGRhdGVPcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKSxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGRhdGVPcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfTtcbiAgICAvKlxuICAgIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxuICAgIG1pZ2h0IGFzIHdlbGwgdXNlIGJ1aWxkSXNvU3RyaW5nIG9yIHNvbWUgb3RoZXIgdXRpbCBkaXJlY3RseVxuICAgICovXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKG1hcmtlciwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgPT09IHZvaWQgMCkgeyBleHRyYU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfTtcbiAgICAvLyBUaW1lWm9uZVxuICAgIERhdGVFbnYucHJvdG90eXBlLnRpbWVzdGFtcFRvTWFya2VyID0gZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKHRoaXMubmFtZWRUaW1lWm9uZUltcGwudGltZXN0YW1wVG9BcnJheShtcykpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUub2Zmc2V0Rm9yTWFya2VyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgLy8gY29udmVydCBcImludmVyc2VcIiBvZmZzZXQgdG8gXCJub3JtYWxcIiBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBDb252ZXJzaW9uXG4gICAgRGF0ZUVudi5wcm90b3R5cGUudG9EYXRlID0gZnVuY3Rpb24gKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVFbnY7XG59KCkpO1xuXG52YXIgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG52YXIgTUlOSU1BTF9SQVdfRU5fTE9DQUxFID0ge1xuICAgIGNvZGU6ICdlbicsXG4gICAgd2Vlazoge1xuICAgICAgICBkb3c6IDAsXG4gICAgICAgIGRveTogNCwgLy8gNCBkYXlzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSB5ZWFyIHRvIGJlIGNvbnNpZGVyZWQgdGhlIGZpcnN0IHdlZWtcbiAgICB9LFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgYnV0dG9uVGV4dDoge1xuICAgICAgICBwcmV2OiAncHJldicsXG4gICAgICAgIG5leHQ6ICduZXh0JyxcbiAgICAgICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIGRheTogJ2RheScsXG4gICAgICAgIGxpc3Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIHdlZWtUZXh0OiAnVycsXG4gICAgd2Vla1RleHRMb25nOiAnV2VlaycsXG4gICAgY2xvc2VIaW50OiAnQ2xvc2UnLFxuICAgIHRpbWVIaW50OiAnVGltZScsXG4gICAgZXZlbnRIaW50OiAnRXZlbnQnLFxuICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcbiAgICBtb3JlTGlua1RleHQ6ICdtb3JlJyxcbiAgICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheScsXG59O1xudmFyIFJBV19FTl9MT0NBTEUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgTUlOSU1BTF9SQVdfRU5fTE9DQUxFKSwgeyBcbiAgICAvLyBJbmNsdWRlcyB0aGluZ3Mgd2UgZG9uJ3Qgd2FudCBvdGhlciBsb2NhbGVzIHRvIGluaGVyaXQsXG4gICAgLy8gdGhpbmdzIHRoYXQgZGVyaXZlIGZyb20gb3RoZXIgdHJhbnNsYXRhYmxlIHN0cmluZ3MuXG4gICAgYnV0dG9uSGludHM6IHtcbiAgICAgICAgcHJldjogJ1ByZXZpb3VzICQwJyxcbiAgICAgICAgbmV4dDogJ05leHQgJDAnLFxuICAgICAgICB0b2RheTogZnVuY3Rpb24gKGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBcIlRoaXMgXCIgKyBidXR0b25UZXh0O1xuICAgICAgICB9LFxuICAgIH0sIHZpZXdIaW50OiAnJDAgdmlldycsIG5hdkxpbmtIaW50OiAnR28gdG8gJDAnLCBtb3JlTGlua0hpbnQ6IGZ1bmN0aW9uIChldmVudENudCkge1xuICAgICAgICByZXR1cm4gXCJTaG93IFwiICsgZXZlbnRDbnQgKyBcIiBtb3JlIGV2ZW50XCIgKyAoZXZlbnRDbnQgPT09IDEgPyAnJyA6ICdzJyk7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICB2YXIgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICB2YXIgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgdmFyIHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFsbFJhd0xvY2FsZXNfMSA9IGFsbFJhd0xvY2FsZXM7IF9pIDwgYWxsUmF3TG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmF3TG9jYWxlID0gYWxsUmF3TG9jYWxlc18xW19pXTtcbiAgICAgICAgcmF3TG9jYWxlTWFwW3Jhd0xvY2FsZS5jb2RlXSA9IHJhd0xvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgICAgIGRlZmF1bHRDb2RlOiBkZWZhdWx0Q29kZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFNpbmd1bGFyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNpbmd1bGFyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VMb2NhbGUoaW5wdXRTaW5ndWxhci5jb2RlLCBbaW5wdXRTaW5ndWxhci5jb2RlXSwgaW5wdXRTaW5ndWxhcik7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpO1xufVxuZnVuY3Rpb24gcXVlcnlMb2NhbGUoY29kZUFyZywgYXZhaWxhYmxlKSB7XG4gICAgdmFyIGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pOyAvLyB3aWxsIGNvbnZlcnQgdG8gYXJyYXlcbiAgICB2YXIgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcbiAgICByZXR1cm4gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdyk7XG59XG5mdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XG4gICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgIHZhciBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlUHJvcHMoW01JTklNQUxfUkFXX0VOX0xPQ0FMRSwgcmF3XSwgWydidXR0b25UZXh0J10pO1xuICAgIGRlbGV0ZSBtZXJnZWQuY29kZTsgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgICB2YXIgd2VlayA9IG1lcmdlZC53ZWVrO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnOiBjb2RlQXJnLFxuICAgICAgICBjb2RlczogY29kZXMsXG4gICAgICAgIHdlZWs6IHdlZWssXG4gICAgICAgIHNpbXBsZU51bWJlckZvcm1hdDogbmV3IEludGwuTnVtYmVyRm9ybWF0KGNvZGVBcmcpLFxuICAgICAgICBvcHRpb25zOiBtZXJnZWQsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEob3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB2YXIgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcbiAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudiQxKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zID8gb3B0aW9ucyA6IHt9KTsgLy8gcGFzcyBpbiBpZiBub24tbnVsbCBvYmplY3RcbiAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIHZhciBzdGFydE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XG4gICAgdmFyIGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpO1xuICAgIGlmICghc3RhcnRNZXRhIHx8ICFlbmRNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc3RhcnRNZXRhLm1hcmtlciwgZW5kTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IG9wdGlvbnMuaXNFbmRFeGNsdXNpdmUsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmRlZmF1bHRSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIFRPRE86IG1vcmUgRFJZIGFuZCBvcHRpbWl6ZWRcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudiQxKHNldHRpbmdzKSB7XG4gICAgdmFyIGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudihfX2Fzc2lnbihfX2Fzc2lnbih7IHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncyksIHsgbG9jYWxlOiBsb2NhbGUgfSkpO1xufVxuXG52YXIgREVGX0RFRkFVTFRTID0ge1xuICAgIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgICBlbmRUaW1lOiAnMTc6MDAnLFxuICAgIGRheXNPZldlZWs6IFsxLCAyLCAzLCA0LCA1XSxcbiAgICBkaXNwbGF5OiAnaW52ZXJzZS1iYWNrZ3JvdW5kJyxcbiAgICBjbGFzc05hbWVzOiAnZmMtbm9uLWJ1c2luZXNzJyxcbiAgICBncm91cElkOiAnX2J1c2luZXNzSG91cnMnLCAvLyBzbyBtdWx0aXBsZSBkZWZzIGdldCBncm91cGVkXG59O1xuLypcblRPRE86IHBhc3MgYXJvdW5kIGFzIEV2ZW50RGVmSGFzaCEhIVxuKi9cbmZ1bmN0aW9uIHBhcnNlQnVzaW5lc3NIb3VycyhpbnB1dCwgY29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUV2ZW50cyhyZWZpbmVJbnB1dHMoaW5wdXQpLCBudWxsLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZmluZUlucHV0cyhpbnB1dCkge1xuICAgIHZhciByYXdEZWZzO1xuICAgIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgREVGX0RFRkFVTFRTIHZlcmJhdGltXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIC8vIGlmIHNwZWNpZnlpbmcgYW4gYXJyYXksIGV2ZXJ5IHN1Yi1kZWZpbml0aW9uIE5FRURTIGEgZGF5LW9mLXdlZWtcbiAgICAgICAgcmF3RGVmcyA9IGlucHV0LmZpbHRlcihmdW5jdGlvbiAocmF3RGVmKSB7IHJldHVybiByYXdEZWYuZGF5c09mV2VlazsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJhd0RlZnMgPSBbaW5wdXRdO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gaXMgcHJvYmFibHkgZmFsc2VcbiAgICAgICAgcmF3RGVmcyA9IFtdO1xuICAgIH1cbiAgICByYXdEZWZzID0gcmF3RGVmcy5tYXAoZnVuY3Rpb24gKHJhd0RlZikgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKTsgfSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxudmFyIGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHZhciBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICB2YXIgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbnZhciBFTVBUWV9FVkVOVF9TVE9SRSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyAvLyBmb3IgcHVyZWNvbXBvbmVudHMuIFRPRE86IGtlZXAgZWxzZXdoZXJlXG52YXIgU3BsaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BsaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IG1lbW9pemUodGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zcGxpdERhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW5kaXZpZHVhbFVpKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0ge307IC8vIFRPRE86IHR5cGVzY3JpcHQgcHJvdGVjdGlvblxuICAgIH1cbiAgICBTcGxpdHRlci5wcm90b3R5cGUuc3BsaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICB2YXIgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgdmFyIGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIHZhciBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgdmFyIGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIHZhciBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICB2YXIgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCBmdW5jdGlvbiAoaW5mbywga2V5KSB7IHJldHVybiBfdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XSB8fCBtZW1vaXplKGJ1aWxkRXZlbnRVaUZvcktleSk7IH0pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4ga2V5SW5mb3MpIHtcbiAgICAgICAgICAgIHZhciBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XTtcbiAgICAgICAgICAgIHZhciBldmVudFN0b3JlID0gZXZlbnRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRTtcbiAgICAgICAgICAgIHZhciBidWlsZEV2ZW50VWkgPSB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldO1xuICAgICAgICAgICAgc3BsaXRQcm9wc1trZXldID0ge1xuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IGtleUluZm8uYnVzaW5lc3NIb3VycyB8fCBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IGRhdGVTZWxlY3Rpb25zW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlLFxuICAgICAgICAgICAgICAgIGV2ZW50VWlCYXNlczogYnVpbGRFdmVudFVpKHByb3BzLmV2ZW50VWlCYXNlc1snJ10sIGtleUluZm8udWksIGluZGl2aWR1YWxVaVtrZXldKSxcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogZXZlbnRTdG9yZS5pbnN0YW5jZXNbcHJvcHMuZXZlbnRTZWxlY3Rpb25dID8gcHJvcHMuZXZlbnRTZWxlY3Rpb24gOiAnJyxcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IGV2ZW50RHJhZ3Nba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZXNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRQcm9wcztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXREYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICB2YXIgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudFN0b3JlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7IHJldHVybiBfdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpOyB9KTtcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGRlZktleXMpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgICAgICB2YXIgc3BsaXRTdG9yZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5kZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZGVmS2V5c1tpbnN0YW5jZS5kZWZJZF07IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RvcmVzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEluZGl2aWR1YWxVaSA9IGZ1bmN0aW9uIChldmVudFVpQmFzZXMsIGRlZktleXMpIHtcbiAgICAgICAgdmFyIHNwbGl0SGFzaGVzID0ge307XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50VWlCYXNlcykge1xuICAgICAgICAgICAgaWYgKGRlZklkKSB7IC8vIG5vdCB0aGUgJycga2V5XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0SGFzaGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdEhhc2hlcztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICB2YXIgc3BsaXRTdGF0ZXMgPSB7fTtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICB2YXIgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIHZhciBtdXRhdGVkU3RvcmVzXzEgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgbXV0YXRlZEtleXNCeURlZklkKTtcbiAgICAgICAgICAgIHZhciBwb3B1bGF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBhZmZlY3RlZFN0b3Jlc18xW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBtdXRhdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhZmZlY3RlZFN0b3Jlc18xKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtdXRhdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0YXRlcztcbiAgICB9O1xuICAgIHJldHVybiBTcGxpdHRlcjtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlGb3JLZXkoYWxsVWksIGV2ZW50VWlGb3JLZXksIGluZGl2aWR1YWxVaSkge1xuICAgIHZhciBiYXNlUGFydHMgPSBbXTtcbiAgICBpZiAoYWxsVWkpIHtcbiAgICAgICAgYmFzZVBhcnRzLnB1c2goYWxsVWkpO1xuICAgIH1cbiAgICBpZiAoZXZlbnRVaUZvcktleSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChldmVudFVpRm9yS2V5KTtcbiAgICB9XG4gICAgdmFyIHN0dWZmID0ge1xuICAgICAgICAnJzogY29tYmluZUV2ZW50VWlzKGJhc2VQYXJ0cyksXG4gICAgfTtcbiAgICBpZiAoaW5kaXZpZHVhbFVpKSB7XG4gICAgICAgIF9fYXNzaWduKHN0dWZmLCBpbmRpdmlkdWFsVWkpO1xuICAgIH1cbiAgICByZXR1cm4gc3R1ZmY7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVNZXRhKGRhdGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGRhdGVQcm9maWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgICAgICBpc0Rpc2FibGVkOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzT3RoZXI6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNQYXN0OiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA8IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlIDwgdG9kYXlSYW5nZS5zdGFydCkgOiBmYWxzZSksXG4gICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA+IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlID49IHRvZGF5UmFuZ2UuZW5kKSA6IGZhbHNlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF5Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtZGF5JyxcbiAgICAgICAgXCJmYy1kYXktXCIgKyBEQVlfSURTW21ldGEuZG93XSxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXRvZGF5Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc090aGVyKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNsb3QnLFxuICAgICAgICBcImZjLXNsb3QtXCIgKyBEQVlfSURTW21ldGEuZG93XSxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbnZhciBEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9KTtcbnZhciBXRUVLX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdsb25nJyB9KTtcbmZ1bmN0aW9uIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGVNYXJrZXIsIHZpZXdUeXBlLCBpc1RhYmJhYmxlKSB7XG4gICAgaWYgKHZpZXdUeXBlID09PSB2b2lkIDApIHsgdmlld1R5cGUgPSAnZGF5JzsgfVxuICAgIGlmIChpc1RhYmJhYmxlID09PSB2b2lkIDApIHsgaXNUYWJiYWJsZSA9IHRydWU7IH1cbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgY2FsZW5kYXJBcGkgPSBjb250ZXh0LmNhbGVuZGFyQXBpO1xuICAgIHZhciBkYXRlU3RyID0gZGF0ZUVudi5mb3JtYXQoZGF0ZU1hcmtlciwgdmlld1R5cGUgPT09ICd3ZWVrJyA/IFdFRUtfRk9STUFUIDogREFZX0ZPUk1BVCk7XG4gICAgaWYgKG9wdGlvbnMubmF2TGlua3MpIHtcbiAgICAgICAgdmFyIHpvbmVkRGF0ZSA9IGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpO1xuICAgICAgICB2YXIgaGFuZGxlSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21BY3Rpb24gPSB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPT09ICd3ZWVrJyA/IG9wdGlvbnMubmF2TGlua1dlZWtDbGljayA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbnZhciBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICB2YXIgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgdmFyIGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbnZhciBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcpIHtcbiAgICBpZiAoZ2V0UGFkZGluZyA9PT0gdm9pZCAwKSB7IGdldFBhZGRpbmcgPSBmYWxzZTsgfVxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHZhciBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICB2YXIgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIHZhciBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICB2YXIgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdDogYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQ6IGJvcmRlclJpZ2h0LFxuICAgICAgICBib3JkZXJUb3A6IGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tOiBib3JkZXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckJvdHRvbTogc2Nyb2xsYmFyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxiYXJSaWdodDogMCxcbiAgICB9O1xuICAgIGlmIChnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpICYmIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XG4gICAgICAgIHJlcy5zY3JvbGxiYXJMZWZ0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzLnNjcm9sbGJhclJpZ2h0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xuICAgIH1cbiAgICBpZiAoZ2V0UGFkZGluZykge1xuICAgICAgICByZXMucGFkZGluZ0xlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21wdXRlSW5uZXJSZWN0KGVsLCBnb1dpdGhpblBhZGRpbmcsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0KSB7XG4gICAgaWYgKGdvV2l0aGluUGFkZGluZyA9PT0gdm9pZCAwKSB7IGdvV2l0aGluUGFkZGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIG91dGVyUmVjdCA9IGRvRnJvbVdpbmRvd1ZpZXdwb3J0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBjb21wdXRlUmVjdChlbCk7XG4gICAgdmFyIGVkZ2VzID0gY29tcHV0ZUVkZ2VzKGVsLCBnb1dpdGhpblBhZGRpbmcpO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIGxlZnQ6IG91dGVyUmVjdC5sZWZ0ICsgZWRnZXMuYm9yZGVyTGVmdCArIGVkZ2VzLnNjcm9sbGJhckxlZnQsXG4gICAgICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgICAgICB0b3A6IG91dGVyUmVjdC50b3AgKyBlZGdlcy5ib3JkZXJUb3AsXG4gICAgICAgIGJvdHRvbTogb3V0ZXJSZWN0LmJvdHRvbSAtIGVkZ2VzLmJvcmRlckJvdHRvbSAtIGVkZ2VzLnNjcm9sbGJhckJvdHRvbSxcbiAgICB9O1xuICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICAgICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjbGlwcGluZ1BhcmVudHNfMSA9IGNsaXBwaW5nUGFyZW50czsgX2kgPCBjbGlwcGluZ1BhcmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICByZWN0ID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyhlbCkge1xuICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBjb21wdXRlVk1hcmdpbnMoZWwpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVZNYXJnaW5zKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Ub3AsIDEwKSArXG4gICAgICAgIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpbkJvdHRvbSwgMTApO1xufVxuLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyB3aWxsIHN0b3Agd2hlbiBnZXRzIHRvIGRvY3VtZW50IG9yIG51bGxcbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKC8oYXV0b3xzY3JvbGwpLykudGVzdChjb21wdXRlZFN0eWxlLm92ZXJmbG93ICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn1cblxuLy8gZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxuLy8gdGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG4vLyBvciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbi8vIGlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy50aGVuKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgfVxufVxuXG52YXIgRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBFbWl0dGVyLnByb3RvdHlwZS5zZXRUaGlzQ29udGV4dCA9IGZ1bmN0aW9uICh0aGlzQ29udGV4dCkge1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gdGhpc0NvbnRleHQ7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICB2YXIgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBoYW5kbGVyc18xID0gaGFuZGxlcnM7IF9hIDwgaGFuZGxlcnNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNfMVtfYV07XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMudGhpc0NvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5oYXNIYW5kbGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9O1xuICAgIHJldHVybiBFbWl0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgKGhhc2hbdHlwZV0gfHwgKGhhc2hbdHlwZV0gPSBbXSkpXG4gICAgICAgIC5wdXNoKGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYXNoW3R5cGVdKSB7XG4gICAgICAgICAgICBoYXNoW3R5cGVdID0gaGFzaFt0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMgIT09IGhhbmRsZXI7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgaGFzaFt0eXBlXTsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyIGZ1bmNzIGZvciB0aGlzIHR5cGVcbiAgICB9XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbnZhciBQb3NpdGlvbkNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGVscywgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZWxzID0gZWxzO1xuICAgICAgICB2YXIgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9IG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3AtbGVmdFxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChvcmlnaW5DbGllbnRMZWZ0KSB7XG4gICAgICAgIHZhciBsZWZ0cyA9IFtdO1xuICAgICAgICB2YXIgcmlnaHRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZWZ0cy5wdXNoKHJlY3QubGVmdCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcbiAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XG4gICAgfTtcbiAgICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZEVsVmVydGljYWxzID0gZnVuY3Rpb24gKG9yaWdpbkNsaWVudFRvcCkge1xuICAgICAgICB2YXIgdG9wcyA9IFtdO1xuICAgICAgICB2YXIgYm90dG9tcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3BzID0gdG9wcztcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcbiAgICB9O1xuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5sZWZ0VG9JbmRleCA9IGZ1bmN0aW9uIChsZWZ0UG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbGVmdHMgPSBfYS5sZWZ0cywgcmlnaHRzID0gX2EucmlnaHRzO1xuICAgICAgICB2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxuICAgIH07XG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUudG9wVG9JbmRleCA9IGZ1bmN0aW9uICh0b3BQb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0b3BzID0gX2EudG9wcywgYm90dG9tcyA9IF9hLmJvdHRvbXM7XG4gICAgICAgIHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfTtcbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG4gICAgfTtcbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9O1xuICAgIHJldHVybiBQb3NpdGlvbkNhY2hlO1xufSgpKTtcblxuLyogZXNsaW50IG1heC1jbGFzc2VzLXBlci1maWxlOiBcIm9mZlwiICovXG4vKlxuQW4gb2JqZWN0IGZvciBnZXR0aW5nL3NldHRpbmcgc2Nyb2xsLXJlbGF0ZWQgaW5mb3JtYXRpb24gZm9yIGFuIGVsZW1lbnQuXG5JbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdmVyeSBkaWZmZXJlbnRseSBmb3Igd2luZG93IHZlcnN1cyBET00gZWxlbWVudCxcbnNvIHRoaXMgb2JqZWN0IHNlcnZlcyBhcyBhIGNvbW1vbiBpbnRlcmZhY2UuXG4qL1xudmFyIFNjcm9sbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKSAtIHRoaXMuZ2V0Q2xpZW50SGVpZ2h0KCk7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxXaWR0aCgpIC0gdGhpcy5nZXRDbGllbnRXaWR0aCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVmVydGljYWxseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpID4gMDtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbERvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsQ29udHJvbGxlcjtcbn0oKSk7XG52YXIgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsID0gZWw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgdGhpcy5lbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsV2lkdGg7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRIZWlnaHQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xufShTY3JvbGxDb250cm9sbGVyKSk7XG52YXIgV2luZG93U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93U2Nyb2xsQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKHdpbmRvdy5wYWdlWE9mZnNldCwgbik7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1Njcm9sbENvbnRyb2xsZXI7XG59KFNjcm9sbENvbnRyb2xsZXIpKTtcblxudmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRoZW1lKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRoZW1lLnByb3RvdHlwZS5zZXRJY29uT3ZlcnJpZGUgPSBmdW5jdGlvbiAoaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICB2YXIgYnV0dG9uTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gX19hc3NpZ24oe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcbiAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH07XG4gICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUsIGlzUnRsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgIGlmIChpc1J0bCAmJiB0aGlzLnJ0bEljb25DbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLnJ0bEljb25DbGFzc2VzW2J1dHRvbk5hbWVdIHx8IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzID0gZnVuY3Rpb24gKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyBcIiBcIiArIHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGhlbWU7XG59KCkpO1xuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcblxudmFyIFNjcm9sbFJlc3BvbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIHNjcm9sbFRpbWUsIHNjcm9sbFRpbWVSZXNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV4ZWNGdW5jID0gZXhlY0Z1bmM7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZSA9IHNjcm9sbFRpbWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZVJlc2V0ID0gc2Nyb2xsVGltZVJlc2V0O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgX3RoaXMucXVldWVkUmVxdWVzdCA9IF9fYXNzaWduKHt9LCBfdGhpcy5xdWV1ZWRSZXF1ZXN0IHx8IHt9LCByZXF1ZXN0KTtcbiAgICAgICAgICAgIF90aGlzLmRyYWluKCk7XG4gICAgICAgIH07XG4gICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xuICAgIH1cbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9mZignX3Njcm9sbFJlcXVlc3QnLCB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaXNEYXRlc05ldykge1xuICAgICAgICBpZiAoaXNEYXRlc05ldyAmJiB0aGlzLnNjcm9sbFRpbWVSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpOyAvLyB3aWxsIGRyYWluXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFJlc3BvbmRlci5wcm90b3R5cGUuZmlyZUluaXRpYWxTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCh7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLnNjcm9sbFRpbWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkUmVxdWVzdCAmJiB0aGlzLmV4ZWNGdW5jKHRoaXMucXVldWVkUmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxSZXNwb25kZXI7XG59KCkpO1xuXG52YXIgVmlld0NvbnRleHRUeXBlID0gY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudjogZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzOiBwbHVnaW5Ib29rcyxcbiAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgICBnZXRDdXJyZW50RGF0YTogZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpOiBjYWxlbmRhckFwaSxcbiAgICAgICAgdmlld1NwZWM6IHZpZXdTcGVjLFxuICAgICAgICB2aWV3QXBpOiB2aWV3QXBpLFxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvcjogZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXG4gICAgICAgIGFkZFJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JvbGxSZXNwb25kZXI6IGZ1bmN0aW9uIChleGVjRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIGNyZWF0ZUR1cmF0aW9uKHZpZXdPcHRpb25zLnNjcm9sbFRpbWUpLCB2aWV3T3B0aW9ucy5zY3JvbGxUaW1lUmVzZXQpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgICAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xudmFyIFB1cmVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFB1cmVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhnZXRVbmVxdWFsUHJvcHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSwgZ2V0VW5lcXVhbFByb3BzKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29tcGFyZU9ianModGhpcy5wcm9wcywgbmV4dFByb3BzLCB0aGlzLnByb3BFcXVhbGl0eSkgfHxcbiAgICAgICAgICAgICFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUsIHRoaXMuc3RhdGVFcXVhbGl0eSk7XG4gICAgfTtcbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCBuZXdTdGF0ZSksIHRoaXMuc3RhdGVFcXVhbGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXJlQ29tcG9uZW50LmFkZFByb3BzRXF1YWxpdHkgPSBhZGRQcm9wc0VxdWFsaXR5O1xuICAgIFB1cmVDb21wb25lbnQuYWRkU3RhdGVFcXVhbGl0eSA9IGFkZFN0YXRlRXF1YWxpdHk7XG4gICAgUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gUHVyZUNvbXBvbmVudDtcbn0oQ29tcG9uZW50KSk7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5wcm9wRXF1YWxpdHkgPSB7fTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSB7fTtcbnZhciBCYXNlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gQmFzZUNvbXBvbmVudDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYWRkUHJvcHNFcXVhbGl0eShwcm9wRXF1YWxpdHkpIHtcbiAgICB2YXIgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5KTtcbiAgICBfX2Fzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICB2YXIgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgX19hc3NpZ24oaGFzaCwgc3RhdGVFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IGhhc2g7XG59XG4vLyB1c2Ugb3RoZXIgb25lXG5mdW5jdGlvbiBzZXRSZWYocmVmLCBjdXJyZW50KSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKGN1cnJlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMwMjlcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIH1cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbnZhciBEYXRlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGVDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51aWQgPSBndWlkKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICB9O1xuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWRTZWdEb3duRWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfTtcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc1ZhbGlkRGF0ZURvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLWV2ZW50Om5vdCguZmMtYmctZXZlbnQpJykgJiZcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1tb3JlLWxpbmsnKSAmJiAvLyBhIFwibW9yZS4uXCIgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnYVtkYXRhLW5hdmxpbmtdJykgJiYgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1wb3BvdmVyJyk7IC8vIGhhY2tcbiAgICB9O1xuICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGd1aWQoKSxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IGlucHV0LmNvbnRlbnRUeXBlSGFuZGxlcnMgfHwge30sXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIHZhciBpc0FkZGVkID0ge307XG4gICAgdmFyIGhvb2tzID0ge1xuICAgICAgICByZWR1Y2VyczogW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLFxuICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxuICAgICAgICBpbml0aWFsVmlldzogJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHt9LFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGVmc18xID0gZGVmczsgX2kgPCBkZWZzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc18xW19pXTtcbiAgICAgICAgICAgIGlmICghaXNBZGRlZFtkZWYuaWRdKSB7XG4gICAgICAgICAgICAgICAgaXNBZGRlZFtkZWYuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luRGVmcykge1xuICAgICAgICBhZGREZWZzKHBsdWdpbkRlZnMpO1xuICAgIH1cbiAgICBhZGREZWZzKGdsb2JhbERlZnMpO1xuICAgIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpIHtcbiAgICB2YXIgY3VycmVudE92ZXJyaWRlRGVmcyA9IFtdO1xuICAgIHZhciBjdXJyZW50R2xvYmFsRGVmcyA9IFtdO1xuICAgIHZhciBjdXJyZW50SG9va3M7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va3MgfHwgIWlzQXJyYXlzRXF1YWwob3ZlcnJpZGVEZWZzLCBjdXJyZW50T3ZlcnJpZGVEZWZzKSB8fCAhaXNBcnJheXNFcXVhbChnbG9iYWxEZWZzLCBjdXJyZW50R2xvYmFsRGVmcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRIb29rcyA9IGJ1aWxkUGx1Z2luSG9va3Mob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50T3ZlcnJpZGVEZWZzID0gb3ZlcnJpZGVEZWZzO1xuICAgICAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnM7XG4gICAgICAgIHJldHVybiBjdXJyZW50SG9va3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczAsIGhvb2tzMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBob29rczAuaXNMb2FkaW5nRnVuY3MuY29uY2F0KGhvb2tzMS5pc0xvYWRpbmdGdW5jcyksXG4gICAgICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3czogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC52aWV3cyksIGhvb2tzMS52aWV3cyksXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaG9va3MwLnZpZXdQcm9wc1RyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLnZpZXdQcm9wc1RyYW5zZm9ybWVycyksXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGhvb2tzMC5leHRlcm5hbERlZlRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5leHRlcm5hbERlZlRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaG9va3MwLnZpZXdDb250YWluZXJBcHBlbmRzLmNvbmNhdChob29rczEudmlld0NvbnRhaW5lckFwcGVuZHMpLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGhvb2tzMC5ldmVudERyb3BUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5ldmVudERyb3BUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGhvb2tzMC5jb21wb25lbnRJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jb21wb25lbnRJbnRlcmFjdGlvbnMpLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogX19hc3NpZ24oX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxuICAgICAgICBjb250ZW50VHlwZUhhbmRsZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaG9va3MwLmNvbnRlbnRUeXBlSGFuZGxlcnMpLCBob29rczEuY29udGVudFR5cGVIYW5kbGVycyksXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBob29rczAucHJvcFNldEhhbmRsZXJzKSwgaG9va3MxLnByb3BTZXRIYW5kbGVycyksXG4gICAgfTtcbn1cblxudmFyIFN0YW5kYXJkVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhbmRhcmRUaGVtZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhbmRhcmRUaGVtZTtcbn0oVGhlbWUpKTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcbiAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXG4gICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcblxuZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICB2YXIgaGFzaCA9IHt9O1xuICAgIHZhciB2aWV3VHlwZTtcbiAgICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBmb3IgKHZpZXdUeXBlIGluIG92ZXJyaWRlQ29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgICAgIHJldHVybiBoYXNoW3ZpZXdUeXBlXTtcbiAgICB9XG4gICAgdmFyIHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIGlmICh2aWV3RGVmKSB7XG4gICAgICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZjtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdEZWY7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWdzW3ZpZXdUeXBlXTtcbiAgICB2YXIgb3ZlcnJpZGVDb25maWcgPSBvdmVycmlkZUNvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIHZhciBxdWVyeVByb3AgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAgICgob3ZlcnJpZGVDb25maWcgJiYgb3ZlcnJpZGVDb25maWdbbmFtZV0gIT09IG51bGwpID8gb3ZlcnJpZGVDb25maWdbbmFtZV0gOiBudWxsKSk7IH07XG4gICAgdmFyIHRoZUNvbXBvbmVudCA9IHF1ZXJ5UHJvcCgnY29tcG9uZW50Jyk7XG4gICAgdmFyIHN1cGVyVHlwZSA9IHF1ZXJ5UHJvcCgnc3VwZXJUeXBlJyk7XG4gICAgdmFyIHN1cGVyRGVmID0gbnVsbDtcbiAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgIGlmIChzdXBlclR5cGUgPT09IHZpZXdUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgaGF2ZSBhIGN1c3RvbSB2aWV3IHR5cGUgdGhhdCByZWZlcmVuY2VzIGl0c2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgICAgICB0aGVDb21wb25lbnQgPSBzdXBlckRlZi5jb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld1R5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhlQ29tcG9uZW50LFxuICAgICAgICBkZWZhdWx0czogX19hc3NpZ24oX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5vdmVycmlkZXMgOiB7fSkpLCAob3ZlcnJpZGVDb25maWcgPyBvdmVycmlkZUNvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuLy8gTk9URTogaW4gSlNYLCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgdGhpcyBjbGFzcyB3aXRoIDxIb29rUHJvcHM+IGFyZy4gb3RoZXJ3aXNlLCB3aWxsIGRlZmF1bHQgdG8gYW55Pz8/XG52YXIgUmVuZGVySG9vayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVySG9vaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJIb29rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVuZGVySG9vay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gcHJvcHMuaG9va1Byb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogcHJvcHMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBwcm9wcy53aWxsVW5tb3VudCwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjb250ZW50OiBwcm9wcy5jb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQsIGJhY2t1cEVsUmVmOiBfdGhpcy5yb290RWxSZWYgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBub3JtYWxpemVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZXMsIGhvb2tQcm9wcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCk7IH0pKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlckhvb2s7XG59KEJhc2VDb21wb25lbnQpKTtcbi8vIFRPRE86IHJlbmFtZSB0byBiZSBhYm91dCBmdW5jdGlvbiwgbm90IGRlZmF1bHQuIHVzZSBpbiBhYm92ZSB0eXBlXG4vLyBmb3IgZm9yY2luZyByZXJlbmRlciBvZiBjb21wb25lbnRzIHRoYXQgdXNlIHRoZSBDb250ZW50SG9va1xudmFyIEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcbmZ1bmN0aW9uIENvbnRlbnRIb29rKHByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAocmVuZGVySWQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRIb29rSW5uZXIsIF9fYXNzaWduKHsgcmVuZGVySWQ6IHJlbmRlcklkIH0sIHByb3BzKSkpOyB9KSk7XG59XG52YXIgQ29udGVudEhvb2tJbm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGVudEhvb2tJbm5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250ZW50SG9va0lubmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5uZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5pbm5lckVsUmVmLCB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDdXN0b21Db250ZW50KCk7XG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8gJiYgdGhpcy5jdXN0b21Db250ZW50SW5mby5kZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvOyAvLyBvbmx5IHBvcHVsYXRlZCBpZiB1c2luZyBub24tW3BdcmVhY3Qgbm9kZShzKVxuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gdGhpcy5nZXRJbm5lckNvbnRlbnQoKTtcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLmdldENvbnRlbnRNZXRhKGlubmVyQ29udGVudCk7XG4gICAgICAgIC8vIGluaXRpYWwgcnVuLCBvciBjb250ZW50LXR5cGUgY2hhbmdpbmc/IChmcm9tIHZ1ZSAtPiByZWFjdCBmb3IgZXhhbXBsZSlcbiAgICAgICAgaWYgKCFjdXN0b21Db250ZW50SW5mbyB8fCBjdXN0b21Db250ZW50SW5mby5jb250ZW50S2V5ICE9PSBtZXRhLmNvbnRlbnRLZXkpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyaW5nIG9sZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXNzaWduaW5nIG5ldyB2YWx1ZVxuICAgICAgICAgICAgaWYgKG1ldGEuY29udGVudEtleSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IF9fYXNzaWduKHsgY29udGVudEtleTogbWV0YS5jb250ZW50S2V5LCBjb250ZW50VmFsOiBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XSB9LCBtZXRhLmJ1aWxkTGlmZWN5Y2xlRnVuY3MoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsID0gaW5uZXJDb250ZW50W21ldGEuY29udGVudEtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnRlbnRJbmZvXG4gICAgICAgICAgICA/IFtdIC8vIHNpZ25hbCB0aGF0IHNvbWV0aGluZyB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICA6IGlubmVyQ29udGVudDsgLy8gYXNzdW1lIGEgW3BdcmVhY3QgdmRvbSBub2RlLiB1c2UgaXRcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmdldElubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGlubmVyQ29udGVudCA9IG5vcm1hbGl6ZUNvbnRlbnQocHJvcHMuY29udGVudCwgcHJvcHMuaG9va1Byb3BzKTtcbiAgICAgICAgaWYgKGlubmVyQ29udGVudCA9PT0gdW5kZWZpbmVkKSB7IC8vIHVzZSB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5kZWZhdWx0Q29udGVudCwgcHJvcHMuaG9va1Byb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5uZXJDb250ZW50ID09IG51bGwgPyBudWxsIDogaW5uZXJDb250ZW50OyAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIChiZXR0ZXIgZm9yIFJlYWN0KVxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuZ2V0Q29udGVudE1ldGEgPSBmdW5jdGlvbiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgIHZhciBjb250ZW50VHlwZUhhbmRsZXJzID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLmNvbnRlbnRUeXBlSGFuZGxlcnM7XG4gICAgICAgIHZhciBjb250ZW50S2V5ID0gJyc7XG4gICAgICAgIHZhciBidWlsZExpZmVjeWNsZUZ1bmNzID0gbnVsbDtcbiAgICAgICAgaWYgKGlubmVyQ29udGVudCkgeyAvLyBhbGxvd2VkIHRvIGJlIG51bGwsIGZvciBjb252ZW5pZW5jZSB0byBjYWxsZXJcbiAgICAgICAgICAgIGZvciAodmFyIHNlYXJjaEtleSBpbiBjb250ZW50VHlwZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudFtzZWFyY2hLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEtleSA9IHNlYXJjaEtleTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRMaWZlY3ljbGVGdW5jcyA9IGNvbnRlbnRUeXBlSGFuZGxlcnNbc2VhcmNoS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbnRlbnRLZXk6IGNvbnRlbnRLZXksIGJ1aWxkTGlmZWN5Y2xlRnVuY3M6IGJ1aWxkTGlmZWN5Y2xlRnVuY3MgfTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUNvbnRlbnRJbmZvKSB7IC8vIGZvciBub24tW3BdcmVhY3RcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8ucmVuZGVyKHRoaXMuaW5uZXJFbFJlZi5jdXJyZW50IHx8IHRoaXMucHJvcHMuYmFja3VwRWxSZWYuY3VycmVudCwgLy8gdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGludG9cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb250ZW50SG9va0lubmVyO1xufShCYXNlQ29tcG9uZW50KSk7XG52YXIgTW91bnRIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb3VudEhvb2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW91bnRIb29rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCByb290RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vdW50SG9vay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmhhbmRsZVJvb3RFbCk7XG4gICAgfTtcbiAgICBNb3VudEhvb2sucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzLmRpZE1vdW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmhvb2tQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW91bnRIb29rLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5wcm9wcy53aWxsVW5tb3VudDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5ob29rUHJvcHMpLCB7IGVsOiB0aGlzLnJvb3RFbCB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb3VudEhvb2s7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcigpIHtcbiAgICB2YXIgY3VycmVudEdlbmVyYXRvcjtcbiAgICB2YXIgY3VycmVudEhvb2tQcm9wcztcbiAgICB2YXIgY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGdlbmVyYXRvciwgaG9va1Byb3BzKSB7XG4gICAgICAgIGlmICghY3VycmVudEhvb2tQcm9wcyB8fCAhaXNQcm9wc0VxdWFsKGN1cnJlbnRIb29rUHJvcHMsIGhvb2tQcm9wcykgfHwgZ2VuZXJhdG9yICE9PSBjdXJyZW50R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50R2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgY3VycmVudEhvb2tQcm9wcyA9IGhvb2tQcm9wcztcbiAgICAgICAgICAgIGN1cnJlbnRDbGFzc05hbWVzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhnZW5lcmF0b3IsIGhvb2tQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDbGFzc05hbWVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKGNsYXNzTmFtZXMsIGhvb2tQcm9wcykge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcyhob29rUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChpbnB1dCwgaG9va1Byb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5wdXQoaG9va1Byb3BzLCBjcmVhdGVFbGVtZW50KTsgLy8gZ2l2ZSB0aGUgZnVuY3Rpb24gdGhlIHZkb20tY3JlYXRpb24gZnVuY1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbnZhciBWaWV3Um9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld1Jvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld1Jvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzID0gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlld1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgdmFyIGN1c3RvbUNsYXNzTmFtZXMgPSB0aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgaG9va1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vdW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgZGlkTW91bnQ6IG9wdGlvbnMudmlld0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy52aWV3V2lsbFVubW91bnQsIGVsUmVmOiBwcm9wcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmKSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIFtcImZjLVwiICsgcHJvcHMudmlld1NwZWMudHlwZSArIFwiLXZpZXdcIiwgJ2ZjLXZpZXcnXS5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld1Jvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICB2YXIgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IHJhd09wdGlvbnMuY29tcG9uZW50O1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQocmF3T3B0aW9ucyk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICByYXdPcHRpb25zOiByYXdPcHRpb25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3UHJvcHMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uICh2aWV3RWxSZWYsIHZpZXdDbGFzc05hbWVzKSB7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuY2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5jb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2lsbFVubW91bnQsIGVsUmVmOiB2aWV3RWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogdmlld0NsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9KSk7IH0pKTsgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgdmFyIG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICB2YXIgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsIGZ1bmN0aW9uICh2aWV3RGVmKSB7IHJldHVybiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICB2YXIgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgdmFyIHNpbmdsZVVuaXQgPSAnJztcbiAgICB2YXIgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIHZhciBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHF1ZXJ5QnV0dG9uVGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zU3Vic2V0KSB7XG4gICAgICAgIHZhciBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICB2YXIgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHZhciBxdWVyeUJ1dHRvblRpdGxlID0gZnVuY3Rpb24gKG9wdGlvbnNTdWJzZXQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgdmFyIGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvblVuaXQ6IGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdDogc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogX19hc3NpZ24oX19hc3NpZ24oe30sIHNpbmdsZVVuaXRPdmVycmlkZXMpLCB2aWV3RGVmLm92ZXJyaWRlcyksXG4gICAgICAgIGJ1dHRvblRleHRPdmVycmlkZTogcXVlcnlCdXR0b25UZXh0KGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uT3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxuICAgICAgICBidXR0b25UZXh0RGVmYXVsdDogcXVlcnlCdXR0b25UZXh0KGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQoQkFTRV9PUFRJT05fREVGQVVMVFMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLnR5cGUsXG4gICAgICAgIC8vIG5vdCBEUllcbiAgICAgICAgYnV0dG9uVGl0bGVPdmVycmlkZTogcXVlcnlCdXR0b25UaXRsZShkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShvcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25IaW50LFxuICAgICAgICBidXR0b25UaXRsZURlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGl0bGUobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvbkhpbnQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUoQkFTRV9PUFRJT05fREVGQVVMVFMpLFxuICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgZmFsbCBiYWNrIHRvIGJ1dHRvblRleHRcbiAgICB9O1xufVxuLy8gaGFjayB0byBnZXQgbWVtb2l6YXRpb24gd29ya2luZ1xudmFyIGR1cmF0aW9uSW5wdXRNYXAgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpIHtcbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGR1cmF0aW9uSW5wdXQpO1xuICAgIHZhciByZXMgPSBkdXJhdGlvbklucHV0TWFwW2pzb25dO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KTtcbiAgICAgICAgZHVyYXRpb25JbnB1dE1hcFtqc29uXSA9IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRQcmV2ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMucHJvcHMuZGF0ZUVudjtcbiAgICAgICAgdmFyIHByZXZEYXRlID0gZGF0ZUVudi5zdWJ0cmFjdChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZE5leHQgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgbmV4dERhdGUgPSBkYXRlRW52LmFkZChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxLCBmb3JjZVRvVmFsaWQpO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZSwgZGlyZWN0aW9uLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCA9PT0gdm9pZCAwKSB7IGZvcmNlVG9WYWxpZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHZhbGlkUmFuZ2U7XG4gICAgICAgIHZhciBjdXJyZW50SW5mbztcbiAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XG4gICAgICAgIHZhciByZW5kZXJSYW5nZTtcbiAgICAgICAgdmFyIGFjdGl2ZVJhbmdlO1xuICAgICAgICB2YXIgaXNWYWxpZDtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkUmFuZ2UpO1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudEluZm8ucmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcbiAgICAgICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgICAgIC8vIG9yIGlmIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpc1ZhbGlkID0gcmFuZ2VzSW50ZXJzZWN0KGN1cnJlbnRJbmZvLnJhbmdlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnQgZm9yIHdoZXJlIHByZXYvbmV4dCBvcGVyYXRpb25zIGNhbiBnbyBhbmQgd2hlcmUgZXZlbnRzIGNhbiBiZSBkcmFnZ2VkL3Jlc2l6ZWQgdG8uXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YWxpZFJhbmdlOiB2YWxpZFJhbmdlLFxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuICAgICAgICAgICAgY3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlOiBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG4gICAgICAgICAgICBzbG90TWluVGltZTogcHJvcHMuc2xvdE1pblRpbWUsXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBleGNsdXNpdmUgdmlzaWJsZSBlbmQgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG4gICAgICAgICAgICBzbG90TWF4VGltZTogcHJvcHMuc2xvdE1heFRpbWUsXG4gICAgICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbiksXG4gICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIHZhciBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXG4gICAgLy8gaGlnaGxpZ2h0ZWQgYXMgYmVpbmcgdGhlIGN1cnJlbnQgbW9udGggZm9yIGV4YW1wbGUuXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1cnJlbnRSYW5nZUluZm8gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcbiAgICAgICAgdmFyIHJhbmdlID0gbnVsbDtcbiAgICAgICAgdmFyIGRheUNvdW50O1xuICAgICAgICBpZiAocHJvcHMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb247XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5wcm9wcy5kYXlDb3VudCkpIHtcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyYW5nZSA9IHRoaXMuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkpKSB7XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZGF0ZUVudi5ncmVhdGVzdFdob2xlVW5pdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKS51bml0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcbiAgICAgICAgICAgIHVuaXQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pLnVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHJhbmdlOiByYW5nZSB9O1xuICAgIH07XG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheTogMSB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5hZGp1c3RBY3RpdmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgdXNlc01pbk1heFRpbWUgPSBfYS51c2VzTWluTWF4VGltZSwgc2xvdE1pblRpbWUgPSBfYS5zbG90TWluVGltZSwgc2xvdE1heFRpbWUgPSBfYS5zbG90TWF4VGltZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgaWYgKHVzZXNNaW5NYXhUaW1lKSB7XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNaW5UaW1lIGlzIG5lZ2F0aXZlICh3aHkgbm90IHdoZW4gcG9zaXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNaW5UaW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LmFkZChzdGFydCwgc2xvdE1pblRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIG5lZ2F0aXZlPylcbiAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWF4VGltZSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIC0xKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIHNsb3RNYXhUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxuICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EdXJhdGlvbiA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBkYXRlQWxpZ25tZW50ID0gX2EuZGF0ZUFsaWdubWVudDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICAgICAgaWYgKCFkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUluY3JlbWVudCA9IHRoaXMucHJvcHMuZGF0ZUluY3JlbWVudDtcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbURheUNvdW50ID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgPSBfYS5kYXRlQWxpZ25tZW50O1xuICAgICAgICB2YXIgcnVubmluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKGRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKHN0YXJ0LCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgMSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW5EYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChydW5uaW5nQ291bnQgPCBkYXlDb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhIG5vcm1hbGl6ZWQgcmFuZ2Ugb2JqZWN0IGZvciB0aGUgXCJ2aXNpYmxlXCIgcmFuZ2UsXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGlucHV0ID0gcHJvcHMudmlzaWJsZVJhbmdlSW5wdXQ7XG4gICAgICAgIHZhciBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHByb3BzLmNhbGVuZGFyQXBpLCBwcm9wcy5kYXRlRW52LnRvRGF0ZShkYXRlKSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgKHJhbmdlLnN0YXJ0ID09IG51bGwgfHwgcmFuZ2UuZW5kID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmFuZ2U7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gICAgLy8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGREYXRlSW5jcmVtZW50ID0gZnVuY3Rpb24gKGZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50ID0gdGhpcy5wcm9wcy5kYXRlSW5jcmVtZW50O1xuICAgICAgICB2YXIgY3VzdG9tQWxpZ25tZW50O1xuICAgICAgICBpZiAoZGF0ZUluY3JlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLnByb3BzLmRhdGVBbGlnbm1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pO1xuICAgIH07XG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnJlZmluZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKiBIaWRkZW4gRGF5c1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhpZGRlbkRheXMgPSB0aGlzLnByb3BzLmhpZGRlbkRheXMgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgICAgIHZhciBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxuICAgICAgICB2YXIgZGF5Q250ID0gMDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndlZWtlbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9IGhpZGRlbkRheXMuaW5kZXhPZihpKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZGF5Q250ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XG4gICAgfTtcbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuICAgIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgRGF0ZSAodXNlZCBmb3IgVVRDKVxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pc0hpZGRlbkRheSA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRheSA9IGRheS5nZXRVVENEYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcbiAgICB9O1xuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnNraXBIaWRkZW5EYXlzID0gZnVuY3Rpb24gKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluYyA9PT0gdm9pZCAwKSB7IGluYyA9IDE7IH1cbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB2b2lkIDApIHsgaXNFeGNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG59KCkpO1xuXG5mdW5jdGlvbiByZWR1Y2VWaWV3VHlwZSh2aWV3VHlwZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHZpZXdUeXBlID0gYWN0aW9uLnZpZXdUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1R5cGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCAoX2EgPSB7fSwgX2FbYWN0aW9uLm9wdGlvbk5hbWVdID0gYWN0aW9uLnJhd09wdGlvblZhbHVlLCBfYSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShjdXJyZW50RGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgdmFyIGRwO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIgfHwgY3VycmVudERhdGUpO1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIpO1xuICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGU7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xuICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xuICAgIGZvciAodmFyIHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfaSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNfMVtfaV07XG4gICAgICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgaGFzaCA9IGZldGNoRGlydHlTb3VyY2VzKGhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkOyB9KTtcbn1cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpOyB9KSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xuICAgIH1cbiAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcbiAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcbiAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIHZhciBuZXh0U291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTb3VyY2VzO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgdmFyIHNvdXJjZURlZiA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICB2YXIgZmV0Y2hJZCA9IGd1aWQoKTtcbiAgICBzb3VyY2VEZWYuZmV0Y2goe1xuICAgICAgICBldmVudFNvdXJjZTogZXZlbnRTb3VyY2UsXG4gICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICBpc1JlZmV0Y2g6IGlzUmVmZXRjaCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciByYXdFdmVudHMgPSByZXMucmF3RXZlbnRzO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgcmF3RXZlbnRzOiByYXdFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkOiBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogdHJ1ZSwgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCB9KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc291cmNlSGFzaCksIChfYSA9IHt9LCBfYVtzb3VyY2VJZF0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlIH0pLCBfYSkpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlSGFzaDtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7IHJldHVybiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KTsgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XG4gICAgdmFyIHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xuICAgIHZhciBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHJhd1NvdXJjZXNfMSA9IHJhd1NvdXJjZXM7IF9pIDwgcmF3U291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmF3U291cmNlID0gcmF3U291cmNlc18xW19pXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2UocmF3U291cmNlLCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApOyB9KTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIHZhciBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICB2YXIgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgdmFyIHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmF3RXZlbnRzXzEgPSByYXdFdmVudHM7IF9pIDwgcmF3RXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmF3RXZlbnQgPSByYXdFdmVudHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XG4gICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XG4gICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XG59XG5mdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcbn1cbmZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5IHx8IGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbnN0YW5jZSksIHsgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvKSksXG4gICAgICAgICAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpLFxuICAgICAgICAgICAgfSwgZm9yY2VkU3RhcnRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkRW5kVHpvIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZDsgfSk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF07IH0pLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RlZEV2ZW50KGN1cnJlbnRJbnN0YW5jZUlkLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAnU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRJbnN0YW5jZUlkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZUlkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24pIHtcbiAgICB2YXIgbmV3RHJhZztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XG4gICAgdmFyIG5ld1Jlc2l6ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXJzKGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgdmFyIGhlYWRlciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHZhciBmb290ZXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICByZXR1cm4geyBoZWFkZXI6IGhlYWRlciwgZm9vdGVyOiBmb290ZXIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihzZWN0aW9uU3RySGFzaCwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgc2VjdGlvbldpZGdldHMgPSB7fTtcbiAgICB2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIHZhciBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHNlY3Rpb25OYW1lIGluIHNlY3Rpb25TdHJIYXNoKSB7XG4gICAgICAgIHZhciBzZWN0aW9uU3RyID0gc2VjdGlvblN0ckhhc2hbc2VjdGlvbk5hbWVdO1xuICAgICAgICB2YXIgc2VjdGlvblJlcyA9IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHNlY3Rpb25XaWRnZXRzW3NlY3Rpb25OYW1lXSA9IHNlY3Rpb25SZXMud2lkZ2V0cztcbiAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoLmFwcGx5KHZpZXdzV2l0aEJ1dHRvbnMsIHNlY3Rpb25SZXMudmlld3NXaXRoQnV0dG9ucyk7XG4gICAgICAgIGhhc1RpdGxlID0gaGFzVGl0bGUgfHwgc2VjdGlvblJlcy5oYXNUaXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VjdGlvbldpZGdldHM6IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zOiB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZTogaGFzVGl0bGUgfTtcbn1cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgLy8gZGVmYXVsdHMrb3ZlcnJpZGVzLCB0aGVuIHJlZmluZWRcbmNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCAvLyBvdmVycmlkZXMgb25seSEsIHVucmVmaW5lZCA6KFxudGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuICAgIHZhciBjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25IaW50cyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25IaW50cyA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25IaW50cyB8fCB7fTtcbiAgICB2YXIgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW107XG4gICAgdmFyIHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICB2YXIgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICB2YXIgd2lkZ2V0cyA9IHNlY3Rpb25TdWJzdHJzLm1hcChmdW5jdGlvbiAoYnV0dG9uR3JvdXBTdHIpIHsgcmV0dXJuIChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgaGFzVGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXN0b21CdXR0b25Qcm9wcztcbiAgICAgICAgdmFyIHZpZXdTcGVjO1xuICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XG4gICAgICAgIHZhciBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICB2YXIgYnV0dG9uVGV4dDsgLy8gXCJcbiAgICAgICAgdmFyIGJ1dHRvbkhpbnQ7XG4gICAgICAgIC8vIF4gZm9yIHRoZSB0aXRsZT1cIlwiIGF0dHJpYnV0ZSwgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldiwgZXYudGFyZ2V0KTsgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGN1c3RvbUJ1dHRvblByb3BzLmhpbnQgfHwgY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcbiAgICAgICAgICAgIHZhciB0ZXh0RmFsbGJhY2sgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHModmlld1NwZWMuYnV0dG9uVGl0bGVPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRpdGxlRGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy52aWV3SGludCwgW3RleHRGYWxsYmFjaywgYnV0dG9uTmFtZV0sIC8vIHZpZXctbmFtZSA9IGJ1dHRvbk5hbWVcbiAgICAgICAgICAgIHRleHRGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgfHwgYnV0dG9uTmFtZSA9PT0gJ25leHRZZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2T3JOZXh0ID0gYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1twcmV2T3JOZXh0XSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW3ByZXZPck5leHRdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dC55ZWFyIHx8ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZnVuY3Rpb24gKG5hdlVuaXQpIHsgcmV0dXJuIGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbYnV0dG9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1tidXR0b25OYW1lXSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHRbbmF2VW5pdF0gfHwgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWU6IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrOiBidXR0b25DbGljaywgYnV0dG9uSWNvbjogYnV0dG9uSWNvbiwgYnV0dG9uVGV4dDogYnV0dG9uVGV4dCwgYnV0dG9uSGludDogYnV0dG9uSGludCB9O1xuICAgIH0pKTsgfSk7XG4gICAgcmV0dXJuIHsgd2lkZ2V0czogd2lkZ2V0cywgdmlld3NXaXRoQnV0dG9uczogdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGU6IGhhc1RpdGxlIH07XG59XG5cbnZhciBldmVudFNvdXJjZURlZiQyID0ge1xuICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmaW5lZC5ldmVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2Vzcykge1xuICAgICAgICBzdWNjZXNzKHtcbiAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xudmFyIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdLFxufSk7XG5cbnZhciBldmVudFNvdXJjZURlZiQxID0ge1xuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVkLmV2ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIChhcmcsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBhcmcuY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSwgZnVuY3Rpb24gKHJhd0V2ZW50cykge1xuICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzIH0pOyAvLyBuZWVkcyBhbiBvYmplY3QgcmVzcG9uc2VcbiAgICAgICAgfSwgZmFpbHVyZSk7XG4gICAgfSxcbn07XG52YXIgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXSxcbn0pO1xuXG5mdW5jdGlvbiByZXF1ZXN0SnNvbihtZXRob2QsIHVybCwgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICB1cmwgPSBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gZW5jb2RlUGFyYW1zKHBhcmFtcyk7XG4gICAgfVxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGhhbmRsZSBwYXJzZWQ9ZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2socmVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdGYWlsdXJlIHBhcnNpbmcgSlNPTicsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ1JlcXVlc3QgZmFpbGVkJywgeGhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpO1xuICAgIH07XG4gICAgeGhyLnNlbmQoYm9keSk7XG59XG5mdW5jdGlvbiBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgIHJldHVybiB1cmwgK1xuICAgICAgICAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgZW5jb2RlUGFyYW1zKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJhbXMocGFyYW1zKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJyYnKTtcbn1cblxudmFyIEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gICAgbWV0aG9kOiBTdHJpbmcsXG4gICAgZXh0cmFQYXJhbXM6IGlkZW50aXR5LFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbn07XG5cbnZhciBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGE6IGZ1bmN0aW9uIChyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KTtcbiAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zLCBmdW5jdGlvbiAocmF3RXZlbnRzLCB4aHIpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3MoeyByYXdFdmVudHM6IHJhd0V2ZW50cywgeGhyOiB4aHIgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UsIHhocikge1xuICAgICAgICAgICAgZmFpbHVyZSh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSwgeGhyOiB4aHIgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xudmFyIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgc3RhcnRQYXJhbTtcbiAgICB2YXIgZW5kUGFyYW07XG4gICAgdmFyIHRpbWVab25lUGFyYW07XG4gICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW07XG4gICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtO1xuICAgIH1cbiAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XG4gICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtO1xuICAgIH1cbiAgICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtO1xuICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICB9XG4gICAgX19hc3NpZ24ocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKTtcbiAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgcGFyYW1zW2VuZFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgaWYgKGRhdGVFbnYudGltZVpvbmUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cblxudmFyIFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gICAgZGF5c09mV2VlazogaWRlbnRpdHksXG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc3RhcnRSZWN1cjogaWRlbnRpdHksXG4gICAgZW5kUmVjdXI6IGlkZW50aXR5LFxufTtcblxudmFyIHJlY3VycmluZyA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24gKHJlZmluZWQsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKHJlZmluZWQuZGF5c09mV2VlayB8fCByZWZpbmVkLnN0YXJ0VGltZSB8fCByZWZpbmVkLmVuZFRpbWUgfHwgcmVmaW5lZC5zdGFydFJlY3VyIHx8IHJlZmluZWQuZW5kUmVjdXIpIHtcbiAgICAgICAgICAgIHZhciByZWN1cnJpbmdEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiByZWZpbmVkLmVuZFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogcmVmaW5lZC5lbmRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuZW5kUmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nRGF0YSwgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24gKHR5cGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgdmFyIGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyh0eXBlRGF0YS5kYXlzT2ZXZWVrLCB0eXBlRGF0YS5zdGFydFRpbWUsIGNsaXBwZWRGcmFtaW5nUmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxufTtcbnZhciBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSk7XG5mdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICB2YXIgZG93SGFzaCA9IGRheXNPZldlZWsgPyBhcnJheVRvSGFzaChkYXlzT2ZXZWVrKSA6IG51bGw7XG4gICAgdmFyIGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kTWFya2VyID0gZnJhbWluZ1JhbmdlLmVuZDtcbiAgICB2YXIgaW5zdGFuY2VTdGFydHMgPSBbXTtcbiAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZVN0YXJ0IFxuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgID0gdm9pZCAwO1xuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XG59XG5cbnZhciBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICBldmVudHM6IGZ1bmN0aW9uIChldmVudHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICAgIH0sXG59KTtcbi8qXG5CVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxuKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcbiAgICB2YXIgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcbiAgICB2YXIgbmV3SW5wdXRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfMSA9IGlucHV0czsgX2kgPCBpbnB1dHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzFbX2ldO1xuICAgICAgICB2YXIgaW5wdXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xuICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgdW5mb3VuZFNvdXJjZXNfMSA9IHVuZm91bmRTb3VyY2VzOyBfYSA8IHVuZm91bmRTb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciB1bmZvdW5kU291cmNlID0gdW5mb3VuZFNvdXJjZXNfMVtfYV07XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYiA9IDAsIG5ld0lucHV0c18xID0gbmV3SW5wdXRzOyBfYiA8IG5ld0lucHV0c18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgbmV3SW5wdXQgPSBuZXdJbnB1dHNfMVtfYl07XG4gICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSksIHsgdmlldzogY29udGV4dC52aWV3QXBpIH0pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVtaXR0ZXIgPSBjb250ZXh0LmVtaXR0ZXI7XG4gICAgaWYgKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50c1NldCcpKSB7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xudmFyIGdsb2JhbFBsdWdpbnMgPSBbXG4gICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcbiAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXG4gICAgY2hhbmdlSGFuZGxlclBsdWdpbixcbiAgICBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBpc0xvYWRpbmdGdW5jczogW1xuICAgICAgICAgICAgZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpOyB9LFxuICAgICAgICBdLFxuICAgICAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB7XG4gICAgICAgICAgICBodG1sOiBidWlsZEh0bWxSZW5kZXJlcixcbiAgICAgICAgICAgIGRvbU5vZGVzOiBidWlsZERvbU5vZGVSZW5kZXJlcixcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgICAgICB9LFxuICAgIH0pLFxuXTtcbmZ1bmN0aW9uIGJ1aWxkSHRtbFJlbmRlcmVyKCkge1xuICAgIHZhciBjdXJyZW50RWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50SHRtbCA9ICcnO1xuICAgIGZ1bmN0aW9uIHJlbmRlcihlbCwgaHRtbCkge1xuICAgICAgICBpZiAoZWwgIT09IGN1cnJlbnRFbCB8fCBodG1sICE9PSBjdXJyZW50SHRtbCkge1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RWwgPSBlbDtcbiAgICAgICAgY3VycmVudEh0bWwgPSBodG1sO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjdXJyZW50RWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRIdG1sID0gJyc7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlcjogcmVuZGVyLCBkZXN0cm95OiBkZXN0cm95IH07XG59XG5mdW5jdGlvbiBidWlsZERvbU5vZGVSZW5kZXJlcigpIHtcbiAgICB2YXIgY3VycmVudEVsID0gbnVsbDtcbiAgICB2YXIgY3VycmVudERvbU5vZGVzID0gW107XG4gICAgZnVuY3Rpb24gcmVuZGVyKGVsLCBkb21Ob2Rlcykge1xuICAgICAgICB2YXIgbmV3RG9tTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb21Ob2Rlcyk7XG4gICAgICAgIGlmIChlbCAhPT0gY3VycmVudEVsIHx8ICFpc0FycmF5c0VxdWFsKGN1cnJlbnREb21Ob2RlcywgbmV3RG9tTm9kZXMpKSB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgZmlyc3QsIHJlbW92ZSBzZWNvbmQgKGZvciBzY3JvbGwgcmVzZXR0aW5nKVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXdEb21Ob2Rlc18xID0gbmV3RG9tTm9kZXM7IF9pIDwgbmV3RG9tTm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld0RvbU5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRFbCA9IGVsO1xuICAgICAgICBjdXJyZW50RG9tTm9kZXMgPSBuZXdEb21Ob2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY3VycmVudERvbU5vZGVzLmZvckVhY2gocmVtb3ZlRWxlbWVudCk7XG4gICAgICAgIGN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICBjdXJyZW50RWwgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXI6IHJlbmRlciwgZGVzdHJveTogZGVzdHJveSB9O1xufVxuXG52YXIgRGVsYXllZFJ1bm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheWVkUnVubmVyKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSAnJzsgfVxuICAgICAgICB2YXIgcGF1c2VEZXB0aHMgPSB0aGlzLnBhdXNlRGVwdGhzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSAnJzsgfVxuICAgICAgICB2YXIgcGF1c2VEZXB0aHMgPSB0aGlzLnBhdXNlRGVwdGhzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXVzZURlcHRocykubGVuZ3RoO1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUudHJ5RHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZCgpOyAvLyBtaWdodCBzZXQgaXNEaXJ0eSB0byB0cnVlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5kcmFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlbGF5ZWRSdW5uZXI7XG59KCkpO1xuXG52YXIgVGFza1J1bm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXNrUnVubmVyKHJ1blRhc2tPcHRpb24sIGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uID0gcnVuVGFza09wdGlvbjtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmRyYWluLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHRhc2ssIGRlbGF5KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlcXVlc3QoZGVsYXkpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKTtcbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUuZHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWRUYXNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJ1blRhc2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICBpZiAodGhpcy5ydW5UYXNrT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24odGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLmRyYWluZWQgPSBmdW5jdGlvbiAoY29tcGxldGVkVGFza3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRhc2tSdW5uZXI7XG59KCkpO1xuXG4vLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhckFwaSBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZSwgdmlld09wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgY3JlYXRlRm9ybWF0dGVyKHZpZXdPcHRpb25zLnRpdGxlRm9ybWF0IHx8IGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpKSwge1xuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbi8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5mdW5jdGlvbiBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSB7XG4gICAgdmFyIGN1cnJlbnRSYW5nZVVuaXQgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0O1xuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgIH1cbiAgICB2YXIgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XG59XG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cbnZhciBDYWxlbmRhckRhdGFNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyRGF0YU1hbmFnZXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVPcHRpb25zRGF0YSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSk7XG4gICAgICAgIHRoaXMub3JnYW5pemVSYXdMb2NhbGVzID0gbWVtb2l6ZShvcmdhbml6ZVJhd0xvY2FsZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgIHRoaXMuYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52KTtcbiAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjcyA9IG1lbW9pemUoYnVpbGRWaWV3U3BlY3MpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdVaVByb3BzID0gbWVtb2l6ZU9iakFyZyhidWlsZFZpZXdVaVByb3BzKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbCk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKTtcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZU9iakFyZyhwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge307XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kYXRhOyB9O1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIHZhciBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB2YXIgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3O1xuICAgICAgICB2YXIgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQ7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfYVtfaV07XG4gICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVCBEUllcbiAgICAgICAgdmFyIGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGU6IGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzOiBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnRleHRBbmRTdGF0ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgcmVkdWNlciA9IF9jW19iXTtcbiAgICAgICAgICAgIF9fYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7IC8vIE5PVCBEUllcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVzdW1lKCk7XG4gICAgfVxuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLnJlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25PdmVycmlkZXMsIGFwcGVuZCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBhcHBlbmRcbiAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzLm9wdGlvbk92ZXJyaWRlcyksIG9wdGlvbk92ZXJyaWRlcykgOiBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLl9oYW5kbGVBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGVtaXR0ZXIgPSBfYS5lbWl0dGVyO1xuICAgICAgICB2YXIgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgdmFyIGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRlID0gc3RhdGUuY3VycmVudERhdGUsIGRhdGVQcm9maWxlID0gc3RhdGUuZGF0ZVByb2ZpbGU7XG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XG4gICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXG4gICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXG4gICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIHZhciBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIHZhciBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXG4gICAgICAgIHZhciByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICBldmVudFN0b3JlO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSwgZXZlbnRVaVNpbmdsZUJhc2UgPSBfYi5ldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnID0gX2Iuc2VsZWN0aW9uQ29uZmlnOyAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICAgIHZhciBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcyk7XG4gICAgICAgIHZhciBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlOiBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmUsXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogcmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnRleHRBbmRTdGF0ZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2VyczsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2NbX2ldO1xuICAgICAgICAgICAgX19hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHZhciB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxuICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xuICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB2YXIgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyB2aWV3VGl0bGU6IHRoaXMuYnVpbGRUaXRsZShzdGF0ZS5kYXRlUHJvZmlsZSwgY3VycmVudFZpZXdEYXRhLm9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpLCBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLCBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhIH0sIG9wdGlvbnNEYXRhKSwgY3VycmVudFZpZXdEYXRhKSwgc3RhdGUpO1xuICAgICAgICB2YXIgY2hhbmdlSGFuZGxlcnMgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5vcHRpb25DaGFuZ2VIYW5kbGVycztcbiAgICAgICAgdmFyIG9sZENhbGVuZGFyT3B0aW9ucyA9IG9sZERhdGEgJiYgb2xkRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIHZhciBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMudGltZVpvbmUgIT09IG5ld0NhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2tcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFNvdXJjZXMgPSBkYXRhLmV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGRhdGEuZXZlbnRTb3VyY2VzLCBzdGF0ZS5kYXRlUHJvZmlsZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTdG9yZSA9IGRhdGEuZXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLmV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5fY29tcHV0ZU9wdGlvbnNEYXRhID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgY2FsZW5kYXJBcGkpIHtcbiAgICAgICAgLy8gVE9ETzogYmxhY2tsaXN0IG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSBvcHRpb25DaGFuZ2VIYW5kbGVyc1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgcmVmaW5lZE9wdGlvbnMgPSBfYS5yZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MgPSBfYS5wbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMgPSBfYS5sb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IF9hLmF2YWlsYWJsZUxvY2FsZURhdGEsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYocmVmaW5lZE9wdGlvbnMudGltZVpvbmUsIHJlZmluZWRPcHRpb25zLmxvY2FsZSwgcmVmaW5lZE9wdGlvbnMud2Vla051bWJlckNhbGN1bGF0aW9uLCByZWZpbmVkT3B0aW9ucy5maXJzdERheSwgcmVmaW5lZE9wdGlvbnMud2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCByZWZpbmVkT3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICB2YXIgdmlld1NwZWNzID0gdGhpcy5idWlsZFZpZXdTcGVjcyhwbHVnaW5Ib29rcy52aWV3cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgb3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgZGF0ZUVudjogZGF0ZUVudixcbiAgICAgICAgICAgIHZpZXdTcGVjczogdmlld1NwZWNzLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZzogdG9vbGJhckNvbmZpZyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzOiBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIF9hID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSksIGxvY2FsZXMgPSBfYS5sb2NhbGVzLCBsb2NhbGUgPSBfYS5sb2NhbGU7XG4gICAgICAgIHZhciBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XG4gICAgICAgIHZhciBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XG4gICAgICAgIHZhciBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XG4gICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XG4gICAgICAgIHZhciByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICAgICAgdmFyIHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByZWZpbmVkID0ge307XG4gICAgICAgIHZhciBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQ7XG4gICAgICAgIHZhciBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIHZhciBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uTmFtZSAhPT0gJ3BsdWdpbnMnKSB7IC8vIGJlY2F1c2UgcGx1Z2lucyBpcyBzcGVjaWFsLWNhc2VkXG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBhdmFpbGFibGVMb2NhbGVEYXRhOiBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHM6IGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUuX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEgPSBmdW5jdGlvbiAodmlld1R5cGUsIG9wdGlvbnNEYXRhLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gb3B0aW9uc0RhdGEudmlld1NwZWNzW3ZpZXdUeXBlXTtcbiAgICAgICAgaWYgKCF2aWV3U3BlYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmlld1R5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UndmUgbG9hZGVkIGFsbCBuZWNjZXNzYXJ5IHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgcmVmaW5lZE9wdGlvbnMgPSBfYS5yZWZpbmVkT3B0aW9ucywgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICAgICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICAgICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgICAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICAgICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICAgICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIG1vbnRoTW9kZTogcmVmaW5lZE9wdGlvbnMubW9udGhNb2RlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHJldHVybiB7IHZpZXdTcGVjOiB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaTogdmlld0FwaSB9O1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1Jhd1ZpZXdPcHRpb25zID0gZnVuY3Rpb24gKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgcmVmaW5lcnMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xuICAgICAgICB2YXIgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIHZhciBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRyYSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRhTWFuYWdlcjtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZERhdGVFbnYodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZUltcGw6IHBsdWdpbkhvb2tzLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgICAgICBmaXJzdERheTogZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0OiB3ZWVrVGV4dCxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBwbHVnaW5Ib29rcy5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFRoZW1lKG9wdGlvbnMsIHBsdWdpbkhvb2tzKSB7XG4gICAgdmFyIFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZTtcbiAgICByZXR1cm4gbmV3IFRoZW1lQ2xhc3Mob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgdmFyIERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIHx8IERhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgIHJldHVybiBuZXcgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gbmV3IFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGV2ZW50U291cmNlLnVpOyB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIHZhciBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRVaVNpbmdsZUJhc2U6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgZGlzcGxheTogb3B0aW9ucy5ldmVudERpc3BsYXksXG4gICAgICAgICAgICBlZGl0YWJsZTogb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IG9wdGlvbnMuZXZlbnRTdGFydEVkaXRhYmxlLFxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogb3B0aW9ucy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLmV2ZW50Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLmV2ZW50T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ldmVudE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5ldmVudEFsbG93LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmV2ZW50QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuZXZlbnRCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIHRleHRDb2xvcjogb3B0aW9ucy5ldmVudFRleHRDb2xvcixcbiAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmV2ZW50Q29sb3IsXG4gICAgICAgICAgICAvLyBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcyAvLyByZW5kZXIgaG9vayB3aWxsIGhhbmRsZSB0aGlzXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZzogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5zZWxlY3RPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlbGVjdE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5zZWxlY3RBbGxvdyxcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY29udGV4dCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXNMb2FkaW5nRnVuYyA9IF9hW19pXTtcbiAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xuICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIG9wdGlvbiAnXCIgKyBvcHRpb25OYW1lICsgXCInXCIgK1xuICAgICAgICAgICAgKHZpZXdOYW1lID8gXCIgZm9yIHZpZXcgJ1wiICsgdmlld05hbWUgKyBcIidcIiA6ICcnKSk7XG4gICAgfVxufVxuXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gcmVhY3QgcGx1Z2luP1xudmFyIENhbGVuZGFyRGF0YVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxlbmRhckRhdGFQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhckRhdGFQcm92aWRlcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmRhdGFNYW5hZ2VyKSB7IC8vIHN0aWxsIHdpdGhpbiBpbml0aWFsIHJ1biwgYmVmb3JlIGFzc2lnbm1lbnQgaW4gY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGlyZWN0LW11dGF0aW9uLXN0YXRlXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBkYXRhOyAvLyBjYW4ndCB1c2Ugc2V0U3RhdGUgeWV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGF0YU1hbmFnZXIgPSBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7XG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXM6IHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIG9uRGF0YTogX3RoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FsZW5kYXJEYXRhUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgbmV3T3B0aW9uT3ZlcnJpZGVzID0gdGhpcy5wcm9wcy5vcHRpb25PdmVycmlkZXM7XG4gICAgICAgIGlmIChuZXdPcHRpb25PdmVycmlkZXMgIT09IHByZXZQcm9wcy5vcHRpb25PdmVycmlkZXMpIHsgLy8gcHJldmVudCByZWN1cnNpdmUgaGFuZGxlRGF0YVxuICAgICAgICAgICAgdGhpcy5kYXRhTWFuYWdlci5yZXNldE9wdGlvbnMobmV3T3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbGVuZGFyRGF0YVByb3ZpZGVyO1xufShDb21wb25lbnQpKTtcblxuLy8gSEVMUEVSU1xuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcbiAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcbn1cblxudmFyIE5hbWVkVGltZVpvbmVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVkVGltZVpvbmVJbXBsO1xufSgpKTtcblxudmFyIFNlZ0hpZXJhcmNoeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWdIaWVyYXJjaHkoKSB7XG4gICAgICAgIC8vIHNldHRpbmdzXG4gICAgICAgIHRoaXMuc3RyaWN0T3JkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxvd1Jlc2xpY2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1heENvb3JkID0gLTE7IC8vIC0xIG1lYW5zIG5vIG1heFxuICAgICAgICB0aGlzLm1heFN0YWNrQ250ID0gLTE7IC8vIC0xIG1lYW5zIG5vIG1heFxuICAgICAgICB0aGlzLmxldmVsQ29vcmRzID0gW107IC8vIG9yZGVyZWRcbiAgICAgICAgdGhpcy5lbnRyaWVzQnlMZXZlbCA9IFtdOyAvLyBwYXJhbGxlbCB3aXRoIGxldmVsQ29vcmRzXG4gICAgICAgIHRoaXMuc3RhY2tDbnRzID0ge307IC8vIFRPRE86IHVzZSBiZXR0ZXIgdGVjaG5pcXVlIT9cbiAgICB9XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5hZGRTZWdzID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzFbX2ldO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShpbnB1dCwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlbkVudHJpZXM7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSB0aGlzLmZpbmRJbnNlcnRpb24oZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5pc0luc2VydGlvblZhbGlkKGluc2VydGlvbiwgZW50cnkpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbik7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5pc0luc2VydGlvblZhbGlkID0gZnVuY3Rpb24gKGluc2VydGlvbiwgZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1heENvb3JkID09PSAtMSB8fCBpbnNlcnRpb24ubGV2ZWxDb29yZCArIGVudHJ5LnRoaWNrbmVzcyA8PSB0aGlzLm1heENvb3JkKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4U3RhY2tDbnQgPT09IC0xIHx8IGluc2VydGlvbi5zdGFja0NudCA8IHRoaXMubWF4U3RhY2tDbnQpO1xuICAgIH07XG4gICAgLy8gcmV0dXJucyBudW1iZXIgb2YgbmV3IGVudHJpZXMgaW5zZXJ0ZWRcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmhhbmRsZUludmFsaWRJbnNlcnRpb24gPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZyAmJiBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5zcGxpdEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBiYXJyaWVyLCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBwYXJ0Q250ID0gMDtcbiAgICAgICAgdmFyIHNwbGl0SGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICB2YXIgZW50cnlTcGFuID0gZW50cnkuc3BhbjtcbiAgICAgICAgdmFyIGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuO1xuICAgICAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGVudHJ5U3Bhbi5zdGFydCwgZW5kOiBiYXJyaWVyU3Bhbi5zdGFydCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgICAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRDbnQpIHtcbiAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaC5hcHBseShoaWRkZW5FbnRyaWVzLCBfX3NwcmVhZEFycmF5KFt7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGludGVyc2VjdFNwYW5zKGJhcnJpZXJTcGFuLCBlbnRyeVNwYW4pLCAvLyBndWFyYW50ZWVkIHRvIGludGVyc2VjdFxuICAgICAgICAgICAgICAgIH1dLCBzcGxpdEhpZGRlbkVudHJpZXMpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q250O1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5pbnNlcnRFbnRyeUF0ID0gZnVuY3Rpb24gKGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZW50cmllc0J5TGV2ZWwgPSBfYS5lbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgPSBfYS5sZXZlbENvb3JkcztcbiAgICAgICAgaWYgKGluc2VydGlvbi5sYXRlcmFsID09PSAtMSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGxldmVsXG4gICAgICAgICAgICBpbnNlcnRBdChsZXZlbENvb3JkcywgaW5zZXJ0aW9uLmxldmVsLCBpbnNlcnRpb24ubGV2ZWxDb29yZCk7XG4gICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbCwgaW5zZXJ0aW9uLmxldmVsLCBbZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBpbnRvIGV4aXN0aW5nIGxldmVsXG4gICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbFtpbnNlcnRpb24ubGV2ZWxdLCBpbnNlcnRpb24ubGF0ZXJhbCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkoZW50cnkpXSA9IGluc2VydGlvbi5zdGFja0NudDtcbiAgICB9O1xuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuZmluZEluc2VydGlvbiA9IGZ1bmN0aW9uIChuZXdFbnRyeSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBzdHJpY3RPcmRlciA9IF9hLnN0cmljdE9yZGVyLCBzdGFja0NudHMgPSBfYS5zdGFja0NudHM7XG4gICAgICAgIHZhciBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUNvb3JkID0gMDtcbiAgICAgICAgdmFyIHRvdWNoaW5nTGV2ZWwgPSAtMTtcbiAgICAgICAgdmFyIHRvdWNoaW5nTGF0ZXJhbCA9IC0xO1xuICAgICAgICB2YXIgdG91Y2hpbmdFbnRyeSA9IG51bGw7XG4gICAgICAgIHZhciBzdGFja0NudCA9IDA7XG4gICAgICAgIGZvciAodmFyIHRyYWNraW5nTGV2ZWwgPSAwOyB0cmFja2luZ0xldmVsIDwgbGV2ZWxDbnQ7IHRyYWNraW5nTGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxuICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIG5ld0VudHJ5LnRoaWNrbmVzcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgdmFyIHRyYWNraW5nRW50cnkgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgdmFyIGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0cmFja2luZ0VudHJ5LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3RzIGludG8gdGhlIHRvcCBvZiB0aGUgY2FuZGlkYXRlP1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQ29vcmQgPSB0cmFja2luZ0VudHJ5Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCA9IGxhdGVyYWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrQ250ID0gTWF0aC5tYXgoc3RhY2tDbnQsIHN0YWNrQ250c1tidWlsZEVudHJ5S2V5KHRyYWNraW5nRW50cnkpXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXRlcmFsSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGVzdGluYXRpb24gbGV2ZWwgd2lsbCBiZSBhZnRlciB0b3VjaGluZ0VudHJ5J3MgbGV2ZWwuIGZpbmQgaXRcbiAgICAgICAgdmFyIGRlc3RMZXZlbCA9IDA7XG4gICAgICAgIGlmICh0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBkZXN0TGV2ZWwgPSB0b3VjaGluZ0xldmVsICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XG4gICAgICAgIHZhciBkZXN0TGF0ZXJhbCA9IC0xO1xuICAgICAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3VjaGluZ0xldmVsOiB0b3VjaGluZ0xldmVsLFxuICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsOiB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5OiB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQ6IHN0YWNrQ250LFxuICAgICAgICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXG4gICAgICAgICAgICBsZXZlbDogZGVzdExldmVsLFxuICAgICAgICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBzb3J0ZWQgYnkgbGV2ZWxDb29yZCAobG93ZXN0IHRvIGhpZ2hlc3QpXG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS50b1JlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzO1xuICAgICAgICB2YXIgbGV2ZWxDbnQgPSBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7XG4gICAgICAgIHZhciByZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBsZXZlbCA9IDA7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgICAgdmFyIGxldmVsQ29vcmQgPSBsZXZlbENvb3Jkc1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9pIDwgZW50cmllc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZW50cnkpLCB7IGxldmVsQ29vcmQ6IGxldmVsQ29vcmQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0cztcbiAgICB9O1xuICAgIHJldHVybiBTZWdIaWVyYXJjaHk7XG59KCkpO1xuZnVuY3Rpb24gZ2V0RW50cnlTcGFuRW5kKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnNwYW4uZW5kO1xufVxuZnVuY3Rpb24gYnVpbGRFbnRyeUtleShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5pbmRleCArICc6JyArIGVudHJ5LnNwYW4uc3RhcnQ7XG59XG4vLyByZXR1cm5zIGdyb3VwcyB3aXRoIGVudHJpZXMgc29ydGVkIGJ5IGlucHV0IG9yZGVyXG5mdW5jdGlvbiBncm91cEludGVyc2VjdGluZ0VudHJpZXMoZW50cmllcykge1xuICAgIHZhciBtZXJnZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGVudHJpZXNfMiA9IGVudHJpZXM7IF9pIDwgZW50cmllc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzXzJbX2ldO1xuICAgICAgICB2YXIgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgdmFyIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgbWVyZ2VzXzEgPSBtZXJnZXM7IF9hIDwgbWVyZ2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSBtZXJnZXNfMVtfYV07XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0U3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbikpIHtcbiAgICAgICAgICAgICAgICBodW5ncnlNZXJnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogbWVyZ2UuZW50cmllcy5jb25jYXQoaHVuZ3J5TWVyZ2UuZW50cmllcyksXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGpvaW5TcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChtZXJnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChodW5ncnlNZXJnZSk7XG4gICAgICAgIG1lcmdlcyA9IGZpbHRlcmVkTWVyZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VzO1xufVxuZnVuY3Rpb24gam9pblNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBNYXRoLm1pbihzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KHNwYW4wLmVuZCwgc3BhbjEuZW5kKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0U3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oc3BhbjAuZW5kLCBzcGFuMS5lbmQpO1xuICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gZ2VuZXJhbCB1dGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGluc2VydEF0KGFyciwgaW5kZXgsIGl0ZW0pIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhLCBzZWFyY2hWYWwsIGdldEl0ZW1WYWwpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGVuZEluZGV4ID0gYS5sZW5ndGg7IC8vIGV4Y2x1c2l2ZVxuICAgIGlmICghZW5kSW5kZXggfHwgc2VhcmNoVmFsIDwgZ2V0SXRlbVZhbChhW3N0YXJ0SW5kZXhdKSkgeyAvLyBubyBpdGVtcyBPUiBiZWZvcmUgZmlyc3QgaXRlbVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoVmFsID4gZ2V0SXRlbVZhbChhW2VuZEluZGV4IC0gMV0pKSB7IC8vIGFmdGVyIGxhc3QgaXRlbVxuICAgICAgICByZXR1cm4gW2VuZEluZGV4LCAwXTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKHN0YXJ0SW5kZXggKyAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIDIpO1xuICAgICAgICB2YXIgbWlkZGxlVmFsID0gZ2V0SXRlbVZhbChhW21pZGRsZUluZGV4XSk7XG4gICAgICAgIGlmIChzZWFyY2hWYWwgPCBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbWlkZGxlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoVmFsID4gbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBlcXVhbCFcbiAgICAgICAgICAgIHJldHVybiBbbWlkZGxlSW5kZXgsIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnRJbmRleCwgMF07XG59XG5cbnZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbihzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5pc0hpdENvbWJvQWxsb3dlZCA9IHNldHRpbmdzLmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGw7XG4gICAgfVxuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEludGVyYWN0aW9uO1xufSgpKTtcbmZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIGVsOiBpbnB1dC5lbCxcbiAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGlucHV0LnVzZUV2ZW50Q2VudGVyICE9IG51bGwgPyBpbnB1dC51c2VFdmVudENlbnRlciA6IHRydWUsXG4gICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBpbnB1dC5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgX2Fbc2V0dGluZ3MuY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncyxcbiAgICAgICAgX2E7XG59XG4vLyBnbG9iYWwgc3RhdGVcbnZhciBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuLypcbkFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxuRG9lcyBoaWdoZXItbGV2ZWwgdGhpbmdzIHRoYW4gUG9pbnRlckRyYWdnZXIsIHN1Y2ggYXMgcG9zc2libHk6XG4tIGEgXCJtaXJyb3JcIiB0aGF0IG1vdmVzIHdpdGggdGhlIHBvaW50ZXJcbi0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXG5cbnN1YmNsYXNzZXMgbXVzdCBlbWl0OlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gZHJhZ21vdmVcbi0gcG9pbnRlcnVwXG4tIGRyYWdlbmRcbiovXG52YXIgRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnREcmFnZ2luZyhlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgIH07XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldEF1dG9TY3JvbGxFbmFibGVkID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50RHJhZ2dpbmc7XG59KCkpO1xuXG4vLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbnZhciBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbnZhciBEUkFHX01FVEFfUkVGSU5FUlMgPSB7XG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgY3JlYXRlOiBCb29sZWFuLFxuICAgIHNvdXJjZUlkOiBTdHJpbmcsXG59O1xuZnVuY3Rpb24gcGFyc2VEcmFnTWV0YShyYXcpIHtcbiAgICB2YXIgX2EgPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgZHVyYXRpb246IHJlZmluZWQuZHVyYXRpb24gfHwgbnVsbCxcbiAgICAgICAgY3JlYXRlOiByZWZpbmVkLmNyZWF0ZSAhPSBudWxsID8gcmVmaW5lZC5jcmVhdGUgOiB0cnVlLFxuICAgICAgICBzb3VyY2VJZDogcmVmaW5lZC5zb3VyY2VJZCxcbiAgICAgICAgbGVmdG92ZXJQcm9wczogZXh0cmEsXG4gICAgfTtcbn1cblxudmFyIFRvb2xiYXJTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUb29sYmFyU2VjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyU2VjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb29sYmFyU2VjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoZnVuY3Rpb24gKHdpZGdldEdyb3VwKSB7IHJldHVybiBfdGhpcy5yZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCk7IH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoWydkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH1dLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgVG9vbGJhclNlY3Rpb24ucHJvdG90eXBlLnJlbmRlcldpZGdldEdyb3VwID0gZnVuY3Rpb24gKHdpZGdldEdyb3VwKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY29udGV4dC50aGVtZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB3aWRnZXRHcm91cF8xID0gd2lkZ2V0R3JvdXA7IF9pIDwgd2lkZ2V0R3JvdXBfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB3aWRnZXQgPSB3aWRnZXRHcm91cF8xW19pXTtcbiAgICAgICAgICAgIHZhciBidXR0b25OYW1lID0gd2lkZ2V0LmJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrID0gd2lkZ2V0LmJ1dHRvbkNsaWNrLCBidXR0b25UZXh0ID0gd2lkZ2V0LmJ1dHRvblRleHQsIGJ1dHRvbkljb24gPSB3aWRnZXQuYnV0dG9uSWNvbiwgYnV0dG9uSGludCA9IHdpZGdldC5idXR0b25IaW50O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkNsYXNzZXMgPSBbXCJmYy1cIiArIGJ1dHRvbk5hbWUgKyBcIi1idXR0b25cIiwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbJ2RpdicsIHsgY2xhc3NOYW1lOiBncm91cENsYXNzTmFtZSB9XSwgY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhclNlY3Rpb247XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRvb2xiYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIG1vZGVsID0gX2EubW9kZWwsIGV4dHJhQ2xhc3NOYW1lID0gX2EuZXh0cmFDbGFzc05hbWU7XG4gICAgICAgIHZhciBmb3JjZUx0ciA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnRDb250ZW50O1xuICAgICAgICB2YXIgZW5kQ29udGVudDtcbiAgICAgICAgdmFyIHNlY3Rpb25XaWRnZXRzID0gbW9kZWwuc2VjdGlvbldpZGdldHM7XG4gICAgICAgIHZhciBjZW50ZXJDb250ZW50ID0gc2VjdGlvbldpZGdldHMuY2VudGVyO1xuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMubGVmdCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5yaWdodCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgICAgJ2ZjLXRvb2xiYXInLFxuICAgICAgICAgICAgZm9yY2VMdHIgPyAnZmMtdG9vbGJhci1sdHInIDogJycsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignc3RhcnQnLCBzdGFydENvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInLCBjZW50ZXJDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignZW5kJywgZW5kQ29udGVudCB8fCBbXSkpKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAoa2V5LCB3aWRnZXRHcm91cHMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRvb2xiYXJTZWN0aW9uLCB7IGtleToga2V5LCB3aWRnZXRHcm91cHM6IHdpZGdldEdyb3VwcywgdGl0bGU6IHByb3BzLnRpdGxlLCBuYXZVbml0OiBwcm9wcy5uYXZVbml0LCBhY3RpdmVCdXR0b246IHByb3BzLmFjdGl2ZUJ1dHRvbiwgaXNUb2RheUVuYWJsZWQ6IHByb3BzLmlzVG9kYXlFbmFibGVkLCBpc1ByZXZFbmFibGVkOiBwcm9wcy5pc1ByZXZFbmFibGVkLCBpc05leHRFbmFibGVkOiBwcm9wcy5pc05leHRFbmFibGVkLCB0aXRsZUlkOiBwcm9wcy50aXRsZUlkIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIFRPRE86IGRvIGZ1bmN0aW9uIGNvbXBvbmVudD9cbnZhciBWaWV3Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IHByb3BzLmFzcGVjdFJhdGlvO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxuICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxuICAgICAgICBdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gJyc7XG4gICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxuICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSAoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMCArIFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzLmxhYmVsZWRCeUlkLCByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogaGVpZ2h0LCBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlQXZhaWxhYmxlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZpZXdDb250YWluZXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbnZhciBFdmVudENsaWNraW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVudENsaWNraW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50Q2xpY2tpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0NsaWNrID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgaWYgKHNlZyAmJiAvLyBtaWdodCBiZSB0aGUgPGRpdj4gc3Vycm91bmRpbmcgdGhlIG1vcmUgbGlua1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvdXIgd2F5IHRvIHNpbXVsYXRlIGEgbGluayBjbGljayBmb3IgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSA8YT4gdGFnc1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgYmVmb3JlIHRyaWdnZXIgZmlyZWQgaW4gY2FzZSB0cmlnZ2VyIHRyYXNoZXMgRE9NIHRocnUgcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKTtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gaGFzVXJsQ29udGFpbmVyID8gaGFzVXJsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl0nKS5ocmVmIDogJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnY2xpY2snLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRDbGlja2luZztcbn0oSW50ZXJhY3Rpb24pKTtcblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG52YXIgRXZlbnRIb3ZlcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnRIb3ZlcmluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudEhvdmVyaW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICAvLyBmb3Igc2ltdWxhdGluZyBhbiBldmVudE1vdXNlTGVhdmUgd2hlbiB0aGUgZXZlbnQgZWwgaXMgZGVzdHJveWVkIHdoaWxlIG1vdXNlIGlzIG92ZXIgaXRcbiAgICAgICAgX3RoaXMuaGFuZGxlRXZlbnRFbFJlbW92ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09PSBfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCBfdGhpcy5jdXJyZW50U2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdFbnRlciA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUVudGVyJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnTGVhdmUgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzID0gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnRW50ZXIsIF90aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudEhvdmVyaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBFdmVudEhvdmVyaW5nLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICBpZiAoIWV2IHx8IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKHB1YmxpY0V2TmFtZSwge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRIb3ZlcmluZztcbn0oSW50ZXJhY3Rpb24pKTtcblxudmFyIENhbGVuZGFyQ29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FsZW5kYXJDb250ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xuICAgICAgICBfdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgX3RoaXMuYnVpbGRUb29sYmFyUHJvcHMgPSBtZW1vaXplKGJ1aWxkVG9vbGJhclByb3BzKTtcbiAgICAgICAgX3RoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmZvb3RlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aWV3TGFiZWxJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBfdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICB2YXIgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQoX3RoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKGZ1bmN0aW9uIChUaGVJbnRlcmFjdGlvbkNsYXNzKSB7IHJldHVybiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncyk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnM7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF90aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJzXzEgPSBsaXN0ZW5lcnM7IF9pIDwgbGlzdGVuZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBfdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTsgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogX3RoaXMucHJvcHMudmlld0FwaSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5wcm9wcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZVJ1bm5lci5yZXF1ZXN0KG9wdGlvbnMud2luZG93UmVzaXplRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qXG4gICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICAgKi9cbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHRvb2xiYXJDb25maWcgPSBwcm9wcy50b29sYmFyQ29uZmlnLCBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICAgICAgdmFyIHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cbiAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcbiAgICAgICAgdmFyIHZpZXdWR3JvdyA9IGZhbHNlO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICB2YXIgdmlld0FzcGVjdFJhdGlvO1xuICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcbiAgICAgICAgdmFyIHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxuICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgX19hc3NpZ24oeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1oZWFkZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5oZWFkZXIsIHRpdGxlSWQ6IHZpZXdMYWJlbElkIH0sIHRvb2xiYXJQcm9wcykpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKGNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgX19hc3NpZ24oeyByZWY6IHRoaXMuZm9vdGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1mb290ZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5mb290ZXIsIHRpdGxlSWQ6IFwiXCIgfSwgdG9vbGJhclByb3BzKSkpKSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgeyByZXR1cm4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcyk7IH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB2YXIgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jYWxlbmRhckludGVyYWN0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3VubW91bnQnKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuYnVpbGRBcHBlbmRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoZnVuY3Rpb24gKGJ1aWxkQXBwZW5kQ29udGVudCkgeyByZXR1cm4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKTsgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbRnJhZ21lbnQsIHt9XSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUucmVuZGVyVmlldyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgcGx1Z2luSG9va3MgPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gcHJvcHMudmlld1NwZWM7XG4gICAgICAgIHZhciB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdHJhbnNmb3JtZXJzXzEgPSB0cmFuc2Zvcm1lcnM7IF9pIDwgdHJhbnNmb3JtZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcnNfMVtfaV07XG4gICAgICAgICAgICBfX2Fzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29tcG9uZW50LCBfX2Fzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGVuZGFyQ29udGVudDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcbiAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgICB2YXIgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gICAgdmFyIHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHZhciBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKGZ1bmN0aW9uIChUaGVDbGFzcykgeyByZXR1cm4gbmV3IFRoZUNsYXNzKCk7IH0pO1xufVxuXG52YXIgQ2FsZW5kYXJSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxlbmRhclJvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQWZ0ZXJQcmludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnM7XG4gICAgICAgIHZhciBmb3JQcmludCA9IHRoaXMuc3RhdGUuZm9yUHJpbnQ7XG4gICAgICAgIHZhciBpc0hlaWdodEF1dG8gPSBmb3JQcmludCB8fCBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKCFpc0hlaWdodEF1dG8gJiYgb3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkgPyBvcHRpb25zLmhlaWdodCA6ICcnO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYycsXG4gICAgICAgICAgICBmb3JQcmludCA/ICdmYy1tZWRpYS1wcmludCcgOiAnZmMtbWVkaWEtc2NyZWVuJyxcbiAgICAgICAgICAgIFwiZmMtZGlyZWN0aW9uLVwiICsgb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfTtcbiAgICBDYWxlbmRhclJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW1pdHRlciA9IHRoaXMucHJvcHMuZW1pdHRlcjtcbiAgICAgICAgZW1pdHRlci5vbignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub24oJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9O1xuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5wcm9wcy5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmZ1bmN0aW9uIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF5Q250KSB7XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcbiAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcbiAgICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnIH0pOyAvLyBcIlNhdFwiXG4gICAgfVxuICAgIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJywgb21pdENvbW1hczogdHJ1ZSB9KTsgLy8gXCJTYXQgMTEvMTJcIlxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pOyAvLyBcIlNhdHVyZGF5XCJcbn1cblxudmFyIENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShob29rUHJvcHMpIHtcbiAgICByZXR1cm4gaG9va1Byb3BzLnRleHQ7XG59XG5cbnZhciBUYWJsZURhdGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZURhdGVDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRGF0ZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVEYXRlQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBvcHRpb25zID0gX2Eub3B0aW9ucywgdGhlbWUgPSBfYS50aGVtZSwgdmlld0FwaSA9IF9hLnZpZXdBcGk7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXRlID0gcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogdmlld0FwaSB9LCBwcm9wcy5leHRyYUhvb2tQcm9wcyksIHsgdGV4dDogdGV4dCB9KSwgZGF5TWV0YSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyJDEsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGhcIiwgX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIFwiZGF0YS1kYXRlXCI6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCAhZGF5TWV0YS5pc0Rpc2FibGVkICYmIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IHJlZjogaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ID8gJ2ZjLXN0aWNreScgOiAnJyxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQpKSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlRGF0ZUNlbGw7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFdFRUtEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pO1xudmFyIFRhYmxlRG93Q2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVEb3dDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRG93Q2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZURvd0NlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgdGhlbWUgPSBfYS50aGVtZSwgdmlld0FwaSA9IF9hLnZpZXdBcGksIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgZGF0ZSA9IGFkZERheXMobmV3IERhdGUoMjU5MjAwMDAwKSwgcHJvcHMuZG93KTsgLy8gc3RhcnQgd2l0aCBTdW4sIDA0IEphbiAxOTcwIDAwOjAwOjAwIEdNVFxuICAgICAgICB2YXIgZGF0ZU1ldGEgPSB7XG4gICAgICAgICAgICBkb3c6IHByb3BzLmRvdyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNGdXR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQYXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IGZhbHNlLFxuICAgICAgICAgICAgaXNPdGhlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRhdGVNZXRhLCB0aGVtZSksIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGU6IGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhSG9va1Byb3BzKSwgeyB0ZXh0OiB0ZXh0IH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lciQxLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRoXCIsIF9fYXNzaWduKHsgcmVmOiByb290RWxSZWYsIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiYVwiLCB7IFwiYXJpYS1sYWJlbFwiOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ID8gJ2ZjLXN0aWNreScgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEb3dDZWxsO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbnZhciBOb3dUaW1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm93VGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm93VGltZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIF90aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihzdGF0ZS5ub3dEYXRlLCBzdGF0ZS50b2RheVJhbmdlKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcHV0ZVRpbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIHZhciBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgdmFyIG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgdmFyIHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXM6IHdhaXRNcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKSwgbmV4dFN0YXRlID0gX2EubmV4dFN0YXRlLCB3YWl0TXMgPSBfYS53YWl0TXM7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm93VGltZXIuY29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGU7XG4gICAgcmV0dXJuIE5vd1RpbWVyO1xufShDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgdmFyIGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cblxudmFyIERheUhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5SGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlIZWFkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVzID0gX2EuZGF0ZXMsIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzID0gX2EuZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvID0gX2EucmVuZGVySW50cm87XG4gICAgICAgIHZhciBkYXlIZWFkZXJGb3JtYXQgPSB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihjb250ZXh0Lm9wdGlvbnMuZGF5SGVhZGVyRm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgZnVuY3Rpb24gKG5vd0RhdGUsIHRvZGF5UmFuZ2UpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICByZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygnZGF5JyksXG4gICAgICAgICAgICBkYXRlcy5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlc1JlcERpc3RpbmN0RGF5cyA/IChjcmVhdGVFbGVtZW50KFRhYmxlRGF0ZUNlbGwsIHsga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgY29sQ250OiBkYXRlcy5sZW5ndGgsIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlRG93Q2VsbCwgeyBrZXk6IGRhdGUuZ2V0VVRDRGF5KCksIGRvdzogZGF0ZS5nZXRVVENEYXkoKSwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpKTsgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUhlYWRlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xuICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xufVxuXG52YXIgRGF5U2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF5U2VyaWVzTW9kZWwocmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBkYXRlID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIHZhciBkYXRlcyA9IFtdO1xuICAgICAgICB2YXIgZGF5SW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlR2VuZXJhdG9yLmlzSGlkZGVuRGF5KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBkYXRlcztcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5jbnQgPSBkYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIERheVNlcmllc01vZGVsLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBmaXJzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgocmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuICAgICAgICB2YXIgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLm1heCgwLCBmaXJzdEluZGV4KTtcbiAgICAgICAgdmFyIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLm1pbih0aGlzLmNudCAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICAgICAgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLmNlaWwoY2xpcHBlZEZpcnN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcbiAgICAgICAgY2xpcHBlZExhc3RJbmRleCA9IE1hdGguZmxvb3IoY2xpcHBlZExhc3RJbmRleCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcbiAgICAgICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleDogY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZpcnN0SW5kZXggPT09IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzRW5kOiBsYXN0SW5kZXggPT09IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgRGF5U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGVEYXlJbmRleCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSk7XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXNbZGF5T2Zmc2V0XTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlTZXJpZXNNb2RlbDtcbn0oKSk7XG5cbnZhciBEYXlUYWJsZU1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCBicmVha09uV2Vla3MpIHtcbiAgICAgICAgdmFyIGRhdGVzID0gZGF5U2VyaWVzLmRhdGVzO1xuICAgICAgICB2YXIgZGF5c1BlclJvdztcbiAgICAgICAgdmFyIGZpcnN0RGF5O1xuICAgICAgICB2YXIgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIERheVRhYmxlTW9kZWwucHJvdG90eXBlLmJ1aWxkQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRDZWxsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRIZWFkZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XG4gICAgICAgIHZhciBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSBzZXJpZXNTZWcuZmlyc3RJbmRleCwgbGFzdEluZGV4ID0gc2VyaWVzU2VnLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2w6IChuZXh0SW5kZXggLSAxKSAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VyaWVzU2VnLmlzU3RhcnQgJiYgaW5kZXggPT09IGZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGVNb2RlbDtcbn0oKSk7XG5cbnZhciBTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VyKCkge1xuICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcbiAgICB9XG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZVByb3BzID0gZnVuY3Rpb24gKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHByb3BzLmV2ZW50VWlCYXNlcztcbiAgICAgICAgdmFyIGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW3Byb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbi5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFVpQmFzZXMsIGNvbnRleHRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW3Byb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0XSwgZXh0cmFBcmdzKSksXG4gICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbcHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgfTsgLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlTm93RGF0ZSA9IGZ1bmN0aW9uICgvLyBkb2VzIG5vdCBtZW1vaXplXG4gICAgZGF0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4uYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGNvbnRleHRdLCBleHRyYUFyZ3MpKTtcbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZS5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLmJnO1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIGV4dHJhQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZXh0cmFBcmdzW19pIC0gNF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5iZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgICAgICBmZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9O1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbiwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxuICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlRGF0ZVNwYW4gPSBmdW5jdGlvbiAoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbZGF0ZVNwYW4ucmFuZ2VdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBzZWdzXzEgPSBzZWdzOyBfYSA8IHNlZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzFbX2FdO1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XG4gICAgICAgIHZhciBzZWdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRSYW5nZXNfMSA9IGV2ZW50UmFuZ2VzOyBfaSA8IGV2ZW50UmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIHRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VFdmVudFJhbmdlID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICB2YXIgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtkYXRlUmFuZ2VdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzJbX2ldO1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XG4gICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBTbGljZXI7XG59KCkpO1xuLypcbmZvciBpbmNvcnBvcmF0aW5nIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIGlmIGFwcHJvcHJpYXRlXG5UT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcblRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XG4qL1xuZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xuICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUubWlsbGlzZWNvbmRzKSxcbiAgICAgICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLm1pbGxpc2Vjb25kcyAtIDg2NGU1KSwgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxuICAgIH07XG59XG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdGFuY2VzID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cy5pbnN0YW5jZXM7XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNvbnRleHQpOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblZhbGlkKGRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgZGF0ZVNlbGVjdGlvbi5yYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dCkge1xuICAgIHZhciBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIHZhciBwcm9wcyA9IF9fYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgaWYgKGRhdGVTcGFuTWV0YSA9PT0gdm9pZCAwKSB7IGRhdGVTcGFuTWV0YSA9IHt9OyB9XG4gICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgdmFyIGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbiAgICB2YXIgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIHZhciBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgdmFyIHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cbiAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcbiAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XG4gICAgdmFyIG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcbiAgICB2YXIgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKHZhciBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgICAgIHZhciBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICB2YXIgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGNvbnN0cmFpbnRcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcmxhcFxuICAgICAgICB2YXIgZXZlbnRPdmVybGFwID0gY29udGV4dC5vcHRpb25zLmV2ZW50T3ZlcmxhcDtcbiAgICAgICAgdmFyIGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcbiAgICAgICAgZm9yICh2YXIgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRBcGkoY29udGV4dCwgc3ViamVjdERlZiwgc3ViamVjdEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICAgICAgdmFyIGNhbGVuZGFyRXZlbnRTdG9yZSA9IGN1cnJlbnRTdGF0ZS5ldmVudFN0b3JlOyAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc3ViamVjdENvbmZpZy5hbGxvd3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ViamVjdEFsbG93ID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHN1YmplY3REYXRlU3BhbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICB2YXIgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgdmFyIG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgdmFyIGV2ZW50QXBpID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgb3JpZ0RlZiwgb3JpZ0luc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB3YXMgYW4gZXh0ZXJuYWwgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIHZhciByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgIHZhciByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xuICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcbiAgICB2YXIgc2VsZWN0aW9uQ29uZmlnID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnNlbGVjdGlvbkNvbmZpZztcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvLyBjb25zdHJhaW50XG4gICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG92ZXJsYXBcbiAgICB2YXIgc2VsZWN0T3ZlcmxhcCA9IGNvbnRleHQub3B0aW9ucy5zZWxlY3RPdmVybGFwO1xuICAgIHZhciBzZWxlY3RPdmVybGFwRnVuYyA9IHR5cGVvZiBzZWxlY3RPdmVybGFwID09PSAnZnVuY3Rpb24nID8gc2VsZWN0T3ZlcmxhcCA6IG51bGw7XG4gICAgZm9yICh2YXIgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgICAgIHZhciByZWxldmFudEluc3RhbmNlID0gcmVsZXZhbnRJbnN0YW5jZXNbcmVsZXZhbnRJbnN0YW5jZUlkXTtcbiAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHNlbGVjdGlvblJhbmdlLCByZWxldmFudEluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RPdmVybGFwRnVuYyAmJiAhc2VsZWN0T3ZlcmxhcEZ1bmMobmV3IEV2ZW50QXBpKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzZWxlY3Rpb25Db25maWcuYWxsb3dzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VsZWN0aW9uQWxsb3cgPSBfYVtfaV07XG4gICAgICAgIHZhciBmdWxsRGF0ZVNwYW4gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENvbnN0cmFpbnQgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnN0cmFpbnRzXzEgPSBjb25zdHJhaW50czsgX2kgPCBjb25zdHJhaW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzFbX2ldO1xuICAgICAgICBpZiAoIWFueVJhbmdlc0NvbnRhaW5SYW5nZShjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSwgc3ViamVjdFJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgLy8gZm9yIGV4cGFuZGluZyBhIHJlY3VycmluZyBjb25zdHJhaW50LCBvciBleHBhbmRpbmcgYnVzaW5lc3MgaG91cnNcbm90aGVyRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzICdidXNpbmVzc0hvdXJzJ1xuY29udGV4dCkge1xuICAgIGlmIChjb25zdHJhaW50ID09PSAnYnVzaW5lc3NIb3VycycpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGV2ZW50RGVmLmdyb3VwSWQgPT09IGNvbnN0cmFpbnQ7IH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdOyAvLyBpZiBpdCdzIGZhbHNlXG59XG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZSkge1xuICAgIHZhciBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VvbSBmaWxlP1xuZnVuY3Rpb24gYW55UmFuZ2VzQ29udGFpblJhbmdlKG91dGVyUmFuZ2VzLCBpbm5lclJhbmdlKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBvdXRlclJhbmdlc18xID0gb3V0ZXJSYW5nZXM7IF9pIDwgb3V0ZXJSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG91dGVyUmFuZ2UgPSBvdXRlclJhbmdlc18xW19pXTtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcbnZhciBTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2Nyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nyb2xsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBsaXF1aWQgPSBwcm9wcy5saXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgPSBwcm9wcy5saXF1aWRJc0Fic29sdXRlO1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IGxpcXVpZCAmJiBsaXF1aWRJc0Fic29sdXRlO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gWydmYy1zY3JvbGxlciddO1xuICAgICAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgICAgICBpZiAobGlxdWlkSXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IHByb3BzLm92ZXJmbG93WCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IHByb3BzLm92ZXJmbG93WSxcbiAgICAgICAgICAgICAgICBsZWZ0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCB8fCAnJyxcbiAgICAgICAgICAgIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5uZWVkc1hTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiByZWFsQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUubmVlZHNZU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgPiByZWFsQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFhTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFlTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbnZhciBSZWZNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmTWFwKG1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sgPSBtYXN0ZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy5jdXJyZW50TWFwID0ge307XG4gICAgICAgIHRoaXMuZGVwdGhzID0ge307XG4gICAgICAgIHRoaXMuY2FsbGJhY2tNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIGRlcHRocyA9IF9hLmRlcHRocywgY3VycmVudE1hcCA9IF9hLmN1cnJlbnRNYXA7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGJ1Zy4uLiBBQ1RVQUxMWTogY2FuIHByb2JhYmx5IGRvIGF3YXkgd2l0aCB0aGlzIG5vdyB0aGF0IGNhbGxlcnMgZG9uJ3Qgc2hhcmUgbnVtZXJpYyBpbmRpY2VzIGFueW1vcmVcbiAgICAgICAgICAgICAgICByZW1vdmVkID0gKGtleSBpbiBjdXJyZW50TWFwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFwW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gPSAoZGVwdGhzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFzdGVyQ2FsbGJhY2sobnVsbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFzdGVyQ2FsbGJhY2sodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZWZNYXAucHJvdG90eXBlLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICBpZiAoIXJlZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZkNhbGxiYWNrO1xuICAgIH07XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBSZWZNYXAucHJvdG90eXBlLmNvbGxlY3QgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tSGFzaCh0aGlzLmN1cnJlbnRNYXAsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKTtcbiAgICB9O1xuICAgIFJlZk1hcC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlc1RvQXJyYXkodGhpcy5jdXJyZW50TWFwKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZNYXA7XG59KCkpO1xuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICB2YXIgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICB2YXIgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNocmlua0NlbGxzXzEgPSBzaHJpbmtDZWxsczsgX2kgPCBzaHJpbmtDZWxsc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2hyaW5rQ2VsbCA9IHNocmlua0NlbGxzXzFbX2ldO1xuICAgICAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChsYXJnZXN0V2lkdGgsIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKTsgLy8gPHRhYmxlPiBlbGVtZW50cyB3b3JrIGJlc3Qgd2l0aCBpbnRlZ2Vycy4gcm91bmQgdXAgdG8gZW5zdXJlIGNvbnRlbnRzIGZpdHNcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gcHJvcHMubGlxdWlkICYmIHNlY3Rpb25Db25maWcubGlxdWlkOyAvLyBkb2VzIHRoZSBzZWN0aW9uIGRvIGxpcXVpZC1oZWlnaHQ/IChuZWVkIHRvIGhhdmUgd2hvbGUgc2Nyb2xsZ3JpZCBsaXF1aWQtaGVpZ2h0IGFzIHdlbGwpXG59XG5mdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgIT0gbnVsbCB8fCAvLyBpZiBpdHMgcG9zc2libGUgZm9yIHRoZSBoZWlnaHQgdG8gbWF4IG91dCwgd2UgbWlnaHQgbmVlZCBzY3JvbGxiYXJzXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBpZiB0aGUgc2VjdGlvbiBpcyBsaXF1aWQgaGVpZ2h0LCBpdCBtaWdodCBjb25kZW5zZSBlbm91Z2ggdG8gcmVxdWlyZSBzY3JvbGxiYXJzXG59XG4vLyBUT0RPOiBPTkxZIHVzZSBgYXJnYC4gZm9yY2Ugb3V0IGludGVybmFsIGZ1bmN0aW9uIHRvIHVzZSBzYW1lIEFQSVxuZnVuY3Rpb24gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCBhcmcsIGlzSGVhZGVyKSB7XG4gICAgdmFyIGV4cGFuZFJvd3MgPSBhcmcuZXhwYW5kUm93cztcbiAgICB2YXIgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICAgICAgY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxuICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xufVxuZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xuICAgIHZhciBjb2xOb2RlcyA9IFtdO1xuICAgIC8qXG4gICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxuICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXG4gICAgKi9cbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHNfMSA9IGNvbHM7IF9pIDwgY29sc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sUHJvcHMgPSBjb2xzXzFbX2ldO1xuICAgICAgICB2YXIgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoWydjb2xncm91cCcsIHt9XSwgY29sTm9kZXMpKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIHtcbiAgICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICAgIDQgYWNjb3VudHMgZm9yIDIgMi1waXhlbCBib3JkZXJzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb24/ICovXG4gICAgcmV0dXJuIHNocmlua1dpZHRoID09IG51bGwgPyA0IDogc2hyaW5rV2lkdGg7XG59XG5mdW5jdGlvbiBoYXNTaHJpbmtXaWR0aChjb2xzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb2xzXzIgPSBjb2xzOyBfaSA8IGNvbHNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvbCA9IGNvbHNfMltfaV07XG4gICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgIF07XG4gICAgaWYgKGxpcXVpZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxuICAgICAgICBcImZjLXNjcm9sbGdyaWQtc2VjdGlvbi1cIiArIHNlY3Rpb25Db25maWcudHlwZSxcbiAgICAgICAgc2VjdGlvbkNvbmZpZy5jbGFzc05hbWUsIC8vIHVzZWQ/XG4gICAgXTtcbiAgICBpZiAod2hvbGVUYWJsZVZHcm93ICYmIHNlY3Rpb25Db25maWcubGlxdWlkICYmIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJyk7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHJlbmRlclNjcm9sbFNoaW0oYXJnKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3RpY2t5LXNoaW1cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgIH0gfSkpO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMob3B0aW9ucykge1xuICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuc3RpY2t5SGVhZGVyRGF0ZXM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgdmFyIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG52YXIgU2ltcGxlU2Nyb2xsR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2ltcGxlU2Nyb2xsR3JpZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW1wbGVTY3JvbGxHcmlkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhOyB9LCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICBfdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXJSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgICAgICBfdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAoX3RoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgX3RoaXMuaGFuZGxlU2l6aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2FmZVNldFN0YXRlKF9fYXNzaWduKHsgc2hyaW5rV2lkdGg6IF90aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIF90aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICB2YXIgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIHZhciBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIHZhciBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIHZhciBjb25maWdJID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb25maWc7XG4gICAgICAgIHZhciBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHZhciBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHZhciBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgdmFyIGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIHZhciByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXG4gICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFsndGhlYWQnLCByb2xlQXR0cnNdLCBoZWFkU2VjdGlvbk5vZGVzKSksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgYm9keVNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFsndGJvZHknLCByb2xlQXR0cnNdLCBib2R5U2VjdGlvbk5vZGVzKSksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFsndGZvb3QnLCByb2xlQXR0cnNdLCBmb290U2VjdGlvbk5vZGVzKSksIGlzQnVnZ3kgJiYgY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFsndGJvZHknLCByb2xlQXR0cnNdLCBoZWFkU2VjdGlvbk5vZGVzKSwgYm9keVNlY3Rpb25Ob2RlcyksIGZvb3RTZWN0aW9uTm9kZXMpKSk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUucmVuZGVyQ2h1bmtUZCA9IGZ1bmN0aW9uIChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgY2h1bmtDb25maWcsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBmb3JjZVlTY3JvbGxiYXJzID0gX2EuZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSBfYS5zY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0gX2Euc2Nyb2xsZXJDbGllbnRIZWlnaHRzO1xuICAgICAgICB2YXIgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgdmFyIGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIHZhciBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICB2YXIgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICB2YXIgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZXItaGFybmVzc1wiICsgKGlzTGlxdWlkID8gJyBmYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCcgOiAnJykgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsZXIsIHsgcmVmOiB0aGlzLnNjcm9sbGVyUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIGVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgb3ZlcmZsb3dZOiBvdmVyZmxvd1ksIG92ZXJmbG93WDogIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nIC8qIG5hdHVyYWwgaGVpZ2h0PyAqLywgbWF4SGVpZ2h0OiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCwgbGlxdWlkOiBpc0xpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSAvLyBiZWNhdXNlIGl0cyB3aXRoaW4gYSBoYXJuZXNzXG4gICAgICAgICAgICAgICAgOiB0cnVlIH0sIGNvbnRlbnQpKSk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5faGFuZGxlU2Nyb2xsZXJFbCA9IGZ1bmN0aW9uIChzY3JvbGxlckVsLCBrZXkpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBnZXRTZWN0aW9uQnlLZXkodGhpcy5wcm9wcy5zZWN0aW9ucywga2V5KTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldFJlZihzZWN0aW9uLmNodW5rLnNjcm9sbGVyRWxSZWYsIHNjcm9sbGVyRWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBuZWVkIGJldHRlciBzb2x1dGlvbiB3aGVuIHN0YXRlIGNvbnRhaW5zIG5vbi1zaXppbmcgdGhpbmdzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNocmlua1dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckRpbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRocygpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzY3JvbGxlclJlZnMgPSBfYS5zY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzID0gX2Euc2Nyb2xsZXJFbFJlZnM7XG4gICAgICAgIHZhciBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIHZhciBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICB2YXIgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAodmFyIHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IHRoaXMucHJvcHMuc2VjdGlvbnM7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IF9iW19pXTtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uS2V5ID0gc2VjdGlvbi5rZXk7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXJFbCA9IHNjcm9sbGVyRWxSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXJuZXNzRWwgPSBzY3JvbGxlckVsLnBhcmVudE5vZGU7IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAoZm9yY2VZU2Nyb2xsYmFyc1xuICAgICAgICAgICAgICAgICAgICA/IHNjcm9sbGJhcldpZHRoLnkgLy8gdXNlIGdsb2JhbCBiZWNhdXNlIHNjcm9sbGVyIG1pZ2h0IG5vdCBoYXZlIHNjcm9sbGJhcnMgeWV0IGJ1dCB3aWxsIG5lZWQgdGhlbSBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgICAgICAgOiAwKSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzOiBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRoczogc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlU2Nyb2xsR3JpZDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuU2ltcGxlU2Nyb2xsR3JpZC5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzY3JvbGxlckNsaWVudFdpZHRoczogaXNQcm9wc0VxdWFsLFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBnZXRTZWN0aW9uQnlLZXkoc2VjdGlvbnMsIGtleSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgc2VjdGlvbnNfMSA9IHNlY3Rpb25zOyBfaSA8IHNlY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNfMVtfaV07XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxudmFyIEV2ZW50Um9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnRSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50Um9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIHNlZyA9IHByb3BzLnNlZztcbiAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgdmFyIHVpID0gZXZlbnRSYW5nZS51aTtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YW5kYXJkQ2xhc3NOYW1lcyA9IGdldEV2ZW50Q2xhc3NOYW1lcyhob29rUHJvcHMpLmNvbmNhdCh1aS5jbGFzc05hbWVzKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5ldmVudERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ldmVudFdpbGxVbm1vdW50LCBlbFJlZjogdGhpcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgc3RhbmRhcmRDbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpOyB9KSk7XG4gICAgfTtcbiAgICBFdmVudFJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuc2VnKTtcbiAgICB9O1xuICAgIC8qXG4gICAgbmVlZCB0byByZS1hc3NpZ24gc2VnIHRvIHRoZSBlbGVtZW50IGlmIHNlZyBjaGFuZ2VzLCBldmVuIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lXG4gICAgKi9cbiAgICBFdmVudFJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHNlZyA9IHRoaXMucHJvcHMuc2VnO1xuICAgICAgICBpZiAoc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHNlZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudFJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcbnZhciBTdGFuZGFyZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGFuZGFyZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YW5kYXJkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU3RhbmRhcmRFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlZyA9IHByb3BzLnNlZztcbiAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRUaW1lRm9ybWF0O1xuICAgICAgICB2YXIgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRSb290LCB7IHNlZzogc2VnLCB0aW1lVGV4dDogdGltZVRleHQsIGRpc2FibGVEcmFnZ2luZzogcHJvcHMuZGlzYWJsZURyYWdnaW5nLCBkaXNhYmxlUmVzaXppbmc6IHByb3BzLmRpc2FibGVSZXNpemluZywgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlcklubmVyQ29udGVudCQxLCBpc0RyYWdnaW5nOiBwcm9wcy5pc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBwcm9wcy5pc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IHByb3BzLmlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogcHJvcHMuaXNTZWxlY3RlZCwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBwcm9wcy5leHRyYUNsYXNzTmFtZXMuY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaG9va1Byb3BzLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaG9va1Byb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sIHJlZjogcm9vdEVsUmVmIH0sIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluXCIsIHJlZjogaW5uZXJFbFJlZiwgc3R5bGU6IHsgY29sb3I6IGhvb2tQcm9wcy50ZXh0Q29sb3IgfSB9LCBpbm5lckNvbnRlbnQpLFxuICAgICAgICAgICAgaG9va1Byb3BzLmlzU3RhcnRSZXNpemFibGUgJiZcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pLFxuICAgICAgICAgICAgaG9va1Byb3BzLmlzRW5kUmVzaXphYmxlICYmXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YW5kYXJkRXZlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpbi1mcmFtZVwiIH0sXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIGlubmVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZS1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZSBmYy1zdGlja3lcIiB9LCBpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7XG59XG5cbnZhciBOb3dJbmRpY2F0b3JSb290ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLm5vd0luZGljYXRvckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSk7XG59KSk7IH07XG5cbnZhciBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xudmFyIERheUNlbGxDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlDZWxsQ29udGVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlDZWxsQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEYXlDZWxsQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSByZWZpbmVEYXlDZWxsSG9va1Byb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjb250ZW50OiBvcHRpb25zLmRheUNlbGxDb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlDZWxsQ29udGVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyhyYXcpIHtcbiAgICB2YXIgZGF0ZSA9IHJhdy5kYXRlLCBkYXRlRW52ID0gcmF3LmRhdGVFbnY7XG4gICAgdmFyIGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgcmF3LmRhdGVQcm9maWxlKTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogcmF3LnZpZXdBcGkgfSwgZGF5TWV0YSksIHsgZGF5TnVtYmVyVGV4dDogcmF3LnNob3dEYXlOdW1iZXIgPyBkYXRlRW52LmZvcm1hdChkYXRlLCBEQVlfTlVNX0ZPUk1BVCkgOiAnJyB9KSwgcmF3LmV4dHJhUHJvcHMpO1xufVxuXG52YXIgRGF5Q2VsbFJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheUNlbGxSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUNlbGxSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVmaW5lSG9va1Byb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVEYXlDZWxsSG9va1Byb3BzKTtcbiAgICAgICAgX3RoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUNlbGxSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHRoaXMucmVmaW5lSG9va1Byb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBnZXREYXlDbGFzc05hbWVzKGhvb2tQcm9wcywgY29udGV4dC50aGVtZSkuY29uY2F0KGhvb2tQcm9wcy5pc0Rpc2FibGVkXG4gICAgICAgICAgICA/IFtdIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgOiB0aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5kYXlDZWxsQ2xhc3NOYW1lcywgaG9va1Byb3BzKSk7XG4gICAgICAgIHZhciBkYXRhQXR0cnMgPSBob29rUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDoge1xuICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vdW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5Q2VsbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlDZWxsV2lsbFVubW91bnQsIGVsUmVmOiBwcm9wcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmKSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIGNsYXNzTmFtZXMsIGRhdGFBdHRycywgaG9va1Byb3BzLmlzRGlzYWJsZWQpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5Q2VsbFJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1cIiArIGZpbGxUeXBlIH0pKTtcbn1cbnZhciBCZ0V2ZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChFdmVudFJvb3QsIHsgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgc2VnOiBwcm9wcy5zZWcgLyogdXNlbGVzc3MgaSB0aGluayAqLywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtYmctZXZlbnQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpOyB9O1xuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMuZXZlbnQudGl0bGU7XG4gICAgcmV0dXJuIHRpdGxlICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcbn1cblxudmFyIFdlZWtOdW1iZXJSb290ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlO1xuICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICB2YXIgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICB2YXIgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgdmFyIGhvb2tQcm9wcyA9IHsgbnVtOiBudW0sIHRleHQ6IHRleHQsIGRhdGU6IGRhdGUgfTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy53ZWVrTnVtYmVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyLCBkaWRNb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpO1xufSkpOyB9O1xuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiBpbm5lclByb3BzLnRleHQ7XG59XG5cbnZhciBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcbnZhciBQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb3BvdmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcG92ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gZWw7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgX3RoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9uQ2xvc2UgPSBfdGhpcy5wcm9wcy5vbkNsb3NlO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIHRoZW1lID0gX2EudGhlbWUsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLCBwcm9wcyA9IF9iLnByb3BzLCBzdGF0ZSA9IF9iLnN0YXRlO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy5leHRyYUF0dHJzLCB7IHJlZjogdGhpcy5oYW5kbGVSb290RWwgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1wb3BvdmVyLXRpdGxlXCIsIGlkOiBzdGF0ZS50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSwgdGl0bGU6IG9wdGlvbnMuY2xvc2VIaW50LCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgfSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgfSwgcHJvcHMuY2hpbGRyZW4pKSwgcHJvcHMucGFyZW50RWwpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc1J0bCA9IHRoaXMuY29udGV4dC5pc1J0bDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgYWxpZ25tZW50RWwgPSBfYS5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wID0gX2EuYWxpZ25HcmlkVG9wO1xuICAgICAgICB2YXIgcm9vdEVsID0gdGhpcy5yb290RWw7XG4gICAgICAgIHZhciBhbGlnbm1lbnRSZWN0ID0gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGFsaWdubWVudEVsKTtcbiAgICAgICAgaWYgKGFsaWdubWVudFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBwb3BvdmVyRGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICAgICAgICB2YXIgcG9wb3ZlclRvcCA9IGFsaWduR3JpZFRvcFxuICAgICAgICAgICAgICAgID8gZWxlbWVudENsb3Nlc3QoYWxpZ25tZW50RWwsICcuZmMtc2Nyb2xsZ3JpZCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAgICAgICAgIDogYWxpZ25tZW50UmVjdC50b3A7XG4gICAgICAgICAgICB2YXIgcG9wb3ZlckxlZnQgPSBpc1J0bCA/IGFsaWdubWVudFJlY3QucmlnaHQgLSBwb3BvdmVyRGltcy53aWR0aCA6IGFsaWdubWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpblxuICAgICAgICAgICAgcG9wb3ZlclRvcCA9IE1hdGgubWF4KHBvcG92ZXJUb3AsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWluKHBvcG92ZXJMZWZ0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBQQURESU5HX0ZST01fVklFV1BPUlQgLSBwb3BvdmVyRGltcy53aWR0aCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWF4KHBvcG92ZXJMZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbl8xID0gcm9vdEVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUocm9vdEVsLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBwb3BvdmVyVG9wIC0gb3JpZ2luXzEudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luXzEubGVmdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUG9wb3Zlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgTW9yZVBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vcmVQb3BvdmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vcmVQb3BvdmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICB1c2VFdmVudENlbnRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9yZVBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBzdGFydERhdGUgPSBwcm9wcy5zdGFydERhdGUsIHRvZGF5UmFuZ2UgPSBwcm9wcy50b2RheVJhbmdlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgdGl0bGUgPSBkYXRlRW52LmZvcm1hdChzdGFydERhdGUsIG9wdGlvbnMuZGF5UG9wb3ZlckZvcm1hdCk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsUm9vdCwgeyBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGRheUNsYXNzTmFtZXMsIGRhdGFBdHRycykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogcm9vdEVsUmVmLCBpZDogcHJvcHMuaWQsIHRpdGxlOiB0aXRsZSwgZXh0cmFDbGFzc05hbWVzOiBbJ2ZjLW1vcmUtcG9wb3ZlciddLmNvbmNhdChkYXlDbGFzc05hbWVzKSwgZXh0cmFBdHRyczogZGF0YUF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRlbnQsIHsgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGlubmVyQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbW9yZS1wb3BvdmVyLW1pc2NcIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpOyB9KSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSk7IH0pKTtcbiAgICB9O1xuICAgIE1vcmVQb3BvdmVyLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByb290RWwgPSBfYS5yb290RWwsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmIChwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCBlbFdpZHRoICYmXG4gICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgZWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBfX2Fzc2lnbih7IGFsbERheTogdHJ1ZSwgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb3BzLmVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgcHJvcHMuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMSwgLy8gaW1wb3J0YW50IHdoZW4gY29tcGFyaW5nIHdpdGggaGl0cyBmcm9tIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gTW9yZVBvcG92ZXI7XG59KERhdGVDb21wb25lbnQpKTtcblxudmFyIE1vcmVMaW5rUm9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9yZUxpbmtSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vcmVMaW5rUm9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpbmtFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzUG9wb3Zlck9wZW46IGZhbHNlLFxuICAgICAgICAgICAgcG9wb3ZlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIG1vcmVMaW5rQ2xpY2sgPSBjb250ZXh0Lm9wdGlvbnMubW9yZUxpbmtDbGljaztcbiAgICAgICAgICAgIHZhciBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIGluc3RhbmNlID0gX2EuaW5zdGFuY2UsIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxuICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnpvb21UbyhkYXRlLCBtb3JlTGlua0NsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3QXBpID0gY29udGV4dC52aWV3QXBpLCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgICAgICAgICB2YXIgbW9yZUxpbmtUZXh0ID0gb3B0aW9ucy5tb3JlTGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgbW9yZUNudCA9IHByb3BzLm1vcmVDbnQ7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBcIitcIiArIG1vcmVDbnQgKyBcIiBcIiArIG1vcmVMaW5rVGV4dDtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcbiAgICAgICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgbnVtOiBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHNob3J0VGV4dDogXCIrXCIgKyBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5tb3JlQ250KSAmJiAoY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGVsUmVmOiBfdGhpcy5saW5rRWxSZWYsIGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJNb3JlTGlua0lubmVyLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBbJ2ZjLW1vcmUtbGluayddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBfdGhpcy5oYW5kbGVDbGljaywgdGl0bGUsIHN0YXRlLmlzUG9wb3Zlck9wZW4sIHN0YXRlLmlzUG9wb3Zlck9wZW4gPyBzdGF0ZS5wb3BvdmVySWQgOiAnJyk7IH0pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvcG92ZXJPcGVuICYmIChjcmVhdGVFbGVtZW50KE1vcmVQb3BvdmVyLCB7IGlkOiBzdGF0ZS5wb3BvdmVySWQsIHN0YXJ0RGF0ZTogcmFuZ2Uuc3RhcnQsIGVuZERhdGU6IHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwYXJlbnRFbDogX3RoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50LCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgb25DbG9zZTogX3RoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfTtcbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS51cGRhdGVQYXJlbnRFbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbFJlZi5jdXJyZW50LCAnLmZjLXZpZXctaGFybmVzcycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9yZUxpbmtSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBoaWRkZW5TZWdzID0gcHJvcHMuaGlkZGVuU2VncztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXG4gICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbn1cbmZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcbn1cblxuLy8gZXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB2ZXJzaW9uID0gJzUuMTEuMyc7IC8vIGltcG9ydGFudCB0byB0eXBlIGl0LCBzbyAuZC50cyBoYXMgZ2VuZXJpYyBzdHJpbmdcblxuZXhwb3J0IHsgQkFTRV9PUFRJT05fREVGQVVMVFMsIEJBU0VfT1BUSU9OX1JFRklORVJTLCBCYXNlQ29tcG9uZW50LCBCZ0V2ZW50LCBDYWxlbmRhckFwaSwgQ2FsZW5kYXJDb250ZW50LCBDYWxlbmRhckRhdGFNYW5hZ2VyLCBDYWxlbmRhckRhdGFQcm92aWRlciwgQ2FsZW5kYXJSb290LCBDb250ZW50SG9vaywgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQsIERhdGVDb21wb25lbnQsIERhdGVFbnYsIERhdGVQcm9maWxlR2VuZXJhdG9yLCBEYXlDZWxsQ29udGVudCwgRGF5Q2VsbFJvb3QsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIERlbGF5ZWRSdW5uZXIsIEVsZW1lbnREcmFnZ2luZywgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIEVtaXR0ZXIsIEV2ZW50QXBpLCBFdmVudFJvb3QsIEV2ZW50U291cmNlQXBpLCBJbnRlcmFjdGlvbiwgTW9yZUxpbmtSb290LCBNb3VudEhvb2ssIE5hbWVkVGltZVpvbmVJbXBsLCBOb3dJbmRpY2F0b3JSb290LCBOb3dUaW1lciwgUG9zaXRpb25DYWNoZSwgUmVmTWFwLCBSZW5kZXJIb29rLCBTY3JvbGxDb250cm9sbGVyLCBTY3JvbGxSZXNwb25kZXIsIFNjcm9sbGVyLCBTZWdIaWVyYXJjaHksIFNpbXBsZVNjcm9sbEdyaWQsIFNsaWNlciwgU3BsaXR0ZXIsIFN0YW5kYXJkRXZlbnQsIFRhYmxlRGF0ZUNlbGwsIFRhYmxlRG93Q2VsbCwgVGhlbWUsIFZpZXdBcGksIFZpZXdDb250ZXh0VHlwZSwgVmlld1Jvb3QsIFdlZWtOdW1iZXJSb290LCBXaW5kb3dTY3JvbGxDb250cm9sbGVyLCBhZGREYXlzLCBhZGREdXJhdGlvbnMsIGFkZE1zLCBhZGRXZWVrcywgYWxsb3dDb250ZXh0TWVudSwgYWxsb3dTZWxlY3Rpb24sIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsIGFwcGx5U3R5bGUsIGFwcGx5U3R5bGVQcm9wLCBhc0NsZWFuRGF5cywgYXNSb3VnaE1pbnV0ZXMsIGFzUm91Z2hNcywgYXNSb3VnaFNlY29uZHMsIGJpbmFyeVNlYXJjaCwgYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyLCBidWlsZEVudHJ5S2V5LCBidWlsZEV2ZW50QXBpcywgYnVpbGRFdmVudFJhbmdlS2V5LCBidWlsZEhhc2hGcm9tQXJyYXksIGJ1aWxkSXNvU3RyaW5nLCBidWlsZE5hdkxpbmtBdHRycywgYnVpbGRTZWdDb21wYXJlT2JqLCBidWlsZFNlZ1RpbWVUZXh0LCBjb2xsZWN0RnJvbUhhc2gsIGNvbWJpbmVFdmVudFVpcywgY29tcGFyZUJ5RmllbGRTcGVjLCBjb21wYXJlQnlGaWVsZFNwZWNzLCBjb21wYXJlTnVtYmVycywgY29tcGFyZU9ianMsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0LCBjb21wdXRlRWRnZXMsIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCwgY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMsIGNvbXB1dGVJbm5lclJlY3QsIGNvbXB1dGVSZWN0LCBjb21wdXRlU2VnRHJhZ2dhYmxlLCBjb21wdXRlU2VnRW5kUmVzaXphYmxlLCBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUsIGNvbXB1dGVTaHJpbmtXaWR0aCwgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoLCBjb21wdXRlVmlzaWJsZURheVJhbmdlLCBjb25maWcsIGNvbnN0cmFpblBvaW50LCBjcmVhdGVBcmlhQ2xpY2tBdHRycywgY3JlYXRlRHVyYXRpb24sIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgY3JlYXRlRXZlbnRJbnN0YW5jZSwgY3JlYXRlRXZlbnRVaSwgY3JlYXRlRm9ybWF0dGVyLCBjcmVhdGVQbHVnaW4sIGRpZmZEYXRlcywgZGlmZkRheUFuZFRpbWUsIGRpZmZEYXlzLCBkaWZmUG9pbnRzLCBkaWZmV2Vla3MsIGRpZmZXaG9sZURheXMsIGRpZmZXaG9sZVdlZWtzLCBkaXNhYmxlQ3Vyc29yLCBlbGVtZW50Q2xvc2VzdCwgZWxlbWVudE1hdGNoZXMsIGVuYWJsZUN1cnNvciwgZXZlbnRUdXBsZVRvU3RvcmUsIGZpbHRlckV2ZW50U3RvcmVEZWZzLCBmaWx0ZXJIYXNoLCBmaW5kRGlyZWN0Q2hpbGRyZW4sIGZpbmRFbGVtZW50cywgZmxleGlibGVDb21wYXJlLCBmb3JtYXREYXRlLCBmb3JtYXREYXlTdHJpbmcsIGZvcm1hdElzb1RpbWVTdHJpbmcsIGZvcm1hdFJhbmdlLCBnZXRBbGxvd1lTY3JvbGxpbmcsIGdldENhblZHcm93V2l0aGluQ2VsbCwgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBnZXREYXRlTWV0YSwgZ2V0RGF5Q2xhc3NOYW1lcywgZ2V0RGVmYXVsdEV2ZW50RW5kLCBnZXRFbFJvb3QsIGdldEVsU2VnLCBnZXRFbnRyeVNwYW5FbmQsIGdldEV2ZW50Q2xhc3NOYW1lcywgZ2V0RXZlbnRUYXJnZXRWaWFSb290LCBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCwgZ2V0UmVjdENlbnRlciwgZ2V0UmVsZXZhbnRFdmVudHMsIGdldFNjcm9sbEdyaWRDbGFzc05hbWVzLCBnZXRTY3JvbGxiYXJXaWR0aHMsIGdldFNlY3Rpb25DbGFzc05hbWVzLCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0LCBnZXRTZWdBbmNob3JBdHRycywgZ2V0U2VnTWV0YSwgZ2V0U2xvdENsYXNzTmFtZXMsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIGdldFVuZXF1YWxQcm9wcywgZ2V0VW5pcXVlRG9tSWQsIGdsb2JhbExvY2FsZXMsIGdsb2JhbFBsdWdpbnMsIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzLCBndWlkLCBoYXNCZ1JlbmRlcmluZywgaGFzU2hyaW5rV2lkdGgsIGlkZW50aXR5LCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLCBpbnRlcnNlY3RSYW5nZXMsIGludGVyc2VjdFJlY3RzLCBpbnRlcnNlY3RTcGFucywgaXNBcnJheXNFcXVhbCwgaXNDb2xQcm9wc0VxdWFsLCBpc0RhdGVTZWxlY3Rpb25WYWxpZCwgaXNEYXRlU3BhbnNFcXVhbCwgaXNJbnQsIGlzSW50ZXJhY3Rpb25WYWxpZCwgaXNNdWx0aURheVJhbmdlLCBpc1Byb3BzRXF1YWwsIGlzUHJvcHNWYWxpZCwgaXNWYWxpZERhdGUsIGpvaW5TcGFucywgbGlzdGVuQnlTZWxlY3RvciwgbWFwSGFzaCwgbWVtb2l6ZSwgbWVtb2l6ZUFycmF5bGlrZSwgbWVtb2l6ZUhhc2hsaWtlLCBtZW1vaXplT2JqQXJnLCBtZXJnZUV2ZW50U3RvcmVzLCBtdWx0aXBseUR1cmF0aW9uLCBwYWRTdGFydCwgcGFyc2VCdXNpbmVzc0hvdXJzLCBwYXJzZUNsYXNzTmFtZXMsIHBhcnNlRHJhZ01ldGEsIHBhcnNlRXZlbnREZWYsIHBhcnNlRmllbGRTcGVjcywgcGFyc2UgYXMgcGFyc2VNYXJrZXIsIHBvaW50SW5zaWRlUmVjdCwgcHJldmVudENvbnRleHRNZW51LCBwcmV2ZW50RGVmYXVsdCwgcHJldmVudFNlbGVjdGlvbiwgcmFuZ2VDb250YWluc01hcmtlciwgcmFuZ2VDb250YWluc1JhbmdlLCByYW5nZXNFcXVhbCwgcmFuZ2VzSW50ZXJzZWN0LCByZWZpbmVFdmVudERlZiwgcmVmaW5lUHJvcHMsIHJlbW92ZUVsZW1lbnQsIHJlbW92ZUV4YWN0LCByZW5kZXJDaHVua0NvbnRlbnQsIHJlbmRlckZpbGwsIHJlbmRlck1pY3JvQ29sR3JvdXAsIHJlbmRlclNjcm9sbFNoaW0sIHJlcXVlc3RKc29uLCBzYW5pdGl6ZVNocmlua1dpZHRoLCBzZXRFbFNlZywgc2V0UmVmLCBzbGljZUV2ZW50U3RvcmUsIHNsaWNlRXZlbnRzLCBzb3J0RXZlbnRTZWdzLCBzdGFydE9mRGF5LCB0cmFuc2xhdGVSZWN0LCB0cmlnZ2VyRGF0ZVNlbGVjdCwgdW5wcm9taXNpZnksIHZlcnNpb24sIHdoZW5UcmFuc2l0aW9uRG9uZSwgd2hvbGVEaXZpZGVEdXJhdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwXG4iXSwibmFtZXMiOlsiX19hc3NpZ24iLCJfX3NwcmVhZEFycmF5IiwiX19leHRlbmRzIiwiY3JlYXRlQ29udGV4dCIsIkNvbXBvbmVudCIsImNyZWF0ZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImNyZWF0ZVBvcnRhbCIsIkV2ZW50U291cmNlQXBpIiwiY29udGV4dCIsImludGVybmFsRXZlbnRTb3VyY2UiLCJwcm90b3R5cGUiLCJyZW1vdmUiLCJkaXNwYXRjaCIsInR5cGUiLCJzb3VyY2VJZCIsInJlZmV0Y2giLCJzb3VyY2VJZHMiLCJpc1JlZmV0Y2giLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInB1YmxpY0lkIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm1ldGEiLCJ1cmwiLCJmb3JtYXQiLCJyZW1vdmVFbGVtZW50IiwiZWwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbGVtZW50Q2xvc2VzdCIsInNlbGVjdG9yIiwiY2xvc2VzdCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJub2RlVHlwZSIsIm1ldGhvZCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwiaSIsImxlbmd0aCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqIiwicHVzaCIsImZpbmREaXJlY3RDaGlsZHJlbiIsInBhcmVudCIsInBhcmVudHMiLCJjaGlsZE5vZGVzIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGUiLCJQSVhFTF9QUk9QX1JFIiwiYXBwbHlTdHlsZSIsInByb3BzIiwicHJvcE5hbWUiLCJhcHBseVN0eWxlUHJvcCIsIm5hbWUiLCJ2YWwiLCJzdHlsZSIsInRlc3QiLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJldiIsIl9hIiwiX2IiLCJjb21wb3NlZFBhdGgiLCJ0YXJnZXQiLCJnZXRFbFJvb3QiLCJnZXRSb290Tm9kZSIsImd1aWQkMSIsImdldFVuaXF1ZURvbUlkIiwicHJldmVudERlZmF1bHQiLCJidWlsZERlbGVnYXRpb25IYW5kbGVyIiwiaGFuZGxlciIsIm1hdGNoZWRDaGlsZCIsImxpc3RlbkJ5U2VsZWN0b3IiLCJldmVudFR5cGUiLCJhdHRhY2hlZEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiY3VycmVudE1hdGNoZWRDaGlsZCIsIm1vdXNlT3ZlckV2IiwicmVhbE9uTW91c2VMZWF2ZV8xIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImZvckVhY2giLCJldmVudE5hbWUiLCJjcmVhdGVBcmlhQ2xpY2tBdHRycyIsIm9uQ2xpY2siLCJjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyIsInRhYkluZGV4Iiwib25LZXlEb3duIiwia2V5IiwiZ3VpZE51bWJlciIsImd1aWQiLCJTdHJpbmciLCJkaXNhYmxlQ3Vyc29yIiwiYm9keSIsImNsYXNzTGlzdCIsImFkZCIsImVuYWJsZUN1cnNvciIsInByZXZlbnRTZWxlY3Rpb24iLCJhbGxvd1NlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93Q29udGV4dE1lbnUiLCJwYXJzZUZpZWxkU3BlY3MiLCJpbnB1dCIsInNwZWNzIiwidG9rZW5zIiwidG9rZW4iLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsImNoYXJBdCIsImZpZWxkIiwic3Vic3RyaW5nIiwib3JkZXIiLCJmdW5jIiwiY29tcGFyZUJ5RmllbGRTcGVjcyIsIm9iajAiLCJvYmoxIiwiZmllbGRTcGVjcyIsImNtcCIsImNvbXBhcmVCeUZpZWxkU3BlYyIsImZpZWxkU3BlYyIsImZsZXhpYmxlQ29tcGFyZSIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInBhZFN0YXJ0IiwibGVuIiwicyIsInN1YnN0ciIsImZvcm1hdFdpdGhPcmRpbmFscyIsImZvcm1hdHRlciIsImFyZ3MiLCJmYWxsYmFja1RleHQiLCJhcHBseSIsInJlZHVjZSIsInN0ciIsImFyZyIsImluZGV4IiwicmVwbGFjZSIsImNvbXBhcmVOdW1iZXJzIiwiaXNJbnQiLCJuIiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsInF1ZXJ5U2VsZWN0b3IiLCJjb250ZW50V2lkdGhFbCIsIkVycm9yIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJtIiwiZGF0ZVRvVXRjQXJyYXkiLCJhcnJheVRvVXRjRGF0ZSIsImFkZERheXMiLCJhZGRNcyIsImRpZmZXZWVrcyIsIm0wIiwibTEiLCJkaWZmRGF5cyIsInZhbHVlT2YiLCJkaWZmSG91cnMiLCJkaWZmTWludXRlcyIsImRpZmZTZWNvbmRzIiwiZGlmZkRheUFuZFRpbWUiLCJtMGRheSIsInN0YXJ0T2ZEYXkiLCJtMWRheSIsInllYXJzIiwibW9udGhzIiwiZGF5cyIsIk1hdGgiLCJyb3VuZCIsIm1pbGxpc2Vjb25kcyIsImRpZmZXaG9sZVdlZWtzIiwiZCIsImRpZmZXaG9sZURheXMiLCJ0aW1lQXNNcyIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwic3RhcnRPZkhvdXIiLCJnZXRVVENIb3VycyIsInN0YXJ0T2ZNaW51dGUiLCJnZXRVVENNaW51dGVzIiwic3RhcnRPZlNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJ3ZWVrT2ZZZWFyIiwibWFya2VyIiwiZG93IiwiZG95IiwieSIsInciLCJ3ZWVrT2ZHaXZlblllYXIiLCJuZXh0VyIsIm1pbiIsInllYXIiLCJmaXJzdFdlZWtTdGFydCIsImZpcnN0V2Vla09mZnNldCIsImRheVN0YXJ0IiwiZmxvb3IiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRhdGVUb0xvY2FsQXJyYXkiLCJkYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiYXJyYXlUb0xvY2FsRGF0ZSIsIkRhdGUiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJjb25jYXQiLCJVVEMiLCJpc1ZhbGlkRGF0ZSIsImlzTmFOIiwiY3JlYXRlRXZlbnRJbnN0YW5jZSIsImRlZklkIiwicmFuZ2UiLCJmb3JjZWRTdGFydFR6byIsImZvcmNlZEVuZFR6byIsImluc3RhbmNlSWQiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlUHJvcHMiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJuYW1lXzEiLCJjb21wbGV4T2JqcyIsInVuc2hpZnQiLCJ1bmRlZmluZWQiLCJuYW1lXzIiLCJmaWx0ZXJIYXNoIiwiaGFzaCIsImZpbHRlcmVkIiwibWFwSGFzaCIsIm5ld0hhc2giLCJhcnJheVRvSGFzaCIsIl9pIiwiYV8xIiwiaXRlbSIsImJ1aWxkSGFzaEZyb21BcnJheSIsInR1cGxlIiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJvYmoiLCJpc1Byb3BzRXF1YWwiLCJnZXRVbmVxdWFsUHJvcHMiLCJrZXlzIiwiY29tcGFyZU9ianMiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwiZXF1YWxpdHlGdW5jcyIsImlzT2JqVmFsc0VxdWFsIiwidmFsMCIsInZhbDEiLCJjb21wYXJhdG9yIiwiY29sbGVjdEZyb21IYXNoIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic3RlcCIsInJlcyIsInBhcnNlUmVjdXJyaW5nIiwicmVmaW5lZCIsImRlZmF1bHRBbGxEYXkiLCJkYXRlRW52IiwicmVjdXJyaW5nVHlwZXMiLCJwYXJzZWQiLCJwYXJzZSIsImFsbERheSIsImFsbERheUd1ZXNzIiwiZHVyYXRpb24iLCJ0eXBlRGF0YSIsInR5cGVJZCIsImV4cGFuZFJlY3VycmluZyIsImV2ZW50U3RvcmUiLCJmcmFtaW5nUmFuZ2UiLCJwbHVnaW5Ib29rcyIsIm9wdGlvbnMiLCJkZWZzIiwiaW5zdGFuY2VzIiwiaW5zdGFuY2UiLCJyZWN1cnJpbmdEZWYiLCJkZWYiLCJkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiIsImRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24iLCJzdGFydHMiLCJleHBhbmRSZWN1cnJpbmdSYW5nZXMiLCJzdGFydHNfMSIsInN0YXJ0IiwiZW5kIiwiZXZlbnREZWYiLCJ0eXBlRGVmIiwibWFya2VycyIsImV4cGFuZCIsInN1YnRyYWN0IiwibWFwIiwiSU5URVJOQUxfVU5JVFMiLCJQQVJTRV9SRSIsImNyZWF0ZUR1cmF0aW9uIiwidW5pdCIsInBhcnNlU3RyaW5nIiwicGFyc2VPYmplY3QiLCJleGVjIiwic2lnbiIsInBhcnNlSW50IiwibW9udGgiLCJkYXkiLCJob3VycyIsImhvdXIiLCJtaW51dGVzIiwibWludXRlIiwic2Vjb25kcyIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwibXMiLCJ3ZWVrcyIsIndlZWsiLCJzcGVjaWZpZWRXZWVrcyIsImR1cmF0aW9uc0VxdWFsIiwiZDAiLCJkMSIsImFzQ2xlYW5EYXlzIiwiZHVyIiwiYWRkRHVyYXRpb25zIiwic3VidHJhY3REdXJhdGlvbnMiLCJtdWx0aXBseUR1cmF0aW9uIiwiYXNSb3VnaFllYXJzIiwiYXNSb3VnaERheXMiLCJhc1JvdWdoTW9udGhzIiwiYXNSb3VnaE1zIiwiYXNSb3VnaE1pbnV0ZXMiLCJhc1JvdWdoU2Vjb25kcyIsIndob2xlRGl2aWRlRHVyYXRpb25zIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJsb2NhbFJlcyIsImdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciIsInZhbHVlIiwiYnVpbGRJc29TdHJpbmciLCJ0aW1lWm9uZU9mZnNldCIsInN0cmlwWmVyb1RpbWUiLCJ0b0lTT1N0cmluZyIsImZvcm1hdFRpbWVab25lT2Zmc2V0IiwiZm9ybWF0RGF5U3RyaW5nIiwiZm9ybWF0SXNvVGltZVN0cmluZyIsImRvSXNvIiwiYWJzIiwibWlucyIsInJlbW92ZUV4YWN0IiwiYXJyYXkiLCJleGFjdFZhbCIsInJlbW92ZUNudCIsInNwbGljZSIsImlzQXJyYXlzRXF1YWwiLCJhMCIsImExIiwiZXF1YWxpdHlGdW5jIiwibWVtb2l6ZSIsIndvcmtlckZ1bmMiLCJyZXNFcXVhbGl0eSIsInRlYXJkb3duRnVuYyIsImN1cnJlbnRBcmdzIiwiY3VycmVudFJlcyIsIm5ld0FyZ3MiLCJhcmd1bWVudHMiLCJtZW1vaXplT2JqQXJnIiwiX3RoaXMiLCJjdXJyZW50QXJnIiwibmV3QXJnIiwibWVtb2l6ZUFycmF5bGlrZSIsImN1cnJlbnRBcmdTZXRzIiwiY3VycmVudFJlc3VsdHMiLCJuZXdBcmdTZXRzIiwiY3VycmVudExlbiIsIm5ld0xlbiIsIm1lbW9pemVIYXNobGlrZSIsImN1cnJlbnRBcmdIYXNoIiwiY3VycmVudFJlc0hhc2giLCJuZXdBcmdIYXNoIiwibmV3UmVzSGFzaCIsIkVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTIiwic2VwYXJhdG9yIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsIm9taXRDb21tYXMiLCJTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyIsInRpbWVab25lTmFtZSIsImVyYSIsIndlZWtkYXkiLCJNRVJJRElFTV9SRSIsIkNPTU1BX1JFIiwiTVVMVElfU1BBQ0VfUkUiLCJMVFJfUkUiLCJVVENfUkUiLCJOYXRpdmVGb3JtYXR0ZXIiLCJmb3JtYXRTZXR0aW5ncyIsInN0YW5kYXJkRGF0ZVByb3BzIiwiZXh0ZW5kZWRTZXR0aW5ncyIsInNldmVyaXR5IiwibWF4IiwiYnVpbGRGb3JtYXR0aW5nRnVuYyIsImZvcm1hdFJhbmdlIiwiYmV0dGVyRGVmYXVsdFNlcGFyYXRvciIsImRpZmZTZXZlcml0eSIsImNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkiLCJjYWxlbmRhclN5c3RlbSIsImJpZ2dlc3RVbml0Rm9yUGFydGlhbCIsImZ1bGwwIiwiZnVsbDEiLCJwYXJ0aWFsRGF0ZVByb3BzIiwiY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyIsInBhcnRpYWxGb3JtYXR0aW5nRnVuYyIsInBhcnRpYWwwIiwicGFydGlhbDEiLCJpbnNlcnRpb24iLCJmaW5kQ29tbW9uSW5zZXJ0aW9uIiwiZGVmYXVsdFNlcGFyYXRvciIsImJlZm9yZSIsImFmdGVyIiwiZ2V0TGFyZ2VzdFVuaXQiLCJzdGFuZGFyZERhdGVQcm9wQ250IiwiZm9ybWF0V2Vla051bWJlciIsImNvbXB1dGVXZWVrTnVtYmVyIiwid2Vla1RleHQiLCJ3ZWVrVGV4dExvbmciLCJsb2NhbGUiLCJidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jIiwic2FuaXRpemVTZXR0aW5ncyIsInRpbWVab25lIiwibm9ybWFsRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiY29kZXMiLCJ6ZXJvRm9ybWF0IiwiemVyb1Byb3BzIiwicG9zdFByb2Nlc3MiLCJpbmplY3RUem9TdHIiLCJ0cmltIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJ0em9TdHIiLCJyZXBsYWNlZCIsIm51bSIsImRpc3BsYXkiLCJwYXJ0cyIsInNpbXBsZU51bWJlckZvcm1hdCIsImRpcmVjdGlvbiIsInJldmVyc2UiLCJqb2luIiwiY2EiLCJnZXRNYXJrZXJZZWFyIiwiZ2V0TWFya2VyTW9udGgiLCJnZXRNYXJrZXJEYXkiLCJiaWdnZXN0VW5pdCIsInBhcnRpYWxPcHRpb25zIiwiaTAiLCJmb3VuZDAiLCJpbmRleE9mIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJjbWRGb3JtYXR0ZXIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJldmVudFNvdXJjZVN1Y2Nlc3MiLCJldmVudERpc3BsYXkiLCJldmVudFN0YXJ0RWRpdGFibGUiLCJldmVudER1cmF0aW9uRWRpdGFibGUiLCJldmVudE92ZXJsYXAiLCJldmVudENvbnN0cmFpbnQiLCJldmVudEFsbG93IiwiZXZlbnRCYWNrZ3JvdW5kQ29sb3IiLCJldmVudEJvcmRlckNvbG9yIiwiZXZlbnRUZXh0Q29sb3IiLCJldmVudENvbG9yIiwiZXZlbnRDbGFzc05hbWVzIiwiZXZlbnRDb250ZW50IiwiZXZlbnREaWRNb3VudCIsImV2ZW50V2lsbFVubW91bnQiLCJzZWxlY3RDb25zdHJhaW50Iiwic2VsZWN0T3ZlcmxhcCIsInNlbGVjdEFsbG93IiwiZHJvcHBhYmxlIiwidW5zZWxlY3RDYW5jZWwiLCJzbG90TGFiZWxGb3JtYXQiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsInNsb3RMYWJlbENsYXNzTmFtZXMiLCJzbG90TGFiZWxDb250ZW50Iiwic2xvdExhYmVsRGlkTW91bnQiLCJzbG90TGFiZWxXaWxsVW5tb3VudCIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsImRheU1pbldpZHRoIiwic2xvdExhYmVsSW50ZXJ2YWwiLCJhbGxEYXlUZXh0IiwiYWxsRGF5Q2xhc3NOYW1lcyIsImFsbERheUNvbnRlbnQiLCJhbGxEYXlEaWRNb3VudCIsImFsbERheVdpbGxVbm1vdW50Iiwic2xvdE1pbldpZHRoIiwibmF2TGlua3MiLCJldmVudFRpbWVGb3JtYXQiLCJyZXJlbmRlckRlbGF5IiwibW9yZUxpbmtUZXh0IiwibW9yZUxpbmtIaW50Iiwic2VsZWN0TWluRGlzdGFuY2UiLCJzZWxlY3RhYmxlIiwic2VsZWN0TG9uZ1ByZXNzRGVsYXkiLCJldmVudExvbmdQcmVzc0RlbGF5Iiwic2VsZWN0TWlycm9yIiwiZXZlbnRNYXhTdGFjayIsImV2ZW50TWluSGVpZ2h0IiwiZXZlbnRNaW5XaWR0aCIsImV2ZW50U2hvcnRIZWlnaHQiLCJzbG90RXZlbnRPdmVybGFwIiwicGx1Z2lucyIsImZpcnN0RGF5IiwiZGF5Q291bnQiLCJkYXRlQWxpZ25tZW50IiwiZGF0ZUluY3JlbWVudCIsImhpZGRlbkRheXMiLCJtb250aE1vZGUiLCJmaXhlZFdlZWtDb3VudCIsInZhbGlkUmFuZ2UiLCJ2aXNpYmxlUmFuZ2UiLCJ0aXRsZUZvcm1hdCIsImV2ZW50SW50ZXJhY3RpdmUiLCJub0V2ZW50c1RleHQiLCJ2aWV3SGludCIsIm5hdkxpbmtIaW50IiwiY2xvc2VIaW50IiwidGltZUhpbnQiLCJldmVudEhpbnQiLCJtb3JlTGlua0NsaWNrIiwibW9yZUxpbmtDbGFzc05hbWVzIiwibW9yZUxpbmtDb250ZW50IiwibW9yZUxpbmtEaWRNb3VudCIsIm1vcmVMaW5rV2lsbFVubW91bnQiLCJCQVNFX09QVElPTl9ERUZBVUxUUyIsImNlbnRlciIsIkNBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIiwiZGF0ZXNTZXQiLCJldmVudHNTZXQiLCJldmVudEFkZCIsImV2ZW50Q2hhbmdlIiwiZXZlbnRSZW1vdmUiLCJ3aW5kb3dSZXNpemUiLCJldmVudENsaWNrIiwiZXZlbnRNb3VzZUVudGVyIiwiZXZlbnRNb3VzZUxlYXZlIiwic2VsZWN0IiwidW5zZWxlY3QiLCJsb2FkaW5nIiwiX3VubW91bnQiLCJfYmVmb3JlcHJpbnQiLCJfYWZ0ZXJwcmludCIsIl9ub0V2ZW50RHJvcCIsIl9ub0V2ZW50UmVzaXplIiwiX3Jlc2l6ZSIsIl9zY3JvbGxSZXF1ZXN0IiwiQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTIiwiYnV0dG9uVGV4dCIsImJ1dHRvbkhpbnRzIiwidmlld3MiLCJpbml0aWFsRXZlbnRzIiwiZXZlbnRzIiwiZXZlbnRTb3VyY2VzIiwiQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMiLCJpc01heWJlT2JqZWN0c0VxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJleHRyYSIsInJhdyIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsImV2ZW50UmVmaW5lcnMiLCJidWlsZEV2ZW50UmVmaW5lcnMiLCJyYXdFdmVudHNfMSIsInJhd0V2ZW50IiwicGFyc2VFdmVudCIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJkZWZfMSIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsInN1YiIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY2xhc3NOYW1lIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzaW5nbGVSZXMiLCJwYXJzZVNpbmdsZSIsImhhc0VuZCIsInVpIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJtZW1iZXJBZGRlciIsImZyZWV6ZSIsInN0YXJ0TWV0YSIsInN0YXJ0TWFya2VyIiwiZW5kTWV0YSIsImVuZE1hcmtlciIsInN0YXJ0SW5wdXQiLCJjcmVhdGVNYXJrZXJNZXRhIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJmb3JjZWRUem8iLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsImNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsImRpZmZEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJsYXJnZVVuaXQiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsInNvcnQiLCJjb21wYXJlUmFuZ2VzIiwicmFuZ2UwIiwicmFuZ2UxIiwiaW50ZXJzZWN0UmFuZ2VzIiwibmV3UmFuZ2UiLCJyYW5nZXNFcXVhbCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsIm91dGVyUmFuZ2UiLCJpbm5lclJhbmdlIiwicmFuZ2VDb250YWluc01hcmtlciIsImNvbnN0cmFpbk1hcmtlclRvUmFuZ2UiLCJzbGljZUV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpbnZlcnNlQmdCeUdyb3VwSWQiLCJpbnZlcnNlQmdCeURlZklkIiwiZGVmQnlHcm91cElkIiwiYmdSYW5nZXMiLCJmZ1JhbmdlcyIsImV2ZW50VWlzIiwiY29tcGlsZUV2ZW50VWlzIiwib3JpZ1JhbmdlIiwibm9ybWFsUmFuZ2UiLCJzbGljZWRSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsImludmVydGVkUmFuZ2VzXzEiLCJpbnZlcnRlZFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXNfMiIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiYyIsIl9zZWciLCJldmVudFJhbmdlIiwiY29tcHV0ZVNlZ0RyYWdnYWJsZSIsInRyYW5zZm9ybWVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXJzXzEiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsImV2ZW50SW5zdGFuY2UiLCJ3aG9sZUV2ZW50U3RhcnQiLCJ3aG9sZUV2ZW50RW5kIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJpc1N0YXJ0RGF5IiwiaXNFbmREYXkiLCJnZXRTZWdNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJzZWdSYW5nZSIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImdldEV2ZW50Q2xhc3NOYW1lcyIsImlzTWlycm9yIiwiaXNEcmFnZ2FibGUiLCJpc1N0YXJ0UmVzaXphYmxlIiwiaXNFbmRSZXNpemFibGUiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzU2VsZWN0ZWQiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJnZXRTZWdBbmNob3JBdHRycyIsImhyZWYiLCJlbWl0dGVyIiwiaGFzSGFuZGxlcnMiLCJ0cmlnZ2VyIiwiZXZlbnQiLCJFdmVudEFwaSIsImpzRXZlbnQiLCJ2aWV3Iiwidmlld0FwaSIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsInN0YW5kYXJkUHJvcHMiLCJpc0RhdGVTcGFuc0VxdWFsIiwic3BhbjAiLCJzcGFuMSIsImlzU3BhblByb3BzRXF1YWwiLCJidWlsZERhdGVTcGFuQXBpIiwiYnVpbGRSYW5nZUFwaSIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJvbWl0VGltZSIsInRvRGF0ZSIsInN0YXJ0U3RyIiwiZm9ybWF0SXNvIiwiZW5kU3RyIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImRhdGVTcGFuIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJvcmlnRXZlbnQiLCJjYWxlbmRhckFwaSIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJnZXREZWZhdWx0RXZlbnRFbmQiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiZXZlbnRDb25maWdCYXNlIiwibXV0YXRpb24iLCJldmVudENvbmZpZ3MiLCJhcHBseU11dGF0aW9uVG9FdmVudERlZiIsImFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UiLCJldmVudENvbmZpZyIsInN0YXJ0RGVsdGEiLCJlbmREZWx0YSIsImNvcHkiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJhcHBsaWVyIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJWaWV3QXBpIiwiZ2V0Q3VycmVudERhdGEiLCJ2aWV3VGl0bGUiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiY3VycmVudFJhbmdlIiwiZ2V0T3B0aW9uIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJsYXRlc3RGZXRjaElkIiwiZmV0Y2hSYW5nZSIsInNvdXJjZURlZklkIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImV2ZW50U291cmNlRGVmcyIsInBhcnNlTWV0YSIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJkYXRlTWFya2VyIiwiZ2V0SW5pdGlhbERhdGUiLCJpbml0aWFsRGF0ZUlucHV0IiwiZ2V0Tm93Iiwibm93SW5wdXQiLCJjcmVhdGVOb3dNYXJrZXIiLCJDYWxlbmRhckFwaSIsImN1cnJlbnREYXRhTWFuYWdlciIsImJhdGNoUmVuZGVyaW5nIiwidXBkYXRlU2l6ZSIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsIm9uIiwiaGFuZGxlck5hbWUiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMiLCJjb25zb2xlIiwid2FybiIsIm9mZiIsImNoYW5nZVZpZXciLCJ2aWV3VHlwZSIsImRhdGVPclJhbmdlIiwiem9vbVRvIiwic3RhdGUiLCJzcGVjIiwidmlld1NwZWNzIiwiZ2V0VW5pdFZpZXdTcGVjIiwidG9vbGJhckNvbmZpZyIsInZpZXdUeXBlcyIsImhlYWRlciIsInZpZXdzV2l0aEJ1dHRvbnMiLCJmb290ZXIiLCJzaW5nbGVVbml0IiwicHJldiIsIm5leHQiLCJwcmV2WWVhciIsImFkZFllYXJzIiwibmV4dFllYXIiLCJ0b2RheSIsImNhbGVuZGFyT3B0aW9ucyIsImdvdG9EYXRlIiwiem9uZWREYXRlSW5wdXQiLCJpbmNyZW1lbnREYXRlIiwiZGVsdGFJbnB1dCIsImRlbHRhIiwiZm9ybWF0RGF0ZSIsInNldHRpbmdzIiwiZGF0ZU9yT2JqIiwiZW5kRGF0ZSIsInNlbGVjdGlvbklucHV0IiwiZGF0ZVNlbGVjdGlvbiIsImFkZEV2ZW50IiwiZXZlbnRJbnB1dCIsInNvdXJjZUlucHV0IiwiX2RlZiIsIl9pbnN0YW5jZSIsImN1cnJlbnREYXRhIiwidHJpZ2dlckV2ZW50QWRkIiwic291cmNlQXBpIiwiZ2V0RXZlbnRTb3VyY2VCeUlkIiwibmV3RXZlbnRBcGkiLCJldmVudEFwaSIsInJlbGF0ZWRFdmVudHMiLCJyZXZlcnQiLCJldmVudEFwaVRvU3RvcmUiLCJnZXRFdmVudEJ5SWQiLCJnZXRFdmVudHMiLCJidWlsZEV2ZW50QXBpcyIsInJlbW92ZUFsbEV2ZW50cyIsImdldEV2ZW50U291cmNlcyIsInNvdXJjZUhhc2giLCJzb3VyY2VBcGlzIiwiaW50ZXJuYWxJZCIsImFkZEV2ZW50U291cmNlIiwic291cmNlcyIsInJlbW92ZUFsbEV2ZW50U291cmNlcyIsInJlZmV0Y2hFdmVudHMiLCJzY3JvbGxUb1RpbWUiLCJ0aW1lSW5wdXQiLCJ0aW1lIiwiX2NvbnRleHQiLCJzZXRQcm9wIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsImNvbnRleHRfMSIsImV2ZW50U3RvcmVfMSIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJhc1N0b3JlIiwidG9QbGFpbk9iamVjdCIsImNvbGxhcHNlQ29sb3IiLCJjb2xsYXBzZUV4dGVuZGVkUHJvcHMiLCJ0b0pTT04iLCJleGNsdWRlSW5zdGFuY2UiLCJldmVudEFwaXMiLCJleGNsdWRlSW5zdGFuY2VJZCIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsIkRhdGVFbnYiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwidGltZXN0YW1wVG9NYXJrZXIiLCJnZXRZZWFyIiwiYWRkTW9udGhzIiwiZ3JlYXRlc3RXaG9sZVVuaXQiLCJjb3VudER1cmF0aW9uc0JldHdlZW4iLCJkaWZmIiwic3RhcnRPZiIsInN0YXJ0T2ZZZWFyIiwic3RhcnRPZk1vbnRoIiwic3RhcnRPZldlZWsiLCJkYXRlT3B0aW9ucyIsIm9mZnNldEZvck1hcmtlciIsImlzRW5kRXhjbHVzaXZlIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0IiwidGltZXN0YW1wVG9BcnJheSIsImdldFRpbWV6b25lT2Zmc2V0Iiwib2Zmc2V0Rm9yQXJyYXkiLCJnbG9iYWxMb2NhbGVzIiwiTUlOSU1BTF9SQVdfRU5fTE9DQUxFIiwiY29kZSIsImxpc3QiLCJSQVdfRU5fTE9DQUxFIiwiZXZlbnRDbnQiLCJvcmdhbml6ZVJhd0xvY2FsZXMiLCJleHBsaWNpdFJhd0xvY2FsZXMiLCJkZWZhdWx0Q29kZSIsImFsbFJhd0xvY2FsZXMiLCJyYXdMb2NhbGVNYXAiLCJlbiIsImFsbFJhd0xvY2FsZXNfMSIsInJhd0xvY2FsZSIsImJ1aWxkTG9jYWxlIiwiaW5wdXRTaW5ndWxhciIsImF2YWlsYWJsZSIsInBhcnNlTG9jYWxlIiwicXVlcnlMb2NhbGUiLCJjb2RlQXJnIiwicXVlcnlSYXdMb2NhbGUiLCJzaW1wbGVJZCIsInNsaWNlIiwibWVyZ2VkIiwiTnVtYmVyRm9ybWF0IiwiZGF0ZUlucHV0IiwiYnVpbGREYXRlRW52JDEiLCJkYXRlTWV0YSIsIkRFRl9ERUZBVUxUUyIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJkYXlzT2ZXZWVrIiwicGFyc2VCdXNpbmVzc0hvdXJzIiwicmVmaW5lSW5wdXRzIiwicmF3RGVmcyIsImZpbHRlciIsInJhd0RlZiIsInBvaW50SW5zaWRlUmVjdCIsInBvaW50IiwicmVjdCIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImludGVyc2VjdFJlY3RzIiwicmVjdDEiLCJyZWN0MiIsInRyYW5zbGF0ZVJlY3QiLCJkZWx0YVgiLCJkZWx0YVkiLCJjb25zdHJhaW5Qb2ludCIsImdldFJlY3RDZW50ZXIiLCJkaWZmUG9pbnRzIiwicG9pbnQxIiwicG9pbnQyIiwiY2FuVkdyb3dXaXRoaW5DZWxsIiwiZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIiwiY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCIsInBvc2l0aW9uIiwiaW5uZXJIVE1MIiwiYXBwZW5kQ2hpbGQiLCJkaXYiLCJwb3NzaWJsZSIsIm9mZnNldEhlaWdodCIsIkVNUFRZX0VWRU5UX1NUT1JFIiwiU3BsaXR0ZXIiLCJnZXRLZXlzRm9yRXZlbnREZWZzIiwiX2dldEtleXNGb3JFdmVudERlZnMiLCJzcGxpdERhdGVTZWxlY3Rpb24iLCJfc3BsaXREYXRlU3BhbiIsInNwbGl0RXZlbnRTdG9yZSIsIl9zcGxpdEV2ZW50U3RvcmUiLCJzcGxpdEluZGl2aWR1YWxVaSIsIl9zcGxpdEluZGl2aWR1YWxVaSIsInNwbGl0RXZlbnREcmFnIiwiX3NwbGl0SW50ZXJhY3Rpb24iLCJzcGxpdEV2ZW50UmVzaXplIiwiZXZlbnRVaUJ1aWxkZXJzIiwic3BsaXRQcm9wcyIsImtleUluZm9zIiwiZ2V0S2V5SW5mbyIsImRlZktleXMiLCJkYXRlU2VsZWN0aW9ucyIsImluZGl2aWR1YWxVaSIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplcyIsImV2ZW50UmVzaXplIiwiaW5mbyIsImJ1aWxkRXZlbnRVaUZvcktleSIsImtleUluZm8iLCJidWlsZEV2ZW50VWkiLCJldmVudFNlbGVjdGlvbiIsImRhdGVTcGFucyIsImdldEtleXNGb3JEYXRlU3BhbiIsImtleXNfMSIsImdldEtleXNGb3JFdmVudERlZiIsInNwbGl0U3RvcmVzIiwiX2MiLCJzcGxpdEhhc2hlcyIsImludGVyYWN0aW9uIiwic3BsaXRTdGF0ZXMiLCJhZmZlY3RlZFN0b3Jlc18xIiwiYWZmZWN0ZWRFdmVudHMiLCJtdXRhdGVkS2V5c0J5RGVmSWQiLCJtdXRhdGVkRXZlbnRzIiwibXV0YXRlZFN0b3Jlc18xIiwicG9wdWxhdGUiLCJpc0V2ZW50IiwiYWxsVWkiLCJldmVudFVpRm9yS2V5IiwiYmFzZVBhcnRzIiwic3R1ZmYiLCJnZXREYXRlTWV0YSIsImlzRGlzYWJsZWQiLCJpc090aGVyIiwiZ2V0RGF5Q2xhc3NOYW1lcyIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJnZXRTbG90Q2xhc3NOYW1lcyIsIkRBWV9GT1JNQVQiLCJXRUVLX0ZPUk1BVCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiaXNUYWJiYWJsZSIsImRhdGVTdHIiLCJ6b25lZERhdGUiLCJoYW5kbGVJbnRlcmFjdGlvbiIsImN1c3RvbUFjdGlvbiIsIl9pc1J0bFNjcm9sbGJhck9uTGVmdCIsImdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0Iiwib3V0ZXJFbCIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImlubmVyRWwiLCJmaXJzdENoaWxkIiwiX3Njcm9sbGJhcldpZHRocyIsImdldFNjcm9sbGJhcldpZHRocyIsImNvbXB1dGVTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwiLCJ4IiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImNvbXB1dGVFZGdlcyIsImdldFBhZGRpbmciLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYmFkU2Nyb2xsYmFyV2lkdGhzIiwic2Nyb2xsYmFyTGVmdFJpZ2h0Iiwic2Nyb2xsYmFyQm90dG9tIiwic2Nyb2xsYmFyTGVmdCIsInNjcm9sbGJhclJpZ2h0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvbXB1dGVJbm5lclJlY3QiLCJnb1dpdGhpblBhZGRpbmciLCJkb0Zyb21XaW5kb3dWaWV3cG9ydCIsIm91dGVyUmVjdCIsImNvbXB1dGVSZWN0IiwiZWRnZXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0IiwiY2xpcHBpbmdQYXJlbnRzIiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2xpcHBpbmdQYXJlbnRzXzEiLCJjbGlwcGluZ1BhcmVudCIsImludGVyc2VjdGlvbiIsImNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zIiwiY29tcHV0ZVZNYXJnaW5zIiwiY29tcHV0ZWQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJ1bnByb21pc2lmeSIsImlzUmVzb2x2ZWQiLCJ3cmFwcGVkU3VjY2VzcyIsIndyYXBwZWRGYWlsdXJlIiwidGhlbiIsIkVtaXR0ZXIiLCJoYW5kbGVycyIsInRoaXNDb250ZXh0Iiwic2V0VGhpc0NvbnRleHQiLCJzZXRPcHRpb25zIiwiYWRkVG9IYXNoIiwicmVtb3ZlRnJvbUhhc2giLCJhdHRhY2hlZEhhbmRsZXJzIiwib3B0aW9uSGFuZGxlciIsImhhbmRsZXJzXzEiLCJQb3NpdGlvbkNhY2hlIiwib3JpZ2luRWwiLCJlbHMiLCJpc0hvcml6b250YWwiLCJpc1ZlcnRpY2FsIiwib3JpZ2luQ2xpZW50UmVjdCIsImJ1aWxkRWxIb3Jpem9udGFscyIsImJ1aWxkRWxWZXJ0aWNhbHMiLCJvcmlnaW5DbGllbnRMZWZ0IiwibGVmdHMiLCJyaWdodHMiLCJvcmlnaW5DbGllbnRUb3AiLCJ0b3BzIiwiYm90dG9tcyIsImxlZnRUb0luZGV4IiwibGVmdFBvc2l0aW9uIiwidG9wVG9JbmRleCIsInRvcFBvc2l0aW9uIiwiZ2V0V2lkdGgiLCJsZWZ0SW5kZXgiLCJnZXRIZWlnaHQiLCJ0b3BJbmRleCIsIlNjcm9sbENvbnRyb2xsZXIiLCJnZXRNYXhTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJnZXRNYXhTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsV2lkdGgiLCJnZXRDbGllbnRXaWR0aCIsImNhblNjcm9sbFZlcnRpY2FsbHkiLCJjYW5TY3JvbGxIb3Jpem9udGFsbHkiLCJjYW5TY3JvbGxVcCIsImdldFNjcm9sbFRvcCIsImNhblNjcm9sbERvd24iLCJjYW5TY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImNhblNjcm9sbFJpZ2h0IiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJfc3VwZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsInNjcm9sbCIsIlRoZW1lIiwiaWNvbk92ZXJyaWRlT3B0aW9uIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwicHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJTY3JvbGxSZXNwb25kZXIiLCJleGVjRnVuYyIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJyZXF1ZXN0IiwicXVldWVkUmVxdWVzdCIsImRyYWluIiwiZmlyZUluaXRpYWxTY3JvbGwiLCJkZXRhY2giLCJ1cGRhdGUiLCJpc0RhdGVzTmV3IiwiVmlld0NvbnRleHRUeXBlIiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJhZGRSZXNpemVIYW5kbGVyIiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImNyZWF0ZVNjcm9sbFJlc3BvbmRlciIsIlB1cmVDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJkZWJ1ZyIsImxvZyIsInByb3BFcXVhbGl0eSIsInN0YXRlRXF1YWxpdHkiLCJzYWZlU2V0U3RhdGUiLCJuZXdTdGF0ZSIsInNldFN0YXRlIiwiYWRkUHJvcHNFcXVhbGl0eSIsImFkZFN0YXRlRXF1YWxpdHkiLCJjb250ZXh0VHlwZSIsIkJhc2VDb21wb25lbnQiLCJjcmVhdGUiLCJzZXRSZWYiLCJyZWYiLCJjdXJyZW50IiwiRGF0ZUNvbXBvbmVudCIsInVpZCIsInByZXBhcmVIaXRzIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImVsV2lkdGgiLCJlbEhlaWdodCIsImlzVmFsaWRTZWdEb3duRWwiLCJpc1ZhbGlkRGF0ZURvd25FbCIsImNyZWF0ZVBsdWdpbiIsImRlcHMiLCJyZWR1Y2VycyIsImlzTG9hZGluZ0Z1bmNzIiwiY29udGV4dEluaXQiLCJldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwidmlld1Byb3BzVHJhbnNmb3JtZXJzIiwiaXNQcm9wc1ZhbGlkIiwiZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIiwidmlld0NvbnRhaW5lckFwcGVuZHMiLCJldmVudERyb3BUcmFuc2Zvcm1lcnMiLCJjb21wb25lbnRJbnRlcmFjdGlvbnMiLCJjYWxlbmRhckludGVyYWN0aW9ucyIsInRoZW1lQ2xhc3NlcyIsIm5hbWVkVGltZVpvbmVkSW1wbCIsImVsZW1lbnREcmFnZ2luZ0ltcGwiLCJvcHRpb25DaGFuZ2VIYW5kbGVycyIsInNjcm9sbEdyaWRJbXBsIiwiY29udGVudFR5cGVIYW5kbGVycyIsImxpc3RlbmVyUmVmaW5lcnMiLCJvcHRpb25SZWZpbmVycyIsInByb3BTZXRIYW5kbGVycyIsImJ1aWxkUGx1Z2luSG9va3MiLCJwbHVnaW5EZWZzIiwiZ2xvYmFsRGVmcyIsImlzQWRkZWQiLCJob29rcyIsImFkZERlZnMiLCJkZWZzXzEiLCJjb21iaW5lSG9va3MiLCJidWlsZEJ1aWxkUGx1Z2luSG9va3MiLCJjdXJyZW50T3ZlcnJpZGVEZWZzIiwiY3VycmVudEdsb2JhbERlZnMiLCJjdXJyZW50SG9va3MiLCJvdmVycmlkZURlZnMiLCJob29rczAiLCJob29rczEiLCJTdGFuZGFyZFRoZW1lIiwicm9vdCIsInRhYmxlQ2VsbFNoYWRlZCIsImJ1dHRvbkdyb3VwIiwiYnV0dG9uIiwiYnV0dG9uQWN0aXZlIiwiY2xvc2UiLCJjb21waWxlVmlld0RlZnMiLCJkZWZhdWx0Q29uZmlncyIsIm92ZXJyaWRlQ29uZmlncyIsImVuc3VyZVZpZXdEZWYiLCJ2aWV3RGVmIiwiYnVpbGRWaWV3RGVmIiwiZGVmYXVsdENvbmZpZyIsIm92ZXJyaWRlQ29uZmlnIiwicXVlcnlQcm9wIiwidGhlQ29tcG9uZW50Iiwic3VwZXJUeXBlIiwic3VwZXJEZWYiLCJkZWZhdWx0cyIsInJhd09wdGlvbnMiLCJvdmVycmlkZXMiLCJSZW5kZXJIb29rIiwicm9vdEVsUmVmIiwiaGFuZGxlUm9vdEVsIiwiZWxSZWYiLCJyZW5kZXIiLCJob29rUHJvcHMiLCJNb3VudEhvb2siLCJDb250ZW50SG9vayIsImRlZmF1bHRDb250ZW50IiwiYmFja3VwRWxSZWYiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50Iiwibm9ybWFsaXplQ2xhc3NOYW1lcyIsIkN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0IiwiQ29uc3VtZXIiLCJyZW5kZXJJZCIsIkNvbnRlbnRIb29rSW5uZXIiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUN1c3RvbUNvbnRlbnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImN1c3RvbUNvbnRlbnRJbmZvIiwiZGVzdHJveSIsImdldElubmVyQ29udGVudCIsImdldENvbnRlbnRNZXRhIiwiY29udGVudEtleSIsImNvbnRlbnRWYWwiLCJidWlsZExpZmVjeWNsZUZ1bmNzIiwibm9ybWFsaXplQ29udGVudCIsInNlYXJjaEtleSIsInJvb3RFbCIsImJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciIsImN1cnJlbnRHZW5lcmF0b3IiLCJjdXJyZW50SG9va1Byb3BzIiwiY3VycmVudENsYXNzTmFtZXMiLCJnZW5lcmF0b3IiLCJWaWV3Um9vdCIsImN1c3RvbUNsYXNzTmFtZXMiLCJwYXJzZVZpZXdDb25maWdzIiwiaW5wdXRzIiwicGFyc2VWaWV3Q29uZmlnIiwiY3JlYXRlVmlld0hvb2tDb21wb25lbnQiLCJ2aWV3UHJvcHMiLCJ2aWV3RWxSZWYiLCJidWlsZFZpZXdTcGVjcyIsImRlZmF1bHRJbnB1dHMiLCJvcHRpb25PdmVycmlkZXMiLCJkeW5hbWljT3B0aW9uT3ZlcnJpZGVzIiwibG9jYWxlRGVmYXVsdHMiLCJ2aWV3RGVmcyIsImJ1aWxkVmlld1NwZWMiLCJkdXJhdGlvbklucHV0IiwiZHVyYXRpb25Vbml0Iiwic2luZ2xlVW5pdE92ZXJyaWRlcyIsImNyZWF0ZUR1cmF0aW9uQ2FjaGVkIiwiZGVub20iLCJxdWVyeUJ1dHRvblRleHQiLCJvcHRpb25zU3Vic2V0IiwiYnV0dG9uVGV4dE1hcCIsInF1ZXJ5QnV0dG9uVGl0bGUiLCJidXR0b25LZXkiLCJvcHRpb25EZWZhdWx0cyIsImJ1dHRvblRleHRPdmVycmlkZSIsImJ1dHRvblRleHREZWZhdWx0IiwiYnV0dG9uVGl0bGVPdmVycmlkZSIsImJ1dHRvbkhpbnQiLCJidXR0b25UaXRsZURlZmF1bHQiLCJkdXJhdGlvbklucHV0TWFwIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsImluaXRIaWRkZW5EYXlzIiwiYnVpbGRQcmV2IiwiY3VycmVudERhdGVQcm9maWxlIiwiZm9yY2VUb1ZhbGlkIiwicHJldkRhdGUiLCJjdXJyZW50UmFuZ2VVbml0IiwiYnVpbGQiLCJidWlsZE5leHQiLCJuZXh0RGF0ZSIsImN1cnJlbnRJbmZvIiwiaXNSYW5nZUFsbERheSIsInJlbmRlclJhbmdlIiwiaXNWYWxpZCIsImJ1aWxkVmFsaWRSYW5nZSIsInRyaW1IaWRkZW5EYXlzIiwiYnVpbGRDdXJyZW50UmFuZ2VJbmZvIiwiYnVpbGRSZW5kZXJSYW5nZSIsImFkanVzdEFjdGl2ZVJhbmdlIiwiYnVpbGREYXRlSW5jcmVtZW50IiwidmFsaWRSYW5nZUlucHV0Iiwic2ltcGxlSW5wdXQiLCJyZWZpbmVSYW5nZSIsImJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24iLCJidWlsZFJhbmdlRnJvbURheUNvdW50IiwiYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UiLCJnZXRGYWxsYmFja0R1cmF0aW9uIiwiaXNIaWRkZW5EYXkiLCJza2lwSGlkZGVuRGF5cyIsImNvbXB1dGVSZXMiLCJydW5uaW5nQ291bnQiLCJ2aXNpYmxlUmFuZ2VJbnB1dCIsImZhbGxiYWNrIiwiY3VzdG9tQWxpZ25tZW50IiwicmFuZ2VJbnB1dCIsImlzSGlkZGVuRGF5SGFzaCIsImluYyIsImlzRXhjbHVzaXZlIiwicmVkdWNlVmlld1R5cGUiLCJyZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzIiwicmVkdWNlRGF0ZVByb2ZpbGUiLCJkcCIsImluaXRFdmVudFNvdXJjZXMiLCJhZGRTb3VyY2VzIiwicGFyc2VJbml0aWFsU291cmNlcyIsInJlZHVjZUV2ZW50U291cmNlcyIsInJlbW92ZVNvdXJjZSIsImZldGNoRGlydHlTb3VyY2VzIiwiZmV0Y2hTb3VyY2VzQnlJZHMiLCJleGNsdWRlU3RhdGljU291cmNlcyIsInJlY2VpdmVSZXNwb25zZSIsImZldGNoSWQiLCJyZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZSIsImNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nIiwiZXZlbnRTb3VyY2VIYXNoIiwic291cmNlc18xIiwic291cmNlIiwiaXNTb3VyY2VEaXJ0eSIsImRvZXNTb3VyY2VOZWVkUmFuZ2UiLCJwcmV2U291cmNlcyIsInNvdXJjZUlkSGFzaCIsIm5leHRTb3VyY2VzIiwiZmV0Y2hTb3VyY2UiLCJzb3VyY2VEZWYiLCJmZXRjaCIsInhociIsImVycm9yIiwibWVzc2FnZSIsInJhd1NvdXJjZXMiLCJyYXdTb3VyY2VzXzEiLCJyYXdTb3VyY2UiLCJpZ25vcmVSYW5nZSIsInJlZHVjZUV2ZW50U3RvcmUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJzdWJzZXQiLCJ0cmFuc2Zvcm1SYXdFdmVudHMiLCJjYWxFYWNoVHJhbnNmb3JtIiwic291cmNlRWFjaFRyYW5zZm9ybSIsInRyYW5zZm9ybUVhY2hSYXdFdmVudCIsInJlZmluZWRFdmVudHMiLCJyZWZpbmVkRXZlbnQiLCJleHBhbmRSYW5nZSIsInJlem9uZUV2ZW50U3RvcmVEYXRlcyIsIm9sZERhdGVFbnYiLCJuZXdEYXRlRW52IiwiZXhjbHVkZUluc3RhbmNlcyIsInJlbW92YWxzIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJwYXJzZVRvb2xiYXIiLCJzZWN0aW9uU3RySGFzaCIsInNlY3Rpb25XaWRnZXRzIiwiaGFzVGl0bGUiLCJzZWN0aW9uTmFtZSIsInNlY3Rpb25TdHIiLCJzZWN0aW9uUmVzIiwicGFyc2VTZWN0aW9uIiwid2lkZ2V0cyIsImNhbGVuZGFyQ3VzdG9tQnV0dG9ucyIsImNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uVGV4dCIsImNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uSGludHMiLCJzZWN0aW9uU3Vic3RycyIsImJ1dHRvbkdyb3VwU3RyIiwiYnV0dG9uQ2xpY2siLCJidXR0b25JY29uIiwiY2xpY2siLCJ0ZXh0IiwiaGludCIsInRleHRGYWxsYmFjayIsInByZXZPck5leHQiLCJuYXZVbml0IiwiZXZlbnRTb3VyY2VEZWYkMiIsImFycmF5RXZlbnRTb3VyY2VQbHVnaW4iLCJldmVudFNvdXJjZURlZiQxIiwiYmluZCIsImZ1bmNFdmVudFNvdXJjZVBsdWdpbiIsInJlcXVlc3RKc29uIiwicGFyYW1zIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwidG9VcHBlckNhc2UiLCJpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyIsImVuY29kZVBhcmFtcyIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbmxvYWQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJlcnIiLCJvbmVycm9yIiwic2VuZCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMiLCJleHRyYVBhcmFtcyIsImV2ZW50U291cmNlRGVmIiwicmVxdWVzdFBhcmFtcyIsImJ1aWxkUmVxdWVzdFBhcmFtcyIsImVycm9yTWVzc2FnZSIsImpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4iLCJjdXN0b21SZXF1ZXN0UGFyYW1zIiwiU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyIsInN0YXJ0UmVjdXIiLCJlbmRSZWN1ciIsInJlY3VycmluZyIsInJlY3VycmluZ0RhdGEiLCJjbGlwcGVkRnJhbWluZ1JhbmdlIiwiZXhwYW5kUmFuZ2VzIiwic2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luIiwiZG93SGFzaCIsImRheU1hcmtlciIsImluc3RhbmNlU3RhcnRzIiwiaW5zdGFuY2VTdGFydCIsImNoYW5nZUhhbmRsZXJQbHVnaW4iLCJoYW5kbGVFdmVudFNvdXJjZXMiLCJ1bmZvdW5kU291cmNlcyIsIm5ld0lucHV0cyIsImlucHV0c18xIiwiaW5wdXRGb3VuZCIsInVuZm91bmRTb3VyY2VzXzEiLCJ1bmZvdW5kU291cmNlIiwibmV3SW5wdXRzXzEiLCJuZXdJbnB1dCIsImhhbmRsZURhdGVQcm9maWxlIiwiaGFuZGxlRXZlbnRTdG9yZSIsImdsb2JhbFBsdWdpbnMiLCJodG1sIiwiYnVpbGRIdG1sUmVuZGVyZXIiLCJkb21Ob2RlcyIsImJ1aWxkRG9tTm9kZVJlbmRlcmVyIiwiY3VycmVudEVsIiwiY3VycmVudEh0bWwiLCJjdXJyZW50RG9tTm9kZXMiLCJuZXdEb21Ob2RlcyIsIm5ld0RvbU5vZGVzXzEiLCJuZXdOb2RlIiwiRGVsYXllZFJ1bm5lciIsImRyYWluZWRPcHRpb24iLCJpc1J1bm5pbmciLCJpc0RpcnR5IiwicGF1c2VEZXB0aHMiLCJ0aW1lb3V0SWQiLCJkZWxheSIsImlzUGF1c2VkIiwiY2xlYXJUaW1lb3V0IiwidHJ5RHJhaW4iLCJzZXRUaW1lb3V0IiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiZGVwdGgiLCJkcmFpbmVkIiwiY2xlYXIiLCJUYXNrUnVubmVyIiwicnVuVGFza09wdGlvbiIsInF1ZXVlIiwiZGVsYXllZFJ1bm5lciIsInRhc2siLCJjb21wbGV0ZWRUYXNrcyIsInNoaWZ0IiwicnVuVGFzayIsImJ1aWxkVGl0bGUiLCJidWlsZFRpdGxlRm9ybWF0IiwiQ2FsZW5kYXJEYXRhTWFuYWdlciIsImNvbXB1dGVPcHRpb25zRGF0YSIsIl9jb21wdXRlT3B0aW9uc0RhdGEiLCJjb21wdXRlQ3VycmVudFZpZXdEYXRhIiwiX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJidWlsZERhdGVFbnYiLCJidWlsZFRoZW1lIiwiYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciIsImJ1aWxkVmlld0FwaSIsImJ1aWxkVmlld1VpUHJvcHMiLCJidWlsZEV2ZW50VWlCeVNvdXJjZSIsImJ1aWxkRXZlbnRVaUJhc2VzIiwicGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyIsImFjdGlvblJ1bm5lciIsIl9oYW5kbGVBY3Rpb24iLCJ1cGRhdGVEYXRhIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQiLCJjdXJyZW50Vmlld09wdGlvbnNJbnB1dCIsImN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQiLCJkYXRhIiwib3B0aW9uc0RhdGEiLCJjdXJyZW50Vmlld1R5cGUiLCJjdXJyZW50Vmlld0RhdGEiLCJjYWxlbmRhckNvbnRleHQiLCJpbml0aWFsU3RhdGUiLCJyZW5kZXJhYmxlRXZlbnRTdG9yZSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbnRleHRBbmRTdGF0ZSIsInJlZHVjZXIiLCJjb21wdXRlSXNMb2FkaW5nIiwicmVzZXRPcHRpb25zIiwiYXBwZW5kIiwiaXNFdmVudHNMb2FkaW5nIiwiZXZlbnRVaVNpbmdsZUJhc2UiLCJldmVudFVpQnlTb3VyY2UiLCJ3YXNMb2FkaW5nIiwiaXNMb2FkaW5nIiwib25BY3Rpb24iLCJvbGREYXRhIiwiY2hhbmdlSGFuZGxlcnMiLCJvbGRDYWxlbmRhck9wdGlvbnMiLCJuZXdDYWxlbmRhck9wdGlvbnMiLCJvbkRhdGEiLCJwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zIiwicmVmaW5lZE9wdGlvbnMiLCJhdmFpbGFibGVMb2NhbGVEYXRhIiwid2FyblVua25vd25PcHRpb25zIiwiY3VycmVudFJhdyIsImN1cnJlbnRSZWZpbmVkIiwiYW55Q2hhbmdlcyIsInByb2Nlc3NSYXdWaWV3T3B0aW9ucyIsImV4cGxpY2l0TG9jYWxlIiwiVGhlbWVDbGFzcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJpc0xvYWRpbmdGdW5jIiwidmlld05hbWUiLCJDYWxlbmRhckRhdGFQcm92aWRlciIsImhhbmRsZURhdGEiLCJkYXRhTWFuYWdlciIsInByZXZQcm9wcyIsIm5ld09wdGlvbk92ZXJyaWRlcyIsInNsaWNlRXZlbnRzIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJzdHJpY3RPcmRlciIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJtYXhTdGFja0NudCIsImxldmVsQ29vcmRzIiwiZW50cmllc0J5TGV2ZWwiLCJzdGFja0NudHMiLCJhZGRTZWdzIiwiaGlkZGVuRW50cmllcyIsImluc2VydEVudHJ5IiwiZW50cnkiLCJmaW5kSW5zZXJ0aW9uIiwiaXNJbnNlcnRpb25WYWxpZCIsImluc2VydEVudHJ5QXQiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsInN0YWNrQ250IiwidG91Y2hpbmdFbnRyeSIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwicGFydENudCIsInNwbGl0SGlkZGVuRW50cmllcyIsImVudHJ5U3BhbiIsImJhcnJpZXJTcGFuIiwiaW50ZXJzZWN0U3BhbnMiLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImVudHJpZXNfMSIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImVudHJpZXNfMiIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZXNfMSIsIm1lcmdlIiwiam9pblNwYW5zIiwic2VhcmNoVmFsIiwiZ2V0SXRlbVZhbCIsIm1pZGRsZUluZGV4IiwibWlkZGxlVmFsIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiVG9vbGJhclNlY3Rpb24iLCJ3aWRnZXRHcm91cHMiLCJ3aWRnZXRHcm91cCIsInJlbmRlcldpZGdldEdyb3VwIiwiaXNPbmx5QnV0dG9ucyIsIndpZGdldEdyb3VwXzEiLCJ3aWRnZXQiLCJ0aXRsZUlkIiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwicmVuZGVyU2VjdGlvbiIsIlZpZXdDb250YWluZXIiLCJhdmFpbGFibGVXaWR0aCIsImhhbmRsZUVsIiwidXBkYXRlQXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVSZXNpemUiLCJsaXF1aWQiLCJsYWJlbGVkQnlJZCIsIkV2ZW50Q2xpY2tpbmciLCJoYW5kbGVTZWdDbGljayIsInNlZ0VsIiwiaGFzVXJsQ29udGFpbmVyIiwiZGVmYXVsdFByZXZlbnRlZCIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJDYWxlbmRhckNvbnRlbnQiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiYnVpbGRUb29sYmFyUHJvcHMiLCJoZWFkZXJSZWYiLCJmb290ZXJSZWYiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInZpZXdMYWJlbElkIiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsImxpc3RlbmVycyIsImxpc3RlbmVyc18xIiwibGlzdGVuZXIiLCJyZXNpemVSdW5uZXIiLCJ0b29sYmFyUHJvcHMiLCJ2aWV3Vkdyb3ciLCJ2aWV3QXNwZWN0UmF0aW8iLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsInZpZXdDb250ZXh0IiwiUHJvdmlkZXIiLCJyZW5kZXJWaWV3IiwiYnVpbGRBcHBlbmRDb250ZW50IiwiQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzIiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhclJvb3QiLCJoYW5kbGVCZWZvcmVQcmludCIsImhhbmRsZUFmdGVyUHJpbnQiLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwiVGFibGVEYXRlQ2VsbCIsImRheU1ldGEiLCJuYXZMaW5rQXR0cnMiLCJjb2xDbnQiLCJleHRyYUhvb2tQcm9wcyIsInJvbGUiLCJjb2xTcGFuIiwiZXh0cmFEYXRhQXR0cnMiLCJpc1N0aWNreSIsIldFRUtEQVlfRk9STUFUIiwiVGFibGVEb3dDZWxsIiwiZXh0cmFDbGFzc05hbWVzIiwiTm93VGltZXIiLCJpbml0aWFsTm93RGF0ZSIsImluaXRpYWxOb3dRdWVyaWVkTXMiLCJjb21wdXRlVGltaW5nIiwiY3VycmVudFN0YXRlIiwidW5yb3VuZGVkTm93IiwiY3VycmVudFVuaXRTdGFydCIsIm5leHRVbml0U3RhcnQiLCJ3YWl0TXMiLCJidWlsZERheVJhbmdlIiwiRGF5SGVhZGVyIiwiY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyIiwiZGF0ZXMiLCJyZW5kZXJJbnRybyIsImV4cGxpY2l0Rm9ybWF0IiwiZGF0ZUNudCIsIkRheVNlcmllc01vZGVsIiwiaW5kaWNlcyIsImRheUluZGV4IiwiY250Iiwic2xpY2VSYW5nZSIsImZpcnN0SW5kZXgiLCJnZXREYXRlRGF5SW5kZXgiLCJsYXN0SW5kZXgiLCJjbGlwcGVkRmlyc3RJbmRleCIsImNsaXBwZWRMYXN0SW5kZXgiLCJjZWlsIiwiZGF5T2Zmc2V0IiwiRGF5VGFibGVNb2RlbCIsImRheVNlcmllcyIsImJyZWFrT25XZWVrcyIsImRheXNQZXJSb3ciLCJyb3dDbnQiLCJjZWxscyIsImJ1aWxkQ2VsbHMiLCJoZWFkZXJEYXRlcyIsImJ1aWxkSGVhZGVyRGF0ZXMiLCJyb3dzIiwicm93IiwiY29sIiwiYnVpbGRDZWxsIiwic2VyaWVzU2VnIiwibmV4dEluZGV4IiwiZmlyc3RDb2wiLCJsYXN0Q29sIiwiU2xpY2VyIiwic2xpY2VCdXNpbmVzc0hvdXJzIiwiX3NsaWNlQnVzaW5lc3NIb3VycyIsInNsaWNlRGF0ZVNlbGVjdGlvbiIsIl9zbGljZURhdGVTcGFuIiwiX3NsaWNlRXZlbnRTdG9yZSIsInNsaWNlRXZlbnREcmFnIiwiX3NsaWNlSW50ZXJhY3Rpb24iLCJzbGljZUV2ZW50UmVzaXplIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VQcm9wcyIsImV4dHJhQXJncyIsImV2ZW50U2VncyIsImRhdGVTZWxlY3Rpb25TZWdzIiwiYnVzaW5lc3NIb3VyU2VncyIsImZnRXZlbnRTZWdzIiwiYmdFdmVudFNlZ3MiLCJzbGljZU5vd0RhdGUiLCJjb21wdXRlQWN0aXZlUmFuZ2UiLCJyYW5nZVJlcyIsInNsaWNlRXZlbnRSYW5nZXMiLCJhZmZlY3RlZEluc3RhbmNlcyIsInNlZ3NfMSIsImV2ZW50UmFuZ2VzIiwiZXZlbnRSYW5nZXNfMSIsInNsaWNlRXZlbnRSYW5nZSIsInNlZ3NfMiIsImlzQ29tcG9uZW50QWxsRGF5IiwiaXNJbnRlcmFjdGlvblZhbGlkIiwiaXNOZXdQcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uVmFsaWQiLCJjYWxlbmRhclN0YXRlIiwiZGF0ZVNwYW5NZXRhIiwiZmlsdGVyQ29uZmlnIiwiaXNJbnRlcmFjdGlvblByb3BzVmFsaWQiLCJpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkIiwic3ViamVjdEV2ZW50U3RvcmUiLCJzdWJqZWN0RGVmcyIsInN1YmplY3RJbnN0YW5jZXMiLCJzdWJqZWN0Q29uZmlncyIsIm90aGVyRXZlbnRTdG9yZSIsIm90aGVyRGVmcyIsIm90aGVySW5zdGFuY2VzIiwib3RoZXJDb25maWdzIiwic3ViamVjdEluc3RhbmNlSWQiLCJzdWJqZWN0SW5zdGFuY2UiLCJzdWJqZWN0UmFuZ2UiLCJzdWJqZWN0Q29uZmlnIiwic3ViamVjdERlZiIsImFsbENvbnN0cmFpbnRzUGFzcyIsImV2ZW50T3ZlcmxhcEZ1bmMiLCJvdGhlckluc3RhbmNlSWQiLCJvdGhlckluc3RhbmNlIiwib3RoZXJPdmVybGFwIiwiY2FsZW5kYXJFdmVudFN0b3JlIiwic3ViamVjdEFsbG93Iiwic3ViamVjdERhdGVTcGFuIiwib3JpZ0RlZiIsIm9yaWdJbnN0YW5jZSIsInJlbGV2YW50RXZlbnRTdG9yZSIsInJlbGV2YW50RGVmcyIsInJlbGV2YW50SW5zdGFuY2VzIiwic2VsZWN0aW9uUmFuZ2UiLCJzZWxlY3RPdmVybGFwRnVuYyIsInJlbGV2YW50SW5zdGFuY2VJZCIsInJlbGV2YW50SW5zdGFuY2UiLCJzZWxlY3Rpb25BbGxvdyIsImZ1bGxEYXRlU3BhbiIsImJ1c2luZXNzSG91cnNVbmV4cGFuZGVkIiwiY29uc3RyYWludHNfMSIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwib3V0ZXJSYW5nZXNfMSIsIlZJU0lCTEVfSElEREVOX1JFIiwiU2Nyb2xsZXIiLCJsaXF1aWRJc0Fic29sdXRlIiwiaXNBYnNvbHV0ZSIsIm92ZXJjb21lTGVmdCIsIm92ZXJjb21lUmlnaHQiLCJvdmVyY29tZUJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1heEhlaWdodCIsIm5lZWRzWFNjcm9sbGluZyIsInJlYWxDbGllbnRXaWR0aCIsImdldFlTY3JvbGxiYXJXaWR0aCIsImNoaWxkRWwiLCJuZWVkc1lTY3JvbGxpbmciLCJyZWFsQ2xpZW50SGVpZ2h0IiwiZ2V0WFNjcm9sbGJhcldpZHRoIiwiUmVmTWFwIiwibWFzdGVyQ2FsbGJhY2siLCJjdXJyZW50TWFwIiwiZGVwdGhzIiwiY2FsbGJhY2tNYXAiLCJoYW5kbGVWYWx1ZSIsInJlbW92ZWQiLCJhZGRlZCIsInJlZkNhbGxiYWNrIiwiY29sbGVjdCIsImdldEFsbCIsImNvbXB1dGVTaHJpbmtXaWR0aCIsImNodW5rRWxzIiwic2hyaW5rQ2VsbHMiLCJsYXJnZXN0V2lkdGgiLCJzaHJpbmtDZWxsc18xIiwic2hyaW5rQ2VsbCIsImdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQiLCJzZWN0aW9uQ29uZmlnIiwiZ2V0QWxsb3dZU2Nyb2xsaW5nIiwicmVuZGVyQ2h1bmtDb250ZW50IiwiY2h1bmtDb25maWciLCJpc0hlYWRlciIsInRhYmxlQ2xhc3NOYW1lIiwic3luY1Jvd0hlaWdodHMiLCJtaW5XaWR0aCIsInRhYmxlTWluV2lkdGgiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsInJvd0NvbnRlbnQiLCJpc0NvbFByb3BzRXF1YWwiLCJjb2xzMCIsImNvbHMxIiwicmVuZGVyTWljcm9Db2xHcm91cCIsImNvbHMiLCJzaHJpbmtXaWR0aCIsImNvbE5vZGVzIiwiY29sc18xIiwiY29sUHJvcHMiLCJzYW5pdGl6ZVNocmlua1dpZHRoIiwiaGFzU2hyaW5rV2lkdGgiLCJjb2xzXzIiLCJnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyIsImdldFNlY3Rpb25DbGFzc05hbWVzIiwid2hvbGVUYWJsZVZHcm93IiwicmVuZGVyU2Nyb2xsU2hpbSIsImdldFN0aWNreUhlYWRlckRhdGVzIiwiZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiU2ltcGxlU2Nyb2xsR3JpZCIsInByb2Nlc3NDb2xzIiwic2Nyb2xsZXJSZWZzIiwic2Nyb2xsZXJFbFJlZnMiLCJfaGFuZGxlU2Nyb2xsZXJFbCIsImZvcmNlWVNjcm9sbGJhcnMiLCJzY3JvbGxlckNsaWVudFdpZHRocyIsInNjcm9sbGVyQ2xpZW50SGVpZ2h0cyIsImhhbmRsZVNpemluZyIsImNvbXB1dGVTY3JvbGxlckRpbXMiLCJzZWN0aW9uQ29uZmlncyIsInNlY3Rpb25zIiwibWljcm9Db2xHcm91cE5vZGUiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29uZmlnQ250IiwiY29uZmlnSSIsImN1cnJlbnRDb25maWciLCJoZWFkU2VjdGlvbk5vZGVzIiwiYm9keVNlY3Rpb25Ob2RlcyIsImZvb3RTZWN0aW9uTm9kZXMiLCJpc0J1Z2d5Iiwicm9sZUF0dHJzIiwib3V0ZXJDb250ZW50IiwicmVuZGVyQ2h1bmtUZCIsImNodW5rIiwiaXNMaXF1aWQiLCJzZWN0aW9uS2V5Iiwicm93U3luY0hlaWdodHMiLCJyZXBvcnRSb3dIZWlnaHRDaGFuZ2UiLCJzY3JvbGxlckVsIiwic2VjdGlvbiIsImdldFNlY3Rpb25CeUtleSIsInNjcm9sbGVyRWxSZWYiLCJzY3JvbGxiYXJXaWR0aCIsInNjcm9sbGVyIiwiaGFybmVzc0VsIiwic2VjdGlvbnNfMSIsIkV2ZW50Um9vdCIsInRpbWVUZXh0IiwiZGlzYWJsZURyYWdnaW5nIiwiZGlzYWJsZVJlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwic3RhbmRhcmRDbGFzc05hbWVzIiwiU3RhbmRhcmRFdmVudCIsImRlZmF1bHRUaW1lRm9ybWF0IiwicmVuZGVySW5uZXJDb250ZW50JDEiLCJpbm5lclByb3BzIiwiTm93SW5kaWNhdG9yUm9vdCIsImlzQXhpcyIsIkRBWV9OVU1fRk9STUFUIiwiRGF5Q2VsbENvbnRlbnQiLCJyZWZpbmVEYXlDZWxsSG9va1Byb3BzIiwic2hvd0RheU51bWJlciIsImV4dHJhUHJvcHMiLCJkYXlOdW1iZXJUZXh0IiwiRGF5Q2VsbFJvb3QiLCJyZWZpbmVIb29rUHJvcHMiLCJkYXRhQXR0cnMiLCJyZW5kZXJGaWxsIiwiZmlsbFR5cGUiLCJCZ0V2ZW50IiwiV2Vla051bWJlclJvb3QiLCJkZWZhdWx0Rm9ybWF0IiwicmVuZGVySW5uZXIiLCJQQURESU5HX0ZST01fVklFV1BPUlQiLCJQb3BvdmVyIiwiaGFuZGxlRG9jdW1lbnRNb3VzZURvd24iLCJoYW5kbGVDbG9zZUNsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwib25DbG9zZSIsImV4dHJhQXR0cnMiLCJwYXJlbnRFbCIsImFsaWdubWVudEVsIiwiYWxpZ25HcmlkVG9wIiwiYWxpZ25tZW50UmVjdCIsInBvcG92ZXJEaW1zIiwicG9wb3ZlclRvcCIsInBvcG92ZXJMZWZ0Iiwib3JpZ2luXzEiLCJvZmZzZXRQYXJlbnQiLCJNb3JlUG9wb3ZlciIsInN0YXJ0RGF0ZSIsImRheUNsYXNzTmFtZXMiLCJleHRyYURhdGVTcGFuIiwiZGF5RWwiLCJsYXllciIsIk1vcmVMaW5rUm9vdCIsImxpbmtFbFJlZiIsImlzUG9wb3Zlck9wZW4iLCJwb3BvdmVySWQiLCJoYW5kbGVDbGljayIsImNvbXB1dGVSYW5nZSIsImJ1aWxkUHVibGljU2VnIiwiYWxsRGF5RGF0ZSIsImFsbFNlZ3MiLCJoaWRkZW5TZWdzIiwiaGFuZGxlUG9wb3ZlckNsb3NlIiwibW9yZUNudCIsInNob3J0VGV4dCIsInJlbmRlck1vcmVMaW5rSW5uZXIiLCJhbGlnbm1lbnRFbFJlZiIsInBvcG92ZXJDb250ZW50IiwidXBkYXRlUGFyZW50RWwiLCJjb21wdXRlRWFybGllc3RTZWdTdGFydCIsImNvbXB1dGVMYXRlc3RTZWdFbmQiLCJwaWNrRWFybGllc3RTdGFydCIsInNlZzAiLCJzZWcxIiwicGlja0xhdGVzdEVuZCIsInZlcnNpb24iLCJwYXJzZU1hcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": function() { return /* binding */ Component; },\n/* harmony export */   \"Fragment\": function() { return /* binding */ Fragment; },\n/* harmony export */   \"createContext\": function() { return /* binding */ createContext; },\n/* harmony export */   \"createElement\": function() { return /* binding */ createElement; },\n/* harmony export */   \"createPortal\": function() { return /* binding */ createPortal; },\n/* harmony export */   \"createRef\": function() { return /* binding */ createRef; },\n/* harmony export */   \"flushSync\": function() { return /* binding */ flushSync; },\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* binding */ unmountComponentAtNode; }\n/* harmony export */ });\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === \"undefined\") {\n    throw new Error(\"Please import the top-level fullcalendar lib before attempting to import a plugin.\");\n}\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushSync = FullCalendarVDom.flushSync;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxtREFBbUQ7QUFDbkQsSUFBSSxPQUFPQSxxQkFBcUIsYUFBYTtJQUN6QyxNQUFNLElBQUlDLE1BQU0sc0ZBQXNGO0FBQzFHLENBQUM7QUFDRCxJQUFJQyxZQUFZRixpQkFBaUJFLFNBQVM7QUFDMUMsSUFBSUMsZ0JBQWdCSCxpQkFBaUJHLGFBQWE7QUFDbEQsSUFBSUMsU0FBU0osaUJBQWlCSSxNQUFNO0FBQ3BDLElBQUlDLFlBQVlMLGlCQUFpQkssU0FBUztBQUMxQyxJQUFJQyxXQUFXTixpQkFBaUJNLFFBQVE7QUFDeEMsSUFBSUMsZ0JBQWdCUCxpQkFBaUJPLGFBQWE7QUFDbEQsSUFBSUMsZUFBZVIsaUJBQWlCUSxZQUFZO0FBQ2hELElBQUlDLFlBQVlULGlCQUFpQlMsU0FBUztBQUMxQyxJQUFJQyx5QkFBeUJWLGlCQUFpQlUsc0JBQXNCO0FBQ3BFLGlCQUFpQixHQUVnSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcz9kMWYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiQGZ1bGxjYWxlbmRhci9jb3JlLXByZWFjdFwiIC8+XG5pZiAodHlwZW9mIEZ1bGxDYWxlbmRhclZEb20gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgaW1wb3J0IHRoZSB0b3AtbGV2ZWwgZnVsbGNhbGVuZGFyIGxpYiBiZWZvcmUgYXR0ZW1wdGluZyB0byBpbXBvcnQgYSBwbHVnaW4uJyk7XG59XG52YXIgQ29tcG9uZW50ID0gRnVsbENhbGVuZGFyVkRvbS5Db21wb25lbnQ7XG52YXIgY3JlYXRlRWxlbWVudCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlRWxlbWVudDtcbnZhciByZW5kZXIgPSBGdWxsQ2FsZW5kYXJWRG9tLnJlbmRlcjtcbnZhciBjcmVhdGVSZWYgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZVJlZjtcbnZhciBGcmFnbWVudCA9IEZ1bGxDYWxlbmRhclZEb20uRnJhZ21lbnQ7XG52YXIgY3JlYXRlQ29udGV4dCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlQ29udGV4dDtcbnZhciBjcmVhdGVQb3J0YWwgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZVBvcnRhbDtcbnZhciBmbHVzaFN5bmMgPSBGdWxsQ2FsZW5kYXJWRG9tLmZsdXNoU3luYztcbnZhciB1bm1vdW50Q29tcG9uZW50QXROb2RlID0gRnVsbENhbGVuZGFyVkRvbS51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnQgeyBDb21wb25lbnQsIEZyYWdtZW50LCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVQb3J0YWwsIGNyZWF0ZVJlZiwgZmx1c2hTeW5jLCByZW5kZXIsIHVubW91bnRDb21wb25lbnRBdE5vZGUgfTtcbiJdLCJuYW1lcyI6WyJGdWxsQ2FsZW5kYXJWRG9tIiwiRXJyb3IiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hTeW5jIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DayGridView\": function() { return /* binding */ DayTableView; },\n/* harmony export */   \"DayTable\": function() { return /* binding */ DayTable; },\n/* harmony export */   \"DayTableSlicer\": function() { return /* binding */ DayTableSlicer; },\n/* harmony export */   \"Table\": function() { return /* binding */ Table; },\n/* harmony export */   \"TableView\": function() { return /* binding */ TableView; },\n/* harmony export */   \"buildDayTableModel\": function() { return /* binding */ buildDayTableModel; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/daygrid/main.css\");\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_main_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nvar TableView = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableView, _super);\n    function TableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    TableView.prototype.renderSimpleLayout = function(headerRowContent, bodyContent) {\n        var _a = this, props = _a.props, context = _a.context;\n        var sections = [];\n        var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [],\n                sections: sections\n            }));\n        });\n    };\n    TableView.prototype.renderHScrollLayout = function(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        var _a = this, props = _a.props, context = _a.context;\n        var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n        var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar)(context.options);\n        var sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                colGroups: [\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    return TableView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction splitSegsByRow(segs, rowCnt) {\n    var byRow = [];\n    for(var i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n        var seg = segs_1[_i];\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    var byCol = [];\n    for(var i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n        var seg = segs_2[_i];\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    var byRow = [];\n    if (!ui) {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){\n            var seg = _a[_i];\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nvar TableCellTop = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellTop, _super);\n    function TableCellTop() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableCellTop.prototype.render = function() {\n        var props = this.props;\n        var navLinkAttrs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkAttrs)(this.context, props.date);\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent, {\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            defaultContent: renderTopInner\n        }, function(innerElRef, innerContent) {\n            return (innerContent || props.forceDayTop) && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                ref: innerElRef\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                id: props.dayNumberId,\n                className: \"fc-daygrid-day-number\"\n            }, navLinkAttrs), innerContent || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\")));\n        });\n    };\n    return TableCellTop;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction renderTopInner(props) {\n    return props.dayNumberText;\n}\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    var display = seg.eventRange.ui.display;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nvar TableBlockEvent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableBlockEvent, _super);\n    function TableBlockEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableBlockEvent.prototype.render = function() {\n        var props = this.props;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props, {\n            extraClassNames: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    };\n    return TableBlockEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nvar TableListItemEvent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableListItemEvent, _super);\n    function TableListItemEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableListItemEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        var timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot, {\n            seg: props.seg,\n            timeText: timeText,\n            defaultContent: renderInnerContent,\n            isDragging: props.isDragging,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                className: [\n                    \"fc-daygrid-event\",\n                    \"fc-daygrid-dot-event\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegAnchorAttrs)(props.seg, context)), innerContent);\n        });\n    };\n    return TableListItemEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction renderInnerContent(innerProps) {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: innerProps.borderColor || innerProps.backgroundColor\n        }\n    }), innerProps.timeText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-title\"\n    }, innerProps.event.title || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xa0\")));\n}\nvar TableCellMoreLink = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellMoreLink, _super);\n    function TableCellMoreLink() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.compileSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(compileSegs);\n        return _this;\n    }\n    TableCellMoreLink.prototype.render = function() {\n        var props = this.props;\n        var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot, {\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: function() {\n                var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map(function(seg) {\n                    var instanceId = seg.eventRange.instance.instanceId;\n                    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))));\n                }));\n            }\n        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid-more-link\"\n                ].concat(classNames).join(\" \"),\n                title: title,\n                \"aria-expanded\": isExpanded,\n                \"aria-controls\": popoverId\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createAriaClickAttrs)(handleClick)), innerContent);\n        });\n    };\n    return TableCellMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction compileSegs(singlePlacements) {\n    var allSegs = [];\n    var invisibleSegs = [];\n    for(var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++){\n        var placement = singlePlacements_1[_i];\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs: allSegs,\n        invisibleSegs: invisibleSegs\n    };\n}\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n    week: \"narrow\"\n});\nvar TableCell = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCell, _super);\n    function TableCell() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            dayNumberId: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getUniqueDomId)()\n        };\n        _this.handleRootEl = function(el) {\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.rootElRef, el);\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    TableCell.prototype.render = function() {\n        var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;\n        var date = props.date, dateProfile = props.dateProfile;\n        var navLinkAttrs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkAttrs)(context, date, \"week\");\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot, {\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            elRef: this.handleRootEl\n        }, function(dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                ref: dayElRef,\n                role: \"gridcell\",\n                className: [\n                    \"fc-daygrid-day\"\n                ].concat(dayClassNames, props.extraClassNames || []).join(\" \")\n            }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                ref: props.innerElRef /* different from hook system! RENAME */ \n            }, props.showWeekNumber && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot, {\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }, function(weekElRef, weekClassNames, innerElRef, innerContent) {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    ref: weekElRef,\n                    className: [\n                        \"fc-daygrid-week-number\"\n                    ].concat(weekClassNames).join(\" \")\n                }, navLinkAttrs), innerContent);\n            }), !isDisabled && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellTop, {\n                date: date,\n                dateProfile: dateProfile,\n                showDayNumber: props.showDayNumber,\n                dayNumberId: state.dayNumberId,\n                forceDayTop: props.forceDayTop,\n                todayRange: props.todayRange,\n                extraHookProps: props.extraHookProps\n            }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n        });\n    };\n    return TableCell;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n    var hierarchy = new DayGridSegHierarchy();\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    var segInputs = [];\n    var unknownHeightSegs = [];\n    for(var i = 0; i < segs.length; i += 1){\n        var seg = segs[i];\n        var instanceId = seg.eventRange.instance.instanceId;\n        var eventHeight = eventInstanceHeights[instanceId];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                thickness: eventHeight,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    var hiddenEntries = hierarchy.addSegs(segInputs);\n    var segRects = hierarchy.toRects();\n    var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;\n    var moreCnts = [];\n    var moreMarginTops = [];\n    // add segs with unknown heights\n    for(var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++){\n        var seg = unknownHeightSegs_1[_i];\n        multiColPlacements[seg.firstCol].push({\n            seg: seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(var col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for(var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++){\n        var hiddenEntry = hiddenEntries_1[_b];\n        var seg = segs[hiddenEntry.index];\n        var hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(var col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        moreCnts: moreCnts,\n        moreMarginTops: moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    var singleColPlacements = [];\n    var multiColPlacements = [];\n    var leftoverMargins = [];\n    for(var col = 0; col < cells.length; col += 1){\n        var rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        var singlePlacements = [];\n        var currentHeight = 0;\n        var currentMarginTop = 0;\n        for(var _i = 0, rects_1 = rects; _i < rects_1.length; _i++){\n            var rect = rects_1[_i];\n            var seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        var multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for(var _a = 0, rects_2 = rects; _a < rects_2.length; _a++){\n            var rect = rects_2[_a];\n            var seg = segs[rect.index];\n            var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            var isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        leftoverMargins: leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    var rectsByEachCol = [];\n    for(var col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for(var _i = 0, rects_3 = rects; _i < rects_3.length; _i++){\n        var rect = rects_3[_i];\n        for(var col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    var eventRange = seg.eventRange;\n    var origRange = eventRange.range;\n    var slicedRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(origRange, {\n        start: cells[spanStart].date,\n        end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(cells[spanEnd - 1].date, 1)\n    });\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nvar DayGridSegHierarchy = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayGridSegHierarchy, _super);\n    function DayGridSegHierarchy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // config\n        _this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        _this.forceHidden = {};\n        return _this;\n    }\n    DayGridSegHierarchy.prototype.addSegs = function(segInputs) {\n        var _this = this;\n        var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n        var entriesByLevel = this.entriesByLevel;\n        var excludeHidden = function(entry) {\n            return !_this.forceHidden[(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(entry)];\n        };\n        // remove the forced-hidden segs\n        for(var level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    };\n    DayGridSegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;\n        var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;\n        if (this.hiddenConsumes && touchingEntry) {\n            var touchingEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(touchingEntry);\n            // if not already hidden\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    var placeholderEntry = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, touchingEntry), {\n                        span: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectSpans)(touchingEntry.span, entry.span)\n                    });\n                    var placeholderEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(placeholderEntry);\n                    forceHidden[placeholderEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                    this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n    };\n    return DayGridSegHierarchy;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy);\nvar TableRow = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableRow, _super);\n    function TableRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the <td>\n        _this.frameElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-frame\n        _this.fgElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-events\n        _this.segHarnessRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // indexed by \"instanceId:firstCol\"\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            eventInstanceHeights: {}\n        };\n        return _this;\n    }\n    TableRow.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var options = context.options;\n        var colCnt = props.cells.length;\n        var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        var _b = computeFgSegPlacement((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;\n        var isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map(function(cell, col) {\n            var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n                key: cell.key,\n                elRef: _this.cellElRefs.createRef(cell.key),\n                innerElRef: _this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraHookProps: cell.extraHookProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: _this.fgElRefs.createRef(cell.key),\n                fgContent: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n                bgContent: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), _this.renderFillSegs(businessHoursByCol[col], \"non-business\"), _this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\"))\n            });\n        }));\n    };\n    TableRow.prototype.componentDidMount = function() {\n        this.updateSizing(true);\n    };\n    TableRow.prototype.componentDidUpdate = function(prevProps, prevState) {\n        var currentProps = this.props;\n        this.updateSizing(!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual)(prevProps, currentProps));\n    };\n    TableRow.prototype.getHighlightSegs = function() {\n        var props = this.props;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    };\n    TableRow.prototype.getMirrorSegs = function() {\n        var props = this.props;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    };\n    TableRow.prototype.renderFgSegs = function(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        var context = this.context;\n        var eventSelection = this.props.eventSelection;\n        var framePositions = this.state.framePositions;\n        var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++){\n                var placement = segPlacements_1[_i];\n                var seg = placement.seg;\n                var instanceId = seg.eventRange.instance.instanceId;\n                var key = instanceId + \":\" + col;\n                var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                var isAbsolute = placement.isAbsolute;\n                var left = \"\";\n                var right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: key,\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left: left,\n                        right: right\n                    }\n                }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    };\n    TableRow.prototype.renderFillSegs = function(segs, fillType) {\n        var isRtl = this.context.isRtl;\n        var todayRange = this.props.todayRange;\n        var framePositions = this.state.framePositions;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n                var seg = segs_1[_i];\n                var leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey)(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    seg: seg\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill)(fillType)));\n            }\n        }\n        return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([\n            _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment,\n            {}\n        ], nodes));\n    };\n    TableRow.prototype.updateSizing = function(isExternalSizingChange) {\n        var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                var frameEls = props.cells.map(function(cell) {\n                    return frameElRefs.currentMap[cell.key];\n                });\n                if (frameEls.length) {\n                    var originEl = this.rootElRef.current;\n                    this.setState({\n                        framePositions: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(originEl, frameEls, true, false)\n                    });\n                }\n            }\n            var oldInstanceHeights = this.state.eventInstanceHeights;\n            var newInstanceHeights = this.queryEventInstanceHeights();\n            var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                eventInstanceHeights: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, oldInstanceHeights), newInstanceHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    };\n    TableRow.prototype.queryEventInstanceHeights = function() {\n        var segElMap = this.segHarnessRefs.currentMap;\n        var eventInstanceHeights = {};\n        // get the max height amongst instance segs\n        for(var key in segElMap){\n            var height = Math.round(segElMap[key].getBoundingClientRect().height);\n            var instanceId = key.split(\":\")[0]; // deconstruct how renderFgSegs makes the key\n            eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n        }\n        return eventInstanceHeights;\n    };\n    TableRow.prototype.computeMaxContentHeight = function() {\n        var firstKey = this.props.cells[0].key;\n        var cellEl = this.cellElRefs.currentMap[firstKey];\n        var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    };\n    TableRow.prototype.getCellEls = function() {\n        var elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map(function(cell) {\n            return elMap[cell.key];\n        });\n    };\n    return TableRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nTableRow.addStateEquality({\n    eventInstanceHeights: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map(function(seg) {\n        return {\n            seg: seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        };\n    });\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    var topsByInstanceId = {};\n    for(var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++){\n        var placements = colPlacements_1[_i];\n        for(var _a = 0, placements_1 = placements; _a < placements_1.length; _a++){\n            var placement = placements_1[_a];\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nvar Table = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Table, _super);\n    function Table() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n        _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n        _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n        _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n        _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n        _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n        _this.rowRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap();\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    isHitComboAllowed: _this.props.isHitComboAllowed\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    Table.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;\n        var rowCnt = props.cells.length;\n        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        var classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: classNames.join(\" \"),\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n                role: \"presentation\",\n                className: \"fc-scrollgrid-sync-table\",\n                style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : \"\"\n                }\n            }, props.colGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n                role: \"presentation\"\n            }, props.cells.map(function(cells, row) {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n                    ref: _this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: dayMaxEvents,\n                    dayMaxEventRows: dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    forPrint: props.forPrint\n                });\n            }))));\n        }));\n    };\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    Table.prototype.prepareHits = function() {\n        this.rowPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.collect().map(function(rowObj) {\n            return rowObj.getCellEls()[0];\n        }), false, true);\n        this.colPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    };\n    Table.prototype.queryHit = function(positionLeft, positionTop) {\n        var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;\n        var col = colPositions.leftToIndex(positionLeft);\n        var row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            var cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    };\n    Table.prototype.getCellEl = function(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    };\n    Table.prototype.getCellRange = function(row, col) {\n        var start = this.props.cells[row][col].date;\n        var end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(start, 1);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return Table;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nvar DayTableSlicer = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableSlicer, _super);\n    function DayTableSlicer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.forceDayIfListItem = true;\n        return _this;\n    }\n    DayTableSlicer.prototype.sliceRange = function(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    };\n    return DayTableSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer);\nvar DayTable = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTable, _super);\n    function DayTable() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.slicer = new DayTableSlicer();\n        _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    DayTable.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    };\n    return DayTable;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nvar DayTableView = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableView, _super);\n    function DayTableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildDayTableModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildDayTableModel);\n        _this.headerRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    DayTableView.prototype.render = function() {\n        var _this = this;\n        var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;\n        var props = this.props;\n        var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        var bodyContent = function(contentArg) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n                ref: _this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: _this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        };\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    };\n    return DayTableView;\n}(TableView);\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nvar TableDateProfileGenerator = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateProfileGenerator, _super);\n    function TableDateProfileGenerator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // Computes the date range that will be rendered.\n    TableDateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        var dateEnv = this.props.dateEnv;\n        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n        var start = renderRange.start;\n        var end = renderRange.end;\n        var endOfWeek;\n        // year and month views should be aligned with weeks. this is already done for week\n        if (/^(year|month)$/.test(currentRangeUnit)) {\n            start = dateEnv.startOfWeek(start);\n            // make end-of-week if not already\n            endOfWeek = dateEnv.startOfWeek(end);\n            if (endOfWeek.valueOf() !== end.valueOf()) {\n                end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(endOfWeek, 1);\n            }\n        }\n        // ensure 6 weeks\n        if (this.props.monthMode && this.props.fixedWeekCount) {\n            var rowCnt = Math.ceil((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWeeks)(start, end));\n            end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(end, 6 - rowCnt);\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return TableDateProfileGenerator;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateProfileGenerator);\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: DayTableView,\n            dateProfileGeneratorClass: TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            monthMode: true,\n            fixedWeekCount: true\n        }\n    }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n //# sourceMappingURL=main.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBSUEsR0FDb0I7QUFFNHFCO0FBQ3JvQjtBQUUzRDtzSEFDc0gsR0FDdEgsa0ZBQWtGO0FBQ2xGLCtDQUErQztBQUMvQyxJQUFJaUQsWUFBWSxXQUFXLEdBQUksU0FBVUMsTUFBTSxFQUFFO0lBQzdDSixnREFBU0EsQ0FBQ0csV0FBV0M7SUFDckIsU0FBU0QsWUFBWTtRQUNqQixJQUFJRSxRQUFRRCxXQUFXLElBQUksSUFBSUEsT0FBT0UsS0FBSyxDQUFDLElBQUksRUFBRUMsY0FBYyxJQUFJO1FBQ3BFRixNQUFNRyxXQUFXLEdBQUd0RCwrREFBU0E7UUFDN0IsT0FBT21EO0lBQ1g7SUFDQUYsVUFBVU0sU0FBUyxDQUFDQyxrQkFBa0IsR0FBRyxTQUFVQyxnQkFBZ0IsRUFBRUMsV0FBVyxFQUFFO1FBQzlFLElBQUlDLEtBQUssSUFBSSxFQUFFQyxRQUFRRCxHQUFHQyxLQUFLLEVBQUVDLFVBQVVGLEdBQUdFLE9BQU87UUFDckQsSUFBSUMsV0FBVyxFQUFFO1FBQ2pCLElBQUlDLG9CQUFvQjlELDBFQUFvQkEsQ0FBQzRELFFBQVFHLE9BQU87UUFDNUQsSUFBSVAsa0JBQWtCO1lBQ2xCSyxTQUFTRyxJQUFJLENBQUM7Z0JBQ1ZDLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0xDLFVBQVVMO2dCQUNWTSxPQUFPO29CQUNIQyxPQUFPLElBQUksQ0FBQ2hCLFdBQVc7b0JBQ3ZCaUIsZ0JBQWdCO29CQUNoQkMsWUFBWWY7Z0JBQ2hCO1lBQ0o7UUFDSixDQUFDO1FBQ0RLLFNBQVNHLElBQUksQ0FBQztZQUNWQyxNQUFNO1lBQ05DLEtBQUs7WUFDTE0sUUFBUSxJQUFJO1lBQ1pKLE9BQU87Z0JBQUVLLFNBQVNoQjtZQUFZO1FBQ2xDO1FBQ0EsT0FBUXhELG1FQUFhQSxDQUFDQywwREFBUUEsRUFBRTtZQUFFd0UsVUFBVWQsUUFBUWMs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K0RBQWVFLElBQUlBLEVBQUM7QUFDbUYsQ0FDdkcsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5qcz8yYTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjExLjNcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIyIEFkYW0gU2hhd1xuKi9cbmltcG9ydCAnLi9tYWluLmNzcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVJlZiwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIGNyZWF0ZUVsZW1lbnQsIFZpZXdSb290LCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIHJlbmRlclNjcm9sbFNoaW0sIERhdGVDb21wb25lbnQsIGJ1aWxkTmF2TGlua0F0dHJzLCBEYXlDZWxsQ29udGVudCwgRnJhZ21lbnQsIEJhc2VDb21wb25lbnQsIGNyZWF0ZUZvcm1hdHRlciwgU3RhbmRhcmRFdmVudCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRSb290LCBnZXRTZWdBbmNob3JBdHRycywgbWVtb2l6ZSwgTW9yZUxpbmtSb290LCBnZXRTZWdNZXRhLCBjcmVhdGVBcmlhQ2xpY2tBdHRycywgZ2V0VW5pcXVlRG9tSWQsIHNldFJlZiwgRGF5Q2VsbFJvb3QsIFdlZWtOdW1iZXJSb290LCBidWlsZEVudHJ5S2V5LCBpbnRlcnNlY3RTcGFucywgU2VnSGllcmFyY2h5LCBpbnRlcnNlY3RSYW5nZXMsIGFkZERheXMsIFJlZk1hcCwgc29ydEV2ZW50U2VncywgaXNQcm9wc0VxdWFsLCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIFBvc2l0aW9uQ2FjaGUsIE5vd1RpbWVyLCBTbGljZXIsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIGFkZFdlZWtzLCBkaWZmV2Vla3MsIERhdGVQcm9maWxlR2VuZXJhdG9yLCBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbic7XG5pbXBvcnQgeyBfX2V4dGVuZHMsIF9fYXNzaWduLCBfX3NwcmVhZEFycmF5IH0gZnJvbSAndHNsaWInO1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cbnZhciBUYWJsZVZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlVmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZVZpZXcoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyU2ltcGxlTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICBUYWJsZVZpZXcucHJvdG90eXBlLnJlbmRlckhTY3JvbGxMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgpIHtcbiAgICAgICAgdmFyIFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogYm9keUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbEdyb3VwczogW3sgY29sczogW3sgc3BhbjogY29sQ250LCBtaW5XaWR0aDogZGF5TWluV2lkdGggfV0gfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVWaWV3O1xufShEYXRlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Um93KHNlZ3MsIHJvd0NudCkge1xuICAgIHZhciBieVJvdyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgYnlSb3dbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XG4gICAgICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuZnVuY3Rpb24gc3BsaXRTZWdzQnlGaXJzdENvbChzZWdzLCBjb2xDbnQpIHtcbiAgICB2YXIgYnlDb2wgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Q29sW2ldID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18yID0gc2VnczsgX2kgPCBzZWdzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdzXzJbX2ldO1xuICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcbiAgICB2YXIgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB1aS5zZWdzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNlZyA9IF9hW19pXTtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxudmFyIFRhYmxlQ2VsbFRvcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsVG9wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGxUb3AucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIG5hdkxpbmtBdHRycyA9IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcHJvcHMuZGF0ZSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlDZWxsQ29udGVudCwgeyBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcywgZGVmYXVsdENvbnRlbnQ6IHJlbmRlclRvcElubmVyIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICgoaW5uZXJDb250ZW50IHx8IHByb3BzLmZvcmNlRGF5VG9wKSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgcmVmOiBpbm5lckVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IGlkOiBwcm9wcy5kYXlOdW1iZXJJZCwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsVG9wO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0O1xufVxuXG52YXIgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pO1xuZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xuICAgIHZhciBkaXNwbGF5ID0gc2VnLmV2ZW50UmFuZ2UudWkuZGlzcGxheTtcbiAgICByZXR1cm4gZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScgfHwgKGRpc3BsYXkgPT09ICdhdXRvJyAmJlxuICAgICAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgICAgICBzZWcuZmlyc3RDb2wgPT09IHNlZy5sYXN0Q29sICYmIC8vIGNhbid0IGJlIG11bHRpLWRheVxuICAgICAgICBzZWcuaXNTdGFydCAmJiAvLyBcIlxuICAgICAgICBzZWcuaXNFbmQgLy8gXCJcbiAgICApO1xufVxuXG52YXIgVGFibGVCbG9ja0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUJsb2NrRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVCbG9ja0V2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlQmxvY2tFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoU3RhbmRhcmRFdmVudCwgX19hc3NpZ24oe30sIHByb3BzLCB7IGV4dHJhQ2xhc3NOYW1lczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlQmxvY2tFdmVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgVGFibGVMaXN0SXRlbUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZUxpc3RJdGVtRXZlbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVMaXN0SXRlbUV2ZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlTGlzdEl0ZW1FdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XG4gICAgICAgIHZhciB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQocHJvcHMuc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Um9vdCwgeyBzZWc6IHByb3BzLnNlZywgdGltZVRleHQ6IHRpbWVUZXh0LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXJDb250ZW50LCBpc0RyYWdnaW5nOiBwcm9wcy5pc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogcHJvcHMuaXNTZWxlY3RlZCwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICggLy8gd2UgZG9uJ3QgdXNlIHN0eWxlcyFcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHJlZjogcm9vdEVsUmVmIH0sIGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCkpLCBpbm5lckNvbnRlbnQpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlTGlzdEl0ZW1FdmVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIiwgc3R5bGU6IHsgYm9yZGVyQ29sb3I6IGlubmVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgaW5uZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfSB9KSxcbiAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgaW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbnZhciBUYWJsZUNlbGxNb3JlTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVDZWxsTW9yZUxpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsTW9yZUxpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbE1vcmVMaW5rLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29tcGlsZVNlZ3MocHJvcHMuc2luZ2xlUGxhY2VtZW50cyksIGFsbFNlZ3MgPSBfYS5hbGxTZWdzLCBpbnZpc2libGVTZWdzID0gX2EuaW52aXNpYmxlU2VncztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rUm9vdCwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBhbGxTZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSkpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2ssIHRpdGxlLCBpc0V4cGFuZGVkLCBwb3BvdmVySWQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1tb3JlLWxpbmsnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCB0aXRsZTogdGl0bGUsIFwiYXJpYS1leHBhbmRlZFwiOiBpc0V4cGFuZGVkLCBcImFyaWEtY29udHJvbHNcIjogcG9wb3ZlcklkIH0sIGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUNsaWNrKSksIGlubmVyQ29udGVudCkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsTW9yZUxpbms7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICB2YXIgYWxsU2VncyA9IFtdO1xuICAgIHZhciBpbnZpc2libGVTZWdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzaW5nbGVQbGFjZW1lbnRzXzEgPSBzaW5nbGVQbGFjZW1lbnRzOyBfaSA8IHNpbmdsZVBsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNpbmdsZVBsYWNlbWVudHNfMVtfaV07XG4gICAgICAgIGFsbFNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcbiAgICAgICAgaWYgKCFwbGFjZW1lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBpbnZpc2libGVTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYWxsU2VnczogYWxsU2VncywgaW52aXNpYmxlU2VnczogaW52aXNpYmxlU2VncyB9O1xufVxuXG52YXIgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KTtcbnZhciBUYWJsZUNlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUNlbGwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucm9vdEVsUmVmLCBlbCk7XG4gICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIHJvb3RFbFJlZiA9IF9hLnJvb3RFbFJlZjtcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgbmF2TGlua0F0dHJzID0gYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxSb290LCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKGRheUVsUmVmLCBkYXlDbGFzc05hbWVzLCByb290RGF0YUF0dHJzLCBpc0Rpc2FibGVkKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIF9fYXNzaWduKHsgcmVmOiBkYXlFbFJlZiwgcm9sZTogXCJncmlkY2VsbFwiLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1kYXknXS5jb25jYXQoZGF5Q2xhc3NOYW1lcywgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKS5qb2luKCcgJykgfSwgcm9vdERhdGFBdHRycywgcHJvcHMuZXh0cmFEYXRhQXR0cnMsIChwcm9wcy5zaG93RGF5TnVtYmVyID8geyAnYXJpYS1sYWJlbGxlZGJ5Jzogc3RhdGUuZGF5TnVtYmVySWQgfSA6IHt9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCByZWY6IHByb3BzLmlubmVyRWxSZWYgLyogZGlmZmVyZW50IGZyb20gaG9vayBzeXN0ZW0hIFJFTkFNRSAqLyB9LFxuICAgICAgICAgICAgICAgIHByb3BzLnNob3dXZWVrTnVtYmVyICYmIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJSb290LCB7IGRhdGU6IGRhdGUsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uICh3ZWVrRWxSZWYsIHdlZWtDbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCBfX2Fzc2lnbih7IHJlZjogd2Vla0VsUmVmLCBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC13ZWVrLW51bWJlciddLmNvbmNhdCh3ZWVrQ2xhc3NOYW1lcykuam9pbignICcpIH0sIG5hdkxpbmtBdHRycyksIGlubmVyQ29udGVudCkpOyB9KSksXG4gICAgICAgICAgICAgICAgIWlzRGlzYWJsZWQgJiYgKGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsVG9wLCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZGF5TnVtYmVySWQ6IHN0YXRlLmRheU51bWJlcklkLCBmb3JjZURheVRvcDogcHJvcHMuZm9yY2VEYXlUb3AsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9KSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5mZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1iZ1wiIH0sIHByb3BzLmJnQ29udGVudCkpKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUNlbGw7XG59KERhdGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNlZ3MsIC8vIGFzc3VtZWQgYWxyZWFkeSBzb3J0ZWRcbmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzLCBzdHJpY3RPcmRlciwgZXZlbnRJbnN0YW5jZUhlaWdodHMsIG1heENvbnRlbnRIZWlnaHQsIGNlbGxzKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IG5ldyBEYXlHcmlkU2VnSGllcmFyY2h5KCk7XG4gICAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZTtcbiAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkge1xuICAgICAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0O1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50Um93cztcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICAgIHZhciBzZWdJbnB1dHMgPSBbXTtcbiAgICB2YXIgdW5rbm93bkhlaWdodFNlZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgdmFyIGV2ZW50SGVpZ2h0ID0gZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF07XG4gICAgICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBldmVudEhlaWdodCxcbiAgICAgICAgICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWcuZmlyc3RDb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnLmxhc3RDb2wgKyAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgdmFyIHNlZ1JlY3RzID0gaGllcmFyY2h5LnRvUmVjdHMoKTtcbiAgICB2YXIgX2EgPSBwbGFjZVJlY3RzKHNlZ1JlY3RzLCBzZWdzLCBjZWxscyksIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBfYS5zaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMgPSBfYS5tdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2lucyA9IF9hLmxlZnRvdmVyTWFyZ2lucztcbiAgICB2YXIgbW9yZUNudHMgPSBbXTtcbiAgICB2YXIgbW9yZU1hcmdpblRvcHMgPSBbXTtcbiAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xuICAgIGZvciAodmFyIF9pID0gMCwgdW5rbm93bkhlaWdodFNlZ3NfMSA9IHVua25vd25IZWlnaHRTZWdzOyBfaSA8IHVua25vd25IZWlnaHRTZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWcgPSB1bmtub3duSGVpZ2h0U2Vnc18xW19pXTtcbiAgICAgICAgbXVsdGlDb2xQbGFjZW1lbnRzW3NlZy5maXJzdENvbF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgaGlkZGVuRW50cmllc18xID0gaGlkZGVuRW50cmllczsgX2IgPCBoaWRkZW5FbnRyaWVzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBoaWRkZW5FbnRyeSA9IGhpZGRlbkVudHJpZXNfMVtfYl07XG4gICAgICAgIHZhciBzZWcgPSBzZWdzW2hpZGRlbkVudHJ5LmluZGV4XTtcbiAgICAgICAgdmFyIGhpZGRlblNwYW4gPSBoaWRkZW5FbnRyeS5zcGFuO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbaGlkZGVuU3Bhbi5zdGFydF0ucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBoaWRkZW5TcGFuLnN0YXJ0LCBoaWRkZW5TcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGhpZGRlblNwYW4uc3RhcnQ7IGNvbCA8IGhpZGRlblNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgbW9yZUNudHNbY29sXSArPSAxO1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVhbCB3aXRoIGxlZnRvdmVyIG1hcmdpbnNcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVNYXJnaW5Ub3BzLnB1c2gobGVmdG92ZXJNYXJnaW5zW2NvbF0pO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHM6IG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHM6IG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wczogbW9yZU1hcmdpblRvcHMgfTtcbn1cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHMsIHNlZ3MsIGNlbGxzKSB7XG4gICAgdmFyIHJlY3RzQnlFYWNoQ29sID0gZ3JvdXBSZWN0c0J5RWFjaENvbChhbGxSZWN0cywgY2VsbHMubGVuZ3RoKTtcbiAgICB2YXIgc2luZ2xlQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBtdWx0aUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbGVmdG92ZXJNYXJnaW5zID0gW107XG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgICAgICB2YXIgcmVjdHMgPSByZWN0c0J5RWFjaENvbFtjb2xdO1xuICAgICAgICAvLyBjb21wdXRlIGFsbCBzdGF0aWMgc2VncyBpbiBzaW5nbGVQbGFjZW1lbnRzXG4gICAgICAgIHZhciBzaW5nbGVQbGFjZW1lbnRzID0gW107XG4gICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlY3RzXzEgPSByZWN0czsgX2kgPCByZWN0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSByZWN0c18xW19pXTtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgc2luZ2xlUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIG1peGVkIHN0YXRpYy9hYnNvbHV0ZSBzZWdzIGluIG11bHRpUGxhY2VtZW50c1xuICAgICAgICB2YXIgbXVsdGlQbGFjZW1lbnRzID0gW107XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCByZWN0c18yID0gcmVjdHM7IF9hIDwgcmVjdHNfMi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVjdHNfMltfYV07XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIHZhciBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cbiAgICAgICAgICAgIHZhciBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XG4gICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xuICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzOiBtdWx0aUNvbFBsYWNlbWVudHMsIGxlZnRvdmVyTWFyZ2luczogbGVmdG92ZXJNYXJnaW5zIH07XG59XG5mdW5jdGlvbiBncm91cFJlY3RzQnlFYWNoQ29sKHJlY3RzLCBjb2xDbnQpIHtcbiAgICB2YXIgcmVjdHNCeUVhY2hDb2wgPSBbXTtcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICAgIHJlY3RzQnlFYWNoQ29sLnB1c2goW10pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlY3RzXzMgPSByZWN0czsgX2kgPCByZWN0c18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmVjdCA9IHJlY3RzXzNbX2ldO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSByZWN0LnNwYW4uc3RhcnQ7IGNvbCA8IHJlY3Quc3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICByZWN0c0J5RWFjaENvbFtjb2xdLnB1c2gocmVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sO1xufVxuZnVuY3Rpb24gcmVzbGljZVNlZyhzZWcsIHNwYW5TdGFydCwgc3BhbkVuZCwgY2VsbHMpIHtcbiAgICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgICAgIHJldHVybiBzZWc7XG4gICAgfVxuICAgIHZhciBldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgdmFyIG9yaWdSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgdmFyIHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICAgIH0pO1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VnKSwgeyBmaXJzdENvbDogc3BhblN0YXJ0LCBsYXN0Q29sOiBzcGFuRW5kIC0gMSwgZXZlbnRSYW5nZToge1xuICAgICAgICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgICAgICAgIHVpOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxudmFyIERheUdyaWRTZWdIaWVyYXJjaHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheUdyaWRTZWdIaWVyYXJjaHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5R3JpZFNlZ0hpZXJhcmNoeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICBfdGhpcy5oaWRkZW5Db25zdW1lcyA9IGZhbHNlO1xuICAgICAgICAvLyBhbGxvd3MgdXMgdG8ga2VlcCBoaWRkZW4gZW50cmllcyBpbiB0aGUgaGllcmFyY2h5IHNvIHRoZXkgdGFrZSB1cCBzcGFjZVxuICAgICAgICBfdGhpcy5mb3JjZUhpZGRlbiA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUdyaWRTZWdIaWVyYXJjaHkucHJvdG90eXBlLmFkZFNlZ3MgPSBmdW5jdGlvbiAoc2VnSW5wdXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoaWRkZW5TZWdzID0gX3N1cGVyLnByb3RvdHlwZS5hZGRTZWdzLmNhbGwodGhpcywgc2VnSW5wdXRzKTtcbiAgICAgICAgdmFyIGVudHJpZXNCeUxldmVsID0gdGhpcy5lbnRyaWVzQnlMZXZlbDtcbiAgICAgICAgdmFyIGV4Y2x1ZGVIaWRkZW4gPSBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICFfdGhpcy5mb3JjZUhpZGRlbltidWlsZEVudHJ5S2V5KGVudHJ5KV07IH07XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZm9yY2VkLWhpZGRlbiBzZWdzXG4gICAgICAgIGZvciAodmFyIGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlblNlZ3M7XG4gICAgfTtcbiAgICBEYXlHcmlkU2VnSGllcmFyY2h5LnByb3RvdHlwZS5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uID0gZnVuY3Rpb24gKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZW50cmllc0J5TGV2ZWwgPSBfYS5lbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gPSBfYS5mb3JjZUhpZGRlbjtcbiAgICAgICAgdmFyIHRvdWNoaW5nRW50cnkgPSBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCA9IGluc2VydGlvbi50b3VjaGluZ0xldmVsLCB0b3VjaGluZ0xhdGVyYWwgPSBpbnNlcnRpb24udG91Y2hpbmdMYXRlcmFsO1xuICAgICAgICBpZiAodGhpcy5oaWRkZW5Db25zdW1lcyAmJiB0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hpbmdFbnRyeUlkID0gYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBhbHJlYWR5IGhpZGRlblxuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnkgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnModG91Y2hpbmdFbnRyeS5zcGFuLCBlbnRyeS5zcGFuKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkocGxhY2Vob2xkZXJFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3BsYWNlaG9sZGVyRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gcGxhY2Vob2xkZXJFbnRyeTsgLy8gcmVwbGFjZSB0b3VjaGluZ0VudHJ5IHdpdGggb3VyIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7IC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW52YWxpZEluc2VydGlvbi5jYWxsKHRoaXMsIGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUdyaWRTZWdIaWVyYXJjaHk7XG59KFNlZ0hpZXJhcmNoeSkpO1xuXG52YXIgVGFibGVSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUm93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cbiAgICAgICAgX3RoaXMuZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICAgICAgICBfdGhpcy5mZ0VsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICAgICAgICBfdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbnVsbCxcbiAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IG51bGwsXG4gICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICB2YXIgYnVzaW5lc3NIb3Vyc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBoaWdobGlnaHRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0SGlnaGxpZ2h0U2VncygpLCBjb2xDbnQpO1xuICAgICAgICB2YXIgbWlycm9yU2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldE1pcnJvclNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgdmFyIF9iID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyksIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBfYi5zaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMgPSBfYi5tdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzID0gX2IubW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzID0gX2IubW9yZU1hcmdpblRvcHM7XG4gICAgICAgIHZhciBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxuICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcbiAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1pcnJvckZnTm9kZXMgPSBfdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksIHByb3BzLnRvZGF5UmFuZ2UsIHt9LCBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksIEJvb2xlYW4ocHJvcHMuZXZlbnRSZXNpemUpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogX3RoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiBfdGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqLywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXJzLCBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMCwgZm9yY2VEYXlUb3A6IHByb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGV4dHJhSG9va1Byb3BzOiBjZWxsLmV4dHJhSG9va1Byb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiBfdGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBmZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG1pcnJvckZnTm9kZXMpKSksIGJnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2VncyhidXNpbmVzc0hvdXJzQnlDb2xbY29sXSwgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpIH0pKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIGN1cnJlbnRQcm9wcykpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldEhpZ2hsaWdodFNlZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0TWlycm9yU2VncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdmFyIGV2ZW50U2VsZWN0aW9uID0gdGhpcy5wcm9wcy5ldmVudFNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMTsgLy8gY29sQ250ID09PSAxXG4gICAgICAgIHZhciBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2VnUGxhY2VtZW50c18xID0gc2VnUGxhY2VtZW50czsgX2kgPCBzZWdQbGFjZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHNlZ1BsYWNlbWVudHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHBsYWNlbWVudC5zZWc7XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBpbnN0YW5jZUlkICsgJzonICsgY29sO1xuICAgICAgICAgICAgICAgIHZhciBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xuICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleToga2V5LCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBfX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkgOiAoY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyRmlsbFNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgdmFyIGlzUnRsID0gdGhpcy5jb250ZXh0LmlzUnRsO1xuICAgICAgICB2YXIgdG9kYXlSYW5nZSA9IHRoaXMucHJvcHMudG9kYXlSYW5nZTtcbiAgICAgICAgdmFyIGZyYW1lUG9zaXRpb25zID0gdGhpcy5zdGF0ZS5mcmFtZVBvc2l0aW9ucztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzEgPSBzZWdzOyBfaSA8IHNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSA6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtGcmFnbWVudCwge31dLCBub2RlcykpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGZyYW1lRWxSZWZzID0gX2EuZnJhbWVFbFJlZnM7XG4gICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7IHJldHVybiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkSW5zdGFuY2VIZWlnaHRzID0gdGhpcy5zdGF0ZS5ldmVudEluc3RhbmNlSGVpZ2h0cztcbiAgICAgICAgICAgIHZhciBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcbiAgICAgICAgICAgIHZhciBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gSEFDSyB0byBwcmV2ZW50IG9zY2lsbGF0aW9ucyBvZiBldmVudHMgYmVpbmcgc2hvd24vaGlkZGVuIGZyb20gbWF4LWV2ZW50LXJvd3NcbiAgICAgICAgICAgICAgICAvLyBFc3NlbnRpYWxseSwgb25jZSB5b3UgY29tcHV0ZSBhbiBlbGVtZW50J3MgaGVpZ2h0LCBuZXZlciBudWxsLW91dC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhbHdheXMgZGlzcGxheSBhbGwgZXZlbnRzLCBhcyB2aXNpYmlsaXR5OmhpZGRlbj9cbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0czogX19hc3NpZ24oX19hc3NpZ24oe30sIG9sZEluc3RhbmNlSGVpZ2h0cyksIG5ld0luc3RhbmNlSGVpZ2h0cyksXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5xdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIHZhciBldmVudEluc3RhbmNlSGVpZ2h0cyA9IHt9O1xuICAgICAgICAvLyBnZXQgdGhlIG1heCBoZWlnaHQgYW1vbmdzdCBpbnN0YW5jZSBzZWdzXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWdFbE1hcCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoc2VnRWxNYXBba2V5XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBrZXkuc3BsaXQoJzonKVswXTsgLy8gZGVjb25zdHJ1Y3QgaG93IHJlbmRlckZnU2VncyBtYWtlcyB0aGUga2V5XG4gICAgICAgICAgICBldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSA9IE1hdGgubWF4KGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdIHx8IDAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VIZWlnaHRzO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlyc3RLZXkgPSB0aGlzLnByb3BzLmNlbGxzWzBdLmtleTtcbiAgICAgICAgdmFyIGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgdmFyIGZjQ29udGFpbmVyRWwgPSB0aGlzLmZnRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIGZjQ29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldENlbGxFbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGVsTWFwW2NlbGwua2V5XTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVSb3c7XG59KERhdGVDb21wb25lbnQpKTtcblRhYmxlUm93LmFkZFN0YXRlRXF1YWxpdHkoe1xuICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiBpc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzLCBjb2xQbGFjZW1lbnRzKSB7XG4gICAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cyk7IC8vIFRPRE86IGNhY2hlIHRoaXMgYXQgZmlyc3QgcmVuZGVyP1xuICAgIHJldHVybiBtaXJyb3JTZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7IHJldHVybiAoe1xuICAgICAgICBzZWc6IHNlZyxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcbiAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pOyB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcbiAgICB2YXIgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sUGxhY2VtZW50c18xID0gY29sUGxhY2VtZW50czsgX2kgPCBjb2xQbGFjZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0gY29sUGxhY2VtZW50c18xW19pXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwbGFjZW1lbnRzXzEgPSBwbGFjZW1lbnRzOyBfYSA8IHBsYWNlbWVudHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzXzFbX2FdO1xuICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XG59XG5cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICBfdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIF90aGlzLnJvd1JlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChyb290RWwpIHtcbiAgICAgICAgICAgIF90aGlzLnJvb3RFbCA9IHJvb3RFbDtcbiAgICAgICAgICAgIGlmIChyb290RWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IF90aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlLCBkYXlNYXhFdmVudFJvd3MgPSBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cyA9IHByb3BzLmRheU1heEV2ZW50cywgZXhwYW5kUm93cyA9IHByb3BzLmV4cGFuZFJvd3M7XG4gICAgICAgIHZhciByb3dDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGZnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0RmdFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93ID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KTtcbiAgICAgICAgdmFyIGV2ZW50UmVzaXplQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIHJvd0NudCk7XG4gICAgICAgIHZhciBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcbiAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxuICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXG4gICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIGZ1bmN0aW9uIChub3dEYXRlLCB0b2RheVJhbmdlKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGxzLCByb3cpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlUm93LCB7IHJlZjogX3RoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7IH0pKSkpKTsgfSkpKTtcbiAgICB9O1xuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVGFibGUucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcChmdW5jdGlvbiAocm93T2JqKSB7IHJldHVybiByb3dPYmouZ2V0Q2VsbEVscygpWzBdOyB9KSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgIGZhbHNlKTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbFBvc2l0aW9ucyA9IF9hLmNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zID0gX2Eucm93UG9zaXRpb25zO1xuICAgICAgICB2YXIgY29sID0gY29sUG9zaXRpb25zLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIHZhciByb3cgPSByb3dQb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XG4gICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW3Jvd11bY29sXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IF9fYXNzaWduKHsgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSwgYWxsRGF5OiB0cnVlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRDZWxsRWwgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF07IC8vIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XG4gICAgICAgIHZhciBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufShEYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBpc1NlZ0FsbERheShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbn1cblxudmFyIERheVRhYmxlU2xpY2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXlUYWJsZVNsaWNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUYWJsZVNsaWNlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5VGFibGVTbGljZXIucHJvdG90eXBlLnNsaWNlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZVNsaWNlcjtcbn0oU2xpY2VyKSk7XG5cbnZhciBEYXlUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5VGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcbiAgICAgICAgX3RoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlLCBfX2Fzc2lnbih7IHJlZjogdGhpcy50YWJsZVJlZiB9LCB0aGlzLnNsaWNlci5zbGljZVByb3BzKHByb3BzLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMubmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgcHJvcHMuZGF5VGFibGVNb2RlbCksIHsgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogcHJvcHMuZGF5VGFibGVNb2RlbC5jZWxscywgY29sR3JvdXBOb2RlOiBwcm9wcy5jb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHJlbmRlclJvd0ludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgaGVhZGVyQWxpZ25FbFJlZjogcHJvcHMuaGVhZGVyQWxpZ25FbFJlZiwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGU7XG59KERhdGVDb21wb25lbnQpKTtcblxudmFyIERheVRhYmxlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5VGFibGVWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRhYmxlVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcbiAgICAgICAgX3RoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRGF5VGFibGVWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yID0gX2EuZGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBkYXlUYWJsZU1vZGVsLnJvd0NudCA9PT0gMSB9KSk7XG4gICAgICAgIHZhciBib2R5Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50QXJnKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChEYXlUYWJsZSwgeyByZWY6IF90aGlzLnRhYmxlUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGRheU1heEV2ZW50czogb3B0aW9ucy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogb3B0aW9ucy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgZXhwYW5kUm93czogIXByb3BzLmlzSGVpZ2h0QXV0bywgaGVhZGVyQWxpZ25FbFJlZjogX3RoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpOyB9O1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGVWaWV3O1xufShUYWJsZVZpZXcpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSk7XG59XG5cbnZhciBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgcmVuZGVyUmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UuY2FsbCh0aGlzLCBjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xuICAgICAgICB2YXIgc3RhcnQgPSByZW5kZXJSYW5nZS5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHJlbmRlclJhbmdlLmVuZDtcbiAgICAgICAgdmFyIGVuZE9mV2VlaztcbiAgICAgICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcbiAgICAgICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb250aE1vZGUgJiZcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZml4ZWRXZWVrQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xuICAgICAgICAgICAgZGlmZldlZWtzKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG59KERhdGVQcm9maWxlR2VuZXJhdG9yKSk7XG5cbnZhciBtYWluID0gY3JlYXRlUGx1Z2luKHtcbiAgICBpbml0aWFsVmlldzogJ2RheUdyaWRNb250aCcsXG4gICAgdmlld3M6IHtcbiAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgICAgICAgbW9udGhNb2RlOiB0cnVlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYWluO1xuZXhwb3J0IHsgRGF5VGFibGVWaWV3IGFzIERheUdyaWRWaWV3LCBEYXlUYWJsZSwgRGF5VGFibGVTbGljZXIsIFRhYmxlLCBUYWJsZVZpZXcsIGJ1aWxkRGF5VGFibGVNb2RlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVSZWYiLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsImNyZWF0ZUVsZW1lbnQiLCJWaWV3Um9vdCIsIlNpbXBsZVNjcm9sbEdyaWQiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJyZW5kZXJTY3JvbGxTaGltIiwiRGF0ZUNvbXBvbmVudCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiRGF5Q2VsbENvbnRlbnQiLCJGcmFnbWVudCIsIkJhc2VDb21wb25lbnQiLCJjcmVhdGVGb3JtYXR0ZXIiLCJTdGFuZGFyZEV2ZW50IiwiYnVpbGRTZWdUaW1lVGV4dCIsIkV2ZW50Um9vdCIsImdldFNlZ0FuY2hvckF0dHJzIiwibWVtb2l6ZSIsIk1vcmVMaW5rUm9vdCIsImdldFNlZ01ldGEiLCJjcmVhdGVBcmlhQ2xpY2tBdHRycyIsImdldFVuaXF1ZURvbUlkIiwic2V0UmVmIiwiRGF5Q2VsbFJvb3QiLCJXZWVrTnVtYmVyUm9vdCIsImJ1aWxkRW50cnlLZXkiLCJpbnRlcnNlY3RTcGFucyIsIlNlZ0hpZXJhcmNoeSIsImludGVyc2VjdFJhbmdlcyIsImFkZERheXMiLCJSZWZNYXAiLCJzb3J0RXZlbnRTZWdzIiwiaXNQcm9wc0VxdWFsIiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJQb3NpdGlvbkNhY2hlIiwiTm93VGltZXIiLCJTbGljZXIiLCJEYXlIZWFkZXIiLCJEYXlTZXJpZXNNb2RlbCIsIkRheVRhYmxlTW9kZWwiLCJhZGRXZWVrcyIsImRpZmZXZWVrcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiY3JlYXRlUGx1Z2luIiwiX19leHRlbmRzIiwiX19hc3NpZ24iLCJfX3NwcmVhZEFycmF5IiwiVGFibGVWaWV3IiwiX3N1cGVyIiwiX3RoaXMiLCJhcHBseSIsImFyZ3VtZW50cyIsImhlYWRlckVsUmVmIiwicHJvdG90eXBlIiwicmVuZGVyU2ltcGxlTGF5b3V0IiwiaGVhZGVyUm93Q29udGVudCIsImJvZHlDb250ZW50IiwiX2EiLCJwcm9wcyIsImNvbnRleHQiLCJzZWN0aW9ucyIsInN0aWNreUhlYWRlckRhdGVzIiwib3B0aW9ucyIsInB1c2giLCJ0eXBlIiwia2V5IiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50IiwibGlxdWlkIiwiY29udGVudCIsInZpZXdTcGVjIiwicm9vdEVsUmVmIiwiY2xhc3NOYW1lcyIsInJlZiIsImNsYXNzTmFtZSIsImNvbmNhdCIsImpvaW4iLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb2xzIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsImNodW5rcyIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsInNwbGl0U2Vnc0J5Um93Iiwic2VncyIsInJvd0NudCIsImJ5Um93IiwiaSIsIl9pIiwic2Vnc18xIiwibGVuZ3RoIiwic2VnIiwicm93Iiwic3BsaXRTZWdzQnlGaXJzdENvbCIsImJ5Q29sIiwic2Vnc18yIiwiZmlyc3RDb2wiLCJzcGxpdEludGVyYWN0aW9uQnlSb3ciLCJ1aSIsImFmZmVjdGVkSW5zdGFuY2VzIiwiaXNFdmVudCIsIlRhYmxlQ2VsbFRvcCIsInJlbmRlciIsIm5hdkxpbmtBdHRycyIsImRhdGUiLCJkYXRlUHJvZmlsZSIsInRvZGF5UmFuZ2UiLCJzaG93RGF5TnVtYmVyIiwiZXh0cmFIb29rUHJvcHMiLCJkZWZhdWx0Q29udGVudCIsInJlbmRlclRvcElubmVyIiwiaW5uZXJFbFJlZiIsImlubmVyQ29udGVudCIsImZvcmNlRGF5VG9wIiwiaWQiLCJkYXlOdW1iZXJJZCIsImRheU51bWJlclRleHQiLCJERUZBVUxUX1RBQkxFX0VWRU5UX1RJTUVfRk9STUFUIiwiaG91ciIsIm1pbnV0ZSIsIm9taXRaZXJvTWludXRlIiwibWVyaWRpZW0iLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJkaXNwbGF5IiwiZXZlbnRSYW5nZSIsImRlZiIsImFsbERheSIsImxhc3RDb2wiLCJpc1N0YXJ0IiwiaXNFbmQiLCJUYWJsZUJsb2NrRXZlbnQiLCJleHRyYUNsYXNzTmFtZXMiLCJkZWZhdWx0VGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRFbmQiLCJkaXNhYmxlUmVzaXppbmciLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJ0aW1lRm9ybWF0IiwiZXZlbnRUaW1lRm9ybWF0IiwidGltZVRleHQiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsImlzU2VsZWN0ZWQiLCJpc1Bhc3QiLCJpc0Z1dHVyZSIsImlzVG9kYXkiLCJpbm5lclByb3BzIiwic3R5bGUiLCJib3JkZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImV2ZW50IiwidGl0bGUiLCJUYWJsZUNlbGxNb3JlTGluayIsImNvbXBpbGVTZWdzIiwic2luZ2xlUGxhY2VtZW50cyIsImFsbFNlZ3MiLCJpbnZpc2libGVTZWdzIiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJhbGlnbkdyaWRUb3AiLCJleHRyYURhdGVTcGFuIiwicG9wb3ZlckNvbnRlbnQiLCJpc0ZvcmNlZEludmlzaWJsZSIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplIiwibWFwIiwiaW5zdGFuY2VJZCIsImluc3RhbmNlIiwidmlzaWJpbGl0eSIsImV2ZW50U2VsZWN0aW9uIiwiaGFuZGxlQ2xpY2siLCJpc0V4cGFuZGVkIiwicG9wb3ZlcklkIiwic2luZ2xlUGxhY2VtZW50c18xIiwicGxhY2VtZW50IiwiaXNWaXNpYmxlIiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJ3ZWVrIiwiVGFibGVDZWxsIiwic3RhdGUiLCJoYW5kbGVSb290RWwiLCJlbCIsImRheUVsUmVmIiwiZGF5Q2xhc3NOYW1lcyIsInJvb3REYXRhQXR0cnMiLCJpc0Rpc2FibGVkIiwicm9sZSIsImV4dHJhRGF0YUF0dHJzIiwic2hvd1dlZWtOdW1iZXIiLCJkZWZhdWx0Rm9ybWF0Iiwid2Vla0VsUmVmIiwid2Vla0NsYXNzTmFtZXMiLCJmZ0NvbnRlbnRFbFJlZiIsImZnQ29udGVudCIsIm1hcmdpblRvcCIsIm1vcmVNYXJnaW5Ub3AiLCJiZ0NvbnRlbnQiLCJjb21wdXRlRmdTZWdQbGFjZW1lbnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJzdHJpY3RPcmRlciIsImV2ZW50SW5zdGFuY2VIZWlnaHRzIiwibWF4Q29udGVudEhlaWdodCIsImNlbGxzIiwiaGllcmFyY2h5IiwiRGF5R3JpZFNlZ0hpZXJhcmNoeSIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJoaWRkZW5Db25zdW1lcyIsIm1heFN0YWNrQ250Iiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJldmVudEhlaWdodCIsImluZGV4IiwidGhpY2tuZXNzIiwic3RhcnQiLCJlbmQiLCJoaWRkZW5FbnRyaWVzIiwiYWRkU2VncyIsInNlZ1JlY3RzIiwidG9SZWN0cyIsInBsYWNlUmVjdHMiLCJzaW5nbGVDb2xQbGFjZW1lbnRzIiwibXVsdGlDb2xQbGFjZW1lbnRzIiwibGVmdG92ZXJNYXJnaW5zIiwibW9yZUNudHMiLCJtb3JlTWFyZ2luVG9wcyIsInVua25vd25IZWlnaHRTZWdzXzEiLCJpc0Fic29sdXRlIiwiYWJzb2x1dGVUb3AiLCJjb2wiLCJyZXNsaWNlU2VnIiwiX2IiLCJoaWRkZW5FbnRyaWVzXzEiLCJoaWRkZW5FbnRyeSIsImhpZGRlblNwYW4iLCJhbGxSZWN0cyIsInJlY3RzQnlFYWNoQ29sIiwiZ3JvdXBSZWN0c0J5RWFjaENvbCIsInJlY3RzIiwiY3VycmVudEhlaWdodCIsImN1cnJlbnRNYXJnaW5Ub3AiLCJyZWN0c18xIiwicmVjdCIsImxldmVsQ29vcmQiLCJtdWx0aVBsYWNlbWVudHMiLCJyZWN0c18yIiwiaXNGaXJzdENvbCIsInJlY3RzXzMiLCJzcGFuU3RhcnQiLCJzcGFuRW5kIiwib3JpZ1JhbmdlIiwicmFuZ2UiLCJzbGljZWRSYW5nZSIsImR1cmF0aW9uRWRpdGFibGUiLCJ2YWx1ZU9mIiwiZm9yY2VIaWRkZW4iLCJjYWxsIiwiZW50cmllc0J5TGV2ZWwiLCJleGNsdWRlSGlkZGVuIiwiZW50cnkiLCJsZXZlbCIsImZpbHRlciIsImhhbmRsZUludmFsaWRJbnNlcnRpb24iLCJpbnNlcnRpb24iLCJ0b3VjaGluZ0VudHJ5IiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRvdWNoaW5nRW50cnlJZCIsInBsYWNlaG9sZGVyRW50cnkiLCJwbGFjZWhvbGRlckVudHJ5SWQiLCJzcGxpdEVudHJ5IiwiVGFibGVSb3ciLCJjZWxsRWxSZWZzIiwiZnJhbWVFbFJlZnMiLCJmZ0VsUmVmcyIsInNlZ0hhcm5lc3NSZWZzIiwiZnJhbWVQb3NpdGlvbnMiLCJidXNpbmVzc0hvdXJzQnlDb2wiLCJidXNpbmVzc0hvdXJTZWdzIiwiYmdFdmVudFNlZ3NCeUNvbCIsImJnRXZlbnRTZWdzIiwiaGlnaGxpZ2h0U2Vnc0J5Q29sIiwiZ2V0SGlnaGxpZ2h0U2VncyIsIm1pcnJvclNlZ3NCeUNvbCIsImdldE1pcnJvclNlZ3MiLCJmZ0V2ZW50U2VncyIsImV2ZW50T3JkZXIiLCJldmVudE9yZGVyU3RyaWN0IiwicmVuZGVySW50cm8iLCJjZWxsIiwibm9ybWFsRmdOb2RlcyIsInJlbmRlckZnU2VncyIsIm1pcnJvckZnTm9kZXMiLCJidWlsZE1pcnJvclBsYWNlbWVudHMiLCJCb29sZWFuIiwic2hvd0RheU51bWJlcnMiLCJzaG93V2Vla051bWJlcnMiLCJyZW5kZXJGaWxsU2VncyIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlU2l6aW5nIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY3VycmVudFByb3BzIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJzZWdQbGFjZW1lbnRzIiwiaXNNaXJyb3IiLCJub2RlcyIsInNlZ1BsYWNlbWVudHNfMSIsImxlZnQiLCJyaWdodCIsImlzUnRsIiwibGVmdHMiLCJyaWdodHMiLCJ0b3AiLCJmaWxsVHlwZSIsImxlZnRSaWdodENzcyIsImlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UiLCJjbGllbnRXaWR0aCIsImZyYW1lRWxzIiwiY3VycmVudE1hcCIsIm9yaWdpbkVsIiwiY3VycmVudCIsInNldFN0YXRlIiwib2xkSW5zdGFuY2VIZWlnaHRzIiwibmV3SW5zdGFuY2VIZWlnaHRzIiwicXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cyIsImxpbWl0QnlDb250ZW50SGVpZ2h0Iiwic2FmZVNldFN0YXRlIiwiY29tcHV0ZU1heENvbnRlbnRIZWlnaHQiLCJzZWdFbE1hcCIsImhlaWdodCIsIk1hdGgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNwbGl0IiwibWF4IiwiZmlyc3RLZXkiLCJjZWxsRWwiLCJmY0NvbnRhaW5lckVsIiwiYm90dG9tIiwiZ2V0Q2VsbEVscyIsImVsTWFwIiwiYWRkU3RhdGVFcXVhbGl0eSIsIm1pcnJvclNlZ3MiLCJjb2xQbGFjZW1lbnRzIiwidG9wc0J5SW5zdGFuY2VJZCIsImJ1aWxkQWJzb2x1dGVUb3BIYXNoIiwiY29sUGxhY2VtZW50c18xIiwicGxhY2VtZW50cyIsInBsYWNlbWVudHNfMSIsIlRhYmxlIiwic3BsaXRCdXNpbmVzc0hvdXJTZWdzIiwic3BsaXRCZ0V2ZW50U2VncyIsInNwbGl0RmdFdmVudFNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwicm93UmVmcyIsInJvb3RFbCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImV4cGFuZFJvd3MiLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJiZ0V2ZW50U2Vnc0J5Um93IiwiZmdFdmVudFNlZ3NCeVJvdyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJldmVudERyYWdCeVJvdyIsImV2ZW50UmVzaXplQnlSb3ciLCJsaW1pdFZpYUJhbGFuY2VkIiwid2lkdGgiLCJ0YWJsZU1pbldpZHRoIiwidW5pdCIsIm5vd0RhdGUiLCJjbGllbnRIZWlnaHQiLCJjb2xHcm91cE5vZGUiLCJ0b0lTT1N0cmluZyIsInJlbmRlclJvd0ludHJvIiwiaXNTZWdBbGxEYXkiLCJwcmVwYXJlSGl0cyIsInJvd1Bvc2l0aW9ucyIsImNvbGxlY3QiLCJyb3dPYmoiLCJjb2xQb3NpdGlvbnMiLCJxdWVyeUhpdCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4IiwiZGF0ZVNwYW4iLCJnZXRDZWxsUmFuZ2UiLCJkYXlFbCIsImdldENlbGxFbCIsInRvcHMiLCJib3R0b21zIiwibGF5ZXIiLCJEYXlUYWJsZVNsaWNlciIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUmFuZ2UiLCJkYXRlUmFuZ2UiLCJkYXlUYWJsZU1vZGVsIiwiRGF5VGFibGUiLCJzbGljZXIiLCJ0YWJsZVJlZiIsInNsaWNlUHJvcHMiLCJuZXh0RGF5VGhyZXNob2xkIiwiaGVhZGVyQWxpZ25FbFJlZiIsIkRheVRhYmxlVmlldyIsImJ1aWxkRGF5VGFibGVNb2RlbCIsImhlYWRlclJlZiIsImRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaGVhZGVyQ29udGVudCIsImRheUhlYWRlcnMiLCJkYXRlcyIsImhlYWRlckRhdGVzIiwiZGF0ZXNSZXBEaXN0aW5jdERheXMiLCJjb250ZW50QXJnIiwiYnVzaW5lc3NIb3VycyIsImRhdGVTZWxlY3Rpb24iLCJldmVudFN0b3JlIiwiZXZlbnRVaUJhc2VzIiwidGFibGVDb2xHcm91cE5vZGUiLCJ3ZWVrTnVtYmVycyIsImRheVNlcmllcyIsInJlbmRlclJhbmdlIiwidGVzdCIsImN1cnJlbnRSYW5nZVVuaXQiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRSZW5kZXJSYW5nZSIsImN1cnJlbnRSYW5nZSIsImlzUmFuZ2VBbGxEYXkiLCJkYXRlRW52IiwiZW5kT2ZXZWVrIiwic3RhcnRPZldlZWsiLCJtb250aE1vZGUiLCJmaXhlZFdlZWtDb3VudCIsImNlaWwiLCJtYWluIiwiaW5pdGlhbFZpZXciLCJ2aWV3cyIsImRheUdyaWQiLCJjb21wb25lbnQiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiZGF5R3JpZERheSIsImR1cmF0aW9uIiwiZGF5cyIsImRheUdyaWRXZWVrIiwid2Vla3MiLCJkYXlHcmlkTW9udGgiLCJtb250aHMiLCJEYXlHcmlkVmlldyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/interaction/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/main.js ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": function() { return /* binding */ ExternalDraggable; },\n/* harmony export */   \"FeaturefulElementDragging\": function() { return /* binding */ FeaturefulElementDragging; },\n/* harmony export */   \"PointerDragging\": function() { return /* binding */ PointerDragging; },\n/* harmony export */   \"ThirdPartyDraggable\": function() { return /* binding */ ThirdPartyDraggable; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/ var PointerDragging = /** @class */ function() {\n    function PointerDragging(containerEl) {\n        var _this = this;\n        this.subjectEl = null;\n        // options that can be directly assigned by caller\n        this.selector = \"\"; // will cause subjectEl in all emitted events to be this element\n        this.handleSelector = \"\";\n        this.shouldIgnoreMove = false;\n        this.shouldWatchScroll = true; // for simulating pointermove on scroll\n        // internal states\n        this.isDragging = false;\n        this.isTouchDragging = false;\n        this.wasTouchScroll = false;\n        // Mouse\n        // ----------------------------------------------------------------------------------------------------\n        this.handleMouseDown = function(ev) {\n            if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {\n                var pev = _this.createEventFromMouse(ev, true);\n                _this.emitter.trigger(\"pointerdown\", pev);\n                _this.initScrollWatch(pev);\n                if (!_this.shouldIgnoreMove) {\n                    document.addEventListener(\"mousemove\", _this.handleMouseMove);\n                }\n                document.addEventListener(\"mouseup\", _this.handleMouseUp);\n            }\n        };\n        this.handleMouseMove = function(ev) {\n            var pev = _this.createEventFromMouse(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleMouseUp = function(ev) {\n            document.removeEventListener(\"mousemove\", _this.handleMouseMove);\n            document.removeEventListener(\"mouseup\", _this.handleMouseUp);\n            _this.emitter.trigger(\"pointerup\", _this.createEventFromMouse(ev));\n            _this.cleanup(); // call last so that pointerup has access to props\n        };\n        // Touch\n        // ----------------------------------------------------------------------------------------------------\n        this.handleTouchStart = function(ev) {\n            if (_this.tryStart(ev)) {\n                _this.isTouchDragging = true;\n                var pev = _this.createEventFromTouch(ev, true);\n                _this.emitter.trigger(\"pointerdown\", pev);\n                _this.initScrollWatch(pev);\n                // unlike mouse, need to attach to target, not document\n                // https://stackoverflow.com/a/45760014\n                var targetEl = ev.target;\n                if (!_this.shouldIgnoreMove) {\n                    targetEl.addEventListener(\"touchmove\", _this.handleTouchMove);\n                }\n                targetEl.addEventListener(\"touchend\", _this.handleTouchEnd);\n                targetEl.addEventListener(\"touchcancel\", _this.handleTouchEnd); // treat it as a touch end\n                // attach a handler to get called when ANY scroll action happens on the page.\n                // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                // http://stackoverflow.com/a/32954565/96342\n                window.addEventListener(\"scroll\", _this.handleTouchScroll, true);\n            }\n        };\n        this.handleTouchMove = function(ev) {\n            var pev = _this.createEventFromTouch(ev);\n            _this.recordCoords(pev);\n            _this.emitter.trigger(\"pointermove\", pev);\n        };\n        this.handleTouchEnd = function(ev) {\n            if (_this.isDragging) {\n                var targetEl = ev.target;\n                targetEl.removeEventListener(\"touchmove\", _this.handleTouchMove);\n                targetEl.removeEventListener(\"touchend\", _this.handleTouchEnd);\n                targetEl.removeEventListener(\"touchcancel\", _this.handleTouchEnd);\n                window.removeEventListener(\"scroll\", _this.handleTouchScroll, true); // useCaptured=true\n                _this.emitter.trigger(\"pointerup\", _this.createEventFromTouch(ev));\n                _this.cleanup(); // call last so that pointerup has access to props\n                _this.isTouchDragging = false;\n                startIgnoringMouse();\n            }\n        };\n        this.handleTouchScroll = function() {\n            _this.wasTouchScroll = true;\n        };\n        this.handleScroll = function(ev) {\n            if (!_this.shouldIgnoreMove) {\n                var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;\n                var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;\n                _this.emitter.trigger(\"pointermove\", {\n                    origEvent: ev,\n                    isTouch: _this.isTouchDragging,\n                    subjectEl: _this.subjectEl,\n                    pageX: pageX,\n                    pageY: pageY,\n                    deltaX: pageX - _this.origPageX,\n                    deltaY: pageY - _this.origPageY\n                });\n            }\n        };\n        this.containerEl = containerEl;\n        this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n        containerEl.addEventListener(\"mousedown\", this.handleMouseDown);\n        containerEl.addEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerCreated();\n    }\n    PointerDragging.prototype.destroy = function() {\n        this.containerEl.removeEventListener(\"mousedown\", this.handleMouseDown);\n        this.containerEl.removeEventListener(\"touchstart\", this.handleTouchStart, {\n            passive: true\n        });\n        listenerDestroyed();\n    };\n    PointerDragging.prototype.tryStart = function(ev) {\n        var subjectEl = this.querySubjectEl(ev);\n        var downEl = ev.target;\n        if (subjectEl && (!this.handleSelector || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, this.handleSelector))) {\n            this.subjectEl = subjectEl;\n            this.isDragging = true; // do this first so cancelTouchScroll will work\n            this.wasTouchScroll = false;\n            return true;\n        }\n        return false;\n    };\n    PointerDragging.prototype.cleanup = function() {\n        isWindowTouchMoveCancelled = false;\n        this.isDragging = false;\n        this.subjectEl = null;\n        // keep wasTouchScroll around for later access\n        this.destroyScrollWatch();\n    };\n    PointerDragging.prototype.querySubjectEl = function(ev) {\n        if (this.selector) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.target, this.selector);\n        }\n        return this.containerEl;\n    };\n    PointerDragging.prototype.shouldIgnoreMouse = function() {\n        return ignoreMouseDepth || this.isTouchDragging;\n    };\n    // can be called by user of this class, to cancel touch-based scrolling for the current drag\n    PointerDragging.prototype.cancelTouchScroll = function() {\n        if (this.isDragging) {\n            isWindowTouchMoveCancelled = true;\n        }\n    };\n    // Scrolling that simulates pointermoves\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.initScrollWatch = function(ev) {\n        if (this.shouldWatchScroll) {\n            this.recordCoords(ev);\n            window.addEventListener(\"scroll\", this.handleScroll, true); // useCapture=true\n        }\n    };\n    PointerDragging.prototype.recordCoords = function(ev) {\n        if (this.shouldWatchScroll) {\n            this.prevPageX = ev.pageX;\n            this.prevPageY = ev.pageY;\n            this.prevScrollX = window.pageXOffset;\n            this.prevScrollY = window.pageYOffset;\n        }\n    };\n    PointerDragging.prototype.destroyScrollWatch = function() {\n        if (this.shouldWatchScroll) {\n            window.removeEventListener(\"scroll\", this.handleScroll, true); // useCaptured=true\n        }\n    };\n    // Event Normalization\n    // ----------------------------------------------------------------------------------------------------\n    PointerDragging.prototype.createEventFromMouse = function(ev, isFirst) {\n        var deltaX = 0;\n        var deltaY = 0;\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = ev.pageX;\n            this.origPageY = ev.pageY;\n        } else {\n            deltaX = ev.pageX - this.origPageX;\n            deltaY = ev.pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: false,\n            subjectEl: this.subjectEl,\n            pageX: ev.pageX,\n            pageY: ev.pageY,\n            deltaX: deltaX,\n            deltaY: deltaY\n        };\n    };\n    PointerDragging.prototype.createEventFromTouch = function(ev, isFirst) {\n        var touches = ev.touches;\n        var pageX;\n        var pageY;\n        var deltaX = 0;\n        var deltaY = 0;\n        // if touch coords available, prefer,\n        // because FF would give bad ev.pageX ev.pageY\n        if (touches && touches.length) {\n            pageX = touches[0].pageX;\n            pageY = touches[0].pageY;\n        } else {\n            pageX = ev.pageX;\n            pageY = ev.pageY;\n        }\n        // TODO: repeat code\n        if (isFirst) {\n            this.origPageX = pageX;\n            this.origPageY = pageY;\n        } else {\n            deltaX = pageX - this.origPageX;\n            deltaY = pageY - this.origPageY;\n        }\n        return {\n            origEvent: ev,\n            isTouch: true,\n            subjectEl: this.subjectEl,\n            pageX: pageX,\n            pageY: pageY,\n            deltaX: deltaX,\n            deltaY: deltaY\n        };\n    };\n    return PointerDragging;\n}();\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n    return ev.button === 0 && !ev.ctrlKey;\n}\n// Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\nfunction startIgnoringMouse() {\n    ignoreMouseDepth += 1;\n    setTimeout(function() {\n        ignoreMouseDepth -= 1;\n    }, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait);\n}\n// We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\nfunction listenerCreated() {\n    listenerCnt += 1;\n    if (listenerCnt === 1) {\n        window.addEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction listenerDestroyed() {\n    listenerCnt -= 1;\n    if (!listenerCnt) {\n        window.removeEventListener(\"touchmove\", onWindowTouchMove, {\n            passive: false\n        });\n    }\n}\nfunction onWindowTouchMove(ev) {\n    if (isWindowTouchMoveCancelled) {\n        ev.preventDefault();\n    }\n}\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/ var ElementMirror = /** @class */ function() {\n    function ElementMirror() {\n        this.isVisible = false; // must be explicitly enabled\n        this.sourceEl = null;\n        this.mirrorEl = null;\n        this.sourceElRect = null; // screen coords relative to viewport\n        // options that can be set directly by caller\n        this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n        this.zIndex = 9999;\n        this.revertDuration = 0;\n    }\n    ElementMirror.prototype.start = function(sourceEl, pageX, pageY) {\n        this.sourceEl = sourceEl;\n        this.sourceElRect = this.sourceEl.getBoundingClientRect();\n        this.origScreenX = pageX - window.pageXOffset;\n        this.origScreenY = pageY - window.pageYOffset;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.updateElPosition();\n    };\n    ElementMirror.prototype.handleMove = function(pageX, pageY) {\n        this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n        this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n        this.updateElPosition();\n    };\n    // can be called before start\n    ElementMirror.prototype.setIsVisible = function(bool) {\n        if (bool) {\n            if (!this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = \"\";\n                }\n                this.isVisible = bool; // needs to happen before updateElPosition\n                this.updateElPosition(); // because was not updating the position while invisible\n            }\n        } else if (this.isVisible) {\n            if (this.mirrorEl) {\n                this.mirrorEl.style.display = \"none\";\n            }\n            this.isVisible = bool;\n        }\n    };\n    // always async\n    ElementMirror.prototype.stop = function(needsRevertAnimation, callback) {\n        var _this = this;\n        var done = function() {\n            _this.cleanup();\n            callback();\n        };\n        if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work\n        (this.deltaX || this.deltaY // if same coords, transition won't work\n        )) {\n            this.doRevertAnimation(done, this.revertDuration);\n        } else {\n            setTimeout(done, 0);\n        }\n    };\n    ElementMirror.prototype.doRevertAnimation = function(callback, revertDuration) {\n        var mirrorEl = this.mirrorEl;\n        var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n        mirrorEl.style.transition = \"top \" + revertDuration + \"ms,\" + \"left \" + revertDuration + \"ms\";\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n            left: finalSourceElRect.left,\n            top: finalSourceElRect.top\n        });\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.whenTransitionDone)(mirrorEl, function() {\n            mirrorEl.style.transition = \"\";\n            callback();\n        });\n    };\n    ElementMirror.prototype.cleanup = function() {\n        if (this.mirrorEl) {\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.removeElement)(this.mirrorEl);\n            this.mirrorEl = null;\n        }\n        this.sourceEl = null;\n    };\n    ElementMirror.prototype.updateElPosition = function() {\n        if (this.sourceEl && this.isVisible) {\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(this.getMirrorEl(), {\n                left: this.sourceElRect.left + this.deltaX,\n                top: this.sourceElRect.top + this.deltaY\n            });\n        }\n    };\n    ElementMirror.prototype.getMirrorEl = function() {\n        var sourceElRect = this.sourceElRect;\n        var mirrorEl = this.mirrorEl;\n        if (!mirrorEl) {\n            mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n            // we don't want long taps or any mouse interaction causing selection/menus.\n            // would use preventSelection(), but that prevents selectstart, causing problems.\n            mirrorEl.classList.add(\"fc-unselectable\");\n            mirrorEl.classList.add(\"fc-event-dragging\");\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n                position: \"fixed\",\n                zIndex: this.zIndex,\n                visibility: \"\",\n                boxSizing: \"border-box\",\n                width: sourceElRect.right - sourceElRect.left,\n                height: sourceElRect.bottom - sourceElRect.top,\n                right: \"auto\",\n                bottom: \"auto\",\n                margin: 0\n            });\n            this.parentNode.appendChild(mirrorEl);\n        }\n        return mirrorEl;\n    };\n    return ElementMirror;\n}();\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/ var ScrollGeomCache = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ScrollGeomCache, _super);\n    function ScrollGeomCache(scrollController, doesListening) {\n        var _this = _super.call(this) || this;\n        _this.handleScroll = function() {\n            _this.scrollTop = _this.scrollController.getScrollTop();\n            _this.scrollLeft = _this.scrollController.getScrollLeft();\n            _this.handleScrollChange();\n        };\n        _this.scrollController = scrollController;\n        _this.doesListening = doesListening;\n        _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n        _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n        _this.scrollWidth = scrollController.getScrollWidth();\n        _this.scrollHeight = scrollController.getScrollHeight();\n        _this.clientWidth = scrollController.getClientWidth();\n        _this.clientHeight = scrollController.getClientHeight();\n        _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n        if (_this.doesListening) {\n            _this.getEventTarget().addEventListener(\"scroll\", _this.handleScroll);\n        }\n        return _this;\n    }\n    ScrollGeomCache.prototype.destroy = function() {\n        if (this.doesListening) {\n            this.getEventTarget().removeEventListener(\"scroll\", this.handleScroll);\n        }\n    };\n    ScrollGeomCache.prototype.getScrollTop = function() {\n        return this.scrollTop;\n    };\n    ScrollGeomCache.prototype.getScrollLeft = function() {\n        return this.scrollLeft;\n    };\n    ScrollGeomCache.prototype.setScrollTop = function(top) {\n        this.scrollController.setScrollTop(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.setScrollLeft = function(top) {\n        this.scrollController.setScrollLeft(top);\n        if (!this.doesListening) {\n            // we are not relying on the element to normalize out-of-bounds scroll values\n            // so we need to sanitize ourselves\n            this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n            this.handleScrollChange();\n        }\n    };\n    ScrollGeomCache.prototype.getClientWidth = function() {\n        return this.clientWidth;\n    };\n    ScrollGeomCache.prototype.getClientHeight = function() {\n        return this.clientHeight;\n    };\n    ScrollGeomCache.prototype.getScrollWidth = function() {\n        return this.scrollWidth;\n    };\n    ScrollGeomCache.prototype.getScrollHeight = function() {\n        return this.scrollHeight;\n    };\n    ScrollGeomCache.prototype.handleScrollChange = function() {};\n    return ScrollGeomCache;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ScrollController);\nvar ElementScrollGeomCache = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ElementScrollGeomCache, _super);\n    function ElementScrollGeomCache(el, doesListening) {\n        return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementScrollController(el), doesListening) || this;\n    }\n    ElementScrollGeomCache.prototype.getEventTarget = function() {\n        return this.scrollController.el;\n    };\n    ElementScrollGeomCache.prototype.computeClientRect = function() {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeInnerRect)(this.scrollController.el);\n    };\n    return ElementScrollGeomCache;\n}(ScrollGeomCache);\nvar WindowScrollGeomCache = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WindowScrollGeomCache, _super);\n    function WindowScrollGeomCache(doesListening) {\n        return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WindowScrollController(), doesListening) || this;\n    }\n    WindowScrollGeomCache.prototype.getEventTarget = function() {\n        return window;\n    };\n    WindowScrollGeomCache.prototype.computeClientRect = function() {\n        return {\n            left: this.scrollLeft,\n            right: this.scrollLeft + this.clientWidth,\n            top: this.scrollTop,\n            bottom: this.scrollTop + this.clientHeight\n        };\n    };\n    // the window is the only scroll object that changes it's rectangle relative\n    // to the document's topleft as it scrolls\n    WindowScrollGeomCache.prototype.handleScrollChange = function() {\n        this.clientRect = this.computeClientRect();\n    };\n    return WindowScrollGeomCache;\n}(ScrollGeomCache);\n// If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\nvar getTime = typeof performance === \"function\" ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/ var AutoScroller = /** @class */ function() {\n    function AutoScroller() {\n        var _this = this;\n        // options that can be set by caller\n        this.isEnabled = true;\n        this.scrollQuery = [\n            window,\n            \".fc-scroller\"\n        ];\n        this.edgeThreshold = 50; // pixels\n        this.maxVelocity = 300; // pixels per second\n        // internal state\n        this.pointerScreenX = null;\n        this.pointerScreenY = null;\n        this.isAnimating = false;\n        this.scrollCaches = null;\n        // protect against the initial pointerdown being too close to an edge and starting the scroll\n        this.everMovedUp = false;\n        this.everMovedDown = false;\n        this.everMovedLeft = false;\n        this.everMovedRight = false;\n        this.animate = function() {\n            if (_this.isAnimating) {\n                var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n                if (edge) {\n                    var now = getTime();\n                    _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n                    _this.requestAnimation(now);\n                } else {\n                    _this.isAnimating = false; // will stop animation\n                }\n            }\n        };\n    }\n    AutoScroller.prototype.start = function(pageX, pageY, scrollStartEl) {\n        if (this.isEnabled) {\n            this.scrollCaches = this.buildCaches(scrollStartEl);\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.handleMove(pageX, pageY);\n        }\n    };\n    AutoScroller.prototype.handleMove = function(pageX, pageY) {\n        if (this.isEnabled) {\n            var pointerScreenX = pageX - window.pageXOffset;\n            var pointerScreenY = pageY - window.pageYOffset;\n            var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n            var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n            if (yDelta < 0) {\n                this.everMovedUp = true;\n            } else if (yDelta > 0) {\n                this.everMovedDown = true;\n            }\n            if (xDelta < 0) {\n                this.everMovedLeft = true;\n            } else if (xDelta > 0) {\n                this.everMovedRight = true;\n            }\n            this.pointerScreenX = pointerScreenX;\n            this.pointerScreenY = pointerScreenY;\n            if (!this.isAnimating) {\n                this.isAnimating = true;\n                this.requestAnimation(getTime());\n            }\n        }\n    };\n    AutoScroller.prototype.stop = function() {\n        if (this.isEnabled) {\n            this.isAnimating = false; // will stop animation\n            for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n                var scrollCache = _a[_i];\n                scrollCache.destroy();\n            }\n            this.scrollCaches = null;\n        }\n    };\n    AutoScroller.prototype.requestAnimation = function(now) {\n        this.msSinceRequest = now;\n        requestAnimationFrame(this.animate);\n    };\n    AutoScroller.prototype.handleSide = function(edge, seconds) {\n        var scrollCache = edge.scrollCache;\n        var edgeThreshold = this.edgeThreshold;\n        var invDistance = edgeThreshold - edge.distance;\n        var velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n        this.maxVelocity * seconds;\n        var sign = 1;\n        switch(edge.name){\n            case \"left\":\n                sign = -1;\n            // falls through\n            case \"right\":\n                scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                break;\n            case \"top\":\n                sign = -1;\n            // falls through\n            case \"bottom\":\n                scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                break;\n        }\n    };\n    // left/top are relative to document topleft\n    AutoScroller.prototype.computeBestEdge = function(left, top) {\n        var edgeThreshold = this.edgeThreshold;\n        var bestSide = null;\n        var scrollCaches = this.scrollCaches || [];\n        for(var _i = 0, scrollCaches_1 = scrollCaches; _i < scrollCaches_1.length; _i++){\n            var scrollCache = scrollCaches_1[_i];\n            var rect = scrollCache.clientRect;\n            var leftDist = left - rect.left;\n            var rightDist = rect.right - left;\n            var topDist = top - rect.top;\n            var bottomDist = rect.bottom - top;\n            // completely within the rect?\n            if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"top\",\n                        distance: topDist\n                    };\n                }\n                if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"bottom\",\n                        distance: bottomDist\n                    };\n                }\n                if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"left\",\n                        distance: leftDist\n                    };\n                }\n                if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n                    bestSide = {\n                        scrollCache: scrollCache,\n                        name: \"right\",\n                        distance: rightDist\n                    };\n                }\n            }\n        }\n        return bestSide;\n    };\n    AutoScroller.prototype.buildCaches = function(scrollStartEl) {\n        return this.queryScrollEls(scrollStartEl).map(function(el) {\n            if (el === window) {\n                return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n            }\n            return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n        });\n    };\n    AutoScroller.prototype.queryScrollEls = function(scrollStartEl) {\n        var els = [];\n        for(var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++){\n            var query = _a[_i];\n            if (typeof query === \"object\") {\n                els.push(query);\n            } else {\n                els.push.apply(els, Array.prototype.slice.call((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(scrollStartEl).querySelectorAll(query)));\n            }\n        }\n        return els;\n    };\n    return AutoScroller;\n}();\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/ var FeaturefulElementDragging = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FeaturefulElementDragging, _super);\n    function FeaturefulElementDragging(containerEl, selector) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.containerEl = containerEl;\n        // options that can be directly set by caller\n        // the caller can also set the PointerDragging's options as well\n        _this.delay = null;\n        _this.minDistance = 0;\n        _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n        _this.mirrorNeedsRevert = false;\n        _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n        _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n        _this.isDelayEnded = false;\n        _this.isDistanceSurpassed = false;\n        _this.delayTimeoutId = null;\n        _this.onPointerDown = function(ev) {\n            if (!_this.isDragging) {\n                _this.isInteracting = true;\n                _this.isDelayEnded = false;\n                _this.isDistanceSurpassed = false;\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventSelection)(document.body);\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventContextMenu)(document.body);\n                // prevent links from being visited if there's an eventual drag.\n                // also prevents selection in older browsers (maybe?).\n                // not necessary for touch, besides, browser would complain about passiveness.\n                if (!ev.isTouch) {\n                    ev.origEvent.preventDefault();\n                }\n                _this.emitter.trigger(\"pointerdown\", ev);\n                if (_this.isInteracting && // not destroyed via pointerdown handler\n                !_this.pointer.shouldIgnoreMove) {\n                    // actions related to initiating dragstart+dragmove+dragend...\n                    _this.mirror.setIsVisible(false); // reset. caller must set-visible\n                    _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                    _this.startDelay(ev);\n                    if (!_this.minDistance) {\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n            }\n        };\n        _this.onPointerMove = function(ev) {\n            if (_this.isInteracting) {\n                _this.emitter.trigger(\"pointermove\", ev);\n                if (!_this.isDistanceSurpassed) {\n                    var minDistance = _this.minDistance;\n                    var distanceSq = void 0; // current distance from the origin, squared\n                    var deltaX = ev.deltaX, deltaY = ev.deltaY;\n                    distanceSq = deltaX * deltaX + deltaY * deltaY;\n                    if (distanceSq >= minDistance * minDistance) {\n                        _this.handleDistanceSurpassed(ev);\n                    }\n                }\n                if (_this.isDragging) {\n                    // a real pointer move? (not one simulated by scrolling)\n                    if (ev.origEvent.type !== \"scroll\") {\n                        _this.mirror.handleMove(ev.pageX, ev.pageY);\n                        _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                    }\n                    _this.emitter.trigger(\"dragmove\", ev);\n                }\n            }\n        };\n        _this.onPointerUp = function(ev) {\n            if (_this.isInteracting) {\n                _this.isInteracting = false;\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowSelection)(document.body);\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowContextMenu)(document.body);\n                _this.emitter.trigger(\"pointerup\", ev); // can potentially set mirrorNeedsRevert\n                if (_this.isDragging) {\n                    _this.autoScroller.stop();\n                    _this.tryStopDrag(ev); // which will stop the mirror\n                }\n                if (_this.delayTimeoutId) {\n                    clearTimeout(_this.delayTimeoutId);\n                    _this.delayTimeoutId = null;\n                }\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", _this.onPointerDown);\n        pointer.emitter.on(\"pointermove\", _this.onPointerMove);\n        pointer.emitter.on(\"pointerup\", _this.onPointerUp);\n        if (selector) {\n            pointer.selector = selector;\n        }\n        _this.mirror = new ElementMirror();\n        _this.autoScroller = new AutoScroller();\n        return _this;\n    }\n    FeaturefulElementDragging.prototype.destroy = function() {\n        this.pointer.destroy();\n        // HACK: simulate a pointer-up to end the current drag\n        // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n        this.onPointerUp({});\n    };\n    FeaturefulElementDragging.prototype.startDelay = function(ev) {\n        var _this = this;\n        if (typeof this.delay === \"number\") {\n            this.delayTimeoutId = setTimeout(function() {\n                _this.delayTimeoutId = null;\n                _this.handleDelayEnd(ev);\n            }, this.delay); // not assignable to number!\n        } else {\n            this.handleDelayEnd(ev);\n        }\n    };\n    FeaturefulElementDragging.prototype.handleDelayEnd = function(ev) {\n        this.isDelayEnded = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.handleDistanceSurpassed = function(ev) {\n        this.isDistanceSurpassed = true;\n        this.tryStartDrag(ev);\n    };\n    FeaturefulElementDragging.prototype.tryStartDrag = function(ev) {\n        if (this.isDelayEnded && this.isDistanceSurpassed) {\n            if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                this.isDragging = true;\n                this.mirrorNeedsRevert = false;\n                this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                this.emitter.trigger(\"dragstart\", ev);\n                if (this.touchScrollAllowed === false) {\n                    this.pointer.cancelTouchScroll();\n                }\n            }\n        }\n    };\n    FeaturefulElementDragging.prototype.tryStopDrag = function(ev) {\n        // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n        // that come from the document to fire beforehand. much more convenient this way.\n        this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n    };\n    FeaturefulElementDragging.prototype.stopDrag = function(ev) {\n        this.isDragging = false;\n        this.emitter.trigger(\"dragend\", ev);\n    };\n    // fill in the implementations...\n    FeaturefulElementDragging.prototype.setIgnoreMove = function(bool) {\n        this.pointer.shouldIgnoreMove = bool;\n    };\n    FeaturefulElementDragging.prototype.setMirrorIsVisible = function(bool) {\n        this.mirror.setIsVisible(bool);\n    };\n    FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function(bool) {\n        this.mirrorNeedsRevert = bool;\n    };\n    FeaturefulElementDragging.prototype.setAutoScrollEnabled = function(bool) {\n        this.autoScroller.isEnabled = bool;\n    };\n    return FeaturefulElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/ var OffsetTracker = /** @class */ function() {\n    function OffsetTracker(el) {\n        this.origRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(el);\n        // will work fine for divs that have overflow:hidden\n        this.scrollCaches = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getClippingParents)(el).map(function(scrollEl) {\n            return new ElementScrollGeomCache(scrollEl, true);\n        });\n    }\n    OffsetTracker.prototype.destroy = function() {\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            scrollCache.destroy();\n        }\n    };\n    OffsetTracker.prototype.computeLeft = function() {\n        var left = this.origRect.left;\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n        }\n        return left;\n    };\n    OffsetTracker.prototype.computeTop = function() {\n        var top = this.origRect.top;\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n        }\n        return top;\n    };\n    OffsetTracker.prototype.isWithinClipping = function(pageX, pageY) {\n        var point = {\n            left: pageX,\n            top: pageY\n        };\n        for(var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++){\n            var scrollCache = _a[_i];\n            if (!isIgnoredClipping(scrollCache.getEventTarget()) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.pointInsideRect)(point, scrollCache.clientRect)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return OffsetTracker;\n}();\n// certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\nfunction isIgnoredClipping(node) {\n    var tagName = node.tagName;\n    return tagName === \"HTML\" || tagName === \"BODY\";\n}\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/ var HitDragging = /** @class */ function() {\n    function HitDragging(dragging, droppableStore) {\n        var _this = this;\n        // options that can be set by caller\n        this.useSubjectCenter = false;\n        this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n        this.initialHit = null;\n        this.movingHit = null;\n        this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n        this.handlePointerDown = function(ev) {\n            var dragging = _this.dragging;\n            _this.initialHit = null;\n            _this.movingHit = null;\n            _this.finalHit = null;\n            _this.prepareHits();\n            _this.processFirstCoord(ev);\n            if (_this.initialHit || !_this.requireInitial) {\n                dragging.setIgnoreMove(false);\n                // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                _this.emitter.trigger(\"pointerdown\", ev);\n            } else {\n                dragging.setIgnoreMove(true);\n            }\n        };\n        this.handleDragStart = function(ev) {\n            _this.emitter.trigger(\"dragstart\", ev);\n            _this.handleMove(ev, true); // force = fire even if initially null\n        };\n        this.handleDragMove = function(ev) {\n            _this.emitter.trigger(\"dragmove\", ev);\n            _this.handleMove(ev);\n        };\n        this.handlePointerUp = function(ev) {\n            _this.releaseHits();\n            _this.emitter.trigger(\"pointerup\", ev);\n        };\n        this.handleDragEnd = function(ev) {\n            if (_this.movingHit) {\n                _this.emitter.trigger(\"hitupdate\", null, true, ev);\n            }\n            _this.finalHit = _this.movingHit;\n            _this.movingHit = null;\n            _this.emitter.trigger(\"dragend\", ev);\n        };\n        this.droppableStore = droppableStore;\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        dragging.emitter.on(\"dragmove\", this.handleDragMove);\n        dragging.emitter.on(\"pointerup\", this.handlePointerUp);\n        dragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.dragging = dragging;\n        this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n    }\n    // sets initialHit\n    // sets coordAdjust\n    HitDragging.prototype.processFirstCoord = function(ev) {\n        var origPoint = {\n            left: ev.pageX,\n            top: ev.pageY\n        };\n        var adjustedPoint = origPoint;\n        var subjectEl = ev.subjectEl;\n        var subjectRect;\n        if (subjectEl instanceof HTMLElement) {\n            subjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(subjectEl);\n            adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.constrainPoint)(adjustedPoint, subjectRect);\n        }\n        var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n        if (initialHit) {\n            if (this.useSubjectCenter && subjectRect) {\n                var slicedSubjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRects)(subjectRect, initialHit.rect);\n                if (slicedSubjectRect) {\n                    adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRectCenter)(slicedSubjectRect);\n                }\n            }\n            this.coordAdjust = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffPoints)(adjustedPoint, origPoint);\n        } else {\n            this.coordAdjust = {\n                left: 0,\n                top: 0\n            };\n        }\n    };\n    HitDragging.prototype.handleMove = function(ev, forceHandle) {\n        var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n        if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n            this.movingHit = hit;\n            this.emitter.trigger(\"hitupdate\", hit, false, ev);\n        }\n    };\n    HitDragging.prototype.prepareHits = function() {\n        this.offsetTrackers = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.mapHash)(this.droppableStore, function(interactionSettings) {\n            interactionSettings.component.prepareHits();\n            return new OffsetTracker(interactionSettings.el);\n        });\n    };\n    HitDragging.prototype.releaseHits = function() {\n        var offsetTrackers = this.offsetTrackers;\n        for(var id in offsetTrackers){\n            offsetTrackers[id].destroy();\n        }\n        this.offsetTrackers = {};\n    };\n    HitDragging.prototype.queryHitForOffset = function(offsetLeft, offsetTop) {\n        var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;\n        var bestHit = null;\n        for(var id in droppableStore){\n            var component = droppableStore[id].component;\n            var offsetTracker = offsetTrackers[id];\n            if (offsetTracker && // wasn't destroyed mid-drag\n            offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                var originLeft = offsetTracker.computeLeft();\n                var originTop = offsetTracker.computeTop();\n                var positionLeft = offsetLeft - originLeft;\n                var positionTop = offsetTop - originTop;\n                var origRect = offsetTracker.origRect;\n                var width = origRect.right - origRect.left;\n                var height = origRect.bottom - origRect.top;\n                if (// must be within the element's bounds\n                positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n                    var hit = component.queryHit(positionLeft, positionTop, width, height);\n                    if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n                    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.rangeContainsRange)(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n                        hit.componentId = id;\n                        hit.context = component.context;\n                        // TODO: better way to re-orient rectangle\n                        hit.rect.left += originLeft;\n                        hit.rect.right += originLeft;\n                        hit.rect.top += originTop;\n                        hit.rect.bottom += originTop;\n                        bestHit = hit;\n                    }\n                }\n            }\n        }\n        return bestHit;\n    };\n    return HitDragging;\n}();\nfunction isHitsEqual(hit0, hit1) {\n    if (!hit0 && !hit1) {\n        return true;\n    }\n    if (Boolean(hit0) !== Boolean(hit1)) {\n        return false;\n    }\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSpansEqual)(hit0.dateSpan, hit1.dateSpan);\n}\nfunction buildDatePointApiWithContext(dateSpan, context) {\n    var props = {};\n    for(var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, transform(dateSpan, context));\n    }\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, buildDatePointApi(dateSpan, context.dateEnv));\n    return props;\n}\nfunction buildDatePointApi(span, dateEnv) {\n    return {\n        date: dateEnv.toDate(span.range.start),\n        dateStr: dateEnv.formatIso(span.range.start, {\n            omitTime: span.allDay\n        }),\n        allDay: span.allDay\n    };\n}\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/ var DateClicking = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateClicking, _super);\n    function DateClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handlePointerDown = function(pev) {\n            var dragging = _this.dragging;\n            var downEl = pev.origEvent.target;\n            // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n            dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n        };\n        // won't even fire if moving was ignored\n        _this.handleDragEnd = function(ev) {\n            var component = _this.component;\n            var pointer = _this.dragging.pointer;\n            if (!pointer.wasTouchScroll) {\n                var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;\n                if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                    var context = component.context;\n                    var arg = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n                        dayEl: initialHit.dayEl,\n                        jsEvent: ev.origEvent,\n                        view: context.viewApi || context.calendarApi.view\n                    });\n                    context.emitter.trigger(\"dateClick\", arg);\n                }\n            }\n        };\n        // we DO want to watch pointer moves because otherwise finalHit won't get populated\n        _this.dragging = new FeaturefulElementDragging(settings.el);\n        _this.dragging.autoScroller.isEnabled = false;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    DateClicking.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return DateClicking;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/ var DateSelecting = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateSelecting, _super);\n    function DateSelecting(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.dragSelection = null;\n        _this.handlePointerDown = function(ev) {\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var options = component.context.options;\n            var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n            // don't bother to watch expensive moves if component won't do selection\n            dragging.setIgnoreMove(!canSelect);\n            // if touch, require user to hold down\n            dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n        };\n        _this.handleDragStart = function(ev) {\n            _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n        };\n        _this.handleHitUpdate = function(hit, isFinal) {\n            var context = _this.component.context;\n            var dragSelection = null;\n            var isInvalid = false;\n            if (hit) {\n                var initialHit = _this.hitDragging.initialHit;\n                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                }\n                if (!dragSelection || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSelectionValid)(dragSelection, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    dragSelection = null;\n                }\n            }\n            if (dragSelection) {\n                context.dispatch({\n                    type: \"SELECT_DATES\",\n                    selection: dragSelection\n                });\n            } else if (!isFinal) {\n                context.dispatch({\n                    type: \"UNSELECT_DATES\"\n                });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            } else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n            }\n        };\n        _this.handlePointerUp = function(pev) {\n            if (_this.dragSelection) {\n                // selection is already rendered, so just need to report selection\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.triggerDateSelect)(_this.dragSelection, pev, _this.component.context);\n                _this.dragSelection = null;\n            }\n        };\n        var component = settings.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.touchScrollAllowed = false;\n        dragging.minDistance = options.selectMinDistance || 0;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", _this.handlePointerUp);\n        return _this;\n    }\n    DateSelecting.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return DateSelecting;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\nfunction getComponentTouchDelay$1(component) {\n    var options = component.context.options;\n    var delay = options.selectLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var ms = [\n        dateSpan0.range.start,\n        dateSpan0.range.end,\n        dateSpan1.range.start,\n        dateSpan1.range.end\n    ];\n    ms.sort(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.compareNumbers);\n    var props = {};\n    for(var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++){\n        var transformer = dateSelectionTransformers_1[_i];\n        var res = transformer(hit0, hit1);\n        if (res === false) {\n            return null;\n        }\n        if (res) {\n            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, res);\n        }\n    }\n    props.range = {\n        start: ms[0],\n        end: ms[3]\n    };\n    props.allDay = dateSpan0.allDay;\n    return props;\n}\nvar EventDragging = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventDragging, _super);\n    function EventDragging(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.subjectEl = null;\n        _this.subjectSeg = null; // the seg being selected/dragged\n        _this.isDragging = false;\n        _this.eventRange = null;\n        _this.relevantEvents = null; // the events being dragged\n        _this.receivingContext = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function(ev) {\n            var origTarget = ev.origEvent.target;\n            var _a = _this, component = _a.component, dragging = _a.dragging;\n            var mirror = dragging.mirror;\n            var options = component.context.options;\n            var initialContext = component.context;\n            _this.subjectEl = ev.subjectEl;\n            var subjectSeg = _this.subjectSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(ev.subjectEl);\n            var eventRange = _this.eventRange = subjectSeg.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(initialContext.getCurrentData().eventStore, eventInstanceId);\n            dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n            dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n            ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n            if (options.fixedMirrorParent) {\n                mirror.parentNode = options.fixedMirrorParent;\n            } else {\n                mirror.parentNode = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, \".fc\");\n            }\n            mirror.revertDuration = options.dragRevertDuration;\n            var isValid = component.isValidSegDownEl(origTarget) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, \".fc-event-resizer\"); // NOT on a resizer\n            dragging.setIgnoreMove(!isValid);\n            // disable dragging for elements that are resizable (ie, selectable)\n            // but are not draggable\n            _this.isDragging = isValid && ev.subjectEl.classList.contains(\"fc-event-draggable\");\n        };\n        _this.handleDragStart = function(ev) {\n            var initialContext = _this.component.context;\n            var eventRange = _this.eventRange;\n            var eventInstanceId = eventRange.instance.instanceId;\n            if (ev.isTouch) {\n                // need to select a different event?\n                if (eventInstanceId !== _this.component.props.eventSelection) {\n                    initialContext.dispatch({\n                        type: \"SELECT_EVENT\",\n                        eventInstanceId: eventInstanceId\n                    });\n                }\n            } else {\n                // if now using mouse, but was previous touch interaction, clear selected event\n                initialContext.dispatch({\n                    type: \"UNSELECT_EVENT\"\n                });\n            }\n            if (_this.isDragging) {\n                initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                initialContext.emitter.trigger(\"eventDragStart\", {\n                    el: _this.subjectEl,\n                    event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: initialContext.viewApi\n                });\n            }\n        };\n        _this.handleHitUpdate = function(hit, isFinal) {\n            if (!_this.isDragging) {\n                return;\n            }\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var initialContext = _this.component.context;\n            // states based on new hit\n            var receivingContext = null;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: true\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                var receivingOptions = receivingContext.options;\n                if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n                    mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                    if (mutation) {\n                        mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                        interaction.mutatedEvents = mutatedRelevantEvents;\n                        if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext)) {\n                            isInvalid = true;\n                            mutation = null;\n                            mutatedRelevantEvents = null;\n                            interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n                        }\n                    }\n                } else {\n                    receivingContext = null;\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            } else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                if (initialContext === receivingContext && // TODO: write test for this\n                isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.dragging.setMirrorNeedsRevert(!mutation);\n                // render the mirror if no already-rendered mirror\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                _this.dragging.setMirrorIsVisible(!hit || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(_this.subjectEl).querySelector(\".fc-event-mirror\"));\n                // assign states based on new hit\n                _this.receivingContext = receivingContext;\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handlePointerUp = function() {\n            if (!_this.isDragging) {\n                _this.cleanup(); // because handleDragEnd won't fire\n            }\n        };\n        _this.handleDragEnd = function(ev) {\n            if (_this.isDragging) {\n                var initialContext_1 = _this.component.context;\n                var initialView = initialContext_1.viewApi;\n                var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;\n                var eventDef = _this.eventRange.def;\n                var eventInstance = _this.eventRange.instance;\n                var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, eventDef, eventInstance);\n                var relevantEvents_1 = _this.relevantEvents;\n                var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n                var finalHit = _this.hitDragging.finalHit;\n                _this.clearDrag(); // must happen after revert animation\n                initialContext_1.emitter.trigger(\"eventDragStop\", {\n                    el: _this.subjectEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: initialView\n                });\n                if (validMutation) {\n                    // dropped within same calendar\n                    if (receivingContext_1 === initialContext_1) {\n                        var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n                        initialContext_1.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents_1\n                        });\n                        var eventChangeArg = {\n                            oldEvent: eventApi,\n                            event: updatedEventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n                            revert: function() {\n                                initialContext_1.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents_1\n                                });\n                            }\n                        };\n                        var transformed = {};\n                        for(var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++){\n                            var transformer = _b[_i];\n                            (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(transformed, transformer(validMutation, initialContext_1));\n                        }\n                        initialContext_1.emitter.trigger(\"eventDrop\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), transformed), {\n                            el: ev.subjectEl,\n                            delta: validMutation.datesDelta,\n                            jsEvent: ev.origEvent,\n                            view: initialView\n                        }));\n                        initialContext_1.emitter.trigger(\"eventChange\", eventChangeArg);\n                    // dropped in different calendar\n                    } else if (receivingContext_1) {\n                        var eventRemoveArg = {\n                            event: eventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(relevantEvents_1, initialContext_1, eventInstance),\n                            revert: function() {\n                                initialContext_1.dispatch({\n                                    type: \"MERGE_EVENTS\",\n                                    eventStore: relevantEvents_1\n                                });\n                            }\n                        };\n                        initialContext_1.emitter.trigger(\"eventLeave\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventRemoveArg), {\n                            draggedEl: ev.subjectEl,\n                            view: initialView\n                        }));\n                        initialContext_1.dispatch({\n                            type: \"REMOVE_EVENTS\",\n                            eventStore: relevantEvents_1\n                        });\n                        initialContext_1.emitter.trigger(\"eventRemove\", eventRemoveArg);\n                        var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n                        var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n                        var addedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n                        receivingContext_1.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: mutatedRelevantEvents_1\n                        });\n                        var eventAddArg = {\n                            event: addedEventApi,\n                            relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n                            revert: function() {\n                                receivingContext_1.dispatch({\n                                    type: \"REMOVE_EVENTS\",\n                                    eventStore: mutatedRelevantEvents_1\n                                });\n                            }\n                        };\n                        receivingContext_1.emitter.trigger(\"eventAdd\", eventAddArg);\n                        if (ev.isTouch) {\n                            receivingContext_1.dispatch({\n                                type: \"SELECT_EVENT\",\n                                eventInstanceId: eventInstance.instanceId\n                            });\n                        }\n                        receivingContext_1.emitter.trigger(\"drop\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {\n                            draggedEl: ev.subjectEl,\n                            jsEvent: ev.origEvent,\n                            view: finalHit.context.viewApi\n                        }));\n                        receivingContext_1.emitter.trigger(\"eventReceive\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventAddArg), {\n                            draggedEl: ev.subjectEl,\n                            view: finalHit.context.viewApi\n                        }));\n                    }\n                } else {\n                    initialContext_1.emitter.trigger(\"_noEventDrop\");\n                }\n            }\n            _this.cleanup();\n        };\n        var component = _this.component;\n        var options = component.context.options;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = EventDragging.SELECTOR;\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n        hitDragging.useSubjectCenter = settings.useEventCenter;\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"pointerup\", _this.handlePointerUp);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    EventDragging.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    // render a drag state on the next receivingCalendar\n    EventDragging.prototype.displayDrag = function(nextContext, state) {\n        var initialContext = this.component.context;\n        var prevContext = this.receivingContext;\n        // does the previous calendar need to be cleared?\n        if (prevContext && prevContext !== nextContext) {\n            // does the initial calendar need to be cleared?\n            // if so, don't clear all the way. we still need to to hide the affectedEvents\n            if (prevContext === initialContext) {\n                prevContext.dispatch({\n                    type: \"SET_EVENT_DRAG\",\n                    state: {\n                        affectedEvents: state.affectedEvents,\n                        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                        isEvent: true\n                    }\n                });\n            // completely clear the old calendar if it wasn't the initial\n            } else {\n                prevContext.dispatch({\n                    type: \"UNSET_EVENT_DRAG\"\n                });\n            }\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state: state\n            });\n        }\n    };\n    EventDragging.prototype.clearDrag = function() {\n        var initialCalendar = this.component.context;\n        var receivingContext = this.receivingContext;\n        if (receivingContext) {\n            receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        // the initial calendar might have an dummy drag state from displayDrag\n        if (initialCalendar !== receivingContext) {\n            initialCalendar.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    };\n    EventDragging.prototype.cleanup = function() {\n        this.subjectSeg = null;\n        this.isDragging = false;\n        this.eventRange = null;\n        this.relevantEvents = null;\n        this.receivingContext = null;\n        this.validMutation = null;\n        this.mutatedRelevantEvents = null;\n    };\n    // TODO: test this in IE11\n    // QUESTION: why do we need it on the resizable???\n    EventDragging.SELECTOR = \".fc-event-draggable, .fc-event-resizable\";\n    return EventDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\nfunction computeEventMutation(hit0, hit1, massagers) {\n    var dateSpan0 = hit0.dateSpan;\n    var dateSpan1 = hit1.dateSpan;\n    var date0 = dateSpan0.range.start;\n    var date1 = dateSpan1.range.start;\n    var standardProps = {};\n    if (dateSpan0.allDay !== dateSpan1.allDay) {\n        standardProps.allDay = dateSpan1.allDay;\n        standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n        if (dateSpan1.allDay) {\n            // means date1 is already start-of-day,\n            // but date0 needs to be converted\n            date0 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(date0);\n        }\n    }\n    var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n    if (delta.milliseconds) {\n        standardProps.allDay = false;\n    }\n    var mutation = {\n        datesDelta: delta,\n        standardProps: standardProps\n    };\n    for(var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++){\n        var massager = massagers_1[_i];\n        massager(mutation, hit0, hit1);\n    }\n    return mutation;\n}\nfunction getComponentTouchDelay(component) {\n    var options = component.context.options;\n    var delay = options.eventLongPressDelay;\n    if (delay == null) {\n        delay = options.longPressDelay;\n    }\n    return delay;\n}\nvar EventResizing = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventResizing, _super);\n    function EventResizing(settings) {\n        var _this = _super.call(this, settings) || this;\n        // internal state\n        _this.draggingSegEl = null;\n        _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n        _this.eventRange = null;\n        _this.relevantEvents = null;\n        _this.validMutation = null;\n        _this.mutatedRelevantEvents = null;\n        _this.handlePointerDown = function(ev) {\n            var component = _this.component;\n            var segEl = _this.querySegEl(ev);\n            var seg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n            var eventRange = _this.eventRange = seg.eventRange;\n            _this.dragging.minDistance = component.context.options.eventDragMinDistance;\n            // if touch, need to be working with a selected event\n            _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);\n        };\n        _this.handleDragStart = function(ev) {\n            var context = _this.component.context;\n            var eventRange = _this.eventRange;\n            _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n            var segEl = _this.querySegEl(ev);\n            _this.draggingSegEl = segEl;\n            _this.draggingSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n            context.calendarApi.unselect();\n            context.emitter.trigger(\"eventResizeStart\", {\n                el: segEl,\n                event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventRange.def, eventRange.instance),\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n        };\n        _this.handleHitUpdate = function(hit, isFinal, ev) {\n            var context = _this.component.context;\n            var relevantEvents = _this.relevantEvents;\n            var initialHit = _this.hitDragging.initialHit;\n            var eventInstance = _this.eventRange.instance;\n            var mutation = null;\n            var mutatedRelevantEvents = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: relevantEvents,\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: true\n            };\n            if (hit) {\n                var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n                if (!disallowed) {\n                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains(\"fc-event-resizer-start\"), eventInstance.range);\n                }\n            }\n            if (mutation) {\n                mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                interaction.mutatedEvents = mutatedRelevantEvents;\n                if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, context)) {\n                    isInvalid = true;\n                    mutation = null;\n                    mutatedRelevantEvents = null;\n                    interaction.mutatedEvents = null;\n                }\n            }\n            if (mutatedRelevantEvents) {\n                context.dispatch({\n                    type: \"SET_EVENT_RESIZE\",\n                    state: interaction\n                });\n            } else {\n                context.dispatch({\n                    type: \"UNSET_EVENT_RESIZE\"\n                });\n            }\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            } else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                if (mutation && isHitsEqual(initialHit, hit)) {\n                    mutation = null;\n                }\n                _this.validMutation = mutation;\n                _this.mutatedRelevantEvents = mutatedRelevantEvents;\n            }\n        };\n        _this.handleDragEnd = function(ev) {\n            var context = _this.component.context;\n            var eventDef = _this.eventRange.def;\n            var eventInstance = _this.eventRange.instance;\n            var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventDef, eventInstance);\n            var relevantEvents = _this.relevantEvents;\n            var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n            context.emitter.trigger(\"eventResizeStop\", {\n                el: _this.draggingSegEl,\n                event: eventApi,\n                jsEvent: ev.origEvent,\n                view: context.viewApi\n            });\n            if (_this.validMutation) {\n                var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: mutatedRelevantEvents\n                });\n                var eventChangeArg = {\n                    oldEvent: eventApi,\n                    event: updatedEventApi,\n                    relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents, context, eventInstance),\n                    revert: function() {\n                        context.dispatch({\n                            type: \"MERGE_EVENTS\",\n                            eventStore: relevantEvents\n                        });\n                    }\n                };\n                context.emitter.trigger(\"eventResize\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), {\n                    el: _this.draggingSegEl,\n                    startDelta: _this.validMutation.startDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n                    endDelta: _this.validMutation.endDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                }));\n                context.emitter.trigger(\"eventChange\", eventChangeArg);\n            } else {\n                context.emitter.trigger(\"_noEventResize\");\n            }\n            // reset all internal state\n            _this.draggingSeg = null;\n            _this.relevantEvents = null;\n            _this.validMutation = null;\n        // okay to keep eventInstance around. useful to set it in handlePointerDown\n        };\n        var component = settings.component;\n        var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n        dragging.pointer.selector = \".fc-event-resizer\";\n        dragging.touchScrollAllowed = false;\n        dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n        var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n        hitDragging.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        hitDragging.emitter.on(\"dragstart\", _this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", _this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", _this.handleDragEnd);\n        return _this;\n    }\n    EventResizing.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    EventResizing.prototype.querySegEl = function(ev) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.subjectEl, \".fc-event\");\n    };\n    return EventResizing;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n    var dateEnv = hit0.context.dateEnv;\n    var date0 = hit0.dateSpan.range.start;\n    var date1 = hit1.dateSpan.range.start;\n    var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, dateEnv, hit0.largeUnit);\n    if (isFromStart) {\n        if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n            return {\n                startDelta: delta\n            };\n        }\n    } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n        return {\n            endDelta: delta\n        };\n    }\n    return null;\n}\nvar UnselectAuto = /** @class */ function() {\n    function UnselectAuto(context) {\n        var _this = this;\n        this.context = context;\n        this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n        this.matchesCancel = false;\n        this.matchesEvent = false;\n        this.onSelect = function(selectInfo) {\n            if (selectInfo.jsEvent) {\n                _this.isRecentPointerDateSelect = true;\n            }\n        };\n        this.onDocumentPointerDown = function(pev) {\n            var unselectCancel = _this.context.options.unselectCancel;\n            var downEl = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getEventTargetViaRoot)(pev.origEvent);\n            _this.matchesCancel = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, unselectCancel);\n            _this.matchesEvent = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, EventDragging.SELECTOR); // interaction started on an event?\n        };\n        this.onDocumentPointerUp = function(pev) {\n            var context = _this.context;\n            var documentPointer = _this.documentPointer;\n            var calendarState = context.getCurrentData();\n            // touch-scrolling should never unfocus any type of selection\n            if (!documentPointer.wasTouchScroll) {\n                if (calendarState.dateSelection && // an existing date selection?\n                !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                ) {\n                    var unselectAuto = context.options.unselectAuto;\n                    if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n                        context.calendarApi.unselect(pev);\n                    }\n                }\n                if (calendarState.eventSelection && // an existing event selected?\n                !_this.matchesEvent // interaction DIDN'T start on an event\n                ) {\n                    context.dispatch({\n                        type: \"UNSELECT_EVENT\"\n                    });\n                }\n            }\n            _this.isRecentPointerDateSelect = false;\n        };\n        var documentPointer = this.documentPointer = new PointerDragging(document);\n        documentPointer.shouldIgnoreMove = true;\n        documentPointer.shouldWatchScroll = false;\n        documentPointer.emitter.on(\"pointerdown\", this.onDocumentPointerDown);\n        documentPointer.emitter.on(\"pointerup\", this.onDocumentPointerUp);\n        /*\n        TODO: better way to know about whether there was a selection with the pointer\n        */ context.emitter.on(\"select\", this.onSelect);\n    }\n    UnselectAuto.prototype.destroy = function() {\n        this.context.emitter.off(\"select\", this.onSelect);\n        this.documentPointer.destroy();\n    };\n    return UnselectAuto;\n}();\nvar OPTION_REFINERS = {\n    fixedMirrorParent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\nvar LISTENER_REFINERS = {\n    dateClick: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDragStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDragStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventDrop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResizeStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResizeStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventResize: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    drop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventReceive: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n    eventLeave: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/ var ExternalElementDragging = /** @class */ function() {\n    function ExternalElementDragging(dragging, suppliedDragMeta) {\n        var _this = this;\n        this.receivingContext = null;\n        this.droppableEvent = null; // will exist for all drags, even if create:false\n        this.suppliedDragMeta = null;\n        this.dragMeta = null;\n        this.handleDragStart = function(ev) {\n            _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n        };\n        this.handleHitUpdate = function(hit, isFinal, ev) {\n            var dragging = _this.hitDragging.dragging;\n            var receivingContext = null;\n            var droppableEvent = null;\n            var isInvalid = false;\n            var interaction = {\n                affectedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n                isEvent: _this.dragMeta.create\n            };\n            if (hit) {\n                receivingContext = hit.context;\n                if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                    droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n                    interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n                    isInvalid = !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext);\n                    if (isInvalid) {\n                        interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n                        droppableEvent = null;\n                    }\n                }\n            }\n            _this.displayDrag(receivingContext, interaction);\n            // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n            // TODO: wish we could somehow wait for dispatch to guarantee render\n            dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector(\".fc-event-mirror\"));\n            if (!isInvalid) {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n            } else {\n                (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n            }\n            if (!isFinal) {\n                dragging.setMirrorNeedsRevert(!droppableEvent);\n                _this.receivingContext = receivingContext;\n                _this.droppableEvent = droppableEvent;\n            }\n        };\n        this.handleDragEnd = function(pev) {\n            var _a = _this, receivingContext = _a.receivingContext, droppableEvent = _a.droppableEvent;\n            _this.clearDrag();\n            if (receivingContext && droppableEvent) {\n                var finalHit = _this.hitDragging.finalHit;\n                var finalView = finalHit.context.viewApi;\n                var dragMeta = _this.dragMeta;\n                receivingContext.emitter.trigger(\"drop\", (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                    draggedEl: pev.subjectEl,\n                    jsEvent: pev.origEvent,\n                    view: finalView\n                }));\n                if (dragMeta.create) {\n                    var addingEvents_1 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n                    receivingContext.dispatch({\n                        type: \"MERGE_EVENTS\",\n                        eventStore: addingEvents_1\n                    });\n                    if (pev.isTouch) {\n                        receivingContext.dispatch({\n                            type: \"SELECT_EVENT\",\n                            eventInstanceId: droppableEvent.instance.instanceId\n                        });\n                    }\n                    // signal that an external event landed\n                    receivingContext.emitter.trigger(\"eventReceive\", {\n                        event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n                        relatedEvents: [],\n                        revert: function() {\n                            receivingContext.dispatch({\n                                type: \"REMOVE_EVENTS\",\n                                eventStore: addingEvents_1\n                            });\n                        },\n                        draggedEl: pev.subjectEl,\n                        view: finalView\n                    });\n                }\n            }\n            _this.receivingContext = null;\n            _this.droppableEvent = null;\n        };\n        var hitDragging = this.hitDragging = new HitDragging(dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n        hitDragging.requireInitial = false; // will start outside of a component\n        hitDragging.emitter.on(\"dragstart\", this.handleDragStart);\n        hitDragging.emitter.on(\"hitupdate\", this.handleHitUpdate);\n        hitDragging.emitter.on(\"dragend\", this.handleDragEnd);\n        this.suppliedDragMeta = suppliedDragMeta;\n    }\n    ExternalElementDragging.prototype.buildDragMeta = function(subjectEl) {\n        if (typeof this.suppliedDragMeta === \"object\") {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta);\n        }\n        if (typeof this.suppliedDragMeta === \"function\") {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta(subjectEl));\n        }\n        return getDragMetaFromEl(subjectEl);\n    };\n    ExternalElementDragging.prototype.displayDrag = function(nextContext, state) {\n        var prevContext = this.receivingContext;\n        if (prevContext && prevContext !== nextContext) {\n            prevContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n        if (nextContext) {\n            nextContext.dispatch({\n                type: \"SET_EVENT_DRAG\",\n                state: state\n            });\n        }\n    };\n    ExternalElementDragging.prototype.clearDrag = function() {\n        if (this.receivingContext) {\n            this.receivingContext.dispatch({\n                type: \"UNSET_EVENT_DRAG\"\n            });\n        }\n    };\n    ExternalElementDragging.prototype.canDropElOnCalendar = function(el, receivingContext) {\n        var dropAccept = receivingContext.options.dropAccept;\n        if (typeof dropAccept === \"function\") {\n            return dropAccept.call(receivingContext.calendarApi, el);\n        }\n        if (typeof dropAccept === \"string\" && dropAccept) {\n            return Boolean((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementMatches)(el, dropAccept));\n        }\n        return true;\n    };\n    return ExternalElementDragging;\n}();\n// Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n    var defProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dragMeta.leftoverProps);\n    for(var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(defProps, transform(dateSpan, dragMeta));\n    }\n    var _b = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.refineEventDef)(defProps, context), refined = _b.refined, extra = _b.extra;\n    var def = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseEventDef)(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);\n    var start = dateSpan.range.start;\n    // only rely on time info if drop zone is all-day,\n    // otherwise, we already know the time\n    if (dateSpan.allDay && dragMeta.startTime) {\n        start = context.dateEnv.add(start, dragMeta.startTime);\n    }\n    var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getDefaultEventEnd)(dateSpan.allDay, start, context);\n    var instance = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEventInstance)(def.defId, {\n        start: start,\n        end: end\n    });\n    return {\n        def: def,\n        instance: instance\n    };\n}\n// Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\nfunction getDragMetaFromEl(el) {\n    var str = getEmbeddedElData(el, \"event\");\n    var obj = str ? JSON.parse(str) : {\n        create: false\n    }; // if no embedded data, assume no event creation\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(obj);\n}\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix = \"\";\nfunction getEmbeddedElData(el, name) {\n    var prefix = _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix;\n    var prefixedName = (prefix ? prefix + \"-\" : \"\") + name;\n    return el.getAttribute(\"data-\" + prefixedName) || \"\";\n}\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/ var ExternalDraggable = /** @class */ function() {\n    function ExternalDraggable(el, settings) {\n        var _this = this;\n        if (settings === void 0) {\n            settings = {};\n        }\n        this.handlePointerDown = function(ev) {\n            var dragging = _this.dragging;\n            var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;\n            dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.eventDragMinDistance;\n            dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.longPressDelay : 0;\n        };\n        this.handleDragStart = function(ev) {\n            if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains(\"fc-event\")) {\n                _this.dragging.mirror.getMirrorEl().classList.add(\"fc-event-selected\");\n            }\n        };\n        this.settings = settings;\n        var dragging = this.dragging = new FeaturefulElementDragging(el);\n        dragging.touchScrollAllowed = false;\n        if (settings.itemSelector != null) {\n            dragging.pointer.selector = settings.itemSelector;\n        }\n        if (settings.appendTo != null) {\n            dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n        }\n        dragging.emitter.on(\"pointerdown\", this.handlePointerDown);\n        dragging.emitter.on(\"dragstart\", this.handleDragStart);\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ExternalDraggable.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return ExternalDraggable;\n}();\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/ var InferredElementDragging = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(InferredElementDragging, _super);\n    function InferredElementDragging(containerEl) {\n        var _this = _super.call(this, containerEl) || this;\n        _this.shouldIgnoreMove = false;\n        _this.mirrorSelector = \"\";\n        _this.currentMirrorEl = null;\n        _this.handlePointerDown = function(ev) {\n            _this.emitter.trigger(\"pointerdown\", ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragstart right away. does not support delay or min-distance\n                _this.emitter.trigger(\"dragstart\", ev);\n            }\n        };\n        _this.handlePointerMove = function(ev) {\n            if (!_this.shouldIgnoreMove) {\n                _this.emitter.trigger(\"dragmove\", ev);\n            }\n        };\n        _this.handlePointerUp = function(ev) {\n            _this.emitter.trigger(\"pointerup\", ev);\n            if (!_this.shouldIgnoreMove) {\n                // fire dragend right away. does not support a revert animation\n                _this.emitter.trigger(\"dragend\", ev);\n            }\n        };\n        var pointer = _this.pointer = new PointerDragging(containerEl);\n        pointer.emitter.on(\"pointerdown\", _this.handlePointerDown);\n        pointer.emitter.on(\"pointermove\", _this.handlePointerMove);\n        pointer.emitter.on(\"pointerup\", _this.handlePointerUp);\n        return _this;\n    }\n    InferredElementDragging.prototype.destroy = function() {\n        this.pointer.destroy();\n    };\n    InferredElementDragging.prototype.setIgnoreMove = function(bool) {\n        this.shouldIgnoreMove = bool;\n    };\n    InferredElementDragging.prototype.setMirrorIsVisible = function(bool) {\n        if (bool) {\n            // restore a previously hidden element.\n            // use the reference in case the selector class has already been removed.\n            if (this.currentMirrorEl) {\n                this.currentMirrorEl.style.visibility = \"\";\n                this.currentMirrorEl = null;\n            }\n        } else {\n            var mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;\n            if (mirrorEl) {\n                this.currentMirrorEl = mirrorEl;\n                mirrorEl.style.visibility = \"hidden\";\n            }\n        }\n    };\n    return InferredElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/ var ThirdPartyDraggable = /** @class */ function() {\n    function ThirdPartyDraggable(containerOrSettings, settings) {\n        var containerEl = document;\n        if (// wish we could just test instanceof EventTarget, but doesn't work in IE11\n        containerOrSettings === document || containerOrSettings instanceof Element) {\n            containerEl = containerOrSettings;\n            settings = settings || {};\n        } else {\n            settings = containerOrSettings || {};\n        }\n        var dragging = this.dragging = new InferredElementDragging(containerEl);\n        if (typeof settings.itemSelector === \"string\") {\n            dragging.pointer.selector = settings.itemSelector;\n        } else if (containerEl === document) {\n            dragging.pointer.selector = \"[data-event]\";\n        }\n        if (typeof settings.mirrorSelector === \"string\") {\n            dragging.mirrorSelector = settings.mirrorSelector;\n        }\n        new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n    }\n    ThirdPartyDraggable.prototype.destroy = function() {\n        this.dragging.destroy();\n    };\n    return ThirdPartyDraggable;\n}();\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    componentInteractions: [\n        DateClicking,\n        DateSelecting,\n        EventDragging,\n        EventResizing\n    ],\n    calendarInteractions: [\n        UnselectAuto\n    ],\n    elementDraggingImpl: FeaturefulElementDragging,\n    optionRefiners: OPTION_REFINERS,\n    listenerRefiners: LISTENER_REFINERS\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n //# sourceMappingURL=main.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBSUEsR0FDdThCO0FBQzM1QjtBQUU1Q0EsNkVBQTJCLEdBQUc7QUFDOUIsSUFBSTBELG1CQUFtQjtBQUN2QixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLDZCQUE2QixLQUFLO0FBQ3RDOzs7Ozs7Ozs7Ozs7QUFZQSxHQUNBLElBQUlDLGtCQUFrQixXQUFXLEdBQUksV0FBWTtJQUM3QyxTQUFTQSxnQkFBZ0JDLFdBQVcsRUFBRTtRQUNsQyxJQUFJQyxRQUFRLElBQUk7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSTtRQUNyQixrREFBa0Q7UUFDbEQsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxnRUFBZ0U7UUFDcEYsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxLQUFLO1FBQzdCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsSUFBSSxFQUFFLHVDQUF1QztRQUN0RSxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsS0FBSztRQUN2QixJQUFJLENBQUNDLGVBQWUsR0FBRyxLQUFLO1FBQzVCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEtBQUs7UUFDM0IsUUFBUTtRQUNSLHVHQUF1RztRQUN2RyxJQUFJLENBQUNDLGVBQWUsR0FBRyxTQUFVQyxFQUFFLEVBQUU7WUFDakMsSUFBSSxDQUFDVixNQUFNVyxpQkFBaUIsTUFDeEJDLHFCQUFxQkYsT0FDckJWLE1BQU1hLFFBQVEsQ0FBQ0gsS0FBSztnQkFDcEIsSUFBSUksTUFBTWQsTUFBTWUsb0JBQW9CLENBQUNMLElBQUksSUFBSTtnQkFDN0NWLE1BQU1nQixPQUFPLENBQUNDLE9BQU8sQ0FBQyxlQUFlSDtnQkFDckNkLE1BQU1rQixlQUFlLENBQUNKO2dCQUN0QixJQUFJLENBQUNkLE1BQU1JLGdCQUFnQixFQUFF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L0IsT0FBTyxDQUFDOU0sUUFBUSxHQUFHO1FBQ2hDLENBQUM7UUFDRCxJQUFJLE9BQU80UyxTQUFTK0wsY0FBYyxLQUFLLFVBQVU7WUFDN0M5UCxTQUFTOFAsY0FBYyxHQUFHL0wsU0FBUytMLGNBQWM7UUFDckQsQ0FBQztRQUNELElBQUluQyx3QkFBd0IzTixVQUFVK0QsU0FBUzZMLFNBQVMsR0FBRyw2QkFBNkI7SUFDNUY7SUFDQUssb0JBQW9CNWIsU0FBUyxDQUFDQyxPQUFPLEdBQUcsV0FBWTtRQUNoRCxJQUFJLENBQUMwTCxRQUFRLENBQUMxTCxPQUFPO0lBQ3pCO0lBQ0EsT0FBTzJiO0FBQ1g7QUFFQSxJQUFJRyxPQUFPNWYsa0VBQVlBLENBQUM7SUFDcEI2Zix1QkFBdUI7UUFBQ3ZNO1FBQWNVO1FBQWU0QjtRQUFla0Y7S0FBYztJQUNsRmdGLHNCQUFzQjtRQUFDckU7S0FBYTtJQUNwQ3NFLHFCQUFxQmhUO0lBQ3JCaVQsZ0JBQWdCekQ7SUFDaEIwRCxrQkFBa0J6RDtBQUN0QjtBQUVBLCtEQUFlb0QsSUFBSUEsRUFBQztBQUN1RixDQUMzRyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb24vbWFpbi5qcz8yMTIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuRnVsbENhbGVuZGFyIHY1LjExLjNcbkRvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbihjKSAyMDIyIEFkYW0gU2hhd1xuKi9cbmltcG9ydCB7IGNvbmZpZywgZWxlbWVudENsb3Nlc3QsIEVtaXR0ZXIsIGFwcGx5U3R5bGUsIHdoZW5UcmFuc2l0aW9uRG9uZSwgcmVtb3ZlRWxlbWVudCwgU2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIsIGNvbXB1dGVJbm5lclJlY3QsIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsIGdldEVsUm9vdCwgcHJldmVudFNlbGVjdGlvbiwgcHJldmVudENvbnRleHRNZW51LCBhbGxvd1NlbGVjdGlvbiwgYWxsb3dDb250ZXh0TWVudSwgRWxlbWVudERyYWdnaW5nLCBjb21wdXRlUmVjdCwgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBwb2ludEluc2lkZVJlY3QsIGlzRGF0ZVNwYW5zRXF1YWwsIGNvbnN0cmFpblBvaW50LCBpbnRlcnNlY3RSZWN0cywgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgbWFwSGFzaCwgcmFuZ2VDb250YWluc1JhbmdlLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSwgSW50ZXJhY3Rpb24sIGlzRGF0ZVNlbGVjdGlvblZhbGlkLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsIHRyaWdnZXJEYXRlU2VsZWN0LCBjb21wYXJlTnVtYmVycywgZ2V0RWxTZWcsIGdldFJlbGV2YW50RXZlbnRzLCBFdmVudEFwaSwgY3JlYXRlRW1wdHlFdmVudFN0b3JlLCBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlLCBpc0ludGVyYWN0aW9uVmFsaWQsIGJ1aWxkRXZlbnRBcGlzLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsIHN0YXJ0T2ZEYXksIGRpZmZEYXRlcywgY3JlYXRlRHVyYXRpb24sIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCwgaWRlbnRpdHksIGV2ZW50VHVwbGVUb1N0b3JlLCBwYXJzZURyYWdNZXRhLCBlbGVtZW50TWF0Y2hlcywgcmVmaW5lRXZlbnREZWYsIHBhcnNlRXZlbnREZWYsIGdldERlZmF1bHRFdmVudEVuZCwgY3JlYXRlRXZlbnRJbnN0YW5jZSwgQkFTRV9PUFRJT05fREVGQVVMVFMsIGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJztcbmltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5cbmNvbmZpZy50b3VjaE1vdXNlSWdub3JlV2FpdCA9IDUwMDtcbnZhciBpZ25vcmVNb3VzZURlcHRoID0gMDtcbnZhciBsaXN0ZW5lckNudCA9IDA7XG52YXIgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcbi8qXG5Vc2VzIGEgXCJwb2ludGVyXCIgYWJzdHJhY3Rpb24sIHdoaWNoIG1vbml0b3JzIFVJIGV2ZW50cyBmb3IgYm90aCBtb3VzZSBhbmQgdG91Y2guXG5UcmFja3Mgd2hlbiB0aGUgcG9pbnRlciBcImRyYWdzXCIgb24gYSBjZXJ0YWluIGVsZW1lbnQsIG1lYW5pbmcgZG93bittb3ZlK3VwLlxuXG5BbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cbkFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cbkFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBwb2ludGVybW92ZVxuLSBwb2ludGVydXBcbiovXG52YXIgUG9pbnRlckRyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgYXNzaWduZWQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSAnJzsgLy8gd2lsbCBjYXVzZSBzdWJqZWN0RWwgaW4gYWxsIGVtaXR0ZWQgZXZlbnRzIHRvIGJlIHRoaXMgZWxlbWVudFxuICAgICAgICB0aGlzLmhhbmRsZVNlbGVjdG9yID0gJyc7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZFdhdGNoU2Nyb2xsID0gdHJ1ZTsgLy8gZm9yIHNpbXVsYXRpbmcgcG9pbnRlcm1vdmUgb24gc2Nyb2xsXG4gICAgICAgIC8vIGludGVybmFsIHN0YXRlc1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53YXNUb3VjaFNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAvLyBNb3VzZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy50cnlTdGFydChldikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIF90aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3RoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgcGV2ID0gX3RoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpO1xuICAgICAgICAgICAgX3RoaXMucmVjb3JkQ29vcmRzKHBldik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF90aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBfdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldikpO1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICB9O1xuICAgICAgICAvLyBUb3VjaFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzVG91Y2hEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0U2Nyb2xsV2F0Y2gocGV2KTtcbiAgICAgICAgICAgICAgICAvLyB1bmxpa2UgbW91c2UsIG5lZWQgdG8gYXR0YWNoIHRvIHRhcmdldCwgbm90IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ1NzYwMDE0XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlVG91Y2hTY3JvbGwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHBldiA9IF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KTtcbiAgICAgICAgICAgIF90aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIGRvbmUgdG8gZ3VhcmQgYWdhaW5zdCB0b3VjaGVuZCBmb2xsb3dlZCBieSB0b3VjaGNhbmNlbFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX3RoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX3RoaXMuaGFuZGxlVG91Y2hFbmQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIF90aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICAgICAgICAgIF90aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0YXJ0SWdub3JpbmdNb3VzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMud2FzVG91Y2hTY3JvbGwgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VYID0gKHdpbmRvdy5wYWdlWE9mZnNldCAtIF90aGlzLnByZXZTY3JvbGxYKSArIF90aGlzLnByZXZQYWdlWDtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IC0gX3RoaXMucHJldlNjcm9sbFkpICsgX3RoaXMucHJldlBhZ2VZO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2g6IF90aGlzLmlzVG91Y2hEcmFnZ2luZyxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdEVsOiBfdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVg6IHBhZ2VYIC0gX3RoaXMub3JpZ1BhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVk6IHBhZ2VZIC0gX3RoaXMub3JpZ1BhZ2VZLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBsaXN0ZW5lckNyZWF0ZWQoKTtcbiAgICB9XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyRGVzdHJveWVkKCk7XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLnRyeVN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBzdWJqZWN0RWwgPSB0aGlzLnF1ZXJ5U3ViamVjdEVsKGV2KTtcbiAgICAgICAgdmFyIGRvd25FbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCAmJlxuICAgICAgICAgICAgKCF0aGlzLmhhbmRsZVNlbGVjdG9yIHx8IGVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7IC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgd2FzVG91Y2hTY3JvbGwgYXJvdW5kIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKTtcbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUucXVlcnlTdWJqZWN0RWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsO1xuICAgIH07XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZU1vdXNlRGVwdGggfHwgdGhpcy5pc1RvdWNoRHJhZ2dpbmc7XG4gICAgfTtcbiAgICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUuY2FuY2VsVG91Y2hTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU2Nyb2xsaW5nIHRoYXQgc2ltdWxhdGVzIHBvaW50ZXJtb3Zlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmluaXRTY3JvbGxXYXRjaCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMoZXYpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZT10cnVlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvaW50ZXJEcmFnZ2luZy5wcm90b3R5cGUucmVjb3JkQ29vcmRzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmRlc3Ryb3lTY3JvbGxXYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRXZlbnQgTm9ybWFsaXphdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBQb2ludGVyRHJhZ2dpbmcucHJvdG90eXBlLmNyZWF0ZUV2ZW50RnJvbU1vdXNlID0gZnVuY3Rpb24gKGV2LCBpc0ZpcnN0KSB7XG4gICAgICAgIHZhciBkZWx0YVggPSAwO1xuICAgICAgICB2YXIgZGVsdGFZID0gMDtcbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gZXYucGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IGV2LnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gZXYucGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IGV2LnBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiBmYWxzZSxcbiAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICBwYWdlWDogZXYucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXYucGFnZVksXG4gICAgICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUG9pbnRlckRyYWdnaW5nLnByb3RvdHlwZS5jcmVhdGVFdmVudEZyb21Ub3VjaCA9IGZ1bmN0aW9uIChldiwgaXNGaXJzdCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGV2LnRvdWNoZXM7XG4gICAgICAgIHZhciBwYWdlWDtcbiAgICAgICAgdmFyIHBhZ2VZO1xuICAgICAgICB2YXIgZGVsdGFYID0gMDtcbiAgICAgICAgdmFyIGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIGlmIHRvdWNoIGNvb3JkcyBhdmFpbGFibGUsIHByZWZlcixcbiAgICAgICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxuICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IHBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZOiBkZWx0YVksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUG9pbnRlckRyYWdnaW5nO1xufSgpKTtcbi8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcbiAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xufVxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XG4gICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XG4gICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcbn1cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgKz0gMTtcbiAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICAgIGxpc3RlbmVyQ250IC09IDE7XG4gICAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcbiAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG52YXIgRWxlbWVudE1pcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50TWlycm9yKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXG4gICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcbiAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IChwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCkgLSB0aGlzLm9yaWdTY3JlZW5YO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IChwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCkgLSB0aGlzLm9yaWdTY3JlZW5ZO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTtcbiAgICB9O1xuICAgIC8vIGNhbiBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuc2V0SXNWaXNpYmxlID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sOyAvLyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHVwZGF0ZUVsUG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTsgLy8gYmVjYXVzZSB3YXMgbm90IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBpbnZpc2libGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2w7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGFsd2F5cyBhc3luY1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5lZWRzUmV2ZXJ0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSAmJlxuICAgICAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiAmJiAvLyBpZiAwLCB0cmFuc2l0aW9uIHdvbid0IHdvcmtcbiAgICAgICAgICAgICh0aGlzLmRlbHRhWCB8fCB0aGlzLmRlbHRhWSkgLy8gaWYgc2FtZSBjb29yZHMsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuZG9SZXZlcnRBbmltYXRpb24oZG9uZSwgdGhpcy5yZXZlcnREdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvbmUsIDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50TWlycm9yLnByb3RvdHlwZS5kb1JldmVydEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcmV2ZXJ0RHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbDtcbiAgICAgICAgdmFyIGZpbmFsU291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gYmVjYXVzZSBhdXRvc2Nyb2xsaW5nIG1pZ2h0IGhhdmUgaGFwcGVuZWRcbiAgICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgICAgICAgICAndG9wICcgKyByZXZlcnREdXJhdGlvbiArICdtcywnICtcbiAgICAgICAgICAgICAgICAnbGVmdCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMnO1xuICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgIH0pO1xuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmUobWlycm9yRWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudE1pcnJvci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLnVwZGF0ZUVsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZUVsICYmIHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHRoaXMuZ2V0TWlycm9yRWwoKSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc291cmNlRWxSZWN0LmxlZnQgKyB0aGlzLmRlbHRhWCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc291cmNlRWxSZWN0LnRvcCArIHRoaXMuZGVsdGFZLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnRNaXJyb3IucHJvdG90eXBlLmdldE1pcnJvckVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3Q7XG4gICAgICAgIHZhciBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGlmICghbWlycm9yRWwpIHtcbiAgICAgICAgICAgIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCA9IHRoaXMuc291cmNlRWwuY2xvbmVOb2RlKHRydWUpOyAvLyBjbG9uZUNoaWxkcmVuPXRydWVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtdW5zZWxlY3RhYmxlJyk7XG4gICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNvdXJjZUVsUmVjdC5yaWdodCAtIHNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogc291cmNlRWxSZWN0LmJvdHRvbSAtIHNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pcnJvckVsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRNaXJyb3I7XG59KCkpO1xuXG4vKlxuSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcbmluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cblxuVGhlIGNhY2hlIGNhbiBiZSBpbiBvbmUgb2YgdHdvIG1vZGVzOlxuLSBkb2VzTGlzdGVuaW5nOmZhbHNlIC0gaWdub3JlcyB3aGVuIHRoZSBjb250YWluZXIgaXMgc2Nyb2xsZWQgYnkgc29tZW9uZSBlbHNlXG4tIGRvZXNMaXN0ZW5pbmc6dHJ1ZSAtIHdhdGNoIGZvciBzY3JvbGxpbmcgYW5kIHVwZGF0ZSB0aGUgY2FjaGVcbiovXG52YXIgU2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nyb2xsR2VvbUNhY2hlKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9wID0gX3RoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbExlZnQgPSBfdGhpcy5zY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlcjtcbiAgICAgICAgX3RoaXMuZG9lc0xpc3RlbmluZyA9IGRvZXNMaXN0ZW5pbmc7XG4gICAgICAgIF90aGlzLnNjcm9sbFRvcCA9IF90aGlzLm9yaWdTY3JvbGxUb3AgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICBfdGhpcy5zY3JvbGxMZWZ0ID0gX3RoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsV2lkdGggPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbFdpZHRoKCk7XG4gICAgICAgIF90aGlzLnNjcm9sbEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgICAgIF90aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xuICAgICAgICBfdGhpcy5jbGllbnRIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldENsaWVudEhlaWdodCgpO1xuICAgICAgICBfdGhpcy5jbGllbnRSZWN0ID0gX3RoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgaWYgKF90aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIF90aGlzLmdldEV2ZW50VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxMZWZ0KHRvcCk7XG4gICAgICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRvcCwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoO1xuICAgIH07XG4gICAgU2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodDtcbiAgICB9O1xuICAgIFNjcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIFNjcm9sbEdlb21DYWNoZTtcbn0oU2Nyb2xsQ29udHJvbGxlcikpO1xuXG52YXIgRWxlbWVudFNjcm9sbEdlb21DYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFNjcm9sbEdlb21DYWNoZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlLnByb3RvdHlwZS5nZXRFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUlubmVyUmVjdCh0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGU7XG59KFNjcm9sbEdlb21DYWNoZSkpO1xuXG52YXIgV2luZG93U2Nyb2xsR2VvbUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dTY3JvbGxHZW9tQ2FjaGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93U2Nyb2xsR2VvbUNhY2hlKGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCksIGRvZXNMaXN0ZW5pbmcpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuZ2V0RXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUucHJvdG90eXBlLmNvbXB1dGVDbGllbnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gdGhlIHdpbmRvdyBpcyB0aGUgb25seSBzY3JvbGwgb2JqZWN0IHRoYXQgY2hhbmdlcyBpdCdzIHJlY3RhbmdsZSByZWxhdGl2ZVxuICAgIC8vIHRvIHRoZSBkb2N1bWVudCdzIHRvcGxlZnQgYXMgaXQgc2Nyb2xsc1xuICAgIFdpbmRvd1Njcm9sbEdlb21DYWNoZS5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93U2Nyb2xsR2VvbUNhY2hlO1xufShTY3JvbGxHZW9tQ2FjaGUpKTtcblxuLy8gSWYgYXZhaWxhYmxlIHdlIGFyZSB1c2luZyBuYXRpdmUgXCJwZXJmb3JtYW5jZVwiIEFQSSBpbnN0ZWFkIG9mIFwiRGF0ZVwiXG4vLyBSZWFkIG1vcmUgYWJvdXQgaXQgb24gTUROOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlXG52YXIgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xuLypcbkZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcbmFwcHJvYWNoZXMgdGhlIGVkZ2UuXG5cblRoZSBjYWxsZXIgbXVzdCBjYWxsIHN0YXJ0ICsgaGFuZGxlTW92ZSArIHN0b3AuXG4qL1xudmFyIEF1dG9TY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRvU2Nyb2xsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsUXVlcnkgPSBbd2luZG93LCAnLmZjLXNjcm9sbGVyJ107XG4gICAgICAgIHRoaXMuZWRnZVRocmVzaG9sZCA9IDUwOyAvLyBwaXhlbHNcbiAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSA9IDMwMDsgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgLy8gcHJvdGVjdCBhZ2FpbnN0IHRoZSBpbml0aWFsIHBvaW50ZXJkb3duIGJlaW5nIHRvbyBjbG9zZSB0byBhbiBlZGdlIGFuZCBzdGFydGluZyB0aGUgc2Nyb2xsXG4gICAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0FuaW1hdGluZykgeyAvLyB3YXNuJ3QgY2FuY2VsbGVkIGJldHdlZW4gYW5pbWF0aW9uIGNhbGxzXG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpcy5jb21wdXRlQmVzdEVkZ2UoX3RoaXMucG9pbnRlclNjcmVlblggKyB3aW5kb3cucGFnZVhPZmZzZXQsIF90aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTaWRlKGVkZ2UsIChub3cgLSBfdGhpcy5tc1NpbmNlUmVxdWVzdCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gd2lsbCBzdG9wIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRlclNjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIHZhciB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIHZhciB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zY3JvbGxDYWNoZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5yZXF1ZXN0QW5pbWF0aW9uID0gZnVuY3Rpb24gKG5vdykge1xuICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcbiAgICB9O1xuICAgIEF1dG9TY3JvbGxlci5wcm90b3R5cGUuaGFuZGxlU2lkZSA9IGZ1bmN0aW9uIChlZGdlLCBzZWNvbmRzKSB7XG4gICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IGVkZ2Uuc2Nyb2xsQ2FjaGU7XG4gICAgICAgIHZhciBlZGdlVGhyZXNob2xkID0gdGhpcy5lZGdlVGhyZXNob2xkO1xuICAgICAgICB2YXIgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcbiAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xuICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XG4gICAgICAgIHZhciBzaWduID0gMTtcbiAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmNvbXB1dGVCZXN0RWRnZSA9IGZ1bmN0aW9uIChsZWZ0LCB0b3ApIHtcbiAgICAgICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSB0aGlzLmVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBiZXN0U2lkZSA9IG51bGw7XG4gICAgICAgIHZhciBzY3JvbGxDYWNoZXMgPSB0aGlzLnNjcm9sbENhY2hlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzY3JvbGxDYWNoZXNfMSA9IHNjcm9sbENhY2hlczsgX2kgPCBzY3JvbGxDYWNoZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IHNjcm9sbENhY2hlc18xW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcbiAgICAgICAgICAgIHZhciBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICB2YXIgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xuICAgICAgICAgICAgdmFyIGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xuICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAndG9wJywgZGlzdGFuY2U6IHRvcERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbURpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZERvd24gJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsRG93bigpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGU6IHNjcm9sbENhY2hlLCBuYW1lOiAnYm90dG9tJywgZGlzdGFuY2U6IGJvdHRvbURpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRMZWZ0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbExlZnQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gbGVmdERpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZTogc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlOiBzY3JvbGxDYWNoZSwgbmFtZTogJ3JpZ2h0JywgZGlzdGFuY2U6IHJpZ2h0RGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdFNpZGU7XG4gICAgfTtcbiAgICBBdXRvU2Nyb2xsZXIucHJvdG90eXBlLmJ1aWxkQ2FjaGVzID0gZnVuY3Rpb24gKHNjcm9sbFN0YXJ0RWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTY3JvbGxFbHMoc2Nyb2xsU3RhcnRFbCkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpbmRvd1Njcm9sbEdlb21DYWNoZShmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShlbCwgZmFsc2UpOyAvLyBmYWxzZSA9IGRvbid0IGxpc3RlbiB0byB1c2VyLWdlbmVyYXRlZCBzY3JvbGxzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b1Njcm9sbGVyLnByb3RvdHlwZS5xdWVyeVNjcm9sbEVscyA9IGZ1bmN0aW9uIChzY3JvbGxTdGFydEVsKSB7XG4gICAgICAgIHZhciBlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsUXVlcnk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVscy5wdXNoLmFwcGx5KGVscywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0RWxSb290KHNjcm9sbFN0YXJ0RWwpLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVscztcbiAgICB9O1xuICAgIHJldHVybiBBdXRvU2Nyb2xsZXI7XG59KCkpO1xuXG4vKlxuTW9uaXRvcnMgZHJhZ2dpbmcgb24gYW4gZWxlbWVudC4gSGFzIGEgbnVtYmVyIG9mIGhpZ2gtbGV2ZWwgZmVhdHVyZXM6XG4tIG1pbmltdW0gZGlzdGFuY2UgcmVxdWlyZWQgYmVmb3JlIGRyYWdnaW5nXG4tIG1pbmltdW0gd2FpdCB0aW1lIChcImRlbGF5XCIpIGJlZm9yZSBkcmFnZ2luZ1xuLSBhIG1pcnJvciBlbGVtZW50IHRoYXQgZm9sbG93cyB0aGUgcG9pbnRlclxuKi9cbnZhciBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRhaW5lckVsKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcbiAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxuICAgICAgICBfdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIF90aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgX3RoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG4gICAgICAgIF90aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTsgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgIF90aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldmVudFNlbGVjdGlvbihkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxuICAgICAgICAgICAgICAgIC8vIGFsc28gcHJldmVudHMgc2VsZWN0aW9uIGluIG9sZGVyIGJyb3dzZXJzIChtYXliZT8pLlxuICAgICAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxuICAgICAgICAgICAgICAgIGlmICghZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNJbnRlcmFjdGluZyAmJiAvLyBub3QgZGVzdHJveWVkIHZpYSBwb2ludGVyZG93biBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5wb2ludGVyLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9ucyByZWxhdGVkIHRvIGluaXRpYXRpbmcgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQuLi5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5taXJyb3Iuc3RhcnQoZXYuc3ViamVjdEVsLCBldi5wYWdlWCwgZXYucGFnZVkpOyAvLyBtdXN0IGhhcHBlbiBvbiBmaXJzdCBwb2ludGVyIGRvd25cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnREZWxheShldik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Qb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSBfdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlU3EgPSB2b2lkIDA7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVggPSBldi5kZWx0YVgsIGRlbHRhWSA9IGV2LmRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmVhbCBwb2ludGVyIG1vdmU/IChub3Qgb25lIHNpbXVsYXRlZCBieSBzY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5vcmlnRXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdXRvU2Nyb2xsZXIuaGFuZGxlTW92ZShldi5wYWdlWCwgZXYucGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBvaW50ZXJVcCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsb3dTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGF5VGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb2ludGVyID0gX3RoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgX3RoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCBfdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcG9pbnRlci5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLm1pcnJvciA9IG5ldyBFbGVtZW50TWlycm9yKCk7XG4gICAgICAgIF90aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyBIQUNLOiBzaW11bGF0ZSBhIHBvaW50ZXItdXAgdG8gZW5kIHRoZSBjdXJyZW50IGRyYWdcbiAgICAgICAgLy8gVE9ETzogZmlyZSAnZHJhZ2VuZCcgZGlyZWN0bHkgYW5kIHN0b3AgaW50ZXJhY3Rpb24uIGRpc2NvdXJhZ2UgdXNlIG9mIHBvaW50ZXJ1cCBldmVudCAoYi9jIG1pZ2h0IG5vdCBmaXJlKVxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwKHt9KTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnN0YXJ0RGVsYXkgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTsgLy8gbm90IGFzc2lnbmFibGUgdG8gbnVtYmVyIVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZURlbGF5RW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUudHJ5U3RhcnREcmFnID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCAmJiB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyLndhc1RvdWNoU2Nyb2xsIHx8IHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RhcnQoZXYucGFnZVgsIGV2LnBhZ2VZLCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLmNhbmNlbFRvdWNoU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS50cnlTdG9wRHJhZyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXG4gICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xuICAgIH07XG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgIH07XG4gICAgLy8gZmlsbCBpbiB0aGUgaW1wbGVtZW50YXRpb25zLi4uXG4gICAgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy5wcm90b3R5cGUuc2V0SWdub3JlTW92ZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbDtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcbiAgICB9O1xuICAgIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvck5lZWRzUmV2ZXJ0ID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGJvb2w7XG4gICAgfTtcbiAgICBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRBdXRvU2Nyb2xsRW5hYmxlZCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGJvb2w7XG4gICAgfTtcbiAgICByZXR1cm4gRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZztcbn0oRWxlbWVudERyYWdnaW5nKSk7XG5cbi8qXG5XaGVuIHRoaXMgY2xhc3MgaXMgaW5zdGFudGlhdGVkLCBpdCByZWNvcmRzIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCAocmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvcGxlZnQpLFxuYW5kIGNvbnRpbnVlcyB0byBtb25pdG9yIHNjcm9sbGluZywgdXBkYXRpbmcgdGhlIGNhY2hlZCBjb29yZGluYXRlcyBpZiBpdCBuZWVkcyB0by5cbkRvZXMgbm90IGFjY2VzcyB0aGUgRE9NIGFmdGVyIGluc3RhbnRpYXRpb24sIHNvIGhpZ2hseSBwZXJmb3JtYW50LlxuXG5BbHNvIGtlZXBzIHRyYWNrIG9mIGFsbCBzY3JvbGxpbmcvb3ZlcmZsb3c6aGlkZGVuIGNvbnRhaW5lcnMgdGhhdCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuYW5kIGFuIGRldGVybWluZSBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgY29tYmluZWQgY2xpcHBpbmcgcmVjdGFuZ2xlLlxuKi9cbnZhciBPZmZzZXRUcmFja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9mZnNldFRyYWNrZXIoZWwpIHtcbiAgICAgICAgdGhpcy5vcmlnUmVjdCA9IGNvbXB1dGVSZWN0KGVsKTtcbiAgICAgICAgLy8gd2lsbCB3b3JrIGZpbmUgZm9yIGRpdnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlblxuICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCkubWFwKGZ1bmN0aW9uIChzY3JvbGxFbCkgeyByZXR1cm4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoc2Nyb2xsRWwsIHRydWUpOyB9KTtcbiAgICB9XG4gICAgT2Zmc2V0VHJhY2tlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm9yaWdSZWN0LmxlZnQ7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcbiAgICBPZmZzZXRUcmFja2VyLnByb3RvdHlwZS5jb21wdXRlVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5vcmlnUmVjdC50b3A7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnNjcm9sbENhY2hlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxDYWNoZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHRvcCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsVG9wIC0gc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcDtcbiAgICB9O1xuICAgIE9mZnNldFRyYWNrZXIucHJvdG90eXBlLmlzV2l0aGluQ2xpcHBpbmcgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHsgbGVmdDogcGFnZVgsIHRvcDogcGFnZVkgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc2Nyb2xsQ2FjaGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNjcm9sbENhY2hlID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKCFpc0lnbm9yZWRDbGlwcGluZyhzY3JvbGxDYWNoZS5nZXRFdmVudFRhcmdldCgpKSAmJlxuICAgICAgICAgICAgICAgICFwb2ludEluc2lkZVJlY3QocG9pbnQsIHNjcm9sbENhY2hlLmNsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9mZnNldFRyYWNrZXI7XG59KCkpO1xuLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxuZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xuICAgIHZhciB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xufVxuXG4vKlxuVHJhY2tzIG1vdmVtZW50IG92ZXIgbXVsdGlwbGUgZHJvcHBhYmxlIGFyZWFzIChha2EgXCJoaXRzXCIpXG50aGF0IGV4aXN0IGluIG9uZSBvciBtb3JlIERhdGVDb21wb25lbnRzLlxuUmVsaWVzIG9uIGFuIGV4aXN0aW5nIGRyYWdnYWJsZS5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcbi0gcG9pbnRlcnVwXG4tIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcbi0gZHJhZ2VuZFxuKi9cbnZhciBIaXREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaXREcmFnZ2luZyhkcmFnZ2luZywgZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMudXNlU3ViamVjdENlbnRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVpcmVJbml0aWFsID0gdHJ1ZTsgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xuICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxIaXQgPSBudWxsOyAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbEhpdCA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuZmluYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucHJlcGFyZUhpdHMoKTtcbiAgICAgICAgICAgIF90aGlzLnByb2Nlc3NGaXJzdENvb3JkKGV2KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbml0aWFsSGl0IHx8ICFfdGhpcy5yZXF1aXJlSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZU1vdmUoZXYsIHRydWUpOyAvLyBmb3JjZSA9IGZpcmUgZXZlbiBpZiBpbml0aWFsbHkgbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW92ZShldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5yZWxlYXNlSGl0cygpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKF90aGlzLm1vdmluZ0hpdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgbnVsbCwgdHJ1ZSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZmluYWxIaXQgPSBfdGhpcy5tb3ZpbmdIaXQ7XG4gICAgICAgICAgICBfdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyb3BwYWJsZVN0b3JlID0gZHJvcHBhYmxlU3RvcmU7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ21vdmUnLCB0aGlzLmhhbmRsZURyYWdNb3ZlKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnByb2Nlc3NGaXJzdENvb3JkID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH07XG4gICAgICAgIHZhciBhZGp1c3RlZFBvaW50ID0gb3JpZ1BvaW50O1xuICAgICAgICB2YXIgc3ViamVjdEVsID0gZXYuc3ViamVjdEVsO1xuICAgICAgICB2YXIgc3ViamVjdFJlY3Q7XG4gICAgICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBjb25zdHJhaW5Qb2ludChhZGp1c3RlZFBvaW50LCBzdWJqZWN0UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRpYWxIaXQgPSB0aGlzLmluaXRpYWxIaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KGFkanVzdGVkUG9pbnQubGVmdCwgYWRqdXN0ZWRQb2ludC50b3ApO1xuICAgICAgICBpZiAoaW5pdGlhbEhpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlU3ViamVjdENlbnRlciAmJiBzdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gZ2V0UmVjdENlbnRlcihzbGljZWRTdWJqZWN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IGRpZmZQb2ludHMoYWRqdXN0ZWRQb2ludCwgb3JpZ1BvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldiwgZm9yY2VIYW5kbGUpIHtcbiAgICAgICAgdmFyIGhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoZXYucGFnZVggKyB0aGlzLmNvb3JkQWRqdXN0LmxlZnQsIGV2LnBhZ2VZICsgdGhpcy5jb29yZEFkanVzdC50b3ApO1xuICAgICAgICBpZiAoZm9yY2VIYW5kbGUgfHwgIWlzSGl0c0VxdWFsKHRoaXMubW92aW5nSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IGhpdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBoaXQsIGZhbHNlLCBldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhpdERyYWdnaW5nLnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IG1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgZnVuY3Rpb24gKGludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSGl0RHJhZ2dpbmcucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0VHJhY2tlcnMgPSB0aGlzLm9mZnNldFRyYWNrZXJzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0ge307XG4gICAgfTtcbiAgICBIaXREcmFnZ2luZy5wcm90b3R5cGUucXVlcnlIaXRGb3JPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRyb3BwYWJsZVN0b3JlID0gX2EuZHJvcHBhYmxlU3RvcmUsIG9mZnNldFRyYWNrZXJzID0gX2Eub2Zmc2V0VHJhY2tlcnM7XG4gICAgICAgIHZhciBiZXN0SGl0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50O1xuICAgICAgICAgICAgdmFyIG9mZnNldFRyYWNrZXIgPSBvZmZzZXRUcmFja2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAob2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5pc1dpdGhpbkNsaXBwaW5nKG9mZnNldExlZnQsIG9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luTGVmdCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZUxlZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luVG9wID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlVG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uTGVmdCA9IG9mZnNldExlZnQgLSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblRvcCA9IG9mZnNldFRvcCAtIG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ1JlY3QgPSBvZmZzZXRUcmFja2VyLm9yaWdSZWN0O1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHdpdGhpbiB0aGUgZWxlbWVudCdzIGJvdW5kc1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IHdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxuICAgICAgICAgICAgICAgICAgICByYW5nZUNvbnRhaW5zUmFuZ2UoaGl0LmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBoaXQuZGF0ZVNwYW4ucmFuZ2UpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XG4gICAgfTtcbiAgICByZXR1cm4gSGl0RHJhZ2dpbmc7XG59KCkpO1xuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVQb2ludFRyYW5zZm9ybXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfYVtfaV07XG4gICAgICAgIF9fYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgX19hc3NpZ24ocHJvcHMsIGJ1aWxkRGF0ZVBvaW50QXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgICAgIGRhdGVTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHNwYW4ucmFuZ2Uuc3RhcnQsIHsgb21pdFRpbWU6IHNwYW4uYWxsRGF5IH0pLFxuICAgICAgICBhbGxEYXk6IHNwYW4uYWxsRGF5LFxuICAgIH07XG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG52YXIgRGF0ZUNsaWNraW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlQ2xpY2tpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF0ZUNsaWNraW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nO1xuICAgICAgICAgICAgdmFyIGRvd25FbCA9IHBldi5vcmlnRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghX3RoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRvd25FbCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3b24ndCBldmVuIGZpcmUgaWYgbW92aW5nIHdhcyBpZ25vcmVkXG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLmRyYWdnaW5nLnBvaW50ZXI7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5oaXREcmFnZ2luZywgaW5pdGlhbEhpdCA9IF9hLmluaXRpYWxIaXQsIGZpbmFsSGl0ID0gX2EuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQgJiYgZmluYWxIaXQgJiYgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgZmluYWxIaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChpbml0aWFsSGl0LmRhdGVTcGFuLCBjb250ZXh0KSksIHsgZGF5RWw6IGluaXRpYWxIaXQuZGF5RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVDbGljaycsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcbn0oSW50ZXJhY3Rpb24pKTtcblxuLypcblRyYWNrcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBwb3J0aW9uIG9mIHRpbWUgb2YgYSBjb21wb25lbnQsXG5jb25zdGl0dXRlZCBieSBhIGRyYWcgb3ZlciBkYXRlIGNlbGxzLCB3aXRoIGEgcG9zc2libGUgZGVsYXkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZHJhZy5cbiovXG52YXIgRGF0ZVNlbGVjdGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0ZVNlbGVjdGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRlU2VsZWN0aW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGRyYWdnaW5nID0gX2EuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgY2FuU2VsZWN0ID0gb3B0aW9ucy5zZWxlY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHRvIHdhdGNoIGV4cGVuc2l2ZSBtb3ZlcyBpZiBjb21wb25lbnQgd29uJ3QgZG8gc2VsZWN0aW9uXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFjYW5TZWxlY3QpO1xuICAgICAgICAgICAgLy8gaWYgdG91Y2gsIHJlcXVpcmUgdXNlciB0byBob2xkIGRvd25cbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID0gZXYuaXNUb3VjaCA/IGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSGl0VXBkYXRlID0gZnVuY3Rpb24gKGhpdCwgaXNGaW5hbCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgX3RoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIV90aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBkcmFnU2VsZWN0aW9uOyAvLyBvbmx5IGNsZWFyIGlmIG1vdmVkIGF3YXkgZnJvbSBhbGwgaGl0cyB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KF90aGlzLmRyYWdTZWxlY3Rpb24sIHBldiwgX3RoaXMuY29tcG9uZW50LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IF90aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBvcHRpb25zLnNlbGVjdE1pbkRpc3RhbmNlIHx8IDA7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIHZhciBoaXREcmFnZ2luZyA9IF90aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKF90aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgX3RoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgX3RoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlU2VsZWN0aW5nO1xufShJbnRlcmFjdGlvbikpO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkge1xuICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcbiAgICB2YXIgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICB2YXIgbXMgPSBbXG4gICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcbiAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxuICAgIF07XG4gICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzXzEgPSBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOyBfaSA8IGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyc18xW19pXTtcbiAgICAgICAgdmFyIHJlcyA9IHRyYW5zZm9ybWVyKGhpdDAsIGhpdDEpO1xuICAgICAgICBpZiAocmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgX19hc3NpZ24ocHJvcHMsIHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMucmFuZ2UgPSB7IHN0YXJ0OiBtc1swXSwgZW5kOiBtc1szXSB9O1xuICAgIHByb3BzLmFsbERheSA9IGRhdGVTcGFuMC5hbGxEYXk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG52YXIgRXZlbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXZlbnREcmFnZ2luZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudERyYWdnaW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICBfdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdWJqZWN0U2VnID0gbnVsbDsgLy8gdGhlIHNlZyBiZWluZyBzZWxlY3RlZC9kcmFnZ2VkXG4gICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDsgLy8gdGhlIGV2ZW50cyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIF90aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBvcmlnVGFyZ2V0ID0gZXYub3JpZ0V2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIGRyYWdnaW5nID0gX2EuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgbWlycm9yID0gZHJhZ2dpbmcubWlycm9yO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICBfdGhpcy5zdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgICAgICB2YXIgc3ViamVjdFNlZyA9IF90aGlzLnN1YmplY3RTZWcgPSBnZXRFbFNlZyhldi5zdWJqZWN0RWwpO1xuICAgICAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBfdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLCBldmVudEluc3RhbmNlSWQpO1xuICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBldi5pc1RvdWNoID8gMCA6IG9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIGV2ZW50SW5zdGFuY2VJZCAhPT0gY29tcG9uZW50LnByb3BzLmV2ZW50U2VsZWN0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maXhlZE1pcnJvclBhcmVudCkge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWlycm9yLnJldmVydER1cmF0aW9uID0gb3B0aW9ucy5kcmFnUmV2ZXJ0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKG9yaWdUYXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpOyAvLyBOT1Qgb24gYSByZXNpemVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFpc1ZhbGlkKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgZHJhZ2dpbmcgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIHJlc2l6YWJsZSAoaWUsIHNlbGVjdGFibGUpXG4gICAgICAgICAgICAvLyBidXQgYXJlIG5vdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBpc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHNlbGVjdCBhIGRpZmZlcmVudCBldmVudD9cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUlkICE9PSBfdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkOiBldmVudEluc3RhbmNlSWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm93IHVzaW5nIG1vdXNlLCBidXQgd2FzIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uLCBjbGVhciBzZWxlY3RlZCBldmVudFxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IF90aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IGZ1bmN0aW9uIChoaXQsIGlzRmluYWwpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50cyA9IF90aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxIaXQgPSBfdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICAvLyBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgICAgICAgICAgdmFyIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmluZ09wdGlvbnMgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAgIChyZWNlaXZpbmdPcHRpb25zLmVkaXRhYmxlICYmIHJlY2VpdmluZ09wdGlvbnMuZHJvcHBhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVFdmVudE11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JOZWVkc1JldmVydCghbXV0YXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCBzb21laG93IHdhaXQgZm9yIGRpc3BhdGNoIHRvIGd1YXJhbnRlZSByZW5kZXJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoIWhpdCB8fCAhZ2V0RWxSb290KF90aGlzLnN1YmplY3RFbCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0XzEgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbFZpZXcgPSBpbml0aWFsQ29udGV4dF8xLnZpZXdBcGk7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHJlY2VpdmluZ0NvbnRleHRfMSA9IF9hLnJlY2VpdmluZ0NvbnRleHQsIHZhbGlkTXV0YXRpb24gPSBfYS52YWxpZE11dGF0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBldmVudERlZiA9IF90aGlzLmV2ZW50UmFuZ2UuZGVmO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gX3RoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoaW5pdGlhbENvbnRleHRfMSwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHZhciByZWxldmFudEV2ZW50c18xID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRSZWxldmFudEV2ZW50c18xID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgIHZhciBmaW5hbEhpdCA9IF90aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyRHJhZygpOyAvLyBtdXN0IGhhcHBlbiBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBfdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBpbml0aWFsVmlldyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIHdpdGhpbiBzYW1lIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0XzEgPT09IGluaXRpYWxDb250ZXh0XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoaW5pdGlhbENvbnRleHRfMSwgbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSwgaW5pdGlhbENvbnRleHRfMSwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50c18xLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gaW5pdGlhbENvbnRleHRfMS5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVyczsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0XzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudERyb3AnLCBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB0cmFuc2Zvcm1lZCksIHsgZWw6IGV2LnN1YmplY3RFbCwgZGVsdGE6IHZhbGlkTXV0YXRpb24uZGF0ZXNEZWx0YSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBpbml0aWFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50UmVtb3ZlQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50c18xLCBpbml0aWFsQ29udGV4dF8xLCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXZlbnRSZW1vdmVBcmcpLCB7IGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLCB2aWV3OiBpbml0aWFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dF8xLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHNfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywgZXZlbnRSZW1vdmVBcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGVkRXZlbnREZWYgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5kZWZzW2V2ZW50RGVmLmRlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNfMS5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKHJlY2VpdmluZ0NvbnRleHRfMSwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEFkZEFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogYWRkZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHNfMSwgcmVjZWl2aW5nQ29udGV4dF8xLCBhZGRlZEV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dF8xLmVtaXR0ZXIudHJpZ2dlcignZXZlbnRBZGQnLCBldmVudEFkZEFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dF8xKSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHRfMS5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudEFkZEFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBFdmVudERyYWdnaW5nLlNFTEVDVE9SO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IG9wdGlvbnMuZHJhZ1Njcm9sbDtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoX3RoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIF90aGlzLmhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5kaXNwbGF5RHJhZyA9IGZ1bmN0aW9uIChuZXh0Q29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHN0YXRlLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgY2xlYXIgdGhlIG9sZCBjYWxlbmRhciBpZiBpdCB3YXNuJ3QgdGhlIGluaXRpYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNsZWFyRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDYWxlbmRhciA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgIHZhciByZWNlaXZpbmdDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgaW5pdGlhbCBjYWxlbmRhciBtaWdodCBoYXZlIGFuIGR1bW15IGRyYWcgc3RhdGUgZnJvbSBkaXNwbGF5RHJhZ1xuICAgICAgICBpZiAoaW5pdGlhbENhbGVuZGFyICE9PSByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgIH07XG4gICAgLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcbiAgICAvLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xuICAgIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IgPSAnLmZjLWV2ZW50LWRyYWdnYWJsZSwgLmZjLWV2ZW50LXJlc2l6YWJsZSc7XG4gICAgcmV0dXJuIEV2ZW50RHJhZ2dpbmc7XG59KEludGVyYWN0aW9uKSk7XG5mdW5jdGlvbiBjb21wdXRlRXZlbnRNdXRhdGlvbihoaXQwLCBoaXQxLCBtYXNzYWdlcnMpIHtcbiAgICB2YXIgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICB2YXIgZGF0ZTAgPSBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGRhdGUxID0gZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0O1xuICAgIHZhciBzdGFuZGFyZFByb3BzID0ge307XG4gICAgaWYgKGRhdGVTcGFuMC5hbGxEYXkgIT09IGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjEuYWxsRGF5O1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGhpdDEuY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgICAgICAvLyBtZWFucyBkYXRlMSBpcyBhbHJlYWR5IHN0YXJ0LW9mLWRheSxcbiAgICAgICAgICAgIC8vIGJ1dCBkYXRlMCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgIGRhdGUwID0gc3RhcnRPZkRheShkYXRlMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRlbHRhID0gZGlmZkRhdGVzKGRhdGUwLCBkYXRlMSwgaGl0MC5jb250ZXh0LmRhdGVFbnYsIGhpdDAuY29tcG9uZW50SWQgPT09IGhpdDEuY29tcG9uZW50SWQgP1xuICAgICAgICBoaXQwLmxhcmdlVW5pdCA6XG4gICAgICAgIG51bGwpO1xuICAgIGlmIChkZWx0YS5taWxsaXNlY29uZHMpIHsgLy8gaGFzIGhvdXJzL21pbnV0ZXMvc2Vjb25kc1xuICAgICAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbXV0YXRpb24gPSB7XG4gICAgICAgIGRhdGVzRGVsdGE6IGRlbHRhLFxuICAgICAgICBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBtYXNzYWdlcnNfMSA9IG1hc3NhZ2VyczsgX2kgPCBtYXNzYWdlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG1hc3NhZ2VyID0gbWFzc2FnZXJzXzFbX2ldO1xuICAgICAgICBtYXNzYWdlcihtdXRhdGlvbiwgaGl0MCwgaGl0MSk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcbiAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbn1cblxudmFyIEV2ZW50UmVzaXppbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50UmVzaXppbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXZlbnRSZXNpemluZyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgX3RoaXMuZHJhZ2dpbmdTZWdFbCA9IG51bGw7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nU2VnID0gbnVsbDsgLy8gVE9ETzogcmVuYW1lIHRvIHJlc2l6aW5nU2VnPyBzdWJqZWN0U2VnP1xuICAgICAgICBfdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBfdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIHZhciBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IF90aGlzLmV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nLm1pbkRpc3RhbmNlID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoLCBuZWVkIHRvIGJlIHdvcmtpbmcgd2l0aCBhIHNlbGVjdGVkIGV2ZW50XG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFfdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIChldi5pc1RvdWNoICYmIF90aGlzLmNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbiAhPT0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBldmVudFJhbmdlID0gX3RoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIF90aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB2YXIgc2VnRWwgPSBfdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nU2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlSGl0VXBkYXRlID0gZnVuY3Rpb24gKGhpdCwgaXNGaW5hbCwgZXYpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXMuY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgcmVsZXZhbnRFdmVudHMgPSBfdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIHZhciBpbml0aWFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgIHZhciBldmVudEluc3RhbmNlID0gX3RoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgICAgICAgICAgICAgJiYgX3RoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIV90aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IF90aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGV2ZW50RGVmID0gX3RoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IF90aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzID0gX3RoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB2YXIgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gX3RoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHtcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMuZHJhZ2dpbmdTZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLnZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVzaXplJywgX19hc3NpZ24oX19hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgeyBlbDogX3RoaXMuZHJhZ2dpbmdTZWdFbCwgc3RhcnREZWx0YTogX3RoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogX3RoaXMudmFsaWRNdXRhdGlvbi5lbmREZWx0YSB8fCBjcmVhdGVEdXJhdGlvbigwKSwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBfdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50O1xuICAgICAgICB2YXIgZHJhZ2dpbmcgPSBfdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICcuZmMtZXZlbnQtcmVzaXplcic7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5kcmFnU2Nyb2xsO1xuICAgICAgICB2YXIgaGl0RHJhZ2dpbmcgPSBfdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhfdGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCBfdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIF90aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIF90aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCBfdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnF1ZXJ5U2VnRWwgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRDbG9zZXN0KGV2LnN1YmplY3RFbCwgJy5mYy1ldmVudCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50UmVzaXppbmc7XG59KEludGVyYWN0aW9uKSk7XG5mdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xuICAgIHZhciBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcbiAgICB2YXIgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XG4gICAgaWYgKGlzRnJvbVN0YXJ0KSB7XG4gICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBVbnNlbGVjdEF1dG8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5zZWxlY3RBdXRvKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7IC8vIHdpc2ggd2UgY291bGQgdXNlIGEgc2VsZWN0b3IgdG8gZGV0ZWN0IGRhdGUgc2VsZWN0aW9uLCBidXQgdXNlcyBoaXQgc3lzdGVtXG4gICAgICAgIHRoaXMubWF0Y2hlc0NhbmNlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXNFdmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdEluZm8pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24gPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICB2YXIgdW5zZWxlY3RDYW5jZWwgPSBfdGhpcy5jb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RDYW5jZWw7XG4gICAgICAgICAgICB2YXIgZG93bkVsID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KHBldi5vcmlnRXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMubWF0Y2hlc0NhbmNlbCA9ICEhZWxlbWVudENsb3Nlc3QoZG93bkVsLCB1bnNlbGVjdENhbmNlbCk7XG4gICAgICAgICAgICBfdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUik7IC8vIGludGVyYWN0aW9uIHN0YXJ0ZWQgb24gYW4gZXZlbnQ/XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCA9IGZ1bmN0aW9uIChwZXYpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3RoaXMuY29udGV4dDtcbiAgICAgICAgICAgIHZhciBkb2N1bWVudFBvaW50ZXIgPSBfdGhpcy5kb2N1bWVudFBvaW50ZXI7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgICAgIC8vIHRvdWNoLXNjcm9sbGluZyBzaG91bGQgbmV2ZXIgdW5mb2N1cyBhbnkgdHlwZSBvZiBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmICghZG9jdW1lbnRQb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBkYXRlIHNlbGVjdGlvbj9cbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5zZWxlY3RBdXRvID0gY29udGV4dC5vcHRpb25zLnVuc2VsZWN0QXV0bztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc2VsZWN0QXV0byAmJiAoIXVuc2VsZWN0QXV0byB8fCAhX3RoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QocGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJTdGF0ZS5ldmVudFNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBldmVudCBzZWxlY3RlZD9cbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLm1hdGNoZXNFdmVudCAvLyBpbnRlcmFjdGlvbiBESUROJ1Qgc3RhcnQgb24gYW4gZXZlbnRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZG9jdW1lbnRQb2ludGVyID0gdGhpcy5kb2N1bWVudFBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGRvY3VtZW50KTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZElnbm9yZU1vdmUgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkV2F0Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24pO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICB9XG4gICAgVW5zZWxlY3RBdXRvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5vZmYoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xuICAgICAgICB0aGlzLmRvY3VtZW50UG9pbnRlci5kZXN0cm95KCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5zZWxlY3RBdXRvO1xufSgpKTtcblxudmFyIE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHksXG59O1xudmFyIExJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnREcmFnU3RhcnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJhZ1N0b3A6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemVTdGFydDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemVTdG9wOiBpZGVudGl0eSxcbiAgICBldmVudFJlc2l6ZTogaWRlbnRpdHksXG4gICAgZHJvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZWNlaXZlOiBpZGVudGl0eSxcbiAgICBldmVudExlYXZlOiBpZGVudGl0eSxcbn07XG5cbi8qXG5HaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcbkludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXG5vZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cbiovXG52YXIgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHN1cHBsaWVkRHJhZ01ldGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5kcmFnTWV0YSA9IF90aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSBmdW5jdGlvbiAoaGl0LCBpc0ZpbmFsLCBldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuaGl0RHJhZ2dpbmcuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBfdGhpcy5kcmFnTWV0YS5jcmVhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oaGl0LmRhdGVTcGFuLCBfdGhpcy5kcmFnTWV0YSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZCA9ICFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NvbnRleHQsIGludGVyYWN0aW9uKTtcbiAgICAgICAgICAgIC8vIHNob3cgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yIGVsZW1lbnQgT1IgaWYgd2UgYXJlIHNodXR0aW5nIGRvd24gdGhlIG1pcnJvciAoPylcbiAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoaXNGaW5hbCB8fCAhZHJvcHBhYmxlRXZlbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSk7XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGFibGVFdmVudCA9IGRyb3BwYWJsZUV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAocGV2KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgcmVjZWl2aW5nQ29udGV4dCA9IF9hLnJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50ID0gX2EuZHJvcHBhYmxlRXZlbnQ7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckRyYWcoKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0ICYmIGRyb3BwYWJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsSGl0ID0gX3RoaXMuaGl0RHJhZ2dpbmcuZmluYWxIaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsVmlldyA9IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ01ldGEgPSBfdGhpcy5kcmFnTWV0YTtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZHJvcCcsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLCBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnTWV0YS5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGluZ0V2ZW50c18xID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShyZWNlaXZpbmdDb250ZXh0LCBkcm9wcGFibGVFdmVudC5kZWYsIGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcucmVxdWlyZUluaXRpYWwgPSBmYWxzZTsgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gc3VwcGxpZWREcmFnTWV0YTtcbiAgICB9XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ01ldGEgPSBmdW5jdGlvbiAoc3ViamVjdEVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKHN1YmplY3RFbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXREcmFnTWV0YUZyb21FbChzdWJqZWN0RWwpO1xuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmRpc3BsYXlEcmFnID0gZnVuY3Rpb24gKG5leHRDb250ZXh0LCBzdGF0ZSkge1xuICAgICAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4dGVybmFsRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5jbGVhckRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLmNhbkRyb3BFbE9uQ2FsZW5kYXIgPSBmdW5jdGlvbiAoZWwsIHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnMuZHJvcEFjY2VwdDtcbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdC5jYWxsKHJlY2VpdmluZ0NvbnRleHQuY2FsZW5kYXJBcGksIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRNYXRjaGVzKGVsLCBkcm9wQWNjZXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmc7XG59KCkpO1xuLy8gVXRpbHMgZm9yIGNvbXB1dGluZyBldmVudCBzdG9yZSBmcm9tIHRoZSBEcmFnTWV0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oZGF0ZVNwYW4sIGRyYWdNZXRhLCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZlByb3BzID0gX19hc3NpZ24oe30sIGRyYWdNZXRhLmxlZnRvdmVyUHJvcHMpO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV4dGVybmFsRGVmVHJhbnNmb3JtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hW19pXTtcbiAgICAgICAgX19hc3NpZ24oZGVmUHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgZHJhZ01ldGEpKTtcbiAgICB9XG4gICAgdmFyIF9iID0gcmVmaW5lRXZlbnREZWYoZGVmUHJvcHMsIGNvbnRleHQpLCByZWZpbmVkID0gX2IucmVmaW5lZCwgZXh0cmEgPSBfYi5leHRyYTtcbiAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZHJhZ01ldGEuc291cmNlSWQsIGRhdGVTcGFuLmFsbERheSwgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgdmFyIHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxuICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgdmFyIGVuZCA9IGRyYWdNZXRhLmR1cmF0aW9uID9cbiAgICAgICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kKGRhdGVTcGFuLmFsbERheSwgc3RhcnQsIGNvbnRleHQpO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgcmV0dXJuIHsgZGVmOiBkZWYsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xufVxuLy8gVXRpbHMgZm9yIGV4dHJhY3RpbmcgZGF0YSBmcm9tIGVsZW1lbnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldERyYWdNZXRhRnJvbUVsKGVsKSB7XG4gICAgdmFyIHN0ciA9IGdldEVtYmVkZGVkRWxEYXRhKGVsLCAnZXZlbnQnKTtcbiAgICB2YXIgb2JqID0gc3RyID9cbiAgICAgICAgSlNPTi5wYXJzZShzdHIpIDpcbiAgICAgICAgeyBjcmVhdGU6IGZhbHNlIH07IC8vIGlmIG5vIGVtYmVkZGVkIGRhdGEsIGFzc3VtZSBubyBldmVudCBjcmVhdGlvblxuICAgIHJldHVybiBwYXJzZURyYWdNZXRhKG9iaik7XG59XG5jb25maWcuZGF0YUF0dHJQcmVmaXggPSAnJztcbmZ1bmN0aW9uIGdldEVtYmVkZGVkRWxEYXRhKGVsLCBuYW1lKSB7XG4gICAgdmFyIHByZWZpeCA9IGNvbmZpZy5kYXRhQXR0clByZWZpeDtcbiAgICB2YXIgcHJlZml4ZWROYW1lID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIG5hbWU7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgcHJlZml4ZWROYW1lKSB8fCAnJztcbn1cblxuLypcbk1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cbkNhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cbkxldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cbiovXG52YXIgRXh0ZXJuYWxEcmFnZ2FibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxEcmFnZ2FibGUoZWwsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nID0gX3RoaXMuZHJhZ2dpbmc7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zZXR0aW5ncywgbWluRGlzdGFuY2UgPSBfYS5taW5EaXN0YW5jZSwgbG9uZ1ByZXNzRGVsYXkgPSBfYS5sb25nUHJlc3NEZWxheTtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID1cbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgOlxuICAgICAgICAgICAgICAgICAgICAoZXYuaXNUb3VjaCA/IDAgOiBCQVNFX09QVElPTl9ERUZBVUxUUy5ldmVudERyYWdNaW5EaXN0YW5jZSk7XG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICAgICAgICAgICAgZXYuaXNUb3VjaCA/IC8vIFRPRE86IGV2ZW50dWFsbHkgcmVhZCBldmVudExvbmdQcmVzc0RlbGF5IGluc3RlYWQgdnZ2XG4gICAgICAgICAgICAgICAgICAgIChsb25nUHJlc3NEZWxheSAhPSBudWxsID8gbG9uZ1ByZXNzRGVsYXkgOiBCQVNFX09QVElPTl9ERUZBVUxUUy5sb25nUHJlc3NEZWxheSkgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2ggJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5kZWxheSAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XG4gICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXG4gICAgICAgIH1cbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICAgIEV4dGVybmFsRHJhZ2dhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlcm5hbERyYWdnYWJsZTtcbn0oKSk7XG5cbi8qXG5EZXRlY3RzIHdoZW4gYSAqVEhJUkQtUEFSVFkqIGRyYWctbi1kcm9wIHN5c3RlbSBpbnRlcmFjdHMgd2l0aCBlbGVtZW50cy5cblRoZSB0aGlyZC1wYXJ0eSBzeXN0ZW0gaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgdGhlIHZpc3VhbHMgZWZmZWN0cyBvZiB0aGUgZHJhZy5cblRoaXMgY2xhc3Mgc2ltcGx5IG1vbml0b3JzIGZvciBwb2ludGVyIG1vdmVtZW50cyBhbmQgZmlyZXMgZXZlbnRzLlxuSXQgYWxzbyBoYXMgdGhlIGFiaWxpdHkgdG8gaGlkZSB0aGUgbW92aW5nIGVsZW1lbnQgKHRoZSBcIm1pcnJvclwiKSBkdXJpbmcgdGhlIGRyYWcuXG4qL1xudmFyIEluZmVycmVkRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZlcnJlZEVsZW1lbnREcmFnZ2luZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbmZlcnJlZEVsZW1lbnREcmFnZ2luZyhjb250YWluZXJFbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250YWluZXJFbCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5taXJyb3JTZWxlY3RvciA9ICcnO1xuICAgICAgICBfdGhpcy5jdXJyZW50TWlycm9yRWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIGZpcmUgZHJhZ3N0YXJ0IHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgZGVsYXkgb3IgbWluLWRpc3RhbmNlXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9pbnRlciA9IF90aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIF90aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIF90aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCBfdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZmVycmVkRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgIH07XG4gICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldElnbm9yZU1vdmUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBib29sO1xuICAgIH07XG4gICAgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldE1pcnJvcklzVmlzaWJsZSA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcbiAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEluZmVycmVkRWxlbWVudERyYWdnaW5nO1xufShFbGVtZW50RHJhZ2dpbmcpKTtcblxuLypcbkJyaWRnZXMgdGhpcmQtcGFydHkgZHJhZy1uLWRyb3Agc3lzdGVtcyB3aXRoIEZ1bGxDYWxlbmRhci5cbk11c3QgYmUgaW5zdGFudGlhdGVkIGFuZCBkZXN0cm95ZWQgYnkgY2FsbGVyLlxuKi9cbnZhciBUaGlyZFBhcnR5RHJhZ2dhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRoaXJkUGFydHlEcmFnZ2FibGUoY29udGFpbmVyT3JTZXR0aW5ncywgc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gZG9jdW1lbnQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gd2lzaCB3ZSBjb3VsZCBqdXN0IHRlc3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCwgYnV0IGRvZXNuJ3Qgd29yayBpbiBJRTExXG4gICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgPT09IGRvY3VtZW50IHx8XG4gICAgICAgICAgICBjb250YWluZXJPclNldHRpbmdzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgY29udGFpbmVyRWwgPSBjb250YWluZXJPclNldHRpbmdzO1xuICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0gKGNvbnRhaW5lck9yU2V0dGluZ3MgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLml0ZW1TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyRWwgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJ1tkYXRhLWV2ZW50XSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5taXJyb3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvclNlbGVjdG9yID0gc2V0dGluZ3MubWlycm9yU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH1cbiAgICBUaGlyZFBhcnR5RHJhZ2dhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBUaGlyZFBhcnR5RHJhZ2dhYmxlO1xufSgpKTtcblxudmFyIG1haW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogW0RhdGVDbGlja2luZywgRGF0ZVNlbGVjdGluZywgRXZlbnREcmFnZ2luZywgRXZlbnRSZXNpemluZ10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcsXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYWluO1xuZXhwb3J0IHsgRXh0ZXJuYWxEcmFnZ2FibGUgYXMgRHJhZ2dhYmxlLCBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLCBQb2ludGVyRHJhZ2dpbmcsIFRoaXJkUGFydHlEcmFnZ2FibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwXG4iXSwibmFtZXMiOlsiY29uZmlnIiwiZWxlbWVudENsb3Nlc3QiLCJFbWl0dGVyIiwiYXBwbHlTdHlsZSIsIndoZW5UcmFuc2l0aW9uRG9uZSIsInJlbW92ZUVsZW1lbnQiLCJTY3JvbGxDb250cm9sbGVyIiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJjb21wdXRlSW5uZXJSZWN0IiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsImdldEVsUm9vdCIsInByZXZlbnRTZWxlY3Rpb24iLCJwcmV2ZW50Q29udGV4dE1lbnUiLCJhbGxvd1NlbGVjdGlvbiIsImFsbG93Q29udGV4dE1lbnUiLCJFbGVtZW50RHJhZ2dpbmciLCJjb21wdXRlUmVjdCIsImdldENsaXBwaW5nUGFyZW50cyIsInBvaW50SW5zaWRlUmVjdCIsImlzRGF0ZVNwYW5zRXF1YWwiLCJjb25zdHJhaW5Qb2ludCIsImludGVyc2VjdFJlY3RzIiwiZ2V0UmVjdENlbnRlciIsImRpZmZQb2ludHMiLCJtYXBIYXNoIiwicmFuZ2VDb250YWluc1JhbmdlIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJJbnRlcmFjdGlvbiIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiZW5hYmxlQ3Vyc29yIiwiZGlzYWJsZUN1cnNvciIsInRyaWdnZXJEYXRlU2VsZWN0IiwiY29tcGFyZU51bWJlcnMiLCJnZXRFbFNlZyIsImdldFJlbGV2YW50RXZlbnRzIiwiRXZlbnRBcGkiLCJjcmVhdGVFbXB0eUV2ZW50U3RvcmUiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiaXNJbnRlcmFjdGlvblZhbGlkIiwiYnVpbGRFdmVudEFwaXMiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJzdGFydE9mRGF5IiwiZGlmZkRhdGVzIiwiY3JlYXRlRHVyYXRpb24iLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJpZGVudGl0eSIsImV2ZW50VHVwbGVUb1N0b3JlIiwicGFyc2VEcmFnTWV0YSIsImVsZW1lbnRNYXRjaGVzIiwicmVmaW5lRXZlbnREZWYiLCJwYXJzZUV2ZW50RGVmIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiY3JlYXRlRXZlbnRJbnN0YW5jZSIsIkJBU0VfT1BUSU9OX0RFRkFVTFRTIiwiY3JlYXRlUGx1Z2luIiwiX19leHRlbmRzIiwiX19hc3NpZ24iLCJ0b3VjaE1vdXNlSWdub3JlV2FpdCIsImlnbm9yZU1vdXNlRGVwdGgiLCJsaXN0ZW5lckNudCIsImlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkIiwiUG9pbnRlckRyYWdnaW5nIiwiY29udGFpbmVyRWwiLCJfdGhpcyIsInN1YmplY3RFbCIsInNlbGVjdG9yIiwiaGFuZGxlU2VsZWN0b3IiLCJzaG91bGRJZ25vcmVNb3ZlIiwic2hvdWxkV2F0Y2hTY3JvbGwiLCJpc0RyYWdnaW5nIiwiaXNUb3VjaERyYWdnaW5nIiwid2FzVG91Y2hTY3JvbGwiLCJoYW5kbGVNb3VzZURvd24iLCJldiIsInNob3VsZElnbm9yZU1vdXNlIiwiaXNQcmltYXJ5TW91c2VCdXR0b24iLCJ0cnlTdGFydCIsInBldiIsImNyZWF0ZUV2ZW50RnJvbU1vdXNlIiwiZW1pdHRlciIsInRyaWdnZXIiLCJpbml0U2Nyb2xsV2F0Y2giLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVNb3VzZU1vdmUiLCJoYW5kbGVNb3VzZVVwIiwicmVjb3JkQ29vcmRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsZWFudXAiLCJoYW5kbGVUb3VjaFN0YXJ0IiwiY3JlYXRlRXZlbnRGcm9tVG91Y2giLCJ0YXJnZXRFbCIsInRhcmdldCIsImhhbmRsZVRvdWNoTW92ZSIsImhhbmRsZVRvdWNoRW5kIiwid2luZG93IiwiaGFuZGxlVG91Y2hTY3JvbGwiLCJzdGFydElnbm9yaW5nTW91c2UiLCJoYW5kbGVTY3JvbGwiLCJwYWdlWCIsInBhZ2VYT2Zmc2V0IiwicHJldlNjcm9sbFgiLCJwcmV2UGFnZVgiLCJwYWdlWSIsInBhZ2VZT2Zmc2V0IiwicHJldlNjcm9sbFkiLCJwcmV2UGFnZVkiLCJvcmlnRXZlbnQiLCJpc1RvdWNoIiwiZGVsdGFYIiwib3JpZ1BhZ2VYIiwiZGVsdGFZIiwib3JpZ1BhZ2VZIiwicGFzc2l2ZSIsImxpc3RlbmVyQ3JlYXRlZCIsInByb3RvdHlwZSIsImRlc3Ryb3kiLCJsaXN0ZW5lckRlc3Ryb3llZCIsInF1ZXJ5U3ViamVjdEVsIiwiZG93bkVsIiwiZGVzdHJveVNjcm9sbFdhdGNoIiwiY2FuY2VsVG91Y2hTY3JvbGwiLCJpc0ZpcnN0IiwidG91Y2hlcyIsImxlbmd0aCIsImJ1dHRvbiIsImN0cmxLZXkiLCJzZXRUaW1lb3V0Iiwib25XaW5kb3dUb3VjaE1vdmUiLCJwcmV2ZW50RGVmYXVsdCIsIkVsZW1lbnRNaXJyb3IiLCJpc1Zpc2libGUiLCJzb3VyY2VFbCIsIm1pcnJvckVsIiwic291cmNlRWxSZWN0IiwicGFyZW50Tm9kZSIsImJvZHkiLCJ6SW5kZXgiLCJyZXZlcnREdXJhdGlvbiIsInN0YXJ0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib3JpZ1NjcmVlblgiLCJvcmlnU2NyZWVuWSIsInVwZGF0ZUVsUG9zaXRpb24iLCJoYW5kbGVNb3ZlIiwic2V0SXNWaXNpYmxlIiwiYm9vbCIsInN0eWxlIiwiZGlzcGxheSIsInN0b3AiLCJuZWVkc1JldmVydEFuaW1hdGlvbiIsImNhbGxiYWNrIiwiZG9uZSIsImRvUmV2ZXJ0QW5pbWF0aW9uIiwiZmluYWxTb3VyY2VFbFJlY3QiLCJ0cmFuc2l0aW9uIiwibGVmdCIsInRvcCIsImdldE1pcnJvckVsIiwiY2xvbmVOb2RlIiwiY2xhc3NMaXN0IiwiYWRkIiwicG9zaXRpb24iLCJ2aXNpYmlsaXR5IiwiYm94U2l6aW5nIiwid2lkdGgiLCJyaWdodCIsImhlaWdodCIsImJvdHRvbSIsIm1hcmdpbiIsImFwcGVuZENoaWxkIiwiU2Nyb2xsR2VvbUNhY2hlIiwiX3N1cGVyIiwic2Nyb2xsQ29udHJvbGxlciIsImRvZXNMaXN0ZW5pbmciLCJjYWxsIiwic2Nyb2xsVG9wIiwiZ2V0U2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImdldFNjcm9sbExlZnQiLCJoYW5kbGVTY3JvbGxDaGFuZ2UiLCJvcmlnU2Nyb2xsVG9wIiwib3JpZ1Njcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsImdldFNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiZ2V0U2Nyb2xsSGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJnZXRDbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldENsaWVudEhlaWdodCIsImNsaWVudFJlY3QiLCJjb21wdXRlQ2xpZW50UmVjdCIsImdldEV2ZW50VGFyZ2V0Iiwic2V0U2Nyb2xsVG9wIiwiTWF0aCIsIm1heCIsIm1pbiIsImdldE1heFNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJnZXRNYXhTY3JvbGxMZWZ0IiwiRWxlbWVudFNjcm9sbEdlb21DYWNoZSIsImVsIiwiV2luZG93U2Nyb2xsR2VvbUNhY2hlIiwiZ2V0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsIkF1dG9TY3JvbGxlciIsImlzRW5hYmxlZCIsInNjcm9sbFF1ZXJ5IiwiZWRnZVRocmVzaG9sZCIsIm1heFZlbG9jaXR5IiwicG9pbnRlclNjcmVlblgiLCJwb2ludGVyU2NyZWVuWSIsImlzQW5pbWF0aW5nIiwic2Nyb2xsQ2FjaGVzIiwiZXZlck1vdmVkVXAiLCJldmVyTW92ZWREb3duIiwiZXZlck1vdmVkTGVmdCIsImV2ZXJNb3ZlZFJpZ2h0IiwiYW5pbWF0ZSIsImVkZ2UiLCJjb21wdXRlQmVzdEVkZ2UiLCJoYW5kbGVTaWRlIiwibXNTaW5jZVJlcXVlc3QiLCJyZXF1ZXN0QW5pbWF0aW9uIiwic2Nyb2xsU3RhcnRFbCIsImJ1aWxkQ2FjaGVzIiwieURlbHRhIiwieERlbHRhIiwiX2kiLCJfYSIsInNjcm9sbENhY2hlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2Vjb25kcyIsImludkRpc3RhbmNlIiwiZGlzdGFuY2UiLCJ2ZWxvY2l0eSIsInNpZ24iLCJuYW1lIiwiYmVzdFNpZGUiLCJzY3JvbGxDYWNoZXNfMSIsInJlY3QiLCJsZWZ0RGlzdCIsInJpZ2h0RGlzdCIsInRvcERpc3QiLCJib3R0b21EaXN0IiwiY2FuU2Nyb2xsVXAiLCJjYW5TY3JvbGxEb3duIiwiY2FuU2Nyb2xsTGVmdCIsImNhblNjcm9sbFJpZ2h0IiwicXVlcnlTY3JvbGxFbHMiLCJtYXAiLCJlbHMiLCJxdWVyeSIsInB1c2giLCJhcHBseSIsIkFycmF5Iiwic2xpY2UiLCJxdWVyeVNlbGVjdG9yQWxsIiwiRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyIsImRlbGF5IiwibWluRGlzdGFuY2UiLCJ0b3VjaFNjcm9sbEFsbG93ZWQiLCJtaXJyb3JOZWVkc1JldmVydCIsImlzSW50ZXJhY3RpbmciLCJpc0RlbGF5RW5kZWQiLCJpc0Rpc3RhbmNlU3VycGFzc2VkIiwiZGVsYXlUaW1lb3V0SWQiLCJvblBvaW50ZXJEb3duIiwicG9pbnRlciIsIm1pcnJvciIsInN0YXJ0RGVsYXkiLCJoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZCIsIm9uUG9pbnRlck1vdmUiLCJkaXN0YW5jZVNxIiwidHlwZSIsImF1dG9TY3JvbGxlciIsIm9uUG9pbnRlclVwIiwidHJ5U3RvcERyYWciLCJjbGVhclRpbWVvdXQiLCJvbiIsImhhbmRsZURlbGF5RW5kIiwidHJ5U3RhcnREcmFnIiwic3RvcERyYWciLCJiaW5kIiwic2V0SWdub3JlTW92ZSIsInNldE1pcnJvcklzVmlzaWJsZSIsInNldE1pcnJvck5lZWRzUmV2ZXJ0Iiwic2V0QXV0b1Njcm9sbEVuYWJsZWQiLCJPZmZzZXRUcmFja2VyIiwib3JpZ1JlY3QiLCJzY3JvbGxFbCIsImNvbXB1dGVMZWZ0IiwiY29tcHV0ZVRvcCIsImlzV2l0aGluQ2xpcHBpbmciLCJwb2ludCIsImlzSWdub3JlZENsaXBwaW5nIiwibm9kZSIsInRhZ05hbWUiLCJIaXREcmFnZ2luZyIsImRyYWdnaW5nIiwiZHJvcHBhYmxlU3RvcmUiLCJ1c2VTdWJqZWN0Q2VudGVyIiwicmVxdWlyZUluaXRpYWwiLCJpbml0aWFsSGl0IiwibW92aW5nSGl0IiwiZmluYWxIaXQiLCJoYW5kbGVQb2ludGVyRG93biIsInByZXBhcmVIaXRzIiwicHJvY2Vzc0ZpcnN0Q29vcmQiLCJoYW5kbGVEcmFnU3RhcnQiLCJoYW5kbGVEcmFnTW92ZSIsImhhbmRsZVBvaW50ZXJVcCIsInJlbGVhc2VIaXRzIiwiaGFuZGxlRHJhZ0VuZCIsIm9yaWdQb2ludCIsImFkanVzdGVkUG9pbnQiLCJzdWJqZWN0UmVjdCIsIkhUTUxFbGVtZW50IiwicXVlcnlIaXRGb3JPZmZzZXQiLCJzbGljZWRTdWJqZWN0UmVjdCIsImNvb3JkQWRqdXN0IiwiZm9yY2VIYW5kbGUiLCJoaXQiLCJpc0hpdHNFcXVhbCIsIm9mZnNldFRyYWNrZXJzIiwiaW50ZXJhY3Rpb25TZXR0aW5ncyIsImNvbXBvbmVudCIsImlkIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsImJlc3RIaXQiLCJvZmZzZXRUcmFja2VyIiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInBvc2l0aW9uTGVmdCIsInBvc2l0aW9uVG9wIiwicXVlcnlIaXQiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiZGF0ZVNwYW4iLCJyYW5nZSIsImxheWVyIiwiY29tcG9uZW50SWQiLCJjb250ZXh0IiwiaGl0MCIsImhpdDEiLCJCb29sZWFuIiwiYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCIsInByb3BzIiwicGx1Z2luSG9va3MiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwidHJhbnNmb3JtIiwiYnVpbGREYXRlUG9pbnRBcGkiLCJkYXRlRW52Iiwic3BhbiIsImRhdGUiLCJ0b0RhdGUiLCJkYXRlU3RyIiwiZm9ybWF0SXNvIiwib21pdFRpbWUiLCJhbGxEYXkiLCJEYXRlQ2xpY2tpbmciLCJzZXR0aW5ncyIsImlzVmFsaWREYXRlRG93bkVsIiwiaGl0RHJhZ2dpbmciLCJhcmciLCJkYXlFbCIsImpzRXZlbnQiLCJ2aWV3Iiwidmlld0FwaSIsImNhbGVuZGFyQXBpIiwiRGF0ZVNlbGVjdGluZyIsImRyYWdTZWxlY3Rpb24iLCJvcHRpb25zIiwiY2FuU2VsZWN0Iiwic2VsZWN0YWJsZSIsImdldENvbXBvbmVudFRvdWNoRGVsYXkkMSIsInVuc2VsZWN0IiwiaGFuZGxlSGl0VXBkYXRlIiwiaXNGaW5hbCIsImlzSW52YWxpZCIsImRpc2FsbG93ZWQiLCJpc0hpdENvbWJvQWxsb3dlZCIsImpvaW5IaXRzSW50b1NlbGVjdGlvbiIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJkaXNwYXRjaCIsInNlbGVjdGlvbiIsInNlbGVjdE1pbkRpc3RhbmNlIiwiZHJhZ1Njcm9sbCIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJkYXRlU3BhbjAiLCJkYXRlU3BhbjEiLCJtcyIsImVuZCIsInNvcnQiLCJkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzXzEiLCJ0cmFuc2Zvcm1lciIsInJlcyIsIkV2ZW50RHJhZ2dpbmciLCJzdWJqZWN0U2VnIiwiZXZlbnRSYW5nZSIsInJlbGV2YW50RXZlbnRzIiwicmVjZWl2aW5nQ29udGV4dCIsInZhbGlkTXV0YXRpb24iLCJtdXRhdGVkUmVsZXZhbnRFdmVudHMiLCJvcmlnVGFyZ2V0IiwiaW5pdGlhbENvbnRleHQiLCJldmVudEluc3RhbmNlSWQiLCJpbnN0YW5jZSIsImluc3RhbmNlSWQiLCJnZXRDdXJyZW50RGF0YSIsImV2ZW50U3RvcmUiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV2ZW50U2VsZWN0aW9uIiwiZ2V0Q29tcG9uZW50VG91Y2hEZWxheSIsImZpeGVkTWlycm9yUGFyZW50IiwiZHJhZ1JldmVydER1cmF0aW9uIiwiaXNWYWxpZCIsImlzVmFsaWRTZWdEb3duRWwiLCJjb250YWlucyIsImV2ZW50IiwiZGVmIiwibXV0YXRpb24iLCJpbnRlcmFjdGlvbiIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEV2ZW50cyIsImlzRXZlbnQiLCJyZWNlaXZpbmdPcHRpb25zIiwiZWRpdGFibGUiLCJkcm9wcGFibGUiLCJjb21wdXRlRXZlbnRNdXRhdGlvbiIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZXZlbnRVaUJhc2VzIiwiZGlzcGxheURyYWciLCJxdWVyeVNlbGVjdG9yIiwiaW5pdGlhbENvbnRleHRfMSIsImluaXRpYWxWaWV3IiwicmVjZWl2aW5nQ29udGV4dF8xIiwiZXZlbnREZWYiLCJldmVudEluc3RhbmNlIiwiZXZlbnRBcGkiLCJyZWxldmFudEV2ZW50c18xIiwibXV0YXRlZFJlbGV2YW50RXZlbnRzXzEiLCJjbGVhckRyYWciLCJ1cGRhdGVkRXZlbnRBcGkiLCJkZWZzIiwiZGVmSWQiLCJpbnN0YW5jZXMiLCJldmVudENoYW5nZUFyZyIsIm9sZEV2ZW50IiwicmVsYXRlZEV2ZW50cyIsInJldmVydCIsInRyYW5zZm9ybWVkIiwiX2IiLCJldmVudERyb3BUcmFuc2Zvcm1lcnMiLCJkZWx0YSIsImRhdGVzRGVsdGEiLCJldmVudFJlbW92ZUFyZyIsImRyYWdnZWRFbCIsImFkZGVkRXZlbnREZWYiLCJhZGRlZEV2ZW50SW5zdGFuY2UiLCJhZGRlZEV2ZW50QXBpIiwiZXZlbnRBZGRBcmciLCJTRUxFQ1RPUiIsInVzZUV2ZW50Q2VudGVyIiwibmV4dENvbnRleHQiLCJzdGF0ZSIsInByZXZDb250ZXh0IiwiaW5pdGlhbENhbGVuZGFyIiwibWFzc2FnZXJzIiwiZGF0ZTAiLCJkYXRlMSIsInN0YW5kYXJkUHJvcHMiLCJoYXNFbmQiLCJhbGxEYXlNYWludGFpbkR1cmF0aW9uIiwibGFyZ2VVbml0IiwibWlsbGlzZWNvbmRzIiwibWFzc2FnZXJzXzEiLCJtYXNzYWdlciIsImV2ZW50TG9uZ1ByZXNzRGVsYXkiLCJFdmVudFJlc2l6aW5nIiwiZHJhZ2dpbmdTZWdFbCIsImRyYWdnaW5nU2VnIiwic2VnRWwiLCJxdWVyeVNlZ0VsIiwic2VnIiwiY29tcHV0ZU11dGF0aW9uIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiaXNGcm9tU3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiVW5zZWxlY3RBdXRvIiwiaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCIsIm1hdGNoZXNDYW5jZWwiLCJtYXRjaGVzRXZlbnQiLCJvblNlbGVjdCIsInNlbGVjdEluZm8iLCJvbkRvY3VtZW50UG9pbnRlckRvd24iLCJ1bnNlbGVjdENhbmNlbCIsIm9uRG9jdW1lbnRQb2ludGVyVXAiLCJkb2N1bWVudFBvaW50ZXIiLCJjYWxlbmRhclN0YXRlIiwiZGF0ZVNlbGVjdGlvbiIsInVuc2VsZWN0QXV0byIsIm9mZiIsIk9QVElPTl9SRUZJTkVSUyIsIkxJU1RFTkVSX1JFRklORVJTIiwiZGF0ZUNsaWNrIiwiZXZlbnREcmFnU3RhcnQiLCJldmVudERyYWdTdG9wIiwiZXZlbnREcm9wIiwiZXZlbnRSZXNpemVTdGFydCIsImV2ZW50UmVzaXplU3RvcCIsImV2ZW50UmVzaXplIiwiZHJvcCIsImV2ZW50UmVjZWl2ZSIsImV2ZW50TGVhdmUiLCJFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyIsInN1cHBsaWVkRHJhZ01ldGEiLCJkcm9wcGFibGVFdmVudCIsImRyYWdNZXRhIiwiYnVpbGREcmFnTWV0YSIsImNyZWF0ZSIsImNhbkRyb3BFbE9uQ2FsZW5kYXIiLCJjb21wdXRlRXZlbnRGb3JEYXRlU3BhbiIsImZpbmFsVmlldyIsImFkZGluZ0V2ZW50c18xIiwiZ2V0RHJhZ01ldGFGcm9tRWwiLCJkcm9wQWNjZXB0IiwiZGVmUHJvcHMiLCJsZWZ0b3ZlclByb3BzIiwiZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIiwicmVmaW5lZCIsImV4dHJhIiwic291cmNlSWQiLCJmb3JjZUV2ZW50RHVyYXRpb24iLCJkdXJhdGlvbiIsInN0YXJ0VGltZSIsInN0ciIsImdldEVtYmVkZGVkRWxEYXRhIiwib2JqIiwiSlNPTiIsInBhcnNlIiwiZGF0YUF0dHJQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhlZE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJFeHRlcm5hbERyYWdnYWJsZSIsIml0ZW1TZWxlY3RvciIsImFwcGVuZFRvIiwiZXZlbnREYXRhIiwiSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmciLCJtaXJyb3JTZWxlY3RvciIsImN1cnJlbnRNaXJyb3JFbCIsImhhbmRsZVBvaW50ZXJNb3ZlIiwiVGhpcmRQYXJ0eURyYWdnYWJsZSIsImNvbnRhaW5lck9yU2V0dGluZ3MiLCJFbGVtZW50IiwibWFpbiIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvblJlZmluZXJzIiwibGlzdGVuZXJSZWZpbmVycyIsIkRyYWdnYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/interaction/main.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/main.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/main.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom */ \"./node_modules/@fullcalendar/react/dist/vdom.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\nvar FullCalendar = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(FullCalendar, _super);\n    function FullCalendar() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._calendarApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarApi();\n        return _this;\n    }\n    FullCalendar.prototype.render = function() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarDataProvider, {\n            optionOverrides: this.props,\n            calendarApi: this._calendarApi\n        }, function(data) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarRoot, {\n                options: data.calendarOptions,\n                theme: data.theme,\n                emitter: data.emitter\n            }, function(classNames, height, isHeightAuto, forPrint) {\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n                    className: classNames.join(\" \"),\n                    style: {\n                        height: height\n                    }\n                }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_2__.CalendarContent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                    isHeightAuto: isHeightAuto,\n                    forPrint: forPrint\n                }, data)));\n            });\n        });\n    };\n    FullCalendar.prototype.getApi = function() {\n        return this._calendarApi;\n    };\n    return FullCalendar;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n/* harmony default export */ __webpack_exports__[\"default\"] = (FullCalendar);\n// export all important utils/types\n //# sourceMappingURL=main.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQzVCO0FBQ2U7QUFDeUU7QUFDeEcsSUFBSU8sZUFBZSxXQUFXLEdBQUksU0FBVUMsTUFBTSxFQUFFO0lBQ2hEUCxnREFBU0EsQ0FBQ00sY0FBY0M7SUFDeEIsU0FBU0QsZUFBZTtRQUNwQixJQUFJRSxRQUFRRCxXQUFXLElBQUksSUFBSUEsT0FBT0UsS0FBSyxDQUFDLElBQUksRUFBRUMsY0FBYyxJQUFJO1FBQ3BFRixNQUFNRyxZQUFZLEdBQUcsSUFBSVQsNkRBQVdBO1FBQ3BDLE9BQU9NO0lBQ1g7SUFDQUYsYUFBYU0sU0FBUyxDQUFDQyxNQUFNLEdBQUcsV0FBWTtRQUN4QyxxQkFBUVosZ0RBQW1CLENBQUNFLHNFQUFvQkEsRUFBRTtZQUFFWSxpQkFBaUIsSUFBSSxDQUFDQyxLQUFLO1lBQUVDLGFBQWEsSUFBSSxDQUFDTixZQUFZO1FBQUMsR0FBRyxTQUFVTyxJQUFJLEVBQUU7WUFBRSxxQkFBUWpCLGdEQUFtQixDQUFDSSw4REFBWUEsRUFBRTtnQkFBRWMsU0FBU0QsS0FBS0UsZUFBZTtnQkFBRUMsT0FBT0gsS0FBS0csS0FBSztnQkFBRUMsU0FBU0osS0FBS0ksT0FBTztZQUFDLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFO2dCQUFFLHFCQUFRekIsZ0RBQW1CLENBQUMsT0FBTztvQkFBRTBCLFdBQVdKLFdBQVdLLElBQUksQ0FBQztvQkFBTUMsT0FBTzt3QkFBRUwsUUFBUUE7b0JBQU87Z0JBQUUsaUJBQ2hadkIsZ0RBQW1CLENBQUNHLGlFQUFlQSxFQUFFTCwrQ0FBUUEsQ0FBQztvQkFBRTBCLGNBQWNBO29CQUFjQyxVQUFVQTtnQkFBUyxHQUFHUjtZQUFVO1FBQUs7SUFDekg7SUFDQVosYUFBYU0sU0FBUyxDQUFDa0IsTUFBTSxHQUFHLFdBQVk7UUFDeEMsT0FBTyxJQUFJLENBQUNuQixZQUFZO0lBQzVCO0lBQ0EsT0FBT0w7QUFDWCxFQUFFTCw0Q0FBZTtBQUNqQiwrREFBZUssWUFBWUEsRUFBQztBQUM1QixtQ0FBbUM7QUFDRSxDQUNyQyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC9tYWluLmpzPzUzNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hc3NpZ24sIF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICcuL3Zkb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FsZW5kYXJBcGksIENhbGVuZGFyRGF0YVByb3ZpZGVyLCBDYWxlbmRhckNvbnRlbnQsIENhbGVuZGFyUm9vdCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJztcbnZhciBGdWxsQ2FsZW5kYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bGxDYWxlbmRhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdWxsQ2FsZW5kYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2FsZW5kYXJBcGkgPSBuZXcgQ2FsZW5kYXJBcGkoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdWxsQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyRGF0YVByb3ZpZGVyLCB7IG9wdGlvbk92ZXJyaWRlczogdGhpcy5wcm9wcywgY2FsZW5kYXJBcGk6IHRoaXMuX2NhbGVuZGFyQXBpIH0sIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxlbmRhclJvb3QsIHsgb3B0aW9uczogZGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBkYXRhLnRoZW1lLCBlbWl0dGVyOiBkYXRhLmVtaXR0ZXIgfSwgZnVuY3Rpb24gKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQ6IGhlaWdodCB9IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyQ29udGVudCwgX19hc3NpZ24oeyBpc0hlaWdodEF1dG86IGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQ6IGZvclByaW50IH0sIGRhdGEpKSkpOyB9KSk7IH0pKTtcbiAgICB9O1xuICAgIEZ1bGxDYWxlbmRhci5wcm90b3R5cGUuZ2V0QXBpID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXJBcGk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVsbENhbGVuZGFyO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydCBkZWZhdWx0IEZ1bGxDYWxlbmRhcjtcbi8vIGV4cG9ydCBhbGwgaW1wb3J0YW50IHV0aWxzL3R5cGVzXG5leHBvcnQgKiBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIl9fZXh0ZW5kcyIsIlJlYWN0IiwiQ2FsZW5kYXJBcGkiLCJDYWxlbmRhckRhdGFQcm92aWRlciIsIkNhbGVuZGFyQ29udGVudCIsIkNhbGVuZGFyUm9vdCIsIkZ1bGxDYWxlbmRhciIsIl9zdXBlciIsIl90aGlzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJfY2FsZW5kYXJBcGkiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50Iiwib3B0aW9uT3ZlcnJpZGVzIiwicHJvcHMiLCJjYWxlbmRhckFwaSIsImRhdGEiLCJvcHRpb25zIiwiY2FsZW5kYXJPcHRpb25zIiwidGhlbWUiLCJlbWl0dGVyIiwiY2xhc3NOYW1lcyIsImhlaWdodCIsImlzSGVpZ2h0QXV0byIsImZvclByaW50IiwiY2xhc3NOYW1lIiwiam9pbiIsInN0eWxlIiwiZ2V0QXBpIiwiQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/main.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/vdom.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/vdom.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flushSync\": function() { return /* binding */ flushSync; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n(typeof globalThis !== \"undefined\" ? globalThis : window).FullCalendarVDom = {\n    Component: react__WEBPACK_IMPORTED_MODULE_0__.Component,\n    createElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement,\n    render: react_dom__WEBPACK_IMPORTED_MODULE_1__.render,\n    createRef: react__WEBPACK_IMPORTED_MODULE_0__.createRef,\n    Fragment: react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    createContext: react__WEBPACK_IMPORTED_MODULE_0__.createContext,\n    createPortal: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal,\n    flushSync: flushSync,\n    unmountComponentAtNode: react_dom__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode // never called by FullCalendar's React component\n};\nfunction flushSync(callback) {\n    // always sync from top-level\n    callback();\n} //# sourceMappingURL=vdom.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDTztBQUNyQyxRQUFPRSxlQUFlLGNBQWNBLGFBQWFDLE1BQU0sRUFBRUMsZ0JBQWdCLEdBQUc7SUFDekVDLFdBQVdMLDRDQUFlO0lBQzFCTSxlQUFlTixnREFBbUI7SUFDbENPLFFBQVFOLDZDQUFlO0lBQ3ZCTyxXQUFXUiw0Q0FBZTtJQUMxQlMsVUFBVVQsMkNBQWM7SUFDeEJVLGVBQWVWLGdEQUFtQjtJQUNsQ1csY0FBY1YsbURBQXFCO0lBQ25DVyxXQUFXQTtJQUNYQyx3QkFBd0JaLDZEQUErQixDQUFDLGlEQUFpRDtBQUM3RztBQUNPLFNBQVNXLFVBQVVFLFFBQVEsRUFBRTtJQUNoQyw2QkFBNkI7SUFDN0JBO0FBQ0osQ0FBQyxDQUNELGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uanM/NGRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyByZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyByZWFjdERvbSBmcm9tICdyZWFjdC1kb20nO1xuKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB3aW5kb3cpLkZ1bGxDYWxlbmRhclZEb20gPSB7XG4gICAgQ29tcG9uZW50OiByZWFjdC5Db21wb25lbnQsXG4gICAgY3JlYXRlRWxlbWVudDogcmVhY3QuY3JlYXRlRWxlbWVudCxcbiAgICByZW5kZXI6IHJlYWN0RG9tLnJlbmRlcixcbiAgICBjcmVhdGVSZWY6IHJlYWN0LmNyZWF0ZVJlZixcbiAgICBGcmFnbWVudDogcmVhY3QuRnJhZ21lbnQsXG4gICAgY3JlYXRlQ29udGV4dDogcmVhY3QuY3JlYXRlQ29udGV4dCxcbiAgICBjcmVhdGVQb3J0YWw6IHJlYWN0RG9tLmNyZWF0ZVBvcnRhbCxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiByZWFjdERvbS51bm1vdW50Q29tcG9uZW50QXROb2RlIC8vIG5ldmVyIGNhbGxlZCBieSBGdWxsQ2FsZW5kYXIncyBSZWFjdCBjb21wb25lbnRcbn07XG5leHBvcnQgZnVuY3Rpb24gZmx1c2hTeW5jKGNhbGxiYWNrKSB7XG4gICAgLy8gYWx3YXlzIHN5bmMgZnJvbSB0b3AtbGV2ZWxcbiAgICBjYWxsYmFjaygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmRvbS5qcy5tYXAiXSwibmFtZXMiOlsicmVhY3QiLCJyZWFjdERvbSIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJGdWxsQ2FsZW5kYXJWRG9tIiwiQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsInJlbmRlciIsImNyZWF0ZVJlZiIsIkZyYWdtZW50IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVBvcnRhbCIsImZsdXNoU3luYyIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJjYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/vdom.js\n"));

/***/ }),

/***/ "./node_modules/@fullcalendar/timegrid/main.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/timegrid/main.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DayTimeCols\": function() { return /* binding */ DayTimeCols; },\n/* harmony export */   \"DayTimeColsSlicer\": function() { return /* binding */ DayTimeColsSlicer; },\n/* harmony export */   \"DayTimeColsView\": function() { return /* binding */ DayTimeColsView; },\n/* harmony export */   \"TimeCols\": function() { return /* binding */ TimeCols; },\n/* harmony export */   \"TimeColsSlatsCoords\": function() { return /* binding */ TimeColsSlatsCoords; },\n/* harmony export */   \"TimeColsView\": function() { return /* binding */ TimeColsView; },\n/* harmony export */   \"buildDayRanges\": function() { return /* binding */ buildDayRanges; },\n/* harmony export */   \"buildSlatMetas\": function() { return /* binding */ buildSlatMetas; },\n/* harmony export */   \"buildTimeColsModel\": function() { return /* binding */ buildTimeColsModel; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/timegrid/main.css\");\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_main_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.js\");\n/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \n\n\n\nvar AllDaySplitter = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(AllDaySplitter, _super);\n    function AllDaySplitter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AllDaySplitter.prototype.getKeyInfo = function() {\n        return {\n            allDay: {},\n            timed: {}\n        };\n    };\n    AllDaySplitter.prototype.getKeysForDateSpan = function(dateSpan) {\n        if (dateSpan.allDay) {\n            return [\n                \"allDay\"\n            ];\n        }\n        return [\n            \"timed\"\n        ];\n    };\n    AllDaySplitter.prototype.getKeysForEventDef = function(eventDef) {\n        if (!eventDef.allDay) {\n            return [\n                \"timed\"\n            ];\n        }\n        if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.hasBgRendering)(eventDef)) {\n            return [\n                \"timed\",\n                \"allDay\"\n            ];\n        }\n        return [\n            \"allDay\"\n        ];\n    };\n    return AllDaySplitter;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Splitter);\nvar DEFAULT_SLAT_LABEL_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"short\"\n});\nfunction TimeColsAxisCell(props) {\n    var classNames = [\n        \"fc-timegrid-slot\",\n        \"fc-timegrid-slot-label\",\n        props.isLabeled ? \"fc-scrollgrid-shrink\" : \"fc-timegrid-slot-minor\"\n    ];\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewContextType.Consumer, null, function(context) {\n        if (!props.isLabeled) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                className: classNames.join(\" \"),\n                \"data-time\": props.isoTimeStr\n            });\n        }\n        var dateEnv = context.dateEnv, options = context.options, viewApi = context.viewApi;\n        var labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)(options.slotLabelFormat[0]) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)(options.slotLabelFormat);\n        var hookProps = {\n            level: 0,\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat)\n        };\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n            hookProps: hookProps,\n            classNames: options.slotLabelClassNames,\n            content: options.slotLabelContent,\n            defaultContent: renderInnerContent,\n            didMount: options.slotLabelDidMount,\n            willUnmount: options.slotLabelWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                ref: rootElRef,\n                className: classNames.concat(customClassNames).join(\" \"),\n                \"data-time\": props.isoTimeStr\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\",\n                ref: innerElRef\n            }, innerContent)));\n        });\n    });\n}\n_c = TimeColsAxisCell;\nfunction renderInnerContent(props) {\n    return props.text;\n}\nvar TimeBodyAxis = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeBodyAxis, _super);\n    function TimeBodyAxis() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeBodyAxis.prototype.render = function() {\n        return this.props.slatMetas.map(function(slatMeta) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                key: slatMeta.key\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, slatMeta)));\n        });\n    };\n    return TimeBodyAxis;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n    week: \"short\"\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nvar TimeColsView = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColsView, _super);\n    function TimeColsView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n        _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.scrollerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            slatCoords: null\n        };\n        _this.handleScrollTopRequest = function(scrollTop) {\n            var scrollerEl = _this.scrollerElRef.current;\n            if (scrollerEl) {\n                scrollerEl.scrollTop = scrollTop;\n            }\n        };\n        /* Header Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ _this.renderHeadAxis = function(rowKey, frameHeight) {\n            if (frameHeight === void 0) {\n                frameHeight = \"\";\n            }\n            var options = _this.context.options;\n            var dateProfile = _this.props.dateProfile;\n            var range = dateProfile.renderRange;\n            var dayCnt = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDays)(range.start, range.end);\n            var navLinkAttrs = dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n             ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkAttrs)(_this.context, range.start, \"week\") : {};\n            if (options.weekNumbers && rowKey === \"day\") {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot, {\n                    date: range.start,\n                    defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n                }, function(rootElRef, classNames, innerElRef, innerContent) {\n                    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", {\n                        ref: rootElRef,\n                        \"aria-hidden\": true,\n                        className: [\n                            \"fc-timegrid-axis\",\n                            \"fc-scrollgrid-shrink\"\n                        ].concat(classNames).join(\" \")\n                    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                        className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\",\n                        style: {\n                            height: frameHeight\n                        }\n                    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                        ref: innerElRef,\n                        className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\"\n                    }, navLinkAttrs), innerContent)));\n                });\n            }\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", {\n                \"aria-hidden\": true,\n                className: \"fc-timegrid-axis\"\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-axis-frame\",\n                style: {\n                    height: frameHeight\n                }\n            }));\n        };\n        /* Table Component Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n        // but DayGrid still needs to have classNames on inner elements in order to measure.\n        _this.renderTableRowAxis = function(rowHeight) {\n            var _a = _this.context, options = _a.options, viewApi = _a.viewApi;\n            var hookProps = {\n                text: options.allDayText,\n                view: viewApi\n            };\n            return(// TODO: make reusable hook. used in list view too\n            (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n                hookProps: hookProps,\n                classNames: options.allDayClassNames,\n                content: options.allDayContent,\n                defaultContent: renderAllDayInner,\n                didMount: options.allDayDidMount,\n                willUnmount: options.allDayWillUnmount\n            }, function(rootElRef, classNames, innerElRef, innerContent) {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    ref: rootElRef,\n                    \"aria-hidden\": true,\n                    className: [\n                        \"fc-timegrid-axis\",\n                        \"fc-scrollgrid-shrink\"\n                    ].concat(classNames).join(\" \")\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame\" + (rowHeight == null ? \" fc-timegrid-axis-frame-liquid\" : \"\"),\n                    style: {\n                        height: rowHeight\n                    }\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n                    className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\",\n                    ref: innerElRef\n                }, innerContent)));\n            }));\n        };\n        _this.handleSlatCoords = function(slatCoords) {\n            _this.setState({\n                slatCoords: slatCoords\n            });\n        };\n        return _this;\n    }\n    // rendering\n    // ----------------------------------------------------------------------------------------------------\n    TimeColsView.prototype.renderSimpleLayout = function(headerRowContent, allDayContent, timeContent) {\n        var _a = this, context = _a.context, props = _a.props;\n        var sections = [];\n        var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                chunk: {\n                    content: allDayContent\n                }\n            });\n            sections.push({\n                type: \"body\",\n                key: \"all-day-divider\",\n                outerContent: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunk: {\n                scrollerElRef: this.scrollerElRef,\n                content: timeContent\n            }\n        });\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n            viewSpec: context.viewSpec,\n            elRef: this.rootElRef\n        }, function(rootElRef, classNames) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: [\n                    \"fc-timegrid\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [\n                    {\n                        width: \"shrink\"\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    TimeColsView.prototype.renderHScrollLayout = function(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n        var _this = this;\n        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        var _a = this, context = _a.context, props = _a.props;\n        var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n        var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar)(context.options);\n        var sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: function(arg) {\n                            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                                role: \"presentation\"\n                            }, _this.renderHeadAxis(\"day\", arg.rowSyncHeights[0]));\n                        }\n                    },\n                    {\n                        key: \"cols\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: \"body\",\n                key: \"all-day\",\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        rowContent: function(contentArg) {\n                            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                                role: \"presentation\"\n                            }, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n                        }\n                    },\n                    {\n                        key: \"cols\",\n                        content: allDayContent\n                    }\n                ]\n            });\n            sections.push({\n                key: \"all-day-divider\",\n                type: \"body\",\n                outerContent: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                    role: \"presentation\",\n                    className: \"fc-scrollgrid-section\"\n                }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    colSpan: 2,\n                    className: \"fc-timegrid-divider \" + context.theme.getClass(\"tableCellShaded\")\n                }))\n            });\n        }\n        var isNowIndicator = context.options.nowIndicator;\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunks: [\n                {\n                    key: \"axis\",\n                    content: function(arg) {\n                        return(// TODO: make this now-indicator arrow more DRY with TimeColsContent\n                        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                            className: \"fc-timegrid-axis-chunk\"\n                        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n                            \"aria-hidden\": true,\n                            style: {\n                                height: arg.expandRows ? arg.clientHeight : \"\"\n                            }\n                        }, arg.tableColGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeBodyAxis, {\n                            slatMetas: slatMetas\n                        }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                            className: \"fc-timegrid-now-indicator-container\"\n                        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n                            unit: isNowIndicator ? \"minute\" : \"day\" /* hacky */ \n                        }, function(nowDate) {\n                            var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                            if (typeof nowIndicatorTop === \"number\") {\n                                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowIndicatorRoot, {\n                                    isAxis: true,\n                                    date: nowDate\n                                }, function(rootElRef, classNames, innerElRef, innerContent) {\n                                    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                                        ref: rootElRef,\n                                        className: [\n                                            \"fc-timegrid-now-indicator-arrow\"\n                                        ].concat(classNames).join(\" \"),\n                                        style: {\n                                            top: nowIndicatorTop\n                                        }\n                                    }, innerContent);\n                                });\n                            }\n                            return null;\n                        }))));\n                    }\n                },\n                {\n                    key: \"cols\",\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                key: \"footer\",\n                type: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"axis\",\n                        content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim\n                    },\n                    {\n                        key: \"cols\",\n                        content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim\n                    }\n                ]\n            });\n        }\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n            viewSpec: context.viewSpec,\n            elRef: this.rootElRef\n        }, function(rootElRef, classNames) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: [\n                    \"fc-timegrid\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: false,\n                colGroups: [\n                    {\n                        width: \"shrink\",\n                        cols: [\n                            {\n                                width: \"shrink\"\n                            }\n                        ]\n                    },\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/ TimeColsView.prototype.getAllDayMaxEventProps = function() {\n        var _a = this.context.options, dayMaxEvents = _a.dayMaxEvents, dayMaxEventRows = _a.dayMaxEventRows;\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            dayMaxEvents = undefined;\n            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n        }\n        return {\n            dayMaxEvents: dayMaxEvents,\n            dayMaxEventRows: dayMaxEventRows\n        };\n    };\n    return TimeColsView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction renderAllDayInner(hookProps) {\n    return hookProps.text;\n}\nvar TimeColsSlatsCoords = /** @class */ function() {\n    function TimeColsSlatsCoords(positions, dateProfile, slotDuration) {\n        this.positions = positions;\n        this.dateProfile = dateProfile;\n        this.slotDuration = slotDuration;\n    }\n    TimeColsSlatsCoords.prototype.safeComputeTop = function(date) {\n        var dateProfile = this.dateProfile;\n        if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangeContainsMarker)(dateProfile.currentRange, date)) {\n            var startOfDayDate = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay)(date);\n            var timeMs = date.valueOf() - startOfDayDate.valueOf();\n            if (timeMs >= (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(dateProfile.slotMinTime) && timeMs < (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(dateProfile.slotMaxTime)) {\n                return this.computeTimeTop((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration)(timeMs));\n            }\n        }\n        return null;\n    };\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    TimeColsSlatsCoords.prototype.computeDateTop = function(when, startOfDayDate) {\n        if (!startOfDayDate) {\n            startOfDayDate = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay)(when);\n        }\n        return this.computeTimeTop((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration)(when.valueOf() - startOfDayDate.valueOf()));\n    };\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n    TimeColsSlatsCoords.prototype.computeTimeTop = function(duration) {\n        var _a = this, positions = _a.positions, dateProfile = _a.dateProfile;\n        var len = positions.els.length;\n        // floating-point value of # of slots covered\n        var slatCoverage = (duration.milliseconds - (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(dateProfile.slotMinTime)) / (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(this.slotDuration);\n        var slatIndex;\n        var slatRemainder;\n        // compute a floating-point number for how many slats should be progressed through.\n        // from 0 to number of slats (inclusive)\n        // constrained because slotMinTime/slotMaxTime might be customized.\n        slatCoverage = Math.max(0, slatCoverage);\n        slatCoverage = Math.min(len, slatCoverage);\n        // an integer index of the furthest whole slat\n        // from 0 to number slats (*exclusive*, so len-1)\n        slatIndex = Math.floor(slatCoverage);\n        slatIndex = Math.min(slatIndex, len - 1);\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n        // could be 1.0 if slatCoverage is covering *all* the slots\n        slatRemainder = slatCoverage - slatIndex;\n        return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n    };\n    return TimeColsSlatsCoords;\n}();\nvar TimeColsSlatsBody = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColsSlatsBody, _super);\n    function TimeColsSlatsBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColsSlatsBody.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var slatElRefs = props.slatElRefs;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, props.slatMetas.map(function(slatMeta, i) {\n            var hookProps = {\n                time: slatMeta.time,\n                date: context.dateEnv.toDate(slatMeta.date),\n                view: context.viewApi\n            };\n            var classNames = [\n                \"fc-timegrid-slot\",\n                \"fc-timegrid-slot-lane\",\n                slatMeta.isLabeled ? \"\" : \"fc-timegrid-slot-minor\"\n            ];\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n                key: slatMeta.key,\n                ref: slatElRefs.createRef(slatMeta.key)\n            }, props.axis && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, slatMeta)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n                hookProps: hookProps,\n                classNames: options.slotLaneClassNames,\n                content: options.slotLaneContent,\n                didMount: options.slotLaneDidMount,\n                willUnmount: options.slotLaneWillUnmount\n            }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n                    ref: rootElRef,\n                    className: classNames.concat(customClassNames).join(\" \"),\n                    \"data-time\": slatMeta.isoTimeStr\n                }, innerContent);\n            }));\n        }));\n    };\n    return TimeColsSlatsBody;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/ var TimeColsSlats = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColsSlats, _super);\n    function TimeColsSlats() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.slatElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap();\n        return _this;\n    }\n    TimeColsSlats.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            ref: this.rootElRef,\n            className: \"fc-timegrid-slots\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            \"aria-hidden\": true,\n            className: context.theme.getClass(\"table\"),\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth,\n                height: props.minHeight\n            }\n        }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlatsBody, {\n            slatElRefs: this.slatElRefs,\n            axis: props.axis,\n            slatMetas: props.slatMetas\n        })));\n    };\n    TimeColsSlats.prototype.componentDidMount = function() {\n        this.updateSizing();\n    };\n    TimeColsSlats.prototype.componentDidUpdate = function() {\n        this.updateSizing();\n    };\n    TimeColsSlats.prototype.componentWillUnmount = function() {\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    };\n    TimeColsSlats.prototype.updateSizing = function() {\n        var _a = this, context = _a.context, props = _a.props;\n        if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            var rootEl = this.rootElRef.current;\n            if (rootEl.offsetHeight) {\n                props.onCoords(new TimeColsSlatsCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n            }\n        }\n    };\n    return TimeColsSlats;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction collectSlatEls(elMap, slatMetas) {\n    return slatMetas.map(function(slatMeta) {\n        return elMap[slatMeta.key];\n    });\n}\nfunction splitSegsByCol(segs, colCnt) {\n    var segsByCol = [];\n    var i;\n    for(i = 0; i < colCnt; i += 1){\n        segsByCol.push([]);\n    }\n    if (segs) {\n        for(i = 0; i < segs.length; i += 1){\n            segsByCol[segs[i].col].push(segs[i]);\n        }\n    }\n    return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n    var byRow = [];\n    if (!ui) {\n        for(var i = 0; i < colCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(var i = 0; i < colCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){\n            var seg = _a[_i];\n            byRow[seg.col].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nvar TimeColMoreLink = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColMoreLink, _super);\n    function TimeColMoreLink() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    TimeColMoreLink.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot, {\n            allDayDate: null,\n            moreCnt: props.hiddenSegs.length,\n            allSegs: props.hiddenSegs,\n            hiddenSegs: props.hiddenSegs,\n            alignmentElRef: this.rootElRef,\n            defaultContent: renderMoreLinkInner,\n            extraDateSpan: props.extraDateSpan,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            popoverContent: function() {\n                return renderPlainFgSegs(props.hiddenSegs, props);\n            }\n        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n                ref: function(el) {\n                    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(rootElRef, el);\n                    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.rootElRef, el);\n                },\n                className: [\n                    \"fc-timegrid-more-link\"\n                ].concat(classNames).join(\" \"),\n                style: {\n                    top: props.top,\n                    bottom: props.bottom\n                },\n                onClick: handleClick,\n                title: title,\n                \"aria-expanded\": isExpanded,\n                \"aria-controls\": popoverId\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: innerElRef,\n                className: \"fc-timegrid-more-link-inner fc-sticky\"\n            }, innerContent));\n        });\n    };\n    return TimeColMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction renderMoreLinkInner(props) {\n    return props.shortText;\n}\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n    var hierarchy = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    var hiddenEntries = hierarchy.addSegs(segInputs);\n    var hiddenGroups = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.groupIntersectingEntries)(hiddenEntries);\n    var web = buildWeb(hierarchy);\n    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n    var segRects = webToRects(web);\n    return {\n        segRects: segRects,\n        hiddenGroups: hiddenGroups\n    };\n}\nfunction buildWeb(hierarchy) {\n    var entriesByLevel = hierarchy.entriesByLevel;\n    var buildNode = cacheable(function(level, lateral) {\n        return level + \":\" + lateral;\n    }, function(level, lateral) {\n        var siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n        var nextLevelRes = buildNodes(siblingRange, buildNode);\n        var entry = entriesByLevel[level][lateral];\n        return [\n            (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, entry), {\n                nextLevelNodes: nextLevelRes[0]\n            }),\n            entry.thickness + nextLevelRes[1]\n        ];\n    });\n    return buildNodes(entriesByLevel.length ? {\n        level: 0,\n        lateralStart: 0,\n        lateralEnd: entriesByLevel[0].length\n    } : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n    if (!siblingRange) {\n        return [\n            [],\n            0\n        ];\n    }\n    var level = siblingRange.level, lateralStart = siblingRange.lateralStart, lateralEnd = siblingRange.lateralEnd;\n    var lateral = lateralStart;\n    var pairs = [];\n    while(lateral < lateralEnd){\n        pairs.push(buildNode(level, lateral));\n        lateral += 1;\n    }\n    pairs.sort(cmpDescPressures);\n    return [\n        pairs.map(extractNode),\n        pairs[0][1]\n    ];\n}\nfunction cmpDescPressures(a, b) {\n    return b[1] - a[1];\n}\nfunction extractNode(a) {\n    return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n    var levelCoords = hierarchy.levelCoords, entriesByLevel = hierarchy.entriesByLevel;\n    var subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n    var afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n    var levelCnt = levelCoords.length;\n    var level = subjectLevel;\n    // skip past levels that are too high up\n    for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n    for(; level < levelCnt; level += 1){\n        var entries = entriesByLevel[level];\n        var entry = void 0;\n        var searchIndex = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.binarySearch)(entries, subjectEntry.span.start, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEntrySpanEnd);\n        var lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n        var lateralEnd = lateralStart;\n        while((entry = entries[lateralEnd]) && // but not past the whole seg list\n        entry.span.start < subjectEntry.span.end){\n            lateralEnd += 1;\n        }\n        if (lateralStart < lateralEnd) {\n            return {\n                level: level,\n                lateralStart: lateralStart,\n                lateralEnd: lateralEnd\n            };\n        }\n    }\n    return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n    var stretchNode = cacheable(function(node, startCoord, prevThickness) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(node);\n    }, function(node, startCoord, prevThickness) {\n        var nextLevelNodes = node.nextLevelNodes, thickness = node.thickness;\n        var allThickness = thickness + prevThickness;\n        var thicknessFraction = thickness / allThickness;\n        var endCoord;\n        var newChildren = [];\n        if (!nextLevelNodes.length) {\n            endCoord = totalThickness;\n        } else {\n            for(var _i = 0, nextLevelNodes_1 = nextLevelNodes; _i < nextLevelNodes_1.length; _i++){\n                var childNode = nextLevelNodes_1[_i];\n                if (endCoord === undefined) {\n                    var res = stretchNode(childNode, startCoord, allThickness);\n                    endCoord = res[0];\n                    newChildren.push(res[1]);\n                } else {\n                    var res = stretchNode(childNode, endCoord, 0);\n                    newChildren.push(res[1]);\n                }\n            }\n        }\n        var newThickness = (endCoord - startCoord) * thicknessFraction;\n        return [\n            endCoord - newThickness,\n            (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), {\n                thickness: newThickness,\n                nextLevelNodes: newChildren\n            })\n        ];\n    });\n    return topLevelNodes.map(function(node) {\n        return stretchNode(node, 0, 0)[1];\n    });\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n    var rects = [];\n    var processNode = cacheable(function(node, levelCoord, stackDepth) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(node);\n    }, function(node, levelCoord, stackDepth) {\n        var rect = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, node), {\n            levelCoord: levelCoord,\n            stackDepth: stackDepth,\n            stackForward: 0\n        });\n        rects.push(rect);\n        return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n    });\n    function processNodes(nodes, levelCoord, stackDepth) {\n        var stackForward = 0;\n        for(var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++){\n            var node = nodes_1[_i];\n            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n        }\n        return stackForward;\n    }\n    processNodes(topLevelNodes, 0, 0);\n    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n    var cache = {};\n    return function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var key = keyFunc.apply(void 0, args);\n        return key in cache ? cache[key] : cache[key] = workFunc.apply(void 0, args);\n    };\n}\nfunction computeSegVCoords(segs, colDate, slatCoords, eventMinHeight) {\n    if (slatCoords === void 0) {\n        slatCoords = null;\n    }\n    if (eventMinHeight === void 0) {\n        eventMinHeight = 0;\n    }\n    var vcoords = [];\n    if (slatCoords) {\n        for(var i = 0; i < segs.length; i += 1){\n            var seg = segs[i];\n            var spanStart = slatCoords.computeDateTop(seg.start, colDate);\n            var spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));\n            vcoords.push({\n                start: Math.round(spanStart),\n                end: Math.round(spanEnd)\n            });\n        }\n    }\n    return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {\n    var segInputs = [];\n    var dumbSegs = []; // segs without coords\n    for(var i = 0; i < segs.length; i += 1){\n        var vcoords = segVCoords[i];\n        if (vcoords) {\n            segInputs.push({\n                index: i,\n                thickness: 1,\n                span: vcoords\n            });\n        } else {\n            dumbSegs.push(segs[i]);\n        }\n    }\n    var _a = buildPositioning(segInputs, eventOrderStrict, eventMaxStack), segRects = _a.segRects, hiddenGroups = _a.hiddenGroups;\n    var segPlacements = [];\n    for(var _i = 0, segRects_1 = segRects; _i < segRects_1.length; _i++){\n        var segRect = segRects_1[_i];\n        segPlacements.push({\n            seg: segs[segRect.index],\n            rect: segRect\n        });\n    }\n    for(var _b = 0, dumbSegs_1 = dumbSegs; _b < dumbSegs_1.length; _b++){\n        var dumbSeg = dumbSegs_1[_b];\n        segPlacements.push({\n            seg: dumbSeg,\n            rect: null\n        });\n    }\n    return {\n        segPlacements: segPlacements,\n        hiddenGroups: hiddenGroups\n    };\n}\nvar DEFAULT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    meridiem: false\n});\nvar TimeColEvent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColEvent, _super);\n    function TimeColEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColEvent.prototype.render = function() {\n        var classNames = [\n            \"fc-timegrid-event\",\n            \"fc-v-event\"\n        ];\n        if (this.props.isShort) {\n            classNames.push(\"fc-timegrid-event-short\");\n        }\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, this.props, {\n            defaultTimeFormat: DEFAULT_TIME_FORMAT,\n            extraClassNames: classNames\n        }));\n    };\n    return TimeColEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nvar TimeColMisc = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColMisc, _super);\n    function TimeColMisc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TimeColMisc.prototype.render = function() {\n        var props = this.props;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent, {\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            extraHookProps: props.extraHookProps\n        }, function(innerElRef, innerContent) {\n            return innerContent && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-misc\",\n                ref: innerElRef\n            }, innerContent);\n        });\n    };\n    return TimeColMisc;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nvar TimeCol = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeCol, _super);\n    function TimeCol() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.sortEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs);\n        return _this;\n    }\n    // TODO: memoize event-placement?\n    TimeCol.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var isSelectMirror = context.options.selectMirror;\n        var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n        var interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        var sortedFgSegs = this.sortEventSegs(props.fgEventSegs, context.options.eventOrder);\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot, {\n            elRef: props.elRef,\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            extraHookProps: props.extraHookProps\n        }, function(rootElRef, classNames, dataAttrs) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                ref: rootElRef,\n                role: \"gridcell\",\n                className: [\n                    \"fc-timegrid-col\"\n                ].concat(classNames, props.extraClassNames || []).join(\" \")\n            }, dataAttrs, props.extraDataAttrs), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-frame\"\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-bg\"\n            }, _this.renderFillSegs(props.businessHourSegs, \"non-business\"), _this.renderFillSegs(props.bgEventSegs, \"bg-event\"), _this.renderFillSegs(props.dateSelectionSegs, \"highlight\")), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, _this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-col-events\"\n            }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n            }, _this.renderNowIndicator(props.nowIndicatorSegs)), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColMisc, {\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraHookProps: props.extraHookProps\n            })));\n        });\n    };\n    TimeCol.prototype.renderFgSegs = function(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        var props = this.props;\n        if (props.forPrint) {\n            return renderPlainFgSegs(sortedFgSegs, props);\n        }\n        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n    };\n    TimeCol.prototype.renderPositionedFgSegs = function(segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n        var _this = this;\n        var _a = this.context.options, eventMaxStack = _a.eventMaxStack, eventShortHeight = _a.eventShortHeight, eventOrderStrict = _a.eventOrderStrict, eventMinHeight = _a.eventMinHeight;\n        var _b = this.props, date = _b.date, slatCoords = _b.slatCoords, eventSelection = _b.eventSelection, todayRange = _b.todayRange, nowDate = _b.nowDate;\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n        var _c = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack), segPlacements = _c.segPlacements, hiddenGroups = _c.hiddenGroups;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map(function(segPlacement) {\n            var seg = segPlacement.seg, rect = segPlacement.rect;\n            var instanceId = seg.eventRange.instance.instanceId;\n            var isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n            var vStyle = computeSegVStyle(rect && rect.span);\n            var hStyle = !isMirror && rect ? _this.computeSegHStyle(rect) : {\n                left: 0,\n                right: 0\n            };\n            var isInset = Boolean(rect) && rect.stackForward > 0;\n            var isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                className: \"fc-timegrid-event-harness\" + (isInset ? \" fc-timegrid-event-harness-inset\" : \"\"),\n                key: instanceId,\n                style: (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                    visibility: isVisible ? \"\" : \"hidden\"\n                }, vStyle), hStyle)\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                seg: seg,\n                isDragging: isDragging,\n                isResizing: isResizing,\n                isDateSelecting: isDateSelecting,\n                isSelected: instanceId === eventSelection,\n                isShort: isShort\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange, nowDate))));\n        }));\n    };\n    // will already have eventMinHeight applied because segInputs already had it\n    TimeCol.prototype.renderHiddenGroups = function(hiddenGroups, segs) {\n        var _a = this.props, extraDateSpan = _a.extraDateSpan, dateProfile = _a.dateProfile, todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, hiddenGroups.map(function(hiddenGroup) {\n            var positionCss = computeSegVStyle(hiddenGroup.span);\n            var hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColMoreLink, {\n                key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildIsoString)((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeEarliestSegStart)(hiddenSegs)),\n                hiddenSegs: hiddenSegs,\n                top: positionCss.top,\n                bottom: positionCss.bottom,\n                extraDateSpan: extraDateSpan,\n                dateProfile: dateProfile,\n                todayRange: todayRange,\n                nowDate: nowDate,\n                eventSelection: eventSelection,\n                eventDrag: eventDrag,\n                eventResize: eventResize\n            });\n        }));\n    };\n    TimeCol.prototype.renderFillSegs = function(segs, fillType) {\n        var _a = this, props = _a.props, context = _a.context;\n        var segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n        var children = segVCoords.map(function(vcoords, i) {\n            var seg = segs[i];\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey)(seg.eventRange),\n                className: \"fc-timegrid-bg-harness\",\n                style: computeSegVStyle(vcoords)\n            }, fillType === \"bg-event\" ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                seg: seg\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange, props.nowDate))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill)(fillType));\n        });\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children);\n    };\n    TimeCol.prototype.renderNowIndicator = function(segs) {\n        var _a = this.props, slatCoords = _a.slatCoords, date = _a.date;\n        if (!slatCoords) {\n            return null;\n        }\n        return segs.map(function(seg, i) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowIndicatorRoot, {\n                isAxis: false,\n                date: date,\n                // key doesn't matter. will only ever be one\n                key: i\n            }, function(rootElRef, classNames, innerElRef, innerContent) {\n                return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                    ref: rootElRef,\n                    className: [\n                        \"fc-timegrid-now-indicator-line\"\n                    ].concat(classNames).join(\" \"),\n                    style: {\n                        top: slatCoords.computeDateTop(seg.start, date)\n                    }\n                }, innerContent);\n            });\n        });\n    };\n    TimeCol.prototype.computeSegHStyle = function(segHCoords) {\n        var _a = this.context, isRtl = _a.isRtl, options = _a.options;\n        var shouldOverlap = options.slotEventOverlap;\n        var nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n        var farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n        var left; // amount of space from left edge, a fraction of the total width\n        var right; // amount of space from right edge, a fraction of the total width\n        if (shouldOverlap) {\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\n            farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n        }\n        if (isRtl) {\n            left = 1 - farCoord;\n            right = nearCoord;\n        } else {\n            left = nearCoord;\n            right = 1 - farCoord;\n        }\n        var props = {\n            zIndex: segHCoords.stackDepth + 1,\n            left: left * 100 + \"%\",\n            right: right * 100 + \"%\"\n        };\n        if (shouldOverlap && !segHCoords.stackForward) {\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\n            props[isRtl ? \"marginLeft\" : \"marginRight\"] = 10 * 2; // 10 is a guesstimate of the icon's width\n        }\n        return props;\n    };\n    return TimeCol;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction renderPlainFgSegs(sortedFgSegs, _a) {\n    var todayRange = _a.todayRange, nowDate = _a.nowDate, eventSelection = _a.eventSelection, eventDrag = _a.eventDrag, eventResize = _a.eventResize;\n    var hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, sortedFgSegs.map(function(seg) {\n        var instanceId = seg.eventRange.instance.instanceId;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            key: instanceId,\n            style: {\n                visibility: hiddenInstances[instanceId] ? \"hidden\" : \"\"\n            }\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === eventSelection,\n            isShort: false\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange, nowDate))));\n    }));\n}\nfunction computeSegVStyle(segVCoords) {\n    if (!segVCoords) {\n        return {\n            top: \"\",\n            bottom: \"\"\n        };\n    }\n    return {\n        top: segVCoords.start,\n        bottom: -segVCoords.end\n    };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n    return segEntries.map(function(segEntry) {\n        return allSegs[segEntry.index];\n    });\n}\nvar TimeColsContent = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeColsContent, _super);\n    function TimeColsContent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByCol);\n        _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByCol);\n        _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByCol);\n        _this.splitNowIndicatorSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByCol);\n        _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByCol);\n        _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByCol);\n        _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByCol);\n        _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap();\n        return _this;\n    }\n    TimeColsContent.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n        var colCnt = props.cells.length;\n        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n        var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n        var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n        var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-cols\",\n            ref: this.rootElRef\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n            role: \"presentation\",\n            style: {\n                minWidth: props.tableMinWidth,\n                width: props.clientWidth\n            }\n        }, props.tableColGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", {\n            role: \"presentation\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n            role: \"row\"\n        }, props.axis && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n            \"aria-hidden\": true,\n            className: \"fc-timegrid-col fc-timegrid-axis\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-col-frame\"\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-now-indicator-container\"\n        }, typeof nowIndicatorTop === \"number\" && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowIndicatorRoot, {\n            isAxis: true,\n            date: props.nowDate\n        }, function(rootElRef, classNames, innerElRef, innerContent) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-timegrid-now-indicator-arrow\"\n                ].concat(classNames).join(\" \"),\n                style: {\n                    top: nowIndicatorTop\n                }\n            }, innerContent);\n        })))), props.cells.map(function(cell, i) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCol, {\n                key: cell.key,\n                elRef: _this.cellElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                nowDate: props.nowDate,\n                todayRange: props.todayRange,\n                extraHookProps: cell.extraHookProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                fgEventSegs: fgEventSegsByRow[i],\n                bgEventSegs: bgEventSegsByRow[i],\n                businessHourSegs: businessHourSegsByRow[i],\n                nowIndicatorSegs: nowIndicatorSegsByRow[i],\n                dateSelectionSegs: dateSelectionSegsByRow[i],\n                eventDrag: eventDragByRow[i],\n                eventResize: eventResizeByRow[i],\n                slatCoords: props.slatCoords,\n                eventSelection: props.eventSelection,\n                forPrint: props.forPrint\n            });\n        })))));\n    };\n    TimeColsContent.prototype.componentDidMount = function() {\n        this.updateCoords();\n    };\n    TimeColsContent.prototype.componentDidUpdate = function() {\n        this.updateCoords();\n    };\n    TimeColsContent.prototype.updateCoords = function() {\n        var props = this.props;\n        if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n        ) {\n            props.onColCoords(new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));\n        }\n    };\n    return TimeColsContent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\nfunction collectCellEls(elMap, cells) {\n    return cells.map(function(cell) {\n        return elMap[cell.key];\n    });\n}\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/ var TimeCols = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(TimeCols, _super);\n    function TimeCols() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.processSlotOptions = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(processSlotOptions);\n        _this.state = {\n            slatCoords: null\n        };\n        _this.handleRootEl = function(el) {\n            if (el) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: el,\n                    isHitComboAllowed: _this.props.isHitComboAllowed\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        _this.handleScrollRequest = function(request) {\n            var onScrollTopRequest = _this.props.onScrollTopRequest;\n            var slatCoords = _this.state.slatCoords;\n            if (onScrollTopRequest && slatCoords) {\n                if (request.time) {\n                    var top_1 = slatCoords.computeTimeTop(request.time);\n                    top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n                    if (top_1) {\n                        top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    onScrollTopRequest(top_1);\n                }\n                return true;\n            }\n            return false;\n        };\n        _this.handleColCoords = function(colCoords) {\n            _this.colCoords = colCoords;\n        };\n        _this.handleSlatCoords = function(slatCoords) {\n            _this.setState({\n                slatCoords: slatCoords\n            });\n            if (_this.props.onSlatCoords) {\n                _this.props.onSlatCoords(slatCoords);\n            }\n        };\n        return _this;\n    }\n    TimeCols.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-timegrid-body\",\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlats, {\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            slatMetas: props.slatMetas,\n            clientWidth: props.clientWidth,\n            minHeight: props.expandRows ? props.clientHeight : \"\",\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.axis ? props.tableColGroupNode : null,\n            onCoords: this.handleSlatCoords\n        }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsContent, {\n            cells: props.cells,\n            axis: props.axis,\n            dateProfile: props.dateProfile,\n            businessHourSegs: props.businessHourSegs,\n            bgEventSegs: props.bgEventSegs,\n            fgEventSegs: props.fgEventSegs,\n            dateSelectionSegs: props.dateSelectionSegs,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            todayRange: props.todayRange,\n            nowDate: props.nowDate,\n            nowIndicatorSegs: props.nowIndicatorSegs,\n            clientWidth: props.clientWidth,\n            tableMinWidth: props.tableMinWidth,\n            tableColGroupNode: props.tableColGroupNode,\n            slatCoords: state.slatCoords,\n            onColCoords: this.handleColCoords,\n            forPrint: props.forPrint\n        }));\n    };\n    TimeCols.prototype.componentDidMount = function() {\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    };\n    TimeCols.prototype.componentDidUpdate = function(prevProps) {\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    };\n    TimeCols.prototype.componentWillUnmount = function() {\n        this.scrollResponder.detach();\n    };\n    TimeCols.prototype.queryHit = function(positionLeft, positionTop) {\n        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options;\n        var colCoords = this.colCoords;\n        var dateProfile = this.props.dateProfile;\n        var slatCoords = this.state.slatCoords;\n        var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration), snapDuration = _b.snapDuration, snapsPerSlot = _b.snapsPerSlot;\n        var colIndex = colCoords.leftToIndex(positionLeft);\n        var slatIndex = slatCoords.positions.topToIndex(positionTop);\n        if (colIndex != null && slatIndex != null) {\n            var cell = this.props.cells[colIndex];\n            var slatTop = slatCoords.positions.tops[slatIndex];\n            var slatHeight = slatCoords.positions.getHeight(slatIndex);\n            var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n            var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n            var dayDate = this.props.cells[colIndex].date;\n            var time = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDurations)(dateProfile.slotMinTime, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.multiplyDuration)(snapDuration, snapIndex));\n            var start = dateEnv.add(dayDate, time);\n            var end = dateEnv.add(start, snapDuration);\n            return {\n                dateProfile: dateProfile,\n                dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                    range: {\n                        start: start,\n                        end: end\n                    },\n                    allDay: false\n                }, cell.extraDateSpan),\n                dayEl: colCoords.els[colIndex],\n                rect: {\n                    left: colCoords.lefts[colIndex],\n                    right: colCoords.rights[colIndex],\n                    top: slatTop,\n                    bottom: slatTop + slatHeight\n                },\n                layer: 0\n            };\n        }\n        return null;\n    };\n    return TimeCols;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n    var snapDuration = snapDurationOverride || slotDuration;\n    var snapsPerSlot = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.wholeDivideDurations)(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n        snapDuration = slotDuration;\n        snapsPerSlot = 1;\n    // TODO: say warning?\n    }\n    return {\n        snapDuration: snapDuration,\n        snapsPerSlot: snapsPerSlot\n    };\n}\nvar DayTimeColsSlicer = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(DayTimeColsSlicer, _super);\n    function DayTimeColsSlicer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DayTimeColsSlicer.prototype.sliceRange = function(range, dayRanges) {\n        var segs = [];\n        for(var col = 0; col < dayRanges.length; col += 1){\n            var segRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(range, dayRanges[col]);\n            if (segRange) {\n                segs.push({\n                    start: segRange.start,\n                    end: segRange.end,\n                    isStart: segRange.start.valueOf() === range.start.valueOf(),\n                    isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                    col: col\n                });\n            }\n        }\n        return segs;\n    };\n    return DayTimeColsSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer);\nvar DayTimeCols = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(DayTimeCols, _super);\n    function DayTimeCols() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildDayRanges = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildDayRanges);\n        _this.slicer = new DayTimeColsSlicer();\n        _this.timeColsRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    DayTimeCols.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, context = _a.context;\n        var dateProfile = props.dateProfile, dayTableModel = props.dayTableModel;\n        var isNowIndicator = context.options.nowIndicator;\n        var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n        // give it the first row of cells\n        // TODO: would move this further down hierarchy, but sliceNowDate needs it\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n            unit: isNowIndicator ? \"minute\" : \"day\"\n        }, function(nowDate, todayRange) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCols, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({\n                ref: _this.timeColsRef\n            }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n                forPrint: props.forPrint,\n                axis: props.axis,\n                dateProfile: dateProfile,\n                slatMetas: props.slatMetas,\n                slotDuration: props.slotDuration,\n                cells: dayTableModel.cells[0],\n                tableColGroupNode: props.tableColGroupNode,\n                tableMinWidth: props.tableMinWidth,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                expandRows: props.expandRows,\n                nowDate: nowDate,\n                nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n                todayRange: todayRange,\n                onScrollTopRequest: props.onScrollTopRequest,\n                onSlatCoords: props.onSlatCoords\n            }));\n        });\n    };\n    return DayTimeCols;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n    var ranges = [];\n    for(var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++){\n        var date = _a[_i];\n        ranges.push({\n            start: dateEnv.add(date, dateProfile.slotMinTime),\n            end: dateEnv.add(date, dateProfile.slotMaxTime)\n        });\n    }\n    return ranges;\n}\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar STOCK_SUB_DURATIONS = [\n    {\n        hours: 1\n    },\n    {\n        minutes: 30\n    },\n    {\n        minutes: 15\n    },\n    {\n        seconds: 30\n    },\n    {\n        seconds: 15\n    }\n];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n    var dayStart = new Date(0);\n    var slatTime = slotMinTime;\n    var slatIterator = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration)(0);\n    var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n    var metas = [];\n    while((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(slatTime) < (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs)(slotMaxTime)){\n        var date = dateEnv.add(dayStart, slatTime);\n        var isLabeled = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.wholeDivideDurations)(slatIterator, labelInterval) !== null;\n        metas.push({\n            date: date,\n            time: slatTime,\n            key: date.toISOString(),\n            isoTimeStr: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatIsoTimeString)(date),\n            isLabeled: isLabeled\n        });\n        slatTime = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDurations)(slatTime, slotDuration);\n        slatIterator = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDurations)(slatIterator, slotDuration);\n    }\n    return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n    var i;\n    var labelInterval;\n    var slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){\n        labelInterval = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration)(STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.wholeDivideDurations)(labelInterval, slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1) {\n            return labelInterval;\n        }\n    }\n    return slotDuration; // fall back\n}\nvar DayTimeColsView = /** @class */ function(_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(DayTimeColsView, _super);\n    function DayTimeColsView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildTimeColsModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildTimeColsModel);\n        _this.buildSlatMetas = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildSlatMetas);\n        return _this;\n    }\n    DayTimeColsView.prototype.render = function() {\n        var _this = this;\n        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv, dateProfileGenerator = _a.dateProfileGenerator;\n        var props = this.props;\n        var dateProfile = props.dateProfile;\n        var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n        var splitProps = this.allDaySplitter.splitProps(props);\n        var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n        var dayMinWidth = options.dayMinWidth;\n        var hasAttachedAxis = !dayMinWidth;\n        var hasDetachedAxis = dayMinWidth;\n        var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader, {\n            dates: dayTableModel.headerDates,\n            dateProfile: dateProfile,\n            datesRepDistinctDays: true,\n            renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n        });\n        var allDayContent = options.allDaySlot !== false && function(contentArg) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__.DayTable, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, splitProps.allDay, {\n                dateProfile: dateProfile,\n                dayTableModel: dayTableModel,\n                nextDayThreshold: options.nextDayThreshold,\n                tableMinWidth: contentArg.tableMinWidth,\n                colGroupNode: contentArg.tableColGroupNode,\n                renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n                showWeekNumbers: false,\n                expandRows: false,\n                headerAlignElRef: _this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            }, _this.getAllDayMaxEventProps()));\n        };\n        var timeGridContent = function(contentArg) {\n            return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTimeCols, (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__assign)({}, splitProps.timed, {\n                dayTableModel: dayTableModel,\n                dateProfile: dateProfile,\n                axis: hasAttachedAxis,\n                slotDuration: options.slotDuration,\n                slatMetas: slatMetas,\n                forPrint: props.forPrint,\n                tableColGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                onSlatCoords: _this.handleSlatCoords,\n                expandRows: contentArg.expandRows,\n                onScrollTopRequest: _this.handleScrollTopRequest\n            }));\n        };\n        return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    };\n    return DayTimeColsView;\n}(TimeColsView);\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n    var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel(daySeries, false);\n}\nvar OPTION_REFINERS = {\n    allDaySlot: Boolean\n};\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n    initialView: \"timeGridWeek\",\n    optionRefiners: OPTION_REFINERS,\n    views: {\n        timeGrid: {\n            component: DayTimeColsView,\n            usesMinMaxTime: true,\n            allDaySlot: true,\n            slotDuration: \"00:30:00\",\n            slotEventOverlap: true\n        },\n        timeGridDay: {\n            type: \"timeGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        timeGridWeek: {\n            type: \"timeGrid\",\n            duration: {\n                weeks: 1\n            }\n        }\n    }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n //# sourceMappingURL=main.js.map\nvar _c;\n$RefreshReg$(_c, \"TimeColsAxisCell\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQSxHQUNvQjtBQUVnMEI7QUFDeHlCO0FBQ0s7QUFFakQsSUFBSXlELGlCQUFpQixXQUFXLEdBQUksU0FBVUMsTUFBTSxFQUFFO0lBQ2xESixnREFBU0EsQ0FBQ0csZ0JBQWdCQztJQUMxQixTQUFTRCxpQkFBaUI7UUFDdEIsT0FBT0MsV0FBVyxJQUFJLElBQUlBLE9BQU9DLEtBQUssQ0FBQyxJQUFJLEVBQUVDLGNBQWMsSUFBSTtJQUNuRTtJQUNBSCxlQUFlSSxTQUFTLENBQUNDLFVBQVUsR0FBRyxXQUFZO1FBQzlDLE9BQU87WUFDSEMsUUFBUSxDQUFDO1lBQ1RDLE9BQU8sQ0FBQztRQUNaO0lBQ0o7SUFDQVAsZUFBZUksU0FBUyxDQUFDSSxrQkFBa0IsR0FBRyxTQUFVQyxRQUFRLEVBQUU7UUFDOUQsSUFBSUEsU0FBU0gsTUFBTSxFQUFFO1lBQ2pCLE9BQU87Z0JBQUM7YUFBUztRQUNyQixDQUFDO1FBQ0QsT0FBTztZQUFDO1NBQVE7SUFDcEI7SUFDQU4sZUFBZUksU0FBUyxDQUFDTSxrQkFBa0IsR0FBRyxTQUFVQyxRQUFRLEVBQUU7UUFDOUQsSUFBSSxDQUFDQSxTQUFTTCxNQUFNLEVBQUU7WUFDbEIsT0FBTztnQkFBQzthQUFRO1FBQ3BCLENBQUM7UUFDRCxJQUFJL0Qsb0VBQWNBLENBQUNvRSxXQUFXO1lBQzFCLE9BQU87Z0JBQUM7Z0JBQVM7YUFBUztRQUM5QixDQUFDO1FBQ0QsT0FBTztZQUFDO1NBQVM7SUFDckI7SUFDQSxPQUFPWDtBQUNYLEVBQUV4RCwwREFBUUE7QUFFVixJQUFJb0UsNEJBQTRCbkUscUVBQWVBLENBQUM7SUFDNUNvRSxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsZ0JBQWdCLElBQUk7SUFDcEJDLFVBQVU7QUFDZDtBQUNBLFNBQVNDLGlCQUFpQkMsS0FBSyxFQUFFO0lBQzdC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LFVBQVUsSUFDM0ksSUFBSSxDQUFDOEIsa0JBQWtCLENBQUM4WCxlQUFlcFksZUFBZStZLGdCQUFnQjtJQUNoRjtJQUNBLE9BQU9sQjtBQUNYLEVBQUUzWjtBQUNGLFNBQVM0WixtQkFBbUI5WSxXQUFXLEVBQUUrWSxvQkFBb0IsRUFBRTtJQUMzRCxJQUFJaUIsWUFBWSxJQUFJcmYsZ0VBQWNBLENBQUNxRixZQUFZRSxXQUFXLEVBQUU2WTtJQUM1RCxPQUFPLElBQUluZSwrREFBYUEsQ0FBQ29mLFdBQVcsS0FBSztBQUM3QztBQUVBLElBQUlDLGtCQUFrQjtJQUNsQlIsWUFBWWpYO0FBQ2hCO0FBRUEsSUFBSTBYLE9BQU9yZixrRUFBWUEsQ0FBQztJQUNwQnNmLGFBQWE7SUFDYkMsZ0JBQWdCSDtJQUNoQkksT0FBTztRQUNIQyxVQUFVO1lBQ05DLFdBQVcxQjtZQUNYMkIsZ0JBQWdCLElBQUk7WUFDcEJmLFlBQVksSUFBSTtZQUNoQnpVLGNBQWM7WUFDZDROLGtCQUFrQixJQUFJO1FBQzFCO1FBQ0E2SCxhQUFhO1lBQ1Q3WSxNQUFNO1lBQ044RCxVQUFVO2dCQUFFZ1YsTUFBTTtZQUFFO1FBQ3hCO1FBQ0FDLGNBQWM7WUFDVi9ZLE1BQU07WUFDTjhELFVBQVU7Z0JBQUVrVixPQUFPO1lBQUU7UUFDekI7SUFDSjtBQUNKO0FBRUEsK0RBQWVWLElBQUlBLEVBQUM7QUFDd0ksQ0FDNUosZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL21haW4uanM/N2I0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbkZ1bGxDYWxlbmRhciB2NS4xMS4zXG5Eb2NzICYgTGljZW5zZTogaHR0cHM6Ly9mdWxsY2FsZW5kYXIuaW8vXG4oYykgMjAyMiBBZGFtIFNoYXdcbiovXG5pbXBvcnQgJy4vbWFpbi5jc3MnO1xuXG5pbXBvcnQgeyBoYXNCZ1JlbmRlcmluZywgU3BsaXR0ZXIsIGNyZWF0ZUZvcm1hdHRlciwgY3JlYXRlRWxlbWVudCwgVmlld0NvbnRleHRUeXBlLCBSZW5kZXJIb29rLCBCYXNlQ29tcG9uZW50LCBjcmVhdGVSZWYsIGRpZmZEYXlzLCBidWlsZE5hdkxpbmtBdHRycywgV2Vla051bWJlclJvb3QsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Um9vdCwgU2ltcGxlU2Nyb2xsR3JpZCwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLCBOb3dUaW1lciwgTm93SW5kaWNhdG9yUm9vdCwgcmVuZGVyU2Nyb2xsU2hpbSwgRGF0ZUNvbXBvbmVudCwgcmFuZ2VDb250YWluc01hcmtlciwgc3RhcnRPZkRheSwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiwgUmVmTWFwLCBQb3NpdGlvbkNhY2hlLCBNb3JlTGlua1Jvb3QsIHNldFJlZiwgU2VnSGllcmFyY2h5LCBncm91cEludGVyc2VjdGluZ0VudHJpZXMsIGJ1aWxkRW50cnlLZXksIGJpbmFyeVNlYXJjaCwgZ2V0RW50cnlTcGFuRW5kLCBTdGFuZGFyZEV2ZW50LCBEYXlDZWxsQ29udGVudCwgRnJhZ21lbnQsIGdldFNlZ01ldGEsIG1lbW9pemUsIHNvcnRFdmVudFNlZ3MsIERheUNlbGxSb290LCBidWlsZElzb1N0cmluZywgY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQsIGJ1aWxkRXZlbnRSYW5nZUtleSwgQmdFdmVudCwgcmVuZGVyRmlsbCwgYWRkRHVyYXRpb25zLCBtdWx0aXBseUR1cmF0aW9uLCB3aG9sZURpdmlkZUR1cmF0aW9ucywgaW50ZXJzZWN0UmFuZ2VzLCBTbGljZXIsIGZvcm1hdElzb1RpbWVTdHJpbmcsIERheUhlYWRlciwgRGF5U2VyaWVzTW9kZWwsIERheVRhYmxlTW9kZWwsIGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJztcbmltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBEYXlUYWJsZSB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCc7XG5cbnZhciBBbGxEYXlTcGxpdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWxsRGF5U3BsaXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWxsRGF5U3BsaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxEYXk6IHt9LFxuICAgICAgICAgICAgdGltZWQ6IHt9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JEYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH07XG4gICAgQWxsRGF5U3BsaXR0ZXIucHJvdG90eXBlLmdldEtleXNGb3JFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICB9O1xuICAgIHJldHVybiBBbGxEYXlTcGxpdHRlcjtcbn0oU3BsaXR0ZXIpKTtcblxudmFyIERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGlmICghcHJvcHMuaXNMYWJlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCB2aWV3QXBpID0gY29udGV4dC52aWV3QXBpO1xuICAgICAgICB2YXIgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0WzBdKSA6XG4gICAgICAgICAgICAgICAgY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KTtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgdGltZTogcHJvcHMudGltZSxcbiAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIHRleHQ6IGRhdGVFbnYuZm9ybWF0KHByb3BzLmRhdGUsIGxhYmVsRm9ybWF0KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuc2xvdExhYmVsQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5zbG90TGFiZWxDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVySW5uZXJDb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRkXCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBwcm9wcy5pc29UaW1lU3RyIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb25cIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpKSk7IH0pKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cblxudmFyIFRpbWVCb2R5QXhpcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUJvZHlBeGlzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVCb2R5QXhpcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUaW1lQm9keUF4aXMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2xhdE1ldGFzLm1hcChmdW5jdGlvbiAoc2xhdE1ldGEpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBfX2Fzc2lnbih7fSwgc2xhdE1ldGEpKSkpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQm9keUF4aXM7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIERFRkFVTFRfV0VFS19OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2VlazogJ3Nob3J0JyB9KTtcbnZhciBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MgPSA1O1xudmFyIFRpbWVDb2xzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbHNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVDb2xzVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xuICAgICAgICBfdGhpcy5oZWFkZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNsYXRDb29yZHM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgPSBmdW5jdGlvbiAoc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXJFbCA9IF90aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIF90aGlzLnJlbmRlckhlYWRBeGlzID0gZnVuY3Rpb24gKHJvd0tleSwgZnJhbWVIZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChmcmFtZUhlaWdodCA9PT0gdm9pZCAwKSB7IGZyYW1lSGVpZ2h0ID0gJyc7IH1cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMuY29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gX3RoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZTtcbiAgICAgICAgICAgIHZhciBkYXlDbnQgPSBkaWZmRGF5cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKSAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKF90aGlzLmNvbnRleHQsIHJhbmdlLnN0YXJ0LCAnd2VlaycpXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLndlZWtOdW1iZXJzICYmIHJvd0tleSA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoV2Vla051bWJlclJvb3QsIHsgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IHJlZjogcm9vdEVsUmVmLCBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBmYy10aW1lZ3JpZC1heGlzLWZyYW1lLWxpcXVpZFwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9fYXNzaWduKHsgcmVmOiBpbm5lckVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgbmF2TGlua0F0dHJzKSwgaW5uZXJDb250ZW50KSkpKTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzXCIgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtZnJhbWVcIiwgc3R5bGU6IHsgaGVpZ2h0OiBmcmFtZUhlaWdodCB9IH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFRhYmxlIENvbXBvbmVudCBSZW5kZXIgTWV0aG9kc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgICAgICAvLyBvbmx5IGEgb25lLXdheSBoZWlnaHQgc3luYy4gd2UgZG9uJ3Qgc2VuZCB0aGUgYXhpcyBpbm5lci1jb250ZW50IGhlaWdodCB0byB0aGUgRGF5R3JpZCxcbiAgICAgICAgLy8gYnV0IERheUdyaWQgc3RpbGwgbmVlZHMgdG8gaGF2ZSBjbGFzc05hbWVzIG9uIGlubmVyIGVsZW1lbnRzIGluIG9yZGVyIHRvIG1lYXN1cmUuXG4gICAgICAgIF90aGlzLnJlbmRlclRhYmxlUm93QXhpcyA9IGZ1bmN0aW9uIChyb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmNvbnRleHQsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCB2aWV3QXBpID0gX2Eudmlld0FwaTtcbiAgICAgICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5hbGxEYXlDb250ZW50LCBkZWZhdWx0Q29udGVudDogcmVuZGVyQWxsRGF5SW5uZXIsIGRpZE1vdW50OiBvcHRpb25zLmFsbERheURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5hbGxEYXlXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyByZWY6IHJvb3RFbFJlZiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgIF0uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyArIChyb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCByZWY6IGlubmVyRWxSZWYgfSwgaW5uZXJDb250ZW50KSkpKTsgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gZnVuY3Rpb24gKHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2xhdENvb3Jkczogc2xhdENvb3JkcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyByZW5kZXJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVGltZUNvbHNWaWV3LnByb3RvdHlwZS5yZW5kZXJTaW1wbGVMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYWxsRGF5Q29udGVudCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld1Jvb3QsIHsgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMsIGVsUmVmOiB0aGlzLnJvb3RFbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHJlZjogcm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzVmlldy5wcm90b3R5cGUucmVuZGVySFNjcm9sbExheW91dCA9IGZ1bmN0aW9uIChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCBzbGF0Q29vcmRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xuICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICB2YXIgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgdmFyIHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gW107XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCBfdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpOyB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIF90aGlzLnJlbmRlclRhYmxlUm93QXhpcyhjb250ZW50QXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpOyB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFsbERheUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZW50OiAoIC8vIFRPRE86IHJlbmFtZSB0byBjZWxsQ29udGVudCBzbyBkb24ndCBuZWVkIHRvIGRlZmluZSA8dHI+P1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXNlY3Rpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtY2h1bmtcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBzdHlsZTogeyBoZWlnaHQ6IGFyZy5leHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUJvZHlBeGlzLCB7IHNsYXRNZXRhczogc2xhdE1ldGFzIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IGlzTm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyAvKiBoYWNreSAqLyB9LCBmdW5jdGlvbiAobm93RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm93SW5kaWNhdG9yVG9wID0gaXNOb3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3Aobm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd0luZGljYXRvclJvb3QsIHsgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9IH0sIGlubmVyQ29udGVudCkpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSk7IH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYywgZWxSZWY6IHRoaXMucm9vdEVsUmVmIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbJ2ZjLXRpbWVncmlkJ10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBmYWxzZSwgY29sR3JvdXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6ICdzaHJpbmsnLCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9LFxuICAgICAgICAgICAgICAgIF0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICAvKiBEaW1lbnNpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBUaW1lQ29sc1ZpZXcucHJvdG90eXBlLmdldEFsbERheU1heEV2ZW50UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dC5vcHRpb25zLCBkYXlNYXhFdmVudHMgPSBfYS5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyA9IF9hLmRheU1heEV2ZW50Um93cztcbiAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzVmlldztcbn0oRGF0ZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIoaG9va1Byb3BzKSB7XG4gICAgcmV0dXJuIGhvb2tQcm9wcy50ZXh0O1xufVxuXG52YXIgVGltZUNvbHNTbGF0c0Nvb3JkcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzQ29vcmRzKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICB9XG4gICAgVGltZUNvbHNTbGF0c0Nvb3Jkcy5wcm90b3R5cGUuc2FmZUNvbXB1dGVUb3AgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgICAgICAgICAgdmFyIHRpbWVNcyA9IGRhdGUudmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKHRpbWVNcyA+PSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpICYmXG4gICAgICAgICAgICAgICAgdGltZU1zIDwgYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHRpbWVNcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuICAgIFRpbWVDb2xzU2xhdHNDb29yZHMucHJvdG90eXBlLmNvbXB1dGVEYXRlVG9wID0gZnVuY3Rpb24gKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH07XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXG4gICAgLy8gVGhpcyBpcyBhIG1ha2VzaGlmeSB3YXkgdG8gY29tcHV0ZSB0aGUgdGltZS10b3AuIEFzc3VtZXMgYWxsIHNsYXRNZXRhcyBkYXRlcyBhcmUgdW5pZm9ybS5cbiAgICAvLyBFdmVudHVhbGx5IGFsbG93IGNvbXB1dGF0aW9uIHdpdGggYXJiaXJhcnkgc2xhdCBkYXRlcy5cbiAgICBUaW1lQ29sc1NsYXRzQ29vcmRzLnByb3RvdHlwZS5jb21wdXRlVGltZVRvcCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwb3NpdGlvbnMgPSBfYS5wb3NpdGlvbnMsIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGU7XG4gICAgICAgIHZhciBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIHZhciBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xuICAgICAgICB2YXIgc2xhdEluZGV4O1xuICAgICAgICB2YXIgc2xhdFJlbWFpbmRlcjtcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbHNTbGF0c0Nvb3Jkcztcbn0oKSk7XG5cbnZhciBUaW1lQ29sc1NsYXRzQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbHNTbGF0c0JvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbHNTbGF0c0JvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHNTbGF0c0JvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgc2xhdEVsUmVmcyA9IHByb3BzLnNsYXRFbFJlZnM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhLCBpKSB7XG4gICAgICAgICAgICB2YXIgaG9va1Byb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgIHNsYXRNZXRhLmlzTGFiZWxlZCA/ICcnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBzbGF0TWV0YS5rZXksIHJlZjogc2xhdEVsUmVmcy5jcmVhdGVSZWYoc2xhdE1ldGEua2V5KSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNBeGlzQ2VsbCwgX19hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuc2xvdExhbmVDb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFuZURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFuZVdpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgXCJkYXRhLXRpbWVcIjogc2xhdE1ldGEuaXNvVGltZVN0ciB9LCBpbm5lckNvbnRlbnQpKTsgfSkpKTtcbiAgICAgICAgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzQm9keTtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG52YXIgVGltZUNvbHNTbGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbHNTbGF0cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc1NsYXRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLnNsYXRFbFJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByb3BzLm1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUgLyogcmVsaWVzIG9uIHRoZXJlIG9ubHkgYmVpbmcgYSBzaW5nbGUgPGNvbD4gZm9yIHRoZSBheGlzICovLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNTbGF0c0JvZHksIHsgc2xhdEVsUmVmczogdGhpcy5zbGF0RWxSZWZzLCBheGlzOiBwcm9wcy5heGlzLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcyB9KSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzU2xhdHMucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xuICAgIH07XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xuICAgIH07XG4gICAgVGltZUNvbHNTbGF0cy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ29vcmRzKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lQ29sc1NsYXRzLnByb3RvdHlwZS51cGRhdGVTaXppbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvbnRleHQgPSBfYS5jb250ZXh0LCBwcm9wcyA9IF9hLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMub25Db29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByb290RWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHJvb3RFbC5vZmZzZXRIZWlnaHQpIHsgLy8gbm90IGhpZGRlbiBieSBjc3NcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkNvb3JkcyhuZXcgVGltZUNvbHNTbGF0c0Nvb3JkcyhuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0U2xhdEVscyh0aGlzLnNsYXRFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuc2xhdE1ldGFzKSwgZmFsc2UsIHRydWUpLCB0aGlzLnByb3BzLmRhdGVQcm9maWxlLCBjb250ZXh0Lm9wdGlvbnMuc2xvdER1cmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc1NsYXRzO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjb2xsZWN0U2xhdEVscyhlbE1hcCwgc2xhdE1ldGFzKSB7XG4gICAgcmV0dXJuIHNsYXRNZXRhcy5tYXAoZnVuY3Rpb24gKHNsYXRNZXRhKSB7IHJldHVybiBlbE1hcFtzbGF0TWV0YS5rZXldOyB9KTtcbn1cblxuZnVuY3Rpb24gc3BsaXRTZWdzQnlDb2woc2VncywgY29sQ250KSB7XG4gICAgdmFyIHNlZ3NCeUNvbCA9IFtdO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICBzZWdzQnlDb2wucHVzaChbXSk7XG4gICAgfVxuICAgIGlmIChzZWdzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBzZWdzQnlDb2xbc2Vnc1tpXS5jb2xdLnB1c2goc2Vnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NCeUNvbDtcbn1cbmZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeUNvbCh1aSwgY29sQ250KSB7XG4gICAgdmFyIGJ5Um93ID0gW107XG4gICAgaWYgKCF1aSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxuICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdWkuc2VnczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBfYVtfaV07XG4gICAgICAgICAgICBieVJvd1tzZWcuY29sXS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbnZhciBUaW1lQ29sTW9yZUxpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVDb2xNb3JlTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sTW9yZUxpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sTW9yZUxpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rUm9vdCwgeyBhbGxEYXlEYXRlOiBudWxsLCBtb3JlQ250OiBwcm9wcy5oaWRkZW5TZWdzLmxlbmd0aCwgYWxsU2VnczogcHJvcHMuaGlkZGVuU2VncywgaGlkZGVuU2VnczogcHJvcHMuaGlkZGVuU2VncywgYWxpZ25tZW50RWxSZWY6IHRoaXMucm9vdEVsUmVmLCBkZWZhdWx0Q29udGVudDogcmVuZGVyTW9yZUxpbmtJbm5lciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBwb3BvdmVyQ29udGVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVuZGVyUGxhaW5GZ1NlZ3MocHJvcHMuaGlkZGVuU2VncywgcHJvcHMpOyB9IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2ssIHRpdGxlLCBpc0V4cGFuZGVkLCBwb3BvdmVySWQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiYVwiLCB7IHJlZjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgICAgIHNldFJlZihfdGhpcy5yb290RWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH0sIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmsnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZTogeyB0b3A6IHByb3BzLnRvcCwgYm90dG9tOiBwcm9wcy5ib3R0b20gfSwgb25DbGljazogaGFuZGxlQ2xpY2ssIHRpdGxlOiB0aXRsZSwgXCJhcmlhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWQsIFwiYXJpYS1jb250cm9sc1wiOiBwb3BvdmVySWQgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGlubmVyRWxSZWYsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXIgZmMtc3RpY2t5XCIgfSwgaW5uZXJDb250ZW50KSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbE1vcmVMaW5rO1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnNob3J0VGV4dDtcbn1cblxuLy8gc2VnSW5wdXRzIGFzc3VtZWQgc29ydGVkXG5mdW5jdGlvbiBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgc3RyaWN0T3JkZXIsIG1heFN0YWNrQ250KSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IG5ldyBTZWdIaWVyYXJjaHkoKTtcbiAgICBpZiAoc3RyaWN0T3JkZXIgIT0gbnVsbCkge1xuICAgICAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICB9XG4gICAgaWYgKG1heFN0YWNrQ250ICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gbWF4U3RhY2tDbnQ7XG4gICAgfVxuICAgIHZhciBoaWRkZW5FbnRyaWVzID0gaGllcmFyY2h5LmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICB2YXIgaGlkZGVuR3JvdXBzID0gZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzKGhpZGRlbkVudHJpZXMpO1xuICAgIHZhciB3ZWIgPSBidWlsZFdlYihoaWVyYXJjaHkpO1xuICAgIHdlYiA9IHN0cmV0Y2hXZWIod2ViLCAxKTsgLy8gYWxsIGxldmVsQ29vcmRzL3RoaWNrbmVzcyB3aWxsIGhhdmUgMC4wLTEuMFxuICAgIHZhciBzZWdSZWN0cyA9IHdlYlRvUmVjdHMod2ViKTtcbiAgICByZXR1cm4geyBzZWdSZWN0czogc2VnUmVjdHMsIGhpZGRlbkdyb3VwczogaGlkZGVuR3JvdXBzIH07XG59XG5mdW5jdGlvbiBidWlsZFdlYihoaWVyYXJjaHkpIHtcbiAgICB2YXIgZW50cmllc0J5TGV2ZWwgPSBoaWVyYXJjaHkuZW50cmllc0J5TGV2ZWw7XG4gICAgdmFyIGJ1aWxkTm9kZSA9IGNhY2hlYWJsZShmdW5jdGlvbiAobGV2ZWwsIGxhdGVyYWwpIHsgcmV0dXJuIGxldmVsICsgJzonICsgbGF0ZXJhbDsgfSwgZnVuY3Rpb24gKGxldmVsLCBsYXRlcmFsKSB7XG4gICAgICAgIHZhciBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcbiAgICAgICAgdmFyIG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZW50cnkpLCB7IG5leHRMZXZlbE5vZGVzOiBuZXh0TGV2ZWxSZXNbMF0gfSksXG4gICAgICAgICAgICBlbnRyeS50aGlja25lc3MgKyBuZXh0TGV2ZWxSZXNbMV0sIC8vIHRoZSBwcmVzc3VyZSBidWlsZHNcbiAgICAgICAgXTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVpbGROb2RlcyhlbnRyaWVzQnlMZXZlbC5sZW5ndGhcbiAgICAgICAgPyB7IGxldmVsOiAwLCBsYXRlcmFsU3RhcnQ6IDAsIGxhdGVyYWxFbmQ6IGVudHJpZXNCeUxldmVsWzBdLmxlbmd0aCB9XG4gICAgICAgIDogbnVsbCwgYnVpbGROb2RlKVswXTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpIHtcbiAgICBpZiAoIXNpYmxpbmdSYW5nZSkge1xuICAgICAgICByZXR1cm4gW1tdLCAwXTtcbiAgICB9XG4gICAgdmFyIGxldmVsID0gc2libGluZ1JhbmdlLmxldmVsLCBsYXRlcmFsU3RhcnQgPSBzaWJsaW5nUmFuZ2UubGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kID0gc2libGluZ1JhbmdlLmxhdGVyYWxFbmQ7XG4gICAgdmFyIGxhdGVyYWwgPSBsYXRlcmFsU3RhcnQ7XG4gICAgdmFyIHBhaXJzID0gW107XG4gICAgd2hpbGUgKGxhdGVyYWwgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgIHBhaXJzLnB1c2goYnVpbGROb2RlKGxldmVsLCBsYXRlcmFsKSk7XG4gICAgICAgIGxhdGVyYWwgKz0gMTtcbiAgICB9XG4gICAgcGFpcnMuc29ydChjbXBEZXNjUHJlc3N1cmVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwYWlycy5tYXAoZXh0cmFjdE5vZGUpLFxuICAgICAgICBwYWlyc1swXVsxXSwgLy8gZmlyc3QgaXRlbSdzIHByZXNzdXJlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNtcERlc2NQcmVzc3VyZXMoYSwgYikge1xuICAgIHJldHVybiBiWzFdIC0gYVsxXTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlKGEpIHtcbiAgICByZXR1cm4gYVswXTtcbn1cbmZ1bmN0aW9uIGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgc3ViamVjdExldmVsLCBzdWJqZWN0TGF0ZXJhbCkge1xuICAgIHZhciBsZXZlbENvb3JkcyA9IGhpZXJhcmNoeS5sZXZlbENvb3JkcywgZW50cmllc0J5TGV2ZWwgPSBoaWVyYXJjaHkuZW50cmllc0J5TGV2ZWw7XG4gICAgdmFyIHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xuICAgIHZhciBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcbiAgICB2YXIgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgdmFyIGxldmVsID0gc3ViamVjdExldmVsO1xuICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXG4gICAgICAgIDsgLy8gZG8gbm90aGluZ1xuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICB2YXIgZW50cnkgPSB2b2lkIDA7XG4gICAgICAgIHZhciBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcbiAgICAgICAgdmFyIGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuICAgICAgICB2YXIgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcbiAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxuICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xuICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsZXZlbDogbGV2ZWwsIGxhdGVyYWxTdGFydDogbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kOiBsYXRlcmFsRW5kIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XG4gICAgdmFyIHN0cmV0Y2hOb2RlID0gY2FjaGVhYmxlKGZ1bmN0aW9uIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSB7IHJldHVybiBidWlsZEVudHJ5S2V5KG5vZGUpOyB9LCBmdW5jdGlvbiAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykge1xuICAgICAgICB2YXIgbmV4dExldmVsTm9kZXMgPSBub2RlLm5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgPSBub2RlLnRoaWNrbmVzcztcbiAgICAgICAgdmFyIGFsbFRoaWNrbmVzcyA9IHRoaWNrbmVzcyArIHByZXZUaGlja25lc3M7XG4gICAgICAgIHZhciB0aGlja25lc3NGcmFjdGlvbiA9IHRoaWNrbmVzcyAvIGFsbFRoaWNrbmVzcztcbiAgICAgICAgdmFyIGVuZENvb3JkO1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgaWYgKCFuZXh0TGV2ZWxOb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZENvb3JkID0gdG90YWxUaGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5leHRMZXZlbE5vZGVzXzEgPSBuZXh0TGV2ZWxOb2RlczsgX2kgPCBuZXh0TGV2ZWxOb2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBuZXh0TGV2ZWxOb2Rlc18xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQ29vcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBzdGFydENvb3JkLCBhbGxUaGlja25lc3MpO1xuICAgICAgICAgICAgICAgICAgICBlbmRDb29yZCA9IHJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgZW5kQ29vcmQsIDApO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdUaGlja25lc3MgPSAoZW5kQ29vcmQgLSBzdGFydENvb3JkKSAqIHRoaWNrbmVzc0ZyYWN0aW9uO1xuICAgICAgICByZXR1cm4gW2VuZENvb3JkIC0gbmV3VGhpY2tuZXNzLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbm9kZSksIHsgdGhpY2tuZXNzOiBuZXdUaGlja25lc3MsIG5leHRMZXZlbE5vZGVzOiBuZXdDaGlsZHJlbiB9KV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcExldmVsTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBzdHJldGNoTm9kZShub2RlLCAwLCAwKVsxXTsgfSk7XG59XG4vLyBub3Qgc29ydGVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyXG5mdW5jdGlvbiB3ZWJUb1JlY3RzKHRvcExldmVsTm9kZXMpIHtcbiAgICB2YXIgcmVjdHMgPSBbXTtcbiAgICB2YXIgcHJvY2Vzc05vZGUgPSBjYWNoZWFibGUoZnVuY3Rpb24gKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHsgcmV0dXJuIGJ1aWxkRW50cnlLZXkobm9kZSk7IH0sIGZ1bmN0aW9uIChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSB7XG4gICAgICAgIHZhciByZWN0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQ6IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoOiBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgdmFyIHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGtleUZ1bmMuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYy5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCkge1xuICAgIGlmIChzbGF0Q29vcmRzID09PSB2b2lkIDApIHsgc2xhdENvb3JkcyA9IG51bGw7IH1cbiAgICBpZiAoZXZlbnRNaW5IZWlnaHQgPT09IHZvaWQgMCkgeyBldmVudE1pbkhlaWdodCA9IDA7IH1cbiAgICB2YXIgdmNvb3JkcyA9IFtdO1xuICAgIGlmIChzbGF0Q29vcmRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICB2YXIgc3BhblN0YXJ0ID0gc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGNvbERhdGUpO1xuICAgICAgICAgICAgdmFyIHNwYW5FbmQgPSBNYXRoLm1heChzcGFuU3RhcnQgKyAoZXZlbnRNaW5IZWlnaHQgfHwgMCksIC8vIDooXG4gICAgICAgICAgICBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGNvbERhdGUpKTtcbiAgICAgICAgICAgIHZjb29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoc3BhblN0YXJ0KSxcbiAgICAgICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoc3BhbkVuZCksIC8vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmNvb3Jkcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgLy8gbWlnaHQgbm90IGhhdmUgZm9yIGV2ZXJ5IHNlZ1xuZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjaykge1xuICAgIHZhciBzZWdJbnB1dHMgPSBbXTtcbiAgICB2YXIgZHVtYlNlZ3MgPSBbXTsgLy8gc2VncyB3aXRob3V0IGNvb3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdmNvb3JkcyA9IHNlZ1ZDb29yZHNbaV07XG4gICAgICAgIGlmICh2Y29vcmRzKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgICAgIHNwYW46IHZjb29yZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1bWJTZWdzLnB1c2goc2Vnc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spLCBzZWdSZWN0cyA9IF9hLnNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgPSBfYS5oaWRkZW5Hcm91cHM7XG4gICAgdmFyIHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ1JlY3RzXzEgPSBzZWdSZWN0czsgX2kgPCBzZWdSZWN0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnUmVjdCA9IHNlZ1JlY3RzXzFbX2ldO1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgc2VnOiBzZWdzW3NlZ1JlY3QuaW5kZXhdLFxuICAgICAgICAgICAgcmVjdDogc2VnUmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9iID0gMCwgZHVtYlNlZ3NfMSA9IGR1bWJTZWdzOyBfYiA8IGR1bWJTZWdzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgIHZhciBkdW1iU2VnID0gZHVtYlNlZ3NfMVtfYl07XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50czogc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzOiBoaWRkZW5Hcm91cHMgfTtcbn1cblxudmFyIERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogZmFsc2UsXG59KTtcbnZhciBUaW1lQ29sRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVDb2xFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGltZUNvbEV2ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcbiAgICAgICAgICAgICdmYy12LWV2ZW50JyxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNTaG9ydCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCwgZXh0cmFDbGFzc05hbWVzOiBjbGFzc05hbWVzIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbEV2ZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbnZhciBUaW1lQ29sTWlzYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZUNvbE1pc2MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbE1pc2MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGltZUNvbE1pc2MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250ZW50LCB7IGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzIH0sIGZ1bmN0aW9uIChpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChpbm5lckNvbnRlbnQgJiZcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLW1pc2NcIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZUNvbE1pc2M7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFRpbWVDb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVDb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZUNvbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvcnRFdmVudFNlZ3MgPSBtZW1vaXplKHNvcnRFdmVudFNlZ3MpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIFRPRE86IG1lbW9pemUgZXZlbnQtcGxhY2VtZW50P1xuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBpc1NlbGVjdE1pcnJvciA9IGNvbnRleHQub3B0aW9ucy5zZWxlY3RNaXJyb3I7XG4gICAgICAgIHZhciBtaXJyb3JTZWdzID0gKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxuICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxuICAgICAgICAgICAgW107XG4gICAgICAgIHZhciBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgdmFyIHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2VncywgY29udGV4dC5vcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbFJvb3QsIHsgZWxSZWY6IHByb3BzLmVsUmVmLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJncmlkY2VsbFwiLCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtY29sJ10uY29uY2F0KGNsYXNzTmFtZXMsIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSkuam9pbignICcpIH0sIGRhdGFBdHRycywgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgJ25vbi1idXNpbmVzcycpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIF90aGlzLnJlbmRlckZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIGludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMsIGZhbHNlLCBmYWxzZSwgZmFsc2UpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCBfdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIF90aGlzLnJlbmRlck5vd0luZGljYXRvcihwcm9wcy5ub3dJbmRpY2F0b3JTZWdzKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sTWlzYywgeyBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9KSkpKTsgfSkpO1xuICAgIH07XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZyk7XG4gICAgfTtcbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIC8vIGlmIG5vdCBtaXJyb3IsIG5lZWRzIHRvIGJlIHNvcnRlZFxuICAgIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMsIGV2ZW50TWF4U3RhY2sgPSBfYS5ldmVudE1heFN0YWNrLCBldmVudFNob3J0SGVpZ2h0ID0gX2EuZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCA9IF9hLmV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWluSGVpZ2h0ID0gX2EuZXZlbnRNaW5IZWlnaHQ7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIGRhdGUgPSBfYi5kYXRlLCBzbGF0Q29vcmRzID0gX2Iuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb24gPSBfYi5ldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSA9IF9iLnRvZGF5UmFuZ2UsIG5vd0RhdGUgPSBfYi5ub3dEYXRlO1xuICAgICAgICB2YXIgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICB2YXIgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50TWluSGVpZ2h0KTtcbiAgICAgICAgdmFyIF9jID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKSwgc2VnUGxhY2VtZW50cyA9IF9jLnNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyA9IF9jLmhpZGRlbkdyb3VwcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKGZ1bmN0aW9uIChzZWdQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2VnUGxhY2VtZW50LnNlZywgcmVjdCA9IHNlZ1BsYWNlbWVudC5yZWN0O1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICB2YXIgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgdmFyIHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIHZhciBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gX3RoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIHZhciBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW5zZXQgPyAnIGZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQnIDogJycpLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiBfX2Fzc2lnbihfX2Fzc2lnbih7IHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICcnIDogJ2hpZGRlbicgfSwgdlN0eWxlKSwgaFN0eWxlKSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xFdmVudCwgX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIFRpbWVDb2wucHJvdG90eXBlLnJlbmRlckhpZGRlbkdyb3VwcyA9IGZ1bmN0aW9uIChoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZXh0cmFEYXRlU3BhbiA9IF9hLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UgPSBfYS50b2RheVJhbmdlLCBub3dEYXRlID0gX2Eubm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24gPSBfYS5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnID0gX2EuZXZlbnREcmFnLCBldmVudFJlc2l6ZSA9IF9hLmV2ZW50UmVzaXplO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGhpZGRlbkdyb3Vwcy5tYXAoZnVuY3Rpb24gKGhpZGRlbkdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25Dc3MgPSBjb21wdXRlU2VnVlN0eWxlKGhpZGRlbkdyb3VwLnNwYW4pO1xuICAgICAgICAgICAgdmFyIGhpZGRlblNlZ3MgPSBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKGhpZGRlbkdyb3VwLmVudHJpZXMsIHNlZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGJ1aWxkSXNvU3RyaW5nKGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpKSwgaGlkZGVuU2VnczogaGlkZGVuU2VncywgdG9wOiBwb3NpdGlvbkNzcy50b3AsIGJvdHRvbTogcG9zaXRpb25Dc3MuYm90dG9tLCBleHRyYURhdGVTcGFuOiBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG5vd0RhdGU6IG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uOiBldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBldmVudERyYWcsIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZSB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICBUaW1lQ29sLnByb3RvdHlwZS5yZW5kZXJGaWxsU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBmaWxsVHlwZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBwcm9wcy5kYXRlLCBwcm9wcy5zbGF0Q29vcmRzLCBjb250ZXh0Lm9wdGlvbnMuZXZlbnRNaW5IZWlnaHQpOyAvLyBkb24ndCBhc3N1bWUgYWxsIHBvcHVsYXRlZFxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBzZWdWQ29vcmRzLm1hcChmdW5jdGlvbiAodmNvb3JkcywgaSkge1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1iZy1oYXJuZXNzXCIsIHN0eWxlOiBjb21wdXRlU2VnVlN0eWxlKHZjb29yZHMpIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEJnRXZlbnQsIF9fYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UsIHByb3BzLm5vd0RhdGUpKSkgOlxuICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gICAgVGltZUNvbC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKHNlZ3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2xhdENvb3JkcyA9IF9hLnNsYXRDb29yZHMsIGRhdGUgPSBfYS5kYXRlO1xuICAgICAgICBpZiAoIXNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzLm1hcChmdW5jdGlvbiAoc2VnLCBpKSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JSb290LCB7IGlzQXhpczogZmFsc2UsIGRhdGU6IGRhdGUsIFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZTogeyB0b3A6IHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0LCBkYXRlKSB9IH0sIGlubmVyQ29udGVudCkpOyB9KSk7IH0pO1xuICAgIH07XG4gICAgVGltZUNvbC5wcm90b3R5cGUuY29tcHV0ZVNlZ0hTdHlsZSA9IGZ1bmN0aW9uIChzZWdIQ29vcmRzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgaXNSdGwgPSBfYS5pc1J0bCwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBzaG91bGRPdmVybGFwID0gb3B0aW9ucy5zbG90RXZlbnRPdmVybGFwO1xuICAgICAgICB2YXIgbmVhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkOyAvLyB0aGUgbGVmdCBzaWRlIGlmIExUUi4gdGhlIHJpZ2h0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuICAgICAgICB2YXIgZmFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQgKyBzZWdIQ29vcmRzLnRoaWNrbmVzczsgLy8gdGhlIHJpZ2h0IHNpZGUgaWYgTFRSLiB0aGUgbGVmdCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgdmFyIGxlZnQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIGxlZnQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgdmFyIHJpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSByaWdodCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCkge1xuICAgICAgICAgICAgLy8gZG91YmxlIHRoZSB3aWR0aCwgYnV0IGRvbid0IGdvIGJleW9uZCB0aGUgbWF4aW11bSBmb3J3YXJkIGNvb3JkaW5hdGUgKDEuMClcbiAgICAgICAgICAgIGZhckNvb3JkID0gTWF0aC5taW4oMSwgbmVhckNvb3JkICsgKGZhckNvb3JkIC0gbmVhckNvb3JkKSAqIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1J0bCkge1xuICAgICAgICAgICAgbGVmdCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgICAgIHJpZ2h0ID0gbmVhckNvb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdCA9IG5lYXJDb29yZDtcbiAgICAgICAgICAgIHJpZ2h0ID0gMSAtIGZhckNvb3JkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIHpJbmRleDogc2VnSENvb3Jkcy5zdGFja0RlcHRoICsgMSxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgKiAxMDAgKyAnJScsXG4gICAgICAgICAgICByaWdodDogcmlnaHQgKiAxMDAgKyAnJScsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwICYmICFzZWdIQ29vcmRzLnN0YWNrRm9yd2FyZCkge1xuICAgICAgICAgICAgLy8gYWRkIHBhZGRpbmcgdG8gdGhlIGVkZ2Ugc28gdGhhdCBmb3J3YXJkIHN0YWNrZWQgZXZlbnRzIGRvbid0IGNvdmVyIHRoZSByZXNpemVyJ3MgaWNvblxuICAgICAgICAgICAgcHJvcHNbaXNSdGwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnXSA9IDEwICogMjsgLy8gMTAgaXMgYSBndWVzc3RpbWF0ZSBvZiB0aGUgaWNvbidzIHdpZHRoXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2w7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlclBsYWluRmdTZWdzKHNvcnRlZEZnU2VncywgX2EpIHtcbiAgICB2YXIgdG9kYXlSYW5nZSA9IF9hLnRvZGF5UmFuZ2UsIG5vd0RhdGUgPSBfYS5ub3dEYXRlLCBldmVudFNlbGVjdGlvbiA9IF9hLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcgPSBfYS5ldmVudERyYWcsIGV2ZW50UmVzaXplID0gX2EuZXZlbnRSZXNpemU7XG4gICAgdmFyIGhpZGRlbkluc3RhbmNlcyA9IChldmVudERyYWcgPyBldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAoZXZlbnRSZXNpemUgPyBldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIHt9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgc29ydGVkRmdTZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBpbnN0YW5jZUlkLCBzdHlsZTogeyB2aXNpYmlsaXR5OiBoaWRkZW5JbnN0YW5jZXNbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnIH0gfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCBfX2Fzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgIH0pKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcbiAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXG4gICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcbiAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoZnVuY3Rpb24gKHNlZ0VudHJ5KSB7IHJldHVybiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XTsgfSk7XG59XG5cbnZhciBUaW1lQ29sc0NvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVDb2xzQ29udGVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29sc0NvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgX3RoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICBfdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICBfdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICBfdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUaW1lQ29sc0NvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBub3dJbmRpY2F0b3JUb3AgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKHByb3BzLm5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICB2YXIgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICB2YXIgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICB2YXIgbm93SW5kaWNhdG9yU2Vnc0J5Um93ID0gdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MocHJvcHMubm93SW5kaWNhdG9yU2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBjb2xDbnQpO1xuICAgICAgICB2YXIgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgY29sQ250KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbHNcIiwgcmVmOiB0aGlzLnJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicgJiYgKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yUm9vdCwgeyBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdyddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHN0eWxlOiB7IHRvcDogbm93SW5kaWNhdG9yVG9wIH0gfSwgaW5uZXJDb250ZW50KSk7IH0pKSkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IF90aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBjZWxsLmV4dHJhSG9va1Byb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKTsgfSkpKSkpKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfTtcbiAgICBUaW1lQ29sc0NvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9O1xuICAgIFRpbWVDb2xzQ29udGVudC5wcm90b3R5cGUudXBkYXRlQ29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUaW1lQ29sc0NvbnRlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGNvbGxlY3RDZWxsRWxzKGVsTWFwLCBjZWxscykge1xuICAgIHJldHVybiBjZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIGVsTWFwW2NlbGwua2V5XTsgfSk7XG59XG5cbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIFRpbWVDb2xzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lQ29scywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lQ29scygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb2Nlc3NTbG90T3B0aW9ucyA9IG1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBfdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgb25TY3JvbGxUb3BSZXF1ZXN0ID0gX3RoaXMucHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0O1xuICAgICAgICAgICAgdmFyIHNsYXRDb29yZHMgPSBfdGhpcy5zdGF0ZS5zbGF0Q29vcmRzO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcF8xID0gTWF0aC5jZWlsKHRvcF8xKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BfMSArPSAxOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFRvcFJlcXVlc3QodG9wXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ29sQ29vcmRzID0gZnVuY3Rpb24gKGNvbENvb3Jkcykge1xuICAgICAgICAgICAgX3RoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gZnVuY3Rpb24gKHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2xhdENvb3Jkczogc2xhdENvb3JkcyB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJvZHlcIiwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNTbGF0cywgeyBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIG1pbkhlaWdodDogcHJvcHMuZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMuYXhpcyA/IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlIDogbnVsbCAvKiBheGlzIGRlcGVuZHMgb24gdGhlIGNvbGdyb3VwJ3Mgc2hyaW5raW5nICovLCBvbkNvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzIH0pLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc0NvbnRlbnQsIHsgY2VsbHM6IHByb3BzLmNlbGxzLCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogcHJvcHMubm93SW5kaWNhdG9yU2VncywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHNsYXRDb29yZHM6IHN0YXRlLnNsYXRDb29yZHMsIG9uQ29sQ29vcmRzOiB0aGlzLmhhbmRsZUNvbENvb3JkcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfTtcbiAgICBUaW1lQ29scy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLmRldGFjaCgpO1xuICAgIH07XG4gICAgVGltZUNvbHMucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb2xDb29yZHMgPSB0aGlzLmNvbENvb3JkcztcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIHNsYXRDb29yZHMgPSB0aGlzLnN0YXRlLnNsYXRDb29yZHM7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zKHRoaXMucHJvcHMuc2xvdER1cmF0aW9uLCBvcHRpb25zLnNuYXBEdXJhdGlvbiksIHNuYXBEdXJhdGlvbiA9IF9iLnNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90ID0gX2Iuc25hcHNQZXJTbG90O1xuICAgICAgICB2YXIgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgdmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgdmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICB2YXIgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIHZhciBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gYWRkRHVyYXRpb25zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBtdWx0aXBseUR1cmF0aW9uKHNuYXBEdXJhdGlvbiwgc25hcEluZGV4KSk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmFkZChkYXlEYXRlLCB0aW1lKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgc25hcER1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBfX2Fzc2lnbih7IHJhbmdlOiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSwgYWxsRGF5OiBmYWxzZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiBjb2xDb29yZHMuZWxzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbENvb3Jkcy5sZWZ0c1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xDb29yZHMucmlnaHRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzbGF0VG9wLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHNsYXRUb3AgKyBzbGF0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVDb2xzO1xufShEYXRlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIHZhciBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgdmFyIHNuYXBzUGVyU2xvdCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uKTtcbiAgICBpZiAoc25hcHNQZXJTbG90ID09PSBudWxsKSB7XG4gICAgICAgIHNuYXBEdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICAgICAgc25hcHNQZXJTbG90ID0gMTtcbiAgICAgICAgLy8gVE9ETzogc2F5IHdhcm5pbmc/XG4gICAgfVxuICAgIHJldHVybiB7IHNuYXBEdXJhdGlvbjogc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3Q6IHNuYXBzUGVyU2xvdCB9O1xufVxuXG52YXIgRGF5VGltZUNvbHNTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERheVRpbWVDb2xzU2xpY2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRpbWVDb2xzU2xpY2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIERheVRpbWVDb2xzU2xpY2VyLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgZGF5UmFuZ2VzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2NvbF0pO1xuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBEYXlUaW1lQ29sc1NsaWNlcjtcbn0oU2xpY2VyKSk7XG5cbnZhciBEYXlUaW1lQ29scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5VGltZUNvbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGltZUNvbHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5idWlsZERheVJhbmdlcyA9IG1lbW9pemUoYnVpbGREYXlSYW5nZXMpO1xuICAgICAgICBfdGhpcy5zbGljZXIgPSBuZXcgRGF5VGltZUNvbHNTbGljZXIoKTtcbiAgICAgICAgX3RoaXMudGltZUNvbHNSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUaW1lQ29scy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWwgPSBwcm9wcy5kYXlUYWJsZU1vZGVsO1xuICAgICAgICB2YXIgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xuICAgICAgICB2YXIgZGF5UmFuZ2VzID0gdGhpcy5idWlsZERheVJhbmdlcyhkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZSwgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgLy8gZ2l2ZSBpdCB0aGUgZmlyc3Qgcm93IG9mIGNlbGxzXG4gICAgICAgIC8vIFRPRE86IHdvdWxkIG1vdmUgdGhpcyBmdXJ0aGVyIGRvd24gaGllcmFyY2h5LCBidXQgc2xpY2VOb3dEYXRlIG5lZWRzIGl0XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBpc05vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgZnVuY3Rpb24gKG5vd0RhdGUsIHRvZGF5UmFuZ2UpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2xzLCBfX2Fzc2lnbih7IHJlZjogX3RoaXMudGltZUNvbHNSZWYgfSwgX3RoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IGlzTm93SW5kaWNhdG9yICYmIF90aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgY29udGV4dCwgZGF5UmFuZ2VzKSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgb25TY3JvbGxUb3BSZXF1ZXN0OiBwcm9wcy5vblNjcm9sbFRvcFJlcXVlc3QsIG9uU2xhdENvb3JkczogcHJvcHMub25TbGF0Q29vcmRzIH0pKSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUaW1lQ29scztcbn0oRGF0ZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkYXRlID0gX2FbX2ldO1xuICAgICAgICByYW5nZXMucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpLFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxuLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XG52YXIgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICB2YXIgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICB2YXIgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICB2YXIgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XG4gICAgdmFyIGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcbiAgICB2YXIgbWV0YXMgPSBbXTtcbiAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICB2YXIgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcbiAgICAgICAgbWV0YXMucHVzaCh7XG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXG4gICAgICAgICAgICBpc0xhYmVsZWQ6IGlzTGFiZWxlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHNsYXRUaW1lID0gYWRkRHVyYXRpb25zKHNsYXRUaW1lLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBzbGF0SXRlcmF0b3IgPSBhZGREdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBzbG90RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YXM7XG59XG4vLyBDb21wdXRlcyBhbiBhdXRvbWF0aWMgdmFsdWUgZm9yIHNsb3RMYWJlbEludGVydmFsXG5mdW5jdGlvbiBjb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGFiZWxJbnRlcnZhbDtcbiAgICB2YXIgc2xvdHNQZXJMYWJlbDtcbiAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdG9jayBsYWJlbCBpbnRlcnZhbCB0aGF0IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSBzbG90cy1wZXItbGFiZWxcbiAgICBmb3IgKGkgPSBTVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGxhYmVsSW50ZXJ2YWwgPSBjcmVhdGVEdXJhdGlvbihTVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcbiAgICAgICAgc2xvdHNQZXJMYWJlbCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKGxhYmVsSW50ZXJ2YWwsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIGlmIChzbG90c1BlckxhYmVsICE9PSBudWxsICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xvdER1cmF0aW9uOyAvLyBmYWxsIGJhY2tcbn1cblxudmFyIERheVRpbWVDb2xzVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF5VGltZUNvbHNWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheVRpbWVDb2xzVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IG1lbW9pemUoYnVpbGRUaW1lQ29sc01vZGVsKTtcbiAgICAgICAgX3RoaXMuYnVpbGRTbGF0TWV0YXMgPSBtZW1vaXplKGJ1aWxkU2xhdE1ldGFzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUaW1lQ29sc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVQcm9maWxlR2VuZXJhdG9yID0gX2EuZGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIHZhciBzcGxpdFByb3BzID0gdGhpcy5hbGxEYXlTcGxpdHRlci5zcGxpdFByb3BzKHByb3BzKTtcbiAgICAgICAgdmFyIHNsYXRNZXRhcyA9IHRoaXMuYnVpbGRTbGF0TWV0YXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLCBvcHRpb25zLnNsb3RMYWJlbEludGVydmFsLCBvcHRpb25zLnNsb3REdXJhdGlvbiwgZGF0ZUVudik7XG4gICAgICAgIHZhciBkYXlNaW5XaWR0aCA9IG9wdGlvbnMuZGF5TWluV2lkdGg7XG4gICAgICAgIHZhciBoYXNBdHRhY2hlZEF4aXMgPSAhZGF5TWluV2lkdGg7XG4gICAgICAgIHZhciBoYXNEZXRhY2hlZEF4aXMgPSBkYXlNaW5XaWR0aDtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzOiB0cnVlLCByZW5kZXJJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJIZWFkQXhpcyA6IG51bGwgfSkpO1xuICAgICAgICB2YXIgYWxsRGF5Q29udGVudCA9IChvcHRpb25zLmFsbERheVNsb3QgIT09IGZhbHNlKSAmJiAoZnVuY3Rpb24gKGNvbnRlbnRBcmcpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheVRhYmxlLCBfX2Fzc2lnbih7fSwgc3BsaXRQcm9wcy5hbGxEYXksIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCByZW5kZXJSb3dJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gX3RoaXMucmVuZGVyVGFibGVSb3dBeGlzIDogbnVsbCwgc2hvd1dlZWtOdW1iZXJzOiBmYWxzZSwgZXhwYW5kUm93czogZmFsc2UsIGhlYWRlckFsaWduRWxSZWY6IF90aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0sIF90aGlzLmdldEFsbERheU1heEV2ZW50UHJvcHMoKSkpKTsgfSk7XG4gICAgICAgIHZhciB0aW1lR3JpZENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudEFyZykgeyByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5VGltZUNvbHMsIF9fYXNzaWduKHt9LCBzcGxpdFByb3BzLnRpbWVkLCB7IGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgYXhpczogaGFzQXR0YWNoZWRBeGlzLCBzbG90RHVyYXRpb246IG9wdGlvbnMuc2xvdER1cmF0aW9uLCBzbGF0TWV0YXM6IHNsYXRNZXRhcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCB0YWJsZUNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgb25TbGF0Q29vcmRzOiBfdGhpcy5oYW5kbGVTbGF0Q29vcmRzLCBleHBhbmRSb3dzOiBjb250ZW50QXJnLmV4cGFuZFJvd3MsIG9uU2Nyb2xsVG9wUmVxdWVzdDogX3RoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCB9KSkpOyB9O1xuICAgICAgICByZXR1cm4gaGFzRGV0YWNoZWRBeGlzXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCB0aGlzLnN0YXRlLnNsYXRDb29yZHMpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGltZUNvbHNWaWV3O1xufShUaW1lQ29sc1ZpZXcpKTtcbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICB2YXIgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgZmFsc2UpO1xufVxuXG52YXIgT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGFsbERheVNsb3Q6IEJvb2xlYW4sXG59O1xuXG52YXIgbWFpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgaW5pdGlhbFZpZXc6ICd0aW1lR3JpZFdlZWsnLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgdmlld3M6IHtcbiAgICAgICAgdGltZUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGltZUNvbHNWaWV3LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxuICAgICAgICAgICAgc2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuICAgICAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSwgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWFpbjtcbmV4cG9ydCB7IERheVRpbWVDb2xzLCBEYXlUaW1lQ29sc1NsaWNlciwgRGF5VGltZUNvbHNWaWV3LCBUaW1lQ29scywgVGltZUNvbHNTbGF0c0Nvb3JkcywgVGltZUNvbHNWaWV3LCBidWlsZERheVJhbmdlcywgYnVpbGRTbGF0TWV0YXMsIGJ1aWxkVGltZUNvbHNNb2RlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJoYXNCZ1JlbmRlcmluZyIsIlNwbGl0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiY3JlYXRlRWxlbWVudCIsIlZpZXdDb250ZXh0VHlwZSIsIlJlbmRlckhvb2siLCJCYXNlQ29tcG9uZW50IiwiY3JlYXRlUmVmIiwiZGlmZkRheXMiLCJidWlsZE5hdkxpbmtBdHRycyIsIldlZWtOdW1iZXJSb290IiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJWaWV3Um9vdCIsIlNpbXBsZVNjcm9sbEdyaWQiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJOb3dUaW1lciIsIk5vd0luZGljYXRvclJvb3QiLCJyZW5kZXJTY3JvbGxTaGltIiwiRGF0ZUNvbXBvbmVudCIsInJhbmdlQ29udGFpbnNNYXJrZXIiLCJzdGFydE9mRGF5IiwiYXNSb3VnaE1zIiwiY3JlYXRlRHVyYXRpb24iLCJSZWZNYXAiLCJQb3NpdGlvbkNhY2hlIiwiTW9yZUxpbmtSb290Iiwic2V0UmVmIiwiU2VnSGllcmFyY2h5IiwiZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIiwiYnVpbGRFbnRyeUtleSIsImJpbmFyeVNlYXJjaCIsImdldEVudHJ5U3BhbkVuZCIsIlN0YW5kYXJkRXZlbnQiLCJEYXlDZWxsQ29udGVudCIsIkZyYWdtZW50IiwiZ2V0U2VnTWV0YSIsIm1lbW9pemUiLCJzb3J0RXZlbnRTZWdzIiwiRGF5Q2VsbFJvb3QiLCJidWlsZElzb1N0cmluZyIsImNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJhZGREdXJhdGlvbnMiLCJtdWx0aXBseUR1cmF0aW9uIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJpbnRlcnNlY3RSYW5nZXMiLCJTbGljZXIiLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiRGF5SGVhZGVyIiwiRGF5U2VyaWVzTW9kZWwiLCJEYXlUYWJsZU1vZGVsIiwiY3JlYXRlUGx1Z2luIiwiX19leHRlbmRzIiwiX19hc3NpZ24iLCJEYXlUYWJsZSIsIkFsbERheVNwbGl0dGVyIiwiX3N1cGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwcm90b3R5cGUiLCJnZXRLZXlJbmZvIiwiYWxsRGF5IiwidGltZWQiLCJnZXRLZXlzRm9yRGF0ZVNwYW4iLCJkYXRlU3BhbiIsImdldEtleXNGb3JFdmVudERlZiIsImV2ZW50RGVmIiwiREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCIsImhvdXIiLCJtaW51dGUiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwiVGltZUNvbHNBeGlzQ2VsbCIsInByb3BzIiwiY2xhc3NOYW1lcyIsImlzTGFiZWxlZCIsIkNvbnN1bWVyIiwiY29udGV4dCIsImNsYXNzTmFtZSIsImpvaW4iLCJpc29UaW1lU3RyIiwiZGF0ZUVudiIsIm9wdGlvbnMiLCJ2aWV3QXBpIiwibGFiZWxGb3JtYXQiLCJzbG90TGFiZWxGb3JtYXQiLCJBcnJheSIsImlzQXJyYXkiLCJob29rUHJvcHMiLCJsZXZlbCIsInRpbWUiLCJkYXRlIiwidG9EYXRlIiwidmlldyIsInRleHQiLCJmb3JtYXQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwiY29udGVudCIsInNsb3RMYWJlbENvbnRlbnQiLCJkZWZhdWx0Q29udGVudCIsInJlbmRlcklubmVyQ29udGVudCIsImRpZE1vdW50Iiwic2xvdExhYmVsRGlkTW91bnQiLCJ3aWxsVW5tb3VudCIsInNsb3RMYWJlbFdpbGxVbm1vdW50Iiwicm9vdEVsUmVmIiwiY3VzdG9tQ2xhc3NOYW1lcyIsImlubmVyRWxSZWYiLCJpbm5lckNvbnRlbnQiLCJyZWYiLCJjb25jYXQiLCJUaW1lQm9keUF4aXMiLCJyZW5kZXIiLCJzbGF0TWV0YXMiLCJtYXAiLCJzbGF0TWV0YSIsImtleSIsIkRFRkFVTFRfV0VFS19OVU1fRk9STUFUIiwid2VlayIsIkFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUyIsIlRpbWVDb2xzVmlldyIsIl90aGlzIiwiYWxsRGF5U3BsaXR0ZXIiLCJoZWFkZXJFbFJlZiIsInNjcm9sbGVyRWxSZWYiLCJzdGF0ZSIsInNsYXRDb29yZHMiLCJoYW5kbGVTY3JvbGxUb3BSZXF1ZXN0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsZXJFbCIsImN1cnJlbnQiLCJyZW5kZXJIZWFkQXhpcyIsInJvd0tleSIsImZyYW1lSGVpZ2h0IiwiZGF0ZVByb2ZpbGUiLCJyYW5nZSIsInJlbmRlclJhbmdlIiwiZGF5Q250Iiwic3RhcnQiLCJlbmQiLCJuYXZMaW5rQXR0cnMiLCJ3ZWVrTnVtYmVycyIsImRlZmF1bHRGb3JtYXQiLCJzdHlsZSIsImhlaWdodCIsInJlbmRlclRhYmxlUm93QXhpcyIsInJvd0hlaWdodCIsIl9hIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwicmVuZGVyQWxsRGF5SW5uZXIiLCJhbGxEYXlEaWRNb3VudCIsImFsbERheVdpbGxVbm1vdW50IiwiaGFuZGxlU2xhdENvb3JkcyIsInNldFN0YXRlIiwicmVuZGVyU2ltcGxlTGF5b3V0IiwiaGVhZGVyUm93Q29udGVudCIsInRpbWVDb250ZW50Iiwic2VjdGlvbnMiLCJzdGlja3lIZWFkZXJEYXRlcyIsInB1c2giLCJ0eXBlIiwiaXNTdGlja3kiLCJjaHVuayIsImVsUmVmIiwidGFibGVDbGFzc05hbWUiLCJyb3dDb250ZW50Iiwib3V0ZXJDb250ZW50Iiwicm9sZSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJsaXF1aWQiLCJleHBhbmRSb3dzIiwiQm9vbGVhbiIsInZpZXdTcGVjIiwiaXNIZWlnaHRBdXRvIiwiZm9yUHJpbnQiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29scyIsIndpZHRoIiwicmVuZGVySFNjcm9sbExheW91dCIsImNvbENudCIsImRheU1pbldpZHRoIiwiU2Nyb2xsR3JpZCIsInBsdWdpbkhvb2tzIiwic2Nyb2xsR3JpZEltcGwiLCJFcnJvciIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInN5bmNSb3dIZWlnaHRzIiwiY2h1bmtzIiwiYXJnIiwicm93U3luY0hlaWdodHMiLCJjb250ZW50QXJnIiwiY29sU3BhbiIsImlzTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yIiwiY2xpZW50SGVpZ2h0IiwidGFibGVDb2xHcm91cE5vZGUiLCJ1bml0Iiwibm93RGF0ZSIsIm5vd0luZGljYXRvclRvcCIsInNhZmVDb21wdXRlVG9wIiwiaXNBeGlzIiwidG9wIiwiY29sR3JvdXBzIiwic3BhbiIsIm1pbldpZHRoIiwiZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcyIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsInVuZGVmaW5lZCIsIlRpbWVDb2xzU2xhdHNDb29yZHMiLCJwb3NpdGlvbnMiLCJzbG90RHVyYXRpb24iLCJjdXJyZW50UmFuZ2UiLCJzdGFydE9mRGF5RGF0ZSIsInRpbWVNcyIsInZhbHVlT2YiLCJzbG90TWluVGltZSIsInNsb3RNYXhUaW1lIiwiY29tcHV0ZVRpbWVUb3AiLCJjb21wdXRlRGF0ZVRvcCIsIndoZW4iLCJkdXJhdGlvbiIsImxlbiIsImVscyIsImxlbmd0aCIsInNsYXRDb3ZlcmFnZSIsIm1pbGxpc2Vjb25kcyIsInNsYXRJbmRleCIsInNsYXRSZW1haW5kZXIiLCJNYXRoIiwibWF4IiwibWluIiwiZmxvb3IiLCJ0b3BzIiwiZ2V0SGVpZ2h0IiwiVGltZUNvbHNTbGF0c0JvZHkiLCJzbGF0RWxSZWZzIiwiaSIsImF4aXMiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsIlRpbWVDb2xzU2xhdHMiLCJ0YWJsZU1pbldpZHRoIiwiY2xpZW50V2lkdGgiLCJtaW5IZWlnaHQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZVNpemluZyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwib25Db29yZHMiLCJyb290RWwiLCJvZmZzZXRIZWlnaHQiLCJjb2xsZWN0U2xhdEVscyIsImN1cnJlbnRNYXAiLCJlbE1hcCIsInNwbGl0U2Vnc0J5Q29sIiwic2VncyIsInNlZ3NCeUNvbCIsImNvbCIsInNwbGl0SW50ZXJhY3Rpb25CeUNvbCIsInVpIiwiYnlSb3ciLCJhZmZlY3RlZEluc3RhbmNlcyIsImlzRXZlbnQiLCJfaSIsInNlZyIsIlRpbWVDb2xNb3JlTGluayIsImFsbERheURhdGUiLCJtb3JlQ250IiwiaGlkZGVuU2VncyIsImFsbFNlZ3MiLCJhbGlnbm1lbnRFbFJlZiIsInJlbmRlck1vcmVMaW5rSW5uZXIiLCJleHRyYURhdGVTcGFuIiwidG9kYXlSYW5nZSIsInBvcG92ZXJDb250ZW50IiwicmVuZGVyUGxhaW5GZ1NlZ3MiLCJoYW5kbGVDbGljayIsInRpdGxlIiwiaXNFeHBhbmRlZCIsInBvcG92ZXJJZCIsImVsIiwiYm90dG9tIiwib25DbGljayIsInNob3J0VGV4dCIsImJ1aWxkUG9zaXRpb25pbmciLCJzZWdJbnB1dHMiLCJzdHJpY3RPcmRlciIsIm1heFN0YWNrQ250IiwiaGllcmFyY2h5IiwiaGlkZGVuRW50cmllcyIsImFkZFNlZ3MiLCJoaWRkZW5Hcm91cHMiLCJ3ZWIiLCJidWlsZFdlYiIsInN0cmV0Y2hXZWIiLCJzZWdSZWN0cyIsIndlYlRvUmVjdHMiLCJlbnRyaWVzQnlMZXZlbCIsImJ1aWxkTm9kZSIsImNhY2hlYWJsZSIsImxhdGVyYWwiLCJzaWJsaW5nUmFuZ2UiLCJmaW5kTmV4dExldmVsU2VncyIsIm5leHRMZXZlbFJlcyIsImJ1aWxkTm9kZXMiLCJlbnRyeSIsIm5leHRMZXZlbE5vZGVzIiwidGhpY2tuZXNzIiwibGF0ZXJhbFN0YXJ0IiwibGF0ZXJhbEVuZCIsInBhaXJzIiwic29ydCIsImNtcERlc2NQcmVzc3VyZXMiLCJleHRyYWN0Tm9kZSIsImEiLCJiIiwic3ViamVjdExldmVsIiwic3ViamVjdExhdGVyYWwiLCJsZXZlbENvb3JkcyIsInN1YmplY3RFbnRyeSIsImFmdGVyU3ViamVjdCIsImxldmVsQ250IiwiZW50cmllcyIsInNlYXJjaEluZGV4IiwidG9wTGV2ZWxOb2RlcyIsInRvdGFsVGhpY2tuZXNzIiwic3RyZXRjaE5vZGUiLCJub2RlIiwic3RhcnRDb29yZCIsInByZXZUaGlja25lc3MiLCJhbGxUaGlja25lc3MiLCJ0aGlja25lc3NGcmFjdGlvbiIsImVuZENvb3JkIiwibmV3Q2hpbGRyZW4iLCJuZXh0TGV2ZWxOb2Rlc18xIiwiY2hpbGROb2RlIiwicmVzIiwibmV3VGhpY2tuZXNzIiwicmVjdHMiLCJwcm9jZXNzTm9kZSIsImxldmVsQ29vcmQiLCJzdGFja0RlcHRoIiwicmVjdCIsInN0YWNrRm9yd2FyZCIsInByb2Nlc3NOb2RlcyIsIm5vZGVzIiwibm9kZXNfMSIsImtleUZ1bmMiLCJ3b3JrRnVuYyIsImNhY2hlIiwiYXJncyIsImNvbXB1dGVTZWdWQ29vcmRzIiwiY29sRGF0ZSIsImV2ZW50TWluSGVpZ2h0IiwidmNvb3JkcyIsInNwYW5TdGFydCIsInNwYW5FbmQiLCJyb3VuZCIsImNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMiLCJzZWdWQ29vcmRzIiwiZXZlbnRPcmRlclN0cmljdCIsImV2ZW50TWF4U3RhY2siLCJkdW1iU2VncyIsImluZGV4Iiwic2VnUGxhY2VtZW50cyIsInNlZ1JlY3RzXzEiLCJzZWdSZWN0IiwiX2IiLCJkdW1iU2Vnc18xIiwiZHVtYlNlZyIsIkRFRkFVTFRfVElNRV9GT1JNQVQiLCJUaW1lQ29sRXZlbnQiLCJpc1Nob3J0IiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJleHRyYUNsYXNzTmFtZXMiLCJUaW1lQ29sTWlzYyIsImV4dHJhSG9va1Byb3BzIiwiVGltZUNvbCIsImlzU2VsZWN0TWlycm9yIiwic2VsZWN0TWlycm9yIiwibWlycm9yU2VncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzIiwic29ydGVkRmdTZWdzIiwiZmdFdmVudFNlZ3MiLCJldmVudE9yZGVyIiwiZGF0YUF0dHJzIiwiZXh0cmFEYXRhQXR0cnMiLCJyZW5kZXJGaWxsU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJiZ0V2ZW50U2VncyIsInJlbmRlckZnU2VncyIsInJlbmRlck5vd0luZGljYXRvciIsIm5vd0luZGljYXRvclNlZ3MiLCJzZWdJc0ludmlzaWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNEYXRlU2VsZWN0aW5nIiwicmVuZGVyUG9zaXRpb25lZEZnU2VncyIsImV2ZW50U2hvcnRIZWlnaHQiLCJldmVudFNlbGVjdGlvbiIsImlzTWlycm9yIiwiX2MiLCJyZW5kZXJIaWRkZW5Hcm91cHMiLCJzZWdQbGFjZW1lbnQiLCJpbnN0YW5jZUlkIiwiZXZlbnRSYW5nZSIsImluc3RhbmNlIiwiaXNWaXNpYmxlIiwidlN0eWxlIiwiY29tcHV0ZVNlZ1ZTdHlsZSIsImhTdHlsZSIsImNvbXB1dGVTZWdIU3R5bGUiLCJsZWZ0IiwicmlnaHQiLCJpc0luc2V0IiwidmlzaWJpbGl0eSIsImlzU2VsZWN0ZWQiLCJoaWRkZW5Hcm91cCIsInBvc2l0aW9uQ3NzIiwiY29tcGlsZVNlZ3NGcm9tRW50cmllcyIsImZpbGxUeXBlIiwiY2hpbGRyZW4iLCJzZWdIQ29vcmRzIiwiaXNSdGwiLCJzaG91bGRPdmVybGFwIiwic2xvdEV2ZW50T3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiekluZGV4IiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwic3BsaXRGZ0V2ZW50U2VncyIsInNwbGl0QmdFdmVudFNlZ3MiLCJzcGxpdEJ1c2luZXNzSG91clNlZ3MiLCJzcGxpdE5vd0luZGljYXRvclNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwiY2VsbEVsUmVmcyIsImNlbGxzIiwiZmdFdmVudFNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJub3dJbmRpY2F0b3JTZWdzQnlSb3ciLCJkYXRlU2VsZWN0aW9uU2Vnc0J5Um93IiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93IiwiY2VsbCIsInVwZGF0ZUNvb3JkcyIsIm9uQ29sQ29vcmRzIiwiY29sbGVjdENlbGxFbHMiLCJUaW1lQ29scyIsInByb2Nlc3NTbG90T3B0aW9ucyIsImhhbmRsZVJvb3RFbCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImhhbmRsZVNjcm9sbFJlcXVlc3QiLCJyZXF1ZXN0Iiwib25TY3JvbGxUb3BSZXF1ZXN0IiwidG9wXzEiLCJjZWlsIiwiaGFuZGxlQ29sQ29vcmRzIiwiY29sQ29vcmRzIiwib25TbGF0Q29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwiY3JlYXRlU2Nyb2xsUmVzcG9uZGVyIiwicHJldlByb3BzIiwidXBkYXRlIiwiZGV0YWNoIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsInNuYXBEdXJhdGlvbiIsInNuYXBzUGVyU2xvdCIsImNvbEluZGV4IiwibGVmdFRvSW5kZXgiLCJ0b3BUb0luZGV4Iiwic2xhdFRvcCIsInNsYXRIZWlnaHQiLCJwYXJ0aWFsIiwibG9jYWxTbmFwSW5kZXgiLCJzbmFwSW5kZXgiLCJkYXlEYXRlIiwiYWRkIiwiZGF5RWwiLCJsZWZ0cyIsInJpZ2h0cyIsImxheWVyIiwic25hcER1cmF0aW9uT3ZlcnJpZGUiLCJEYXlUaW1lQ29sc1NsaWNlciIsInNsaWNlUmFuZ2UiLCJkYXlSYW5nZXMiLCJzZWdSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsIkRheVRpbWVDb2xzIiwiYnVpbGREYXlSYW5nZXMiLCJzbGljZXIiLCJ0aW1lQ29sc1JlZiIsImRheVRhYmxlTW9kZWwiLCJzbGljZVByb3BzIiwic2xpY2VOb3dEYXRlIiwicmFuZ2VzIiwiaGVhZGVyRGF0ZXMiLCJTVE9DS19TVUJfRFVSQVRJT05TIiwiaG91cnMiLCJtaW51dGVzIiwic2Vjb25kcyIsImJ1aWxkU2xhdE1ldGFzIiwiZXhwbGljaXRMYWJlbEludGVydmFsIiwiZGF5U3RhcnQiLCJEYXRlIiwic2xhdFRpbWUiLCJzbGF0SXRlcmF0b3IiLCJsYWJlbEludGVydmFsIiwiY29tcHV0ZUxhYmVsSW50ZXJ2YWwiLCJtZXRhcyIsInRvSVNPU3RyaW5nIiwic2xvdHNQZXJMYWJlbCIsIkRheVRpbWVDb2xzVmlldyIsImJ1aWxkVGltZUNvbHNNb2RlbCIsImRhdGVQcm9maWxlR2VuZXJhdG9yIiwic3BsaXRQcm9wcyIsInNsb3RMYWJlbEludGVydmFsIiwiaGFzQXR0YWNoZWRBeGlzIiwiaGFzRGV0YWNoZWRBeGlzIiwiaGVhZGVyQ29udGVudCIsImRheUhlYWRlcnMiLCJkYXRlcyIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwicmVuZGVySW50cm8iLCJhbGxEYXlTbG90IiwibmV4dERheVRocmVzaG9sZCIsImNvbEdyb3VwTm9kZSIsInJlbmRlclJvd0ludHJvIiwic2hvd1dlZWtOdW1iZXJzIiwiaGVhZGVyQWxpZ25FbFJlZiIsInRpbWVHcmlkQ29udGVudCIsImRheVNlcmllcyIsIk9QVElPTl9SRUZJTkVSUyIsIm1haW4iLCJpbml0aWFsVmlldyIsIm9wdGlvblJlZmluZXJzIiwidmlld3MiLCJ0aW1lR3JpZCIsImNvbXBvbmVudCIsInVzZXNNaW5NYXhUaW1lIiwidGltZUdyaWREYXkiLCJkYXlzIiwidGltZUdyaWRXZWVrIiwid2Vla3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/timegrid/main.js\n"));

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": function() { return /* binding */ __assign; },\n/* harmony export */   \"__asyncDelegator\": function() { return /* binding */ __asyncDelegator; },\n/* harmony export */   \"__asyncGenerator\": function() { return /* binding */ __asyncGenerator; },\n/* harmony export */   \"__asyncValues\": function() { return /* binding */ __asyncValues; },\n/* harmony export */   \"__await\": function() { return /* binding */ __await; },\n/* harmony export */   \"__awaiter\": function() { return /* binding */ __awaiter; },\n/* harmony export */   \"__classPrivateFieldGet\": function() { return /* binding */ __classPrivateFieldGet; },\n/* harmony export */   \"__classPrivateFieldIn\": function() { return /* binding */ __classPrivateFieldIn; },\n/* harmony export */   \"__classPrivateFieldSet\": function() { return /* binding */ __classPrivateFieldSet; },\n/* harmony export */   \"__createBinding\": function() { return /* binding */ __createBinding; },\n/* harmony export */   \"__decorate\": function() { return /* binding */ __decorate; },\n/* harmony export */   \"__exportStar\": function() { return /* binding */ __exportStar; },\n/* harmony export */   \"__extends\": function() { return /* binding */ __extends; },\n/* harmony export */   \"__generator\": function() { return /* binding */ __generator; },\n/* harmony export */   \"__importDefault\": function() { return /* binding */ __importDefault; },\n/* harmony export */   \"__importStar\": function() { return /* binding */ __importStar; },\n/* harmony export */   \"__makeTemplateObject\": function() { return /* binding */ __makeTemplateObject; },\n/* harmony export */   \"__metadata\": function() { return /* binding */ __metadata; },\n/* harmony export */   \"__param\": function() { return /* binding */ __param; },\n/* harmony export */   \"__read\": function() { return /* binding */ __read; },\n/* harmony export */   \"__rest\": function() { return /* binding */ __rest; },\n/* harmony export */   \"__spread\": function() { return /* binding */ __spread; },\n/* harmony export */   \"__spreadArray\": function() { return /* binding */ __spreadArray; },\n/* harmony export */   \"__spreadArrays\": function() { return /* binding */ __spreadArrays; },\n/* harmony export */   \"__values\": function() { return /* binding */ __values; }\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzdJO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/YTY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n"));

/***/ })

});